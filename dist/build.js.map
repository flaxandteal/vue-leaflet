{"version":3,"sources":["webpack:///build.js","webpack:///webpack/bootstrap cc559e26e8dff1b5d368","webpack:///./src/main.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.wks.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.global.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.an-object.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.core.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.ctx.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.iterators.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.cof.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.is-object.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.a-function.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.descriptors.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.hide.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.set-to-string-tag.js","webpack:///./~/leaflet/dist/leaflet-src.js","webpack:///./~/q/q.js","webpack:///./~/vue/dist/vue.common.js","webpack:///(webpack)/~/node-libs-browser/~/timers-browserify/main.js","webpack:///./src/components/mapComponent.js","webpack:///./src/deferredReady.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.classof.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.defined.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.export.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.has.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.iter-define.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.library.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.property-desc.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.redefine.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.to-integer.js","webpack:///./~/css-loader/lib/css-base.js","webpack:///./~/vue-style-loader/addStyles.js","webpack:///(webpack)/~/node-libs-browser/~/process/browser.js","webpack:///./src/components/Marker.js","webpack:///./src/components/TileLayer.js","webpack:///App.vue","webpack:///Map.vue","webpack:///./~/babel-runtime/core-js/promise.js","webpack:///./~/babel-runtime/~/core-js/library/fn/promise.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.add-to-unscopables.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.dom-create.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.fails.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.for-of.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.html.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.invoke.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.iobject.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.is-array-iter.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.iter-call.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.iter-create.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.iter-detect.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.iter-step.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.microtask.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.redefine-all.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.same-value.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.set-proto.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.set-species.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.shared.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.species-constructor.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.strict-new.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.string-at.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.task.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.to-iobject.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.to-length.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.uid.js","webpack:///./~/babel-runtime/~/core-js/library/modules/core.get-iterator-method.js","webpack:///./~/babel-runtime/~/core-js/library/modules/es6.array.iterator.js","webpack:///./~/babel-runtime/~/core-js/library/modules/es6.promise.js","webpack:///./~/babel-runtime/~/core-js/library/modules/es6.string.iterator.js","webpack:///./~/babel-runtime/~/core-js/library/modules/web.dom.iterable.js","webpack:///./src/App.vue?c44f","webpack:///./src/components/Map.vue?8d55","webpack:///./src/App.vue?d818","webpack:///./src/components/Map.vue?252c","webpack:///./src/App.vue","webpack:///./src/components/Map.vue","webpack:///./src/App.vue?9d6d","webpack:///./src/components/Map.vue?eb6f"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_vue","_vue2","_App","_App2","el","components","App","store","uid","Symbol","name","global","window","Math","self","Function","__g","$Object","Object","create","getProto","getPrototypeOf","isEnum","propertyIsEnumerable","getDesc","getOwnPropertyDescriptor","setDesc","defineProperty","setDescs","defineProperties","getKeys","keys","getNames","getOwnPropertyNames","getSymbols","getOwnPropertySymbols","each","forEach","isObject","it","TypeError","core","version","__e","aFunction","fn","that","length","undefined","a","b","apply","arguments","toString","slice","get","$","createDesc","object","key","value","def","has","TAG","tag","stat","prototype","configurable","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","document","oldL","L","noConflict","this","Util","extend","dest","i","j","len","src","sources","Array","hasOwnProperty","bind","args","stamp","lastId","invokeEach","method","context","concat","limitExecByInterval","time","lock","execOnUnlock","wrapperFn","setTimeout","falseFn","formatNum","num","digits","pow","round","trim","str","replace","splitWords","split","setOptions","options","getParamString","existingUrl","uppercase","params","push","encodeURIComponent","toUpperCase","indexOf","join","template","data","Error","isArray","emptyImageUrl","getPrefixed","prefixes","timeoutDefer","Date","timeToCall","max","lastTime","requestFn","requestAnimationFrame","cancelFn","cancelAnimationFrame","clearTimeout","requestAnimFrame","immediate","element","cancelAnimFrame","Class","props","NewClass","initialize","_initHooks","callInitHooks","F","proto","constructor","statics","includes","parent","__super__","_initHooksCalled","include","mergeOptions","addInitHook","init","eventsKey","Mixin","Events","addEventListener","types","event","type","indexKey","indexLenKey","typeIndex","events","contextId","action","hasEventListeners","removeEventListener","clearAllEventListeners","listeners","removed","splice","fireEvent","target","addOneTimeEventListener","handler","on","off","once","fire","ie","ielt9","ua","navigator","userAgent","toLowerCase","webkit","chrome","phantomjs","android","android23","search","gecko","mobile","orientation","msPointer","PointerEvent","MSPointerEvent","pointer","pointerEnabled","retina","devicePixelRatio","matchMedia","matches","doc","documentElement","ie3d","style","webkit3d","WebKitCSSMatrix","gecko3d","opera3d","any3d","L_DISABLE_3D","touch","L_NO_TOUCH","DocumentTouch","Browser","opera","mobileWebkit","mobileWebkit3d","mobileOpera","Point","x","y","clone","add","point","_add","subtract","_subtract","divideBy","_divideBy","multiplyBy","_multiplyBy","_round","floor","_floor","distanceTo","sqrt","equals","contains","abs","Bounds","points","min","getCenter","getBottomLeft","getTopRight","getSize","bounds","intersects","min2","max2","xIntersects","yIntersects","isValid","Transformation","d","_a","_b","_c","_d","transform","scale","_transform","untransform","DomUtil","getElementById","getStyle","currentStyle","defaultView","css","getComputedStyle","getViewportOffset","pos","top","left","docBody","body","docEl","offsetTop","offsetLeft","parseInt","offsetParent","scrollTop","scrollLeft","width","maxWidth","r","getBoundingClientRect","clientLeft","parentNode","documentIsLtr","_docIsLtrCached","_docIsLtr","tagName","className","container","createElement","appendChild","hasClass","classList","_getClass","RegExp","test","addClass","classes","_setClass","removeClass","remove","baseVal","setOpacity","opacity","filter","filterName","filters","item","e","Enabled","Opacity","testProp","getTranslateString","is3d","open","close","getScaleString","origin","preTranslateStr","scaleStr","setPosition","disable3D","_leaflet_pos","TRANSFORM","getPosition","TRANSITION","TRANSITION_END","disableTextSelection","DomEvent","preventDefault","enableTextSelection","userSelectProperty","_userSelect","disableImageDrag","enableImageDrag","LatLng","lat","lng","alt","parseFloat","isNaN","DEG_TO_RAD","PI","RAD_TO_DEG","MAX_MARGIN","latLng","margin","precision","other","R","d2r","dLat","dLon","lat1","lat2","sin1","sin","sin2","cos","atan2","wrap","lon","LatLngBounds","southWest","northEast","latlngs","latLngBounds","_southWest","_northEast","pad","bufferRatio","sw","ne","heightBuffer","widthBuffer","getSouthWest","getNorthEast","getNorthWest","getNorth","getWest","getSouthEast","getSouth","getEast","sw2","ne2","latIntersects","lngIntersects","toBBoxString","Projection","SphericalMercator","MAX_LATITUDE","project","latlng","log","tan","unproject","atan","exp","LonLat","CRS","latLngToPoint","zoom","projectedPoint","projection","transformation","pointToLatLng","untransformedPoint","s","Simple","EPSG3857","code","earthRadius","EPSG900913","EPSG4326","Map","crs","fadeAnimation","trackResize","markerZoomAnimation","_initContainer","_initLayout","_onResize","_initEvents","maxBounds","setMaxBounds","center","setView","reset","_handlers","_layers","_zoomBoundLayers","_tileLayersNum","_addLayers","layers","getZoom","_resetView","_limitZoom","setZoom","_loaded","_zoom","zoomIn","delta","zoomOut","setZoomAround","getZoomScale","viewHalf","containerPoint","latLngToContainerPoint","centerOffset","newCenter","containerPointToLatLng","fitBounds","getBounds","paddingTL","paddingTopLeft","padding","paddingBR","paddingBottomRight","getBoundsZoom","maxZoom","paddingOffset","swPoint","nePoint","fitWorld","panTo","pan","panBy","offset","_rawPanBy","_panInsideMaxBounds","panInsideBounds","_limitCenter","addLayer","layer","minZoom","_updateZoomLevels","zoomAnimation","TileLayer","_tileLayersToLoad","_onTileLayerLoad","_layerAdd","removeLayer","onRemove","hasLayer","eachLayer","invalidateSize","animate","oldSize","_sizeChanged","_initialCenter","newSize","oldCenter","debounceMoveend","_sizeTimer","addHandler","HandlerClass","enable","_container","_leaflet","_clearPanes","_clearControlPos","_clearHandlers","_checkIfLoaded","_moved","layerPointToLatLng","_getCenterLayerPoint","getPixelBounds","getMinZoom","_layersMinZoom","getMaxZoom","_layersMaxZoom","Infinity","inside","boundsSize","size","nw","se","zoomNotFound","_size","clientWidth","clientHeight","topLeftPoint","_getTopLeftPoint","getPixelOrigin","_initialTopLeftPoint","getPanes","_panes","getContainer","toZoom","getScaleZoom","LN2","latLngToLayerPoint","containerPointToLayerPoint","_getMapPanePos","layerPointToContainerPoint","layerPoint","mouseEventToContainerPoint","getMousePosition","mouseEventToLayerPoint","mouseEventToLatLng","position","_initPanes","_initControlPos","panes","_mapPane","mapPane","_createPane","_tilePane","tilePane","objectsPane","shadowPane","overlayPane","markerPane","popupPane","zoomHide","removeChild","preserveMapOffset","afterZoomAnim","zoomChanged","_getNewTopLeftPoint","loading","hard","_getZoomSpan","oldZoomSpan","onOff","_onMouseClick","_fireMouseEvent","_resizeRequest","_simulated","dragging","moved","boxZoom","_skipped","originalEvent","disable","whenReady","callback","onAdd","_latLngToNewLayerPoint","newZoom","topLeft","_getCenterOffset","centerPoint","viewBounds","_getBoundsOffset","_limitOffset","newBounds","pxBounds","nwOffset","seOffset","dx","_rebound","dy","right","ceil","map","Mercator","R_MINOR","R_MAJOR","r2","tmp","eccent","con","ts","phi","numIter","tol","dphi","EPSG3395","tileSize","subdomains","errorTileUrl","attribution","zoomOffset","unloadInvisibleTiles","updateWhenIdle","url","detectRetina","_url","_map","_animated","_zoomAnimated","viewreset","_reset","moveend","_update","zoomanim","_animateZoom","zoomend","_endZoomAnim","_limitedUpdate","addTo","bringToFront","pane","_setAutoZIndex","bringToBack","insertBefore","firstChild","getAttribution","_updateOpacity","setZIndex","zIndex","_updateZIndex","setUrl","noRedraw","redraw","compare","children","edgeZIndex","isFinite","tiles","_tiles","_bgBuffer","_tileContainer","tile","_tilesToLoad","reuseTiles","_unusedTiles","innerHTML","_clearBgBuffer","_getTileSize","zoomN","maxNativeZoom","tileBounds","_addTilesFromCenterOut","_removeOtherTiles","queue","_tileShouldBeLoaded","tilesToLoad","sort","fragment","createDocumentFragment","_addTile","tilePoint","continuousWorld","limit","_getWrapTileNum","noWrap","nwPoint","sePoint","kArr","_removeTile","onload","tilePos","_getTilePos","_getTile","_loadTile","_getZoomForUrl","zoomReverse","getTileUrl","_getSubdomain","z","_adjustTilePoint","tms","index","pop","_resetTile","_createTile","height","galleryimg","onselectstart","onmousemove","WebkitBackfaceVisibility","_layer","_tileOnLoad","onerror","_tileOnError","_tileLoaded","_clearBgBufferTimer","newUrl","tileLayer","WMS","defaultWmsParams","service","request","styles","format","transparent","wmsParams","_crs","_wmsVersion","projectionKey","bbox","setParams","wms","Canvas","async","_redrawTile","drawTile","_tilePoint","tileDrawn","canvas","ImageOverlay","_bounds","_image","_initImage","_onImageLoad","image","imageOverlay","Icon","createIcon","oldIcon","_createIcon","createShadow","_getIconUrl","img","_createImg","_setIconStyles","anchor","shadowAnchor","iconAnchor","marginLeft","marginTop","icon","Default","iconSize","popupAnchor","shadowSize","path","imagePath","scripts","getElementsByTagName","leafletRe","match","Marker","title","clickable","draggable","keyboard","zIndexOffset","riseOnHover","riseOffset","_latlng","update","_initIcon","_removeIcon","_removeShadow","getLatLng","setLatLng","setZIndexOffset","setIcon","_popup","bindPopup","_icon","_setPos","animation","classToAdd","addIcon","tabIndex","_initInteraction","_bringToFront","_resetZIndex","newShadow","_shadow","addShadow","_zIndex","opt","_onKeyPress","Handler","MarkerDrag","wasDragged","stopPropagation","_enabled","keyCode","marker","DivIcon","html","div","bgPos","backgroundPosition","divIcon","closePopupOnClick","Popup","minWidth","autoPan","closeButton","autoPanPadding","keepInView","source","_source","_isOpen","animFade","_getEvents","popup","openOn","openPopup","offsetWidth","_updatePosition","_adjustPan","getContent","_content","setContent","content","visibility","_updateContent","_updateLayout","_zoomAnimation","closeOnClick","preclick","_close","closePopup","prefix","containerClass","_closeButton","href","disableClickPropagation","_onCloseButtonClick","wrapper","_wrapper","_contentNode","disableScrollPropagation","_tipContainer","_tip","hasChildNodes","whiteSpace","offsetHeight","maxHeight","scrolledClass","_containerWidth","animated","_containerBottom","_containerLeft","bottom","containerHeight","containerWidth","layerPos","containerPos","autoPanPaddingTopLeft","autoPanPaddingBottomRight","stop","togglePopup","_popupHandlersAdded","_movePopup","setPopupContent","unbindPopup","getPopup","LayerGroup","getLayerId","clearLayers","invoke","methodName","getLayer","getLayers","layerGroup","FeatureGroup","EVENTS","_propagateEvent","_popupContent","_popupOptions","setStyle","featureGroup","Path","CLIP_PADDING","outerWidth","outerHeight","stroke","color","dashArray","lineCap","lineJoin","weight","fill","fillColor","fillOpacity","_initElements","projectLatlngs","_updatePath","_pathRoot","vml","_stroke","_fill","_updateStyle","_updatePathViewport","panePos","_pathViewport","SVG_NS","svg","createElementNS","createSVGRect","SVG","root","lastChild","first","getPathString","_createElement","_initPathRoot","_initPath","_initStyle","_path","setAttribute","pointerEvents","removeAttribute","_animatePathZoom","_endPathZoom","_updateSvgViewport","_pathZooming","vp","_openPopup","_latlngs","shape","behavior","adj","VML","namespaces","coordsize","stroked","filled","endcap","dashStyle","joinstyle","display","v","getContext","L_PREFER_CANVAS","CANVAS","_requestUpdate","_onClick","_onMouseMove","_updateRequest","_fireMapMoveEnd","_ctx","_canvasCtx","lineWidth","strokeStyle","fillStyle","_drawPath","len2","drawMethod","beginPath","_parts","Polygon","closePath","_checkIfEmpty","ctx","save","globalAlpha","fillRule","restore","_containsPoint","_animatingZoom","cursor","_mouseInside","_updateCanvasViewport","translate","LineUtil","simplify","tolerance","sqTolerance","_reducePoints","_simplifyDP","pointToSegmentDistance","p1","p2","_sqClosestPointOnSegment","closestPointOnSegment","ArrayConstructor","Uint8Array","markers","_simplifyDPStep","newPoints","last","sqDist","maxSqDist","reducedPoints","prev","_sqDist","clipSegment","useLastCode","codeOut","newCode","codeA","_lastCode","_getBitCode","codeB","_getEdgeIntersection","t","dot","Polyline","_convertLatLngs","smoothFactor","noClip","_originalPoints","_getPathPartStr","getLatLngs","setLatLngs","addLatLng","spliceLatLngs","closestLayerPoint","minDistance","parts","minPoint","jLen","distance","overwrite","_clipPoints","k","segment","lu","_simplifyPoints","polyline","PolyUtil","clipPolygon","clippedPoints","edge","edges","_code","_initWithHoles","hole","_holes","_holePoints","newParts","clipped","polygon","createMulti","Klass","_options","MultiPolyline","MultiPolygon","multiPolyline","multiPolygon","Rectangle","_boundsToLatLngs","setBounds","rectangle","Circle","radius","_mRadius","setRadius","lngRadius","_getLngRadius","pointLeft","_point","_radius","latRadius","getRadius","_getLatRadius","circle","CircleMarker","circleMarker","closed","dist","part","w","arc","w2","GeoJSON","geojson","addData","feature","features","geometries","geometry","coordinates","geometryToLayer","pointToLayer","coordsToLatLng","asFeature","defaultOptions","resetStyle","onEachFeature","_setLayerStyle","vectorOptions","coords","coordsToLatLngs","properties","levelsDeep","latLngToCoords","latLngsToCoords","latLngs","getFeature","newGeometry","geoJSON","PointToGeoJSON","toGeoJSON","multiToGeoJSON","json","jsons","isGeometryCollection","geoJson","addListener","originalHandler","newType","_getEvent","addPointerListener","addDoubleTapListener","_checkMouse","_filterClick","attachEvent","removeListener","removePointerListener","removeDoubleTapListener","detachEvent","cancelBubble","Draggable","START","_fakeStop","returnValue","clientX","clientY","rect","clientTop","getWheelDelta","wheelDelta","detail","_skipEvents","skipped","related","relatedTarget","err","caller","callee","Event","timeStamp","elapsed","_lastClick","_simulatedClick","END","mousedown","touchstart","pointerdown","MSPointerDown","MOVE","dragStartTarget","_element","_dragStartTarget","_onDown","shiftKey","which","button","touches","_disabled","_moving","_startPoint","_startPos","_newPos","_onMove","_onUp","newPoint","_lastTarget","srcElement","_animRequest","addHooks","removeHooks","enabled","inertia","inertiaDeceleration","inertiaMaxSpeed","inertiaThreshold","easeLinearity","worldCopyJump","Drag","_draggable","dragstart","_onDragStart","drag","_onDrag","dragend","_onDragEnd","_onPreDrag","_onViewReset","_panAnim","_positions","_times","_lastTime","_lastPos","shift","pxCenter","pxWorldCenter","_initialWorldOffset","_worldWidth","worldWidth","halfWidth","newX1","newX2","newX","delay","noInertia","direction","duration","ease","speedVector","speed","limitedSpeed","limitedSpeedVector","decelerationDuration","noMoveStart","doubleClickZoom","DoubleClickZoom","_onDoubleClick","scrollWheelZoom","ScrollWheelZoom","_onWheelScroll","_delta","_lastMousePos","_startTime","_timer","_performZoom","_touchstart","_touchend","onTouchStart","count","trackedTouches","pointerId","now","doubleTap","onTouchEnd","idx","prop","newTouch","pre","touchend","endElement","POINTER_CANCEL","POINTER_DOWN","POINTER_MOVE","POINTER_UP","_pointers","_pointerDocumentListener","addPointerListenerStart","addPointerListenerEnd","addPointerListenerMove","pointers","cb","pointerType","MSPOINTER_TYPE_MOUSE","alreadyInArray","changedTouches","internalCb","buttons","touchZoom","bounceAtZoomLimits","TouchZoom","_onTouchStart","_zooming","viewCenter","_startCenter","_startDist","_centerOffset","_onTouchMove","_onTouchEnd","_scale","_updateOnMove","_getScaleOrigin","oldZoom","floatZoomDelta","roundZoomDelta","tap","tapTolerance","Tap","_fireClick","_holdTimeout","_isTapValid","_simulateEvent","simulatedEvent","createEvent","initMouseEvent","screenX","screenY","dispatchEvent","BoxZoom","_pane","_onMouseDown","_startLayerPoint","_onMouseUp","_onKeyDown","_box","startPoint","box","newPos","_finish","boxZoomBounds","keyboardPanOffset","keyboardZoomOffset","Keyboard","keyCodes","down","up","_setPanOffset","_setZoomOffset","_onFocus","_onBlur","_addHooks","_removeHooks","_focused","focus","scrollTo","_panKeys","codes","_zoomKeys","_inProgress","_marker","shadow","iconPos","Control","removeControl","addControl","corner","_controlCorners","removeFrom","_refocusOnMap","control","createCorner","vSide","hSide","l","corners","_controlContainer","Zoom","zoomInText","zoomInTitle","zoomOutText","zoomOutTitle","zoomName","_zoomInButton","_createButton","_zoomIn","_zoomOutButton","_zoomOut","_updateDisabled","link","zoomControl","Attribution","_attributions","addAttribution","_onLayerAdd","_onLayerRemove","setPrefix","text","removeAttribution","attribs","prefixAndAttribs","attributionControl","Scale","metric","imperial","_addScales","_mScale","_iScale","centerLat","halfWorldMeters","maxMeters","_updateScales","_updateMetric","_updateImperial","meters","_getRoundNum","_getScaleWidth","maxMiles","miles","feet","maxFeet","ratio","pow10","Layers","collapsed","autoZIndex","baseLayers","overlays","_lastZIndex","_handlingClick","_addLayer","_onLayerChange","addBaseLayer","addOverlay","form","_form","_expand","_collapse","_layersLink","_onInputClick","_baseLayersList","_separator","_overlaysList","overlay","baseLayersPresent","overlaysPresent","_addItem","_createRadioElement","checked","radioHtml","radioFragment","input","label","defaultChecked","layerId","inputs","inputsLen","PosAnimation","run","_el","_onTransitionEnd","_stepTimer","setInterval","_onStep","_getPos","stepPos","_transformRe","clearInterval","_tryAnimatedZoom","_tryAnimatedPan","step","_onPanTransitionStep","end","_onPanTransitionEnd","_duration","_easeOutPower","_offset","_animate","_step","_complete","_animId","_runFrame","_easeOut","progress","zoomAnimationThreshold","_catchTransitionEnd","propertyName","_onZoomTransitionEnd","_nothingToAnimate","getElementsByClassName","backwards","forTouchZoom","_animateToCenter","_animateToZoom","_animating","_prepareBgBuffer","bg","initialTransform","front","bgLoaded","_getLoadedTilesPercentage","frontLoaded","_stopLoadingImages","complete","_defaultLocateOptions","watch","timeout","maximumAge","enableHighAccuracy","locate","_locateOptions","geolocation","_handleGeolocationError","message","onResponse","_handleGeolocationResponse","onError","_locationWatchId","watchPosition","getCurrentPosition","stopLocate","clearWatch","error","latitude","longitude","latAccuracy","accuracy","lngAccuracy","timestamp","process","setImmediate","definition","bootstrap","uncurryThis","f","isStopIteration","exception","object_toString","QReturnValue","makeStackTraceLong","promise","hasStacks","stack","STACK_JUMP_SEPARATOR","stacks","unshift","concatedStacks","filterStackString","stackString","lines","desiredLines","line","isInternalFrame","isNodeFrame","stackLine","getFileNameAndLineNumber","attempt1","exec","Number","attempt2","attempt3","fileNameAndLineNumber","fileName","lineNumber","qFileName","qStartingLine","qEndingLine","captureLine","firstLine","deprecate","alternative","console","warn","Q","Promise","isPromiseAlike","coerce","fulfill","defer","become","newPromise","resolvedPromise","array_reduce","messages","nextTick","promiseDispatch","progressListeners","deferred","object_create","resolve","op","operands","array_slice","valueOf","nearerValue","nearer","isPromise","inspect","state","longStackSupport","substring","reject","reason","notify","progressListener","resolver","race","answerPs","then","descriptor","fallback","result","inspected","when","fulfilled","rejected","progressed","isPending","isFulfilled","isRejected","resetUnhandledRejections","unhandledReasons","unhandledRejections","trackUnhandledRejections","trackRejection","emit","runAfter","array_indexOf","reportedUnhandledRejections","untrackRejection","at","atReport","rejection","set","rhs","delete","post","thisp","object_keys","master","isDef","dispatch","spread","makeGenerator","continuer","verb","arg","StopIteration","generator","done","errback","spawn","_return","promised","all","promises","pendingCount","snapshot","any","current","onFulfilled","onRejected","onProgress","allResolved","array_map","noop","allSettled","nodeify","nodeback","flush","task","domain","head","next","enter","runSingle","laterQueue","flushing","isNodeJS","exit","tail","requestTick","MessageChannel","channel","port1","onmessage","requestPortTick","port2","postMessage","reduce","basis","collect","Type","object_hasOwnProperty","ReturnValue","NODE_ENV","Q_DEBUG","makeNodeResolver","passByCopy","makePromise","_fulfilled","_rejected","newException","_progressed","newValue","threw","fcall","thenResolve","thenReject","getUnhandledReasons","stopUnhandledRejectionTracking","array","del","mapply","send","mcall","fapply","fbind","regardless","fail","fin","onUnhandledError","ms","timeoutId","nfapply","nodeArgs","nfcall","nfbind","denodeify","baseArgs","nbind","bound","nmapply","npost","nsend","nmcall","ninvoke","val","hasOwn","_isVue","_data","ob","__ob__","convert","dep","vms","vm","_proxy","_digest","_unproxy","isLiteral","literalValueRE","isReserved","charCodeAt","_toString","toNumber","parsed","toBoolean","stripQuotes","camelize","camelizeRE","toUpper","_","hyphenate","hyphenateRE","classify","classifyRE","toArray","list","start","ret","to","from","isPlainObject","OBJECT_STRING","enumerable","writable","_debounce","func","wait","later","arr","cancellable","cancelled","cancel","looseEqual","JSON","stringify","Cache","_keymap","pushFilter","lastFilterIndex","tokens","filterTokenRE","processFilterArg","dir","reservedArgRE","dynamic","stripped","parseDirective","hit","cache$1","inSingle","inDouble","curly","square","paren","expression","put","escapeRegex","regexEscapeRE","compileRegex","config","delimiters","unsafeOpen","unsafeDelimiters","unsafeClose","tagRE","htmlRE","cache","parseText","oneTime","lastIndex","tokensToExp","token","formatToken","single","$eval","inlineFilters","filterRE","appendWithTransition","applyTransition","beforeWithTransition","before","removeWithTransition","transition","__v_trans","hooks","transitionEndEvent","_isCompiled","$parent","query","querySelector","inDoc","node","nodeType","getAttr","_attr","getAttribute","getBindAttr","hasBindAttr","hasAttribute","after","nextSibling","prepend","replaceChild","useCapture","getClass","classname","setClass","cls","isIE9","namespaceURI","cur","tar","extractContent","asFragment","child","rawContent","isTemplate","isFragment","trimNode","isTrimmable","createAnchor","persist","debug","createComment","createTextNode","__v_anchor","findRef","hasAttributes","attrs","attributes","refRE","mapNodeRange","removeNodeRange","frag","onRemoved","nodes","getOuterHTML","outerHTML","cloneNode","checkComponentAttr","hasAttrs","commonTagRE","reservedTagRE","getIsBinding","resolveAsset","is","mergeData","toVal","fromVal","mergeAssets","parentVal","childVal","res","guardArrayAssets","guardComponents","ids","Vue","guardProps","assets","asset","mergeField","strat","strats","defaultStrat","mixins","warnMissing","camelizedId","charAt","Dep","uid$1","subs","withoutConversion","shouldConvert","Observer","augment","hasProto","protoAugment","copyAugment","arrayMethods","arrayKeys","observeArray","walk","__proto__","observe","isExtensible","addVm","defineReactive","property","getter","setter","childOb","depend","newVal","initMixin","_init","$el","$root","$children","$refs","$els","_watchers","_directives","_uid","_events","_eventsCount","_isFragment","_fragment","_fragmentStart","_fragmentEnd","_isDestroyed","_isReady","_isAttached","_isBeingDestroyed","_vForRemoving","_unlinkFn","_context","_scope","_frag","$options","_updateRef","_runtimeData","_callHook","_initState","$mount","getPathCharType","ch","formatSubPath","trimmed","parse","maybeUnescapeQuote","nextChar","mode","IN_SINGLE_QUOTE","IN_DOUBLE_QUOTE","newChar","actions","APPEND","typeMap","BEFORE_PATH","subPathDepth","PUSH","INC_SUB_PATH_DEPTH","PUSH_SUB_PATH","IN_SUB_PATH","pathStateMachine","ERROR","AFTER_PATH","raw","parsePath","pathCache","getPath","parseExpression","setPath","original","$set","isString","saved","newlineRE","rewrite","allowedKeywordsRE","restoreRE","compileGetter","improperKeywordsRE","saveRE","wsRE","identRE","makeGetterFn","compileSetter","scope","needSet","expressionCache","isSimplePath","pathTestRE","booleanLiteralRE","resetBatcherState","userQueue","circular","waiting","internalQueueDepleted","flushBatcherQueue","runBatcherQueue","devtools","queueIndex","watcher","pushWatcher","user","q","Watcher","expOrFn","isFn","uid$2","active","dirty","lazy","deps","newDeps","depIds","newDepIds","prevError","twoWay","queued","shallow","traverse","isRealTemplate","stringToFragment","templateString","cacheKey","templateCache","tagMatch","tagRE$1","entityMatch","entityRE","efault","depth","suffix","nodeToFragment","textContent","clonedNode","querySelectorAll","cloned","hasBrokenTemplate","tempClone","hasTextareaCloneBug","parseTemplate","shouldClone","idSelectorCache","Fragment","linker","host","parentFrag","childFrags","inserted","unlink","childNodes","singleBefore","singleRemove","multiBefore","multiRemove","__v_frag","withTransition","callHook","attach","shouldCallRemove","beforeRemove","detach","destroy","FragmentFactory","cid","cacheId","linkerCache","compile","findPrevFrag","previousSibling","forId","findVmFromFrag","__vue__","range","n","getValue","multi","selected","_value","indexOf$1","keyFilter","charCode","stopFilter","preventFilter","selfFilter","currentTarget","normalize","propCache","camel","upper","testEl","prefixed","camelPrefixes","kebab","setObjectClasses","toggleClasses","stringToObject","callActivateHooks","called","total","compileProps","propOptions","attr","names","empty","identRE$1","propBindingModes","ONE_WAY","TWO_WAY","ONE_TIME","optimizedLiteral","parentPath","makePropsLinkFn","_props","initProp","$get","_bindDir","propDef","Boolean","processPropValue","rawValue","isSimple","getPropDefaultValue","coerceProp","coerced","assertProp","updateProp","required","valid","expectedTypes","assertedType","assertType","expectedType","validator","String","pushJob","job","queue$1","Transition","enterClass","leaveClass","pendingCssEvent","pendingCssCb","pendingJsCb","justEntered","entered","typeCache","isHidden","getClientRects","partial","nodeLinkFn","_asComponent","compileNode","childLinkFn","terminal","compileNodeList","dirs","linkAndCapture","makeUnlinkFn","originalDirCount","directiveComparator","_bind","priority","DEFAULT_PRIORITY","contextDirs","destroying","teardownDirs","_teardown","compileAndLinkProps","propsLinkFn","propDirs","compileRoot","contextOptions","contextLinkFn","replacerLinkFn","containerAttrs","_containerAttrs","replacerAttrs","_replacerAttrs","compileDirectives","selfDirs","compileElement","compileTextNode","linkFn","checkTerminalDirectives","checkElementDirectives","checkComponent","_skip","removeText","wholeText","processTextToken","makeTextNodeLinkFn","setTokenType","directives","fragClone","nodeList","linkFns","makeChildLinkFn","childrenLinkFn","makeTerminalNodeLinkFn","component","ref","internalDirectives","modifiers","literal","componentLinkFn","skip","previousElementSibling","matched","dirName","rawName","termDef","parseModifiers","modifierRE","dirAttrRE","DEFAULT_TERMINAL_PRIORITY","pushDir","interpTokens","hasOneTimeToken","hasOneTime","interp","dirDef","transitionRE","bindRE","onRE","makeNodeLinkFn","transclude","extractAttrs","transcludeTemplate","replacer","mergeAttrs","specialCharRE","resolveSlots","contents","_slotContents","extractFragment","stateMixin","makeComputedGetter","owner","evaluate","newData","_setData","_initProps","_initMeta","_initMethods","_initData","_initComputed","_propsUnlinkFn","dataFn","runtimeData","oldData","removeVm","computed","userDef","methods","metas","_meta","eventsMixin","registerComponentEvents","eventRE","_fromParent","$on","registerCallbacks","hash","handlers","register","onAttached","callAttach","onDetached","callDetach","_initDOMHooks","hook","$emit","Directive","_locked","_bound","_listeners","_host","lifecycleMixin","_ref","refs","_compile","_initElement","rootLinker","contentLinkFn","ctor","_linkerCachable","rootUnlinkFn","contentUnlinkFn","_destroy","deferCleanup","_cleanup","destroyReady","pendingRemoval","cleanupIfPossible","$remove","$destroy","teardown","$off","miscMixin","_applyFilters","oldValue","write","read","_resolveComponent","factory","resolved","requested","pendingCallbacks","cbs","dataAPI","clean","asStatement","$arguments","$delete","$watch","deep","sync","filterRE$1","$interpolate","$log","domAPI","insert","op1","op2","targetIsDetached","shouldCallHook","append","beforeWithCb","removeWithCb","$nextTick","$appendTo","$prependTo","$before","$after","inDocument","realCb","eventsAPI","modifyListenerCount","hookRE","$once","isSource","shouldPropagate","hasParentCbs","some","$broadcast","$dispatch","lifecycleAPI","ready","$compile","limitBy","filterBy","delimiter","convertArray","$value","$key","orderBy","baseCompare","sortKeyIndex","sortKey","sortKeys","order","comparator","firstArg","installGlobalAPI","createClass","elementDirectives","transitions","partials","util","compiler","parsers","directive","extendOptions","Super","isFirstExtend","_Ctor","Sub","_assetTypes","use","plugin","installed","install","mixin","inBrowser","__VUE_DEVTOOLS_GLOBAL_HOOK__","UA","isAndroid","transitionProp","animationProp","animationEndEvent","isWebkitTrans","ontransitionend","onwebkittransitionend","isWebkitAnim","onanimationend","onwebkitanimationend","nextTickHandler","pending","copies","callbacks","timerFunc","MutationObserver","counter","observer","textNode","characterData","entry","newer","older","returnEntry","freeze","silent","warnExpressionErrors","_delimitersChanged","_propBindingModes","_maxUpdateCount","optionMergeStrategies","instanceData","defaultData","created","attached","detached","beforeCompile","compiled","beforeDestroy","destroyed","activate","addSub","sub","removeSub","addDep","arrayProto","items","debounce","IN_PATH","BEFORE_IDENT","IN_IDENT","ws","ident","[","eof",".","0","number","'","\"","]","else","allowedKeywords","improperKeywords","beforeGet","preProcess","postProcess","afterGet","forContext","$forContext","alias","_withLock","$index","text$1","legend","tr","col","td","th","option","optgroup","thead","tbody","colgroup","caption","tfoot","g","defs","symbol","ellipse","placeholder","swap","_watcher","ON","MODEL","BIND","EL","COMPONENT","PARTIAL","IF","FOR","SLOT","uid$3","vFor","inMatch","itMatch","iterator","isOption","diff","updateRef","updateModel","primitive","convertedFromObject","fromObject","trackByKey","trackBy","oldFrags","frags","getCachedFrag","reused","fresh","removalIndex","totalRemoved","deleteCachedFrag","targetPrev","prevEl","currentPrev","insertionIndex","staggerCb","staggerAnchor","move","parentScope","cacheFrag","model","__v_model","forceUpdate","staggerAmount","getStagger","trans","stagger","_preProcess","_postProcess","unbind","vIf","invalid","nextElementSibling","elseEl","elseFrag","elseFactory","show","toggle","text$2","isRange","composing","listener","focused","rawListener","hasjQuery","jQuery","afterBind","radio","select","multiple","initValue","selectedIndex","checkbox","getBooleanValue","_trueValue","_falseValue","checkFilters","hasRead","hasWrite","_unbind","esc","tab","space","on$1","acceptStatement","iframeBind","contentWindow","capture","prevent","importantRE","cssText","handleObject","handleSingle","isImportant","setProperty","xlinkNS","xlinkRE","disallowedInterpAttrRE","attrWithPropsRE","enumeratedAttrRE","modelProps","true-value","false-value","bind$1","modelProp","setAttributeNS","cloak","for","if","vClass","handleArray","cleanup","prevKeys","keepAlive","inlineTemplate","pendingComponentCb","Component","pendingRemovals","pendingRemovalCb","setComponent","invalidatePending","resolveComponent","mountComponent","unbuild","childVM","ComponentName","activateHooks","cached","getCached","newComponent","build","waitingFor","extraOptions","_isRouterView","_inactive","transitionMode","bindingModes","childKey","parentKey","parentWatcher","childWatcher","TYPE_TRANSITION","TYPE_ANIMATION","transDurationProp","animDurationProp","raf","waitForTransitionStart","p$1","cancelPending","callHookWithCb","enterCancelled","enterNextTick","_this","enterDone","getCssTransitionType","setupCssCb","leave","leaveCancelled","leaveDone","leaveNextTick","hasPending","hidden","inlineStyles","computedStyles","transDuration","animDuration","onEnd","transition$1","oldId","class","_setupParams","_checkStatement","oldVal","mappedKey","_setupParamWatcher","unwatch","paramWatchers","_paramUnwatchFns","$event","unwatchFns","slot","elseBlock","digitsRE","indent","capitalize","lowercase","currency","_currency","stringified","toFixed","_int","_float","sign","pluralize","clearImmediate","Timeout","clearFn","_id","_clearFn","immediateIds","nextImmediateId","unref","enroll","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","_onTimeout","_q","_deferredReady","DeferredReady","DeferredReadyMixin","$map","deferredReady","map-ready","runHooks","_promise2","rv","$deferredReadyDeferred","_promise","_q2","$hasDeferredReadyAncestors","register-deferredReadyChild","cof","ARG","O","T","B","PROTOTYPE","$export","own","out","IS_FORCED","IS_GLOBAL","G","IS_STATIC","S","IS_PROTO","P","IS_BIND","IS_WRAP","W","C","param","LIBRARY","redefine","hide","Iterators","$iterCreate","setToStringTag","ITERATOR","BUGGY","FF_ITERATOR","KEYS","VALUES","returnThis","Base","NAME","Constructor","DEFAULT","IS_SET","FORCED","getMethod","kind","DEF_VALUES","VALUES_BUG","$native","$default","IteratorPrototype","values","entries","bitmap","mediaQuery","alreadyImportedModules","addStylesToDom","domStyle","stylesInDom","addStyle","listToStyles","newStyles","media","sourceMap","insertStyleElement","styleElement","getHeadElement","lastStyleElementInsertedAtTop","styleElementsInsertedAtTop","insertAt","removeStyleElement","createStyleElement","singleton","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","applyToTag","newObj","styleSheet","replaceText","cssNode","btoa","unescape","memoize","memo","isOldIE","newList","mayRemove","textStore","replacement","cleanUpNextTick","draining","currentQueue","drainQueue","Item","fun","browser","env","argv","versions","removeAllListeners","binding","cwd","chdir","umask","_mapComponent","_mapComponent2","_leaflet2","_Map","_Map2","_TileLayer","_TileLayer2","_Marker","_Marker2","tilelayer","registerChild","mapObject","eventListeners","register-component","mapCreatedDefered","mapCreated","isArrayIter","anObject","toLength","getIterFn","iterable","iterFn","un","ArrayProto","SAFE_CLOSING","riter","skipClosing","safe","iter","macrotask","WebKitMutationObserver","isNode","check","setPrototypeOf","buggy","DESCRIPTORS","SPECIES","KEY","SHARED","D","toInteger","defined","TO_STRING","port","cel","setTask","clearTask","ONREADYSTATECHANGE","listner","importScripts","clear","IObject","px","random","classof","getIteratorMethod","addToUnscopables","toIObject","iterated","_t","_i","_k","Arguments","Wrapper","strictNew","forOf","setProto","same","speciesConstructor","asap","PROMISE","testResolve","USE_NATIVE","P2","works","thenableThenGotten","sameConstructor","getConstructor","isThenable","PromiseCapability","$$resolve","$$reject","perform","record","isReject","chain","ok","reaction","h","isUnhandled","onunhandledrejection","$reject","$resolve","executor","catch","capability","abrupt","remaining","results","alreadyCalled","$at","NodeList","HTMLCollection","__vue_script__","__vue_template__","locals"],"mappings":"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","file":"build.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _vue = __webpack_require__(16);\n\t\n\tvar _vue2 = _interopRequireDefault(_vue);\n\t\n\tvar _App = __webpack_require__(73);\n\t\n\tvar _App2 = _interopRequireDefault(_App);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tnew _vue2.default({\n\t  el: 'body',\n\t  components: { App: _App2.default }\n\t});\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar store  = __webpack_require__(55)('wks')\n\t  , uid    = __webpack_require__(62)\n\t  , Symbol = __webpack_require__(2).Symbol;\n\tmodule.exports = function(name){\n\t  return store[name] || (store[name] =\n\t    Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));\n\t};\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n\tvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n\t  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\n\tif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tvar $Object = Object;\n\tmodule.exports = {\n\t  create:     $Object.create,\n\t  getProto:   $Object.getPrototypeOf,\n\t  isEnum:     {}.propertyIsEnumerable,\n\t  getDesc:    $Object.getOwnPropertyDescriptor,\n\t  setDesc:    $Object.defineProperty,\n\t  setDescs:   $Object.defineProperties,\n\t  getKeys:    $Object.keys,\n\t  getNames:   $Object.getOwnPropertyNames,\n\t  getSymbols: $Object.getOwnPropertySymbols,\n\t  each:       [].forEach\n\t};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(9);\n\tmodule.exports = function(it){\n\t  if(!isObject(it))throw TypeError(it + ' is not an object!');\n\t  return it;\n\t};\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tvar core = module.exports = {version: '1.2.6'};\n\tif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// optional / simple context binding\n\tvar aFunction = __webpack_require__(10);\n\tmodule.exports = function(fn, that, length){\n\t  aFunction(fn);\n\t  if(that === undefined)return fn;\n\t  switch(length){\n\t    case 1: return function(a){\n\t      return fn.call(that, a);\n\t    };\n\t    case 2: return function(a, b){\n\t      return fn.call(that, a, b);\n\t    };\n\t    case 3: return function(a, b, c){\n\t      return fn.call(that, a, b, c);\n\t    };\n\t  }\n\t  return function(/* ...args */){\n\t    return fn.apply(that, arguments);\n\t  };\n\t};\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {};\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\tvar toString = {}.toString;\n\t\n\tmodule.exports = function(it){\n\t  return toString.call(it).slice(8, -1);\n\t};\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(it){\n\t  return typeof it === 'object' ? it !== null : typeof it === 'function';\n\t};\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(it){\n\t  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n\t  return it;\n\t};\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Thank's IE8 for his funny defineProperty\n\tmodule.exports = !__webpack_require__(40)(function(){\n\t  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n\t});\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar $          = __webpack_require__(3)\n\t  , createDesc = __webpack_require__(26);\n\tmodule.exports = __webpack_require__(11) ? function(object, key, value){\n\t  return $.setDesc(object, key, createDesc(1, value));\n\t} : function(object, key, value){\n\t  object[key] = value;\n\t  return object;\n\t};\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar def = __webpack_require__(3).setDesc\n\t  , has = __webpack_require__(23)\n\t  , TAG = __webpack_require__(1)('toStringTag');\n\t\n\tmodule.exports = function(it, tag, stat){\n\t  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n\t};\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n\t Leaflet, a JavaScript library for mobile-friendly interactive maps. http://leafletjs.com\n\t (c) 2010-2013, Vladimir Agafonkin\n\t (c) 2010-2011, CloudMade\n\t*/\n\t(function (window, document, undefined) {\r\n\tvar oldL = window.L,\r\n\t    L = {};\r\n\t\r\n\tL.version = '0.7.7';\r\n\t\r\n\t// define Leaflet for Node module pattern loaders, including Browserify\r\n\tif (typeof module === 'object' && typeof module.exports === 'object') {\r\n\t\tmodule.exports = L;\r\n\t\r\n\t// define Leaflet as an AMD module\r\n\t} else if (true) {\r\n\t\t!(__WEBPACK_AMD_DEFINE_FACTORY__ = (L), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t}\r\n\t\r\n\t// define Leaflet as a global L variable, saving the original L to restore later if needed\r\n\t\r\n\tL.noConflict = function () {\r\n\t\twindow.L = oldL;\r\n\t\treturn this;\r\n\t};\r\n\t\r\n\twindow.L = L;\r\n\t\n\t\n\t/*\r\n\t * L.Util contains various utility functions used throughout Leaflet code.\r\n\t */\r\n\t\r\n\tL.Util = {\r\n\t\textend: function (dest) { // (Object[, Object, ...]) ->\r\n\t\t\tvar sources = Array.prototype.slice.call(arguments, 1),\r\n\t\t\t    i, j, len, src;\r\n\t\r\n\t\t\tfor (j = 0, len = sources.length; j < len; j++) {\r\n\t\t\t\tsrc = sources[j] || {};\r\n\t\t\t\tfor (i in src) {\r\n\t\t\t\t\tif (src.hasOwnProperty(i)) {\r\n\t\t\t\t\t\tdest[i] = src[i];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn dest;\r\n\t\t},\r\n\t\r\n\t\tbind: function (fn, obj) { // (Function, Object) -> Function\r\n\t\t\tvar args = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;\r\n\t\t\treturn function () {\r\n\t\t\t\treturn fn.apply(obj, args || arguments);\r\n\t\t\t};\r\n\t\t},\r\n\t\r\n\t\tstamp: (function () {\r\n\t\t\tvar lastId = 0,\r\n\t\t\t    key = '_leaflet_id';\r\n\t\t\treturn function (obj) {\r\n\t\t\t\tobj[key] = obj[key] || ++lastId;\r\n\t\t\t\treturn obj[key];\r\n\t\t\t};\r\n\t\t}()),\r\n\t\r\n\t\tinvokeEach: function (obj, method, context) {\r\n\t\t\tvar i, args;\r\n\t\r\n\t\t\tif (typeof obj === 'object') {\r\n\t\t\t\targs = Array.prototype.slice.call(arguments, 3);\r\n\t\r\n\t\t\t\tfor (i in obj) {\r\n\t\t\t\t\tmethod.apply(context, [i, obj[i]].concat(args));\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\r\n\t\t\treturn false;\r\n\t\t},\r\n\t\r\n\t\tlimitExecByInterval: function (fn, time, context) {\r\n\t\t\tvar lock, execOnUnlock;\r\n\t\r\n\t\t\treturn function wrapperFn() {\r\n\t\t\t\tvar args = arguments;\r\n\t\r\n\t\t\t\tif (lock) {\r\n\t\t\t\t\texecOnUnlock = true;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tlock = true;\r\n\t\r\n\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\tlock = false;\r\n\t\r\n\t\t\t\t\tif (execOnUnlock) {\r\n\t\t\t\t\t\twrapperFn.apply(context, args);\r\n\t\t\t\t\t\texecOnUnlock = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}, time);\r\n\t\r\n\t\t\t\tfn.apply(context, args);\r\n\t\t\t};\r\n\t\t},\r\n\t\r\n\t\tfalseFn: function () {\r\n\t\t\treturn false;\r\n\t\t},\r\n\t\r\n\t\tformatNum: function (num, digits) {\r\n\t\t\tvar pow = Math.pow(10, digits || 5);\r\n\t\t\treturn Math.round(num * pow) / pow;\r\n\t\t},\r\n\t\r\n\t\ttrim: function (str) {\r\n\t\t\treturn str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\r\n\t\t},\r\n\t\r\n\t\tsplitWords: function (str) {\r\n\t\t\treturn L.Util.trim(str).split(/\\s+/);\r\n\t\t},\r\n\t\r\n\t\tsetOptions: function (obj, options) {\r\n\t\t\tobj.options = L.extend({}, obj.options, options);\r\n\t\t\treturn obj.options;\r\n\t\t},\r\n\t\r\n\t\tgetParamString: function (obj, existingUrl, uppercase) {\r\n\t\t\tvar params = [];\r\n\t\t\tfor (var i in obj) {\r\n\t\t\t\tparams.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));\r\n\t\t\t}\r\n\t\t\treturn ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');\r\n\t\t},\r\n\t\ttemplate: function (str, data) {\r\n\t\t\treturn str.replace(/\\{ *([\\w_]+) *\\}/g, function (str, key) {\r\n\t\t\t\tvar value = data[key];\r\n\t\t\t\tif (value === undefined) {\r\n\t\t\t\t\tthrow new Error('No value provided for variable ' + str);\r\n\t\t\t\t} else if (typeof value === 'function') {\r\n\t\t\t\t\tvalue = value(data);\r\n\t\t\t\t}\r\n\t\t\t\treturn value;\r\n\t\t\t});\r\n\t\t},\r\n\t\r\n\t\tisArray: Array.isArray || function (obj) {\r\n\t\t\treturn (Object.prototype.toString.call(obj) === '[object Array]');\r\n\t\t},\r\n\t\r\n\t\temptyImageUrl: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='\r\n\t};\r\n\t\r\n\t(function () {\r\n\t\r\n\t\t// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/\r\n\t\r\n\t\tfunction getPrefixed(name) {\r\n\t\t\tvar i, fn,\r\n\t\t\t    prefixes = ['webkit', 'moz', 'o', 'ms'];\r\n\t\r\n\t\t\tfor (i = 0; i < prefixes.length && !fn; i++) {\r\n\t\t\t\tfn = window[prefixes[i] + name];\r\n\t\t\t}\r\n\t\r\n\t\t\treturn fn;\r\n\t\t}\r\n\t\r\n\t\tvar lastTime = 0;\r\n\t\r\n\t\tfunction timeoutDefer(fn) {\r\n\t\t\tvar time = +new Date(),\r\n\t\t\t    timeToCall = Math.max(0, 16 - (time - lastTime));\r\n\t\r\n\t\t\tlastTime = time + timeToCall;\r\n\t\t\treturn window.setTimeout(fn, timeToCall);\r\n\t\t}\r\n\t\r\n\t\tvar requestFn = window.requestAnimationFrame ||\r\n\t\t        getPrefixed('RequestAnimationFrame') || timeoutDefer;\r\n\t\r\n\t\tvar cancelFn = window.cancelAnimationFrame ||\r\n\t\t        getPrefixed('CancelAnimationFrame') ||\r\n\t\t        getPrefixed('CancelRequestAnimationFrame') ||\r\n\t\t        function (id) { window.clearTimeout(id); };\r\n\t\r\n\t\r\n\t\tL.Util.requestAnimFrame = function (fn, context, immediate, element) {\r\n\t\t\tfn = L.bind(fn, context);\r\n\t\r\n\t\t\tif (immediate && requestFn === timeoutDefer) {\r\n\t\t\t\tfn();\r\n\t\t\t} else {\r\n\t\t\t\treturn requestFn.call(window, fn, element);\r\n\t\t\t}\r\n\t\t};\r\n\t\r\n\t\tL.Util.cancelAnimFrame = function (id) {\r\n\t\t\tif (id) {\r\n\t\t\t\tcancelFn.call(window, id);\r\n\t\t\t}\r\n\t\t};\r\n\t\r\n\t}());\r\n\t\r\n\t// shortcuts for most used utility functions\r\n\tL.extend = L.Util.extend;\r\n\tL.bind = L.Util.bind;\r\n\tL.stamp = L.Util.stamp;\r\n\tL.setOptions = L.Util.setOptions;\r\n\t\n\t\n\t/*\r\n\t * L.Class powers the OOP facilities of the library.\r\n\t * Thanks to John Resig and Dean Edwards for inspiration!\r\n\t */\r\n\t\r\n\tL.Class = function () {};\r\n\t\r\n\tL.Class.extend = function (props) {\r\n\t\r\n\t\t// extended class with the new prototype\r\n\t\tvar NewClass = function () {\r\n\t\r\n\t\t\t// call the constructor\r\n\t\t\tif (this.initialize) {\r\n\t\t\t\tthis.initialize.apply(this, arguments);\r\n\t\t\t}\r\n\t\r\n\t\t\t// call all constructor hooks\r\n\t\t\tif (this._initHooks) {\r\n\t\t\t\tthis.callInitHooks();\r\n\t\t\t}\r\n\t\t};\r\n\t\r\n\t\t// instantiate class without calling constructor\r\n\t\tvar F = function () {};\r\n\t\tF.prototype = this.prototype;\r\n\t\r\n\t\tvar proto = new F();\r\n\t\tproto.constructor = NewClass;\r\n\t\r\n\t\tNewClass.prototype = proto;\r\n\t\r\n\t\t//inherit parent's statics\r\n\t\tfor (var i in this) {\r\n\t\t\tif (this.hasOwnProperty(i) && i !== 'prototype') {\r\n\t\t\t\tNewClass[i] = this[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\t// mix static properties into the class\r\n\t\tif (props.statics) {\r\n\t\t\tL.extend(NewClass, props.statics);\r\n\t\t\tdelete props.statics;\r\n\t\t}\r\n\t\r\n\t\t// mix includes into the prototype\r\n\t\tif (props.includes) {\r\n\t\t\tL.Util.extend.apply(null, [proto].concat(props.includes));\r\n\t\t\tdelete props.includes;\r\n\t\t}\r\n\t\r\n\t\t// merge options\r\n\t\tif (props.options && proto.options) {\r\n\t\t\tprops.options = L.extend({}, proto.options, props.options);\r\n\t\t}\r\n\t\r\n\t\t// mix given properties into the prototype\r\n\t\tL.extend(proto, props);\r\n\t\r\n\t\tproto._initHooks = [];\r\n\t\r\n\t\tvar parent = this;\r\n\t\t// jshint camelcase: false\r\n\t\tNewClass.__super__ = parent.prototype;\r\n\t\r\n\t\t// add method for calling all hooks\r\n\t\tproto.callInitHooks = function () {\r\n\t\r\n\t\t\tif (this._initHooksCalled) { return; }\r\n\t\r\n\t\t\tif (parent.prototype.callInitHooks) {\r\n\t\t\t\tparent.prototype.callInitHooks.call(this);\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._initHooksCalled = true;\r\n\t\r\n\t\t\tfor (var i = 0, len = proto._initHooks.length; i < len; i++) {\r\n\t\t\t\tproto._initHooks[i].call(this);\r\n\t\t\t}\r\n\t\t};\r\n\t\r\n\t\treturn NewClass;\r\n\t};\r\n\t\r\n\t\r\n\t// method for adding properties to prototype\r\n\tL.Class.include = function (props) {\r\n\t\tL.extend(this.prototype, props);\r\n\t};\r\n\t\r\n\t// merge new default options to the Class\r\n\tL.Class.mergeOptions = function (options) {\r\n\t\tL.extend(this.prototype.options, options);\r\n\t};\r\n\t\r\n\t// add a constructor hook\r\n\tL.Class.addInitHook = function (fn) { // (Function) || (String, args...)\r\n\t\tvar args = Array.prototype.slice.call(arguments, 1);\r\n\t\r\n\t\tvar init = typeof fn === 'function' ? fn : function () {\r\n\t\t\tthis[fn].apply(this, args);\r\n\t\t};\r\n\t\r\n\t\tthis.prototype._initHooks = this.prototype._initHooks || [];\r\n\t\tthis.prototype._initHooks.push(init);\r\n\t};\r\n\t\n\t\n\t/*\r\n\t * L.Mixin.Events is used to add custom events functionality to Leaflet classes.\r\n\t */\r\n\t\r\n\tvar eventsKey = '_leaflet_events';\r\n\t\r\n\tL.Mixin = {};\r\n\t\r\n\tL.Mixin.Events = {\r\n\t\r\n\t\taddEventListener: function (types, fn, context) { // (String, Function[, Object]) or (Object[, Object])\r\n\t\r\n\t\t\t// types can be a map of types/handlers\r\n\t\t\tif (L.Util.invokeEach(types, this.addEventListener, this, fn, context)) { return this; }\r\n\t\r\n\t\t\tvar events = this[eventsKey] = this[eventsKey] || {},\r\n\t\t\t    contextId = context && context !== this && L.stamp(context),\r\n\t\t\t    i, len, event, type, indexKey, indexLenKey, typeIndex;\r\n\t\r\n\t\t\t// types can be a string of space-separated words\r\n\t\t\ttypes = L.Util.splitWords(types);\r\n\t\r\n\t\t\tfor (i = 0, len = types.length; i < len; i++) {\r\n\t\t\t\tevent = {\r\n\t\t\t\t\taction: fn,\r\n\t\t\t\t\tcontext: context || this\r\n\t\t\t\t};\r\n\t\t\t\ttype = types[i];\r\n\t\r\n\t\t\t\tif (contextId) {\r\n\t\t\t\t\t// store listeners of a particular context in a separate hash (if it has an id)\r\n\t\t\t\t\t// gives a major performance boost when removing thousands of map layers\r\n\t\r\n\t\t\t\t\tindexKey = type + '_idx';\r\n\t\t\t\t\tindexLenKey = indexKey + '_len';\r\n\t\r\n\t\t\t\t\ttypeIndex = events[indexKey] = events[indexKey] || {};\r\n\t\r\n\t\t\t\t\tif (!typeIndex[contextId]) {\r\n\t\t\t\t\t\ttypeIndex[contextId] = [];\r\n\t\r\n\t\t\t\t\t\t// keep track of the number of keys in the index to quickly check if it's empty\r\n\t\t\t\t\t\tevents[indexLenKey] = (events[indexLenKey] || 0) + 1;\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\ttypeIndex[contextId].push(event);\r\n\t\r\n\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\tevents[type] = events[type] || [];\r\n\t\t\t\t\tevents[type].push(event);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\thasEventListeners: function (type) { // (String) -> Boolean\r\n\t\t\tvar events = this[eventsKey];\r\n\t\t\treturn !!events && ((type in events && events[type].length > 0) ||\r\n\t\t\t                    (type + '_idx' in events && events[type + '_idx_len'] > 0));\r\n\t\t},\r\n\t\r\n\t\tremoveEventListener: function (types, fn, context) { // ([String, Function, Object]) or (Object[, Object])\r\n\t\r\n\t\t\tif (!this[eventsKey]) {\r\n\t\t\t\treturn this;\r\n\t\t\t}\r\n\t\r\n\t\t\tif (!types) {\r\n\t\t\t\treturn this.clearAllEventListeners();\r\n\t\t\t}\r\n\t\r\n\t\t\tif (L.Util.invokeEach(types, this.removeEventListener, this, fn, context)) { return this; }\r\n\t\r\n\t\t\tvar events = this[eventsKey],\r\n\t\t\t    contextId = context && context !== this && L.stamp(context),\r\n\t\t\t    i, len, type, listeners, j, indexKey, indexLenKey, typeIndex, removed;\r\n\t\r\n\t\t\ttypes = L.Util.splitWords(types);\r\n\t\r\n\t\t\tfor (i = 0, len = types.length; i < len; i++) {\r\n\t\t\t\ttype = types[i];\r\n\t\t\t\tindexKey = type + '_idx';\r\n\t\t\t\tindexLenKey = indexKey + '_len';\r\n\t\r\n\t\t\t\ttypeIndex = events[indexKey];\r\n\t\r\n\t\t\t\tif (!fn) {\r\n\t\t\t\t\t// clear all listeners for a type if function isn't specified\r\n\t\t\t\t\tdelete events[type];\r\n\t\t\t\t\tdelete events[indexKey];\r\n\t\t\t\t\tdelete events[indexLenKey];\r\n\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlisteners = contextId && typeIndex ? typeIndex[contextId] : events[type];\r\n\t\r\n\t\t\t\t\tif (listeners) {\r\n\t\t\t\t\t\tfor (j = listeners.length - 1; j >= 0; j--) {\r\n\t\t\t\t\t\t\tif ((listeners[j].action === fn) && (!context || (listeners[j].context === context))) {\r\n\t\t\t\t\t\t\t\tremoved = listeners.splice(j, 1);\r\n\t\t\t\t\t\t\t\t// set the old action to a no-op, because it is possible\r\n\t\t\t\t\t\t\t\t// that the listener is being iterated over as part of a dispatch\r\n\t\t\t\t\t\t\t\tremoved[0].action = L.Util.falseFn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif (context && typeIndex && (listeners.length === 0)) {\r\n\t\t\t\t\t\t\tdelete typeIndex[contextId];\r\n\t\t\t\t\t\t\tevents[indexLenKey]--;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tclearAllEventListeners: function () {\r\n\t\t\tdelete this[eventsKey];\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tfireEvent: function (type, data) { // (String[, Object])\r\n\t\t\tif (!this.hasEventListeners(type)) {\r\n\t\t\t\treturn this;\r\n\t\t\t}\r\n\t\r\n\t\t\tvar event = L.Util.extend({}, data, { type: type, target: this });\r\n\t\r\n\t\t\tvar events = this[eventsKey],\r\n\t\t\t    listeners, i, len, typeIndex, contextId;\r\n\t\r\n\t\t\tif (events[type]) {\r\n\t\t\t\t// make sure adding/removing listeners inside other listeners won't cause infinite loop\r\n\t\t\t\tlisteners = events[type].slice();\r\n\t\r\n\t\t\t\tfor (i = 0, len = listeners.length; i < len; i++) {\r\n\t\t\t\t\tlisteners[i].action.call(listeners[i].context, event);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\t// fire event for the context-indexed listeners as well\r\n\t\t\ttypeIndex = events[type + '_idx'];\r\n\t\r\n\t\t\tfor (contextId in typeIndex) {\r\n\t\t\t\tlisteners = typeIndex[contextId].slice();\r\n\t\r\n\t\t\t\tif (listeners) {\r\n\t\t\t\t\tfor (i = 0, len = listeners.length; i < len; i++) {\r\n\t\t\t\t\t\tlisteners[i].action.call(listeners[i].context, event);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\taddOneTimeEventListener: function (types, fn, context) {\r\n\t\r\n\t\t\tif (L.Util.invokeEach(types, this.addOneTimeEventListener, this, fn, context)) { return this; }\r\n\t\r\n\t\t\tvar handler = L.bind(function () {\r\n\t\t\t\tthis\r\n\t\t\t\t    .removeEventListener(types, fn, context)\r\n\t\t\t\t    .removeEventListener(types, handler, context);\r\n\t\t\t}, this);\r\n\t\r\n\t\t\treturn this\r\n\t\t\t    .addEventListener(types, fn, context)\r\n\t\t\t    .addEventListener(types, handler, context);\r\n\t\t}\r\n\t};\r\n\t\r\n\tL.Mixin.Events.on = L.Mixin.Events.addEventListener;\r\n\tL.Mixin.Events.off = L.Mixin.Events.removeEventListener;\r\n\tL.Mixin.Events.once = L.Mixin.Events.addOneTimeEventListener;\r\n\tL.Mixin.Events.fire = L.Mixin.Events.fireEvent;\r\n\t\n\t\n\t/*\r\n\t * L.Browser handles different browser and feature detections for internal Leaflet use.\r\n\t */\r\n\t\r\n\t(function () {\r\n\t\r\n\t\tvar ie = 'ActiveXObject' in window,\r\n\t\t\tielt9 = ie && !document.addEventListener,\r\n\t\r\n\t\t    // terrible browser detection to work around Safari / iOS / Android browser bugs\r\n\t\t    ua = navigator.userAgent.toLowerCase(),\r\n\t\t    webkit = ua.indexOf('webkit') !== -1,\r\n\t\t    chrome = ua.indexOf('chrome') !== -1,\r\n\t\t    phantomjs = ua.indexOf('phantom') !== -1,\r\n\t\t    android = ua.indexOf('android') !== -1,\r\n\t\t    android23 = ua.search('android [23]') !== -1,\r\n\t\t\tgecko = ua.indexOf('gecko') !== -1,\r\n\t\r\n\t\t    mobile = typeof orientation !== undefined + '',\r\n\t\t    msPointer = !window.PointerEvent && window.MSPointerEvent,\r\n\t\t\tpointer = (window.PointerEvent && window.navigator.pointerEnabled) ||\r\n\t\t\t\t\t  msPointer,\r\n\t\t    retina = ('devicePixelRatio' in window && window.devicePixelRatio > 1) ||\r\n\t\t             ('matchMedia' in window && window.matchMedia('(min-resolution:144dpi)') &&\r\n\t\t              window.matchMedia('(min-resolution:144dpi)').matches),\r\n\t\r\n\t\t    doc = document.documentElement,\r\n\t\t    ie3d = ie && ('transition' in doc.style),\r\n\t\t    webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,\r\n\t\t    gecko3d = 'MozPerspective' in doc.style,\r\n\t\t    opera3d = 'OTransition' in doc.style,\r\n\t\t    any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d || opera3d) && !phantomjs;\r\n\t\r\n\t\tvar touch = !window.L_NO_TOUCH && !phantomjs && (pointer || 'ontouchstart' in window ||\r\n\t\t\t(window.DocumentTouch && document instanceof window.DocumentTouch));\r\n\t\r\n\t\tL.Browser = {\r\n\t\t\tie: ie,\r\n\t\t\tielt9: ielt9,\r\n\t\t\twebkit: webkit,\r\n\t\t\tgecko: gecko && !webkit && !window.opera && !ie,\r\n\t\r\n\t\t\tandroid: android,\r\n\t\t\tandroid23: android23,\r\n\t\r\n\t\t\tchrome: chrome,\r\n\t\r\n\t\t\tie3d: ie3d,\r\n\t\t\twebkit3d: webkit3d,\r\n\t\t\tgecko3d: gecko3d,\r\n\t\t\topera3d: opera3d,\r\n\t\t\tany3d: any3d,\r\n\t\r\n\t\t\tmobile: mobile,\r\n\t\t\tmobileWebkit: mobile && webkit,\r\n\t\t\tmobileWebkit3d: mobile && webkit3d,\r\n\t\t\tmobileOpera: mobile && window.opera,\r\n\t\r\n\t\t\ttouch: touch,\r\n\t\t\tmsPointer: msPointer,\r\n\t\t\tpointer: pointer,\r\n\t\r\n\t\t\tretina: retina\r\n\t\t};\r\n\t\r\n\t}());\r\n\t\n\t\n\t/*\r\n\t * L.Point represents a point with x and y coordinates.\r\n\t */\r\n\t\r\n\tL.Point = function (/*Number*/ x, /*Number*/ y, /*Boolean*/ round) {\r\n\t\tthis.x = (round ? Math.round(x) : x);\r\n\t\tthis.y = (round ? Math.round(y) : y);\r\n\t};\r\n\t\r\n\tL.Point.prototype = {\r\n\t\r\n\t\tclone: function () {\r\n\t\t\treturn new L.Point(this.x, this.y);\r\n\t\t},\r\n\t\r\n\t\t// non-destructive, returns a new point\r\n\t\tadd: function (point) {\r\n\t\t\treturn this.clone()._add(L.point(point));\r\n\t\t},\r\n\t\r\n\t\t// destructive, used directly for performance in situations where it's safe to modify existing point\r\n\t\t_add: function (point) {\r\n\t\t\tthis.x += point.x;\r\n\t\t\tthis.y += point.y;\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tsubtract: function (point) {\r\n\t\t\treturn this.clone()._subtract(L.point(point));\r\n\t\t},\r\n\t\r\n\t\t_subtract: function (point) {\r\n\t\t\tthis.x -= point.x;\r\n\t\t\tthis.y -= point.y;\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tdivideBy: function (num) {\r\n\t\t\treturn this.clone()._divideBy(num);\r\n\t\t},\r\n\t\r\n\t\t_divideBy: function (num) {\r\n\t\t\tthis.x /= num;\r\n\t\t\tthis.y /= num;\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tmultiplyBy: function (num) {\r\n\t\t\treturn this.clone()._multiplyBy(num);\r\n\t\t},\r\n\t\r\n\t\t_multiplyBy: function (num) {\r\n\t\t\tthis.x *= num;\r\n\t\t\tthis.y *= num;\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tround: function () {\r\n\t\t\treturn this.clone()._round();\r\n\t\t},\r\n\t\r\n\t\t_round: function () {\r\n\t\t\tthis.x = Math.round(this.x);\r\n\t\t\tthis.y = Math.round(this.y);\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tfloor: function () {\r\n\t\t\treturn this.clone()._floor();\r\n\t\t},\r\n\t\r\n\t\t_floor: function () {\r\n\t\t\tthis.x = Math.floor(this.x);\r\n\t\t\tthis.y = Math.floor(this.y);\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tdistanceTo: function (point) {\r\n\t\t\tpoint = L.point(point);\r\n\t\r\n\t\t\tvar x = point.x - this.x,\r\n\t\t\t    y = point.y - this.y;\r\n\t\r\n\t\t\treturn Math.sqrt(x * x + y * y);\r\n\t\t},\r\n\t\r\n\t\tequals: function (point) {\r\n\t\t\tpoint = L.point(point);\r\n\t\r\n\t\t\treturn point.x === this.x &&\r\n\t\t\t       point.y === this.y;\r\n\t\t},\r\n\t\r\n\t\tcontains: function (point) {\r\n\t\t\tpoint = L.point(point);\r\n\t\r\n\t\t\treturn Math.abs(point.x) <= Math.abs(this.x) &&\r\n\t\t\t       Math.abs(point.y) <= Math.abs(this.y);\r\n\t\t},\r\n\t\r\n\t\ttoString: function () {\r\n\t\t\treturn 'Point(' +\r\n\t\t\t        L.Util.formatNum(this.x) + ', ' +\r\n\t\t\t        L.Util.formatNum(this.y) + ')';\r\n\t\t}\r\n\t};\r\n\t\r\n\tL.point = function (x, y, round) {\r\n\t\tif (x instanceof L.Point) {\r\n\t\t\treturn x;\r\n\t\t}\r\n\t\tif (L.Util.isArray(x)) {\r\n\t\t\treturn new L.Point(x[0], x[1]);\r\n\t\t}\r\n\t\tif (x === undefined || x === null) {\r\n\t\t\treturn x;\r\n\t\t}\r\n\t\treturn new L.Point(x, y, round);\r\n\t};\r\n\t\n\t\n\t/*\r\n\t * L.Bounds represents a rectangular area on the screen in pixel coordinates.\r\n\t */\r\n\t\r\n\tL.Bounds = function (a, b) { //(Point, Point) or Point[]\r\n\t\tif (!a) { return; }\r\n\t\r\n\t\tvar points = b ? [a, b] : a;\r\n\t\r\n\t\tfor (var i = 0, len = points.length; i < len; i++) {\r\n\t\t\tthis.extend(points[i]);\r\n\t\t}\r\n\t};\r\n\t\r\n\tL.Bounds.prototype = {\r\n\t\t// extend the bounds to contain the given point\r\n\t\textend: function (point) { // (Point)\r\n\t\t\tpoint = L.point(point);\r\n\t\r\n\t\t\tif (!this.min && !this.max) {\r\n\t\t\t\tthis.min = point.clone();\r\n\t\t\t\tthis.max = point.clone();\r\n\t\t\t} else {\r\n\t\t\t\tthis.min.x = Math.min(point.x, this.min.x);\r\n\t\t\t\tthis.max.x = Math.max(point.x, this.max.x);\r\n\t\t\t\tthis.min.y = Math.min(point.y, this.min.y);\r\n\t\t\t\tthis.max.y = Math.max(point.y, this.max.y);\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tgetCenter: function (round) { // (Boolean) -> Point\r\n\t\t\treturn new L.Point(\r\n\t\t\t        (this.min.x + this.max.x) / 2,\r\n\t\t\t        (this.min.y + this.max.y) / 2, round);\r\n\t\t},\r\n\t\r\n\t\tgetBottomLeft: function () { // -> Point\r\n\t\t\treturn new L.Point(this.min.x, this.max.y);\r\n\t\t},\r\n\t\r\n\t\tgetTopRight: function () { // -> Point\r\n\t\t\treturn new L.Point(this.max.x, this.min.y);\r\n\t\t},\r\n\t\r\n\t\tgetSize: function () {\r\n\t\t\treturn this.max.subtract(this.min);\r\n\t\t},\r\n\t\r\n\t\tcontains: function (obj) { // (Bounds) or (Point) -> Boolean\r\n\t\t\tvar min, max;\r\n\t\r\n\t\t\tif (typeof obj[0] === 'number' || obj instanceof L.Point) {\r\n\t\t\t\tobj = L.point(obj);\r\n\t\t\t} else {\r\n\t\t\t\tobj = L.bounds(obj);\r\n\t\t\t}\r\n\t\r\n\t\t\tif (obj instanceof L.Bounds) {\r\n\t\t\t\tmin = obj.min;\r\n\t\t\t\tmax = obj.max;\r\n\t\t\t} else {\r\n\t\t\t\tmin = max = obj;\r\n\t\t\t}\r\n\t\r\n\t\t\treturn (min.x >= this.min.x) &&\r\n\t\t\t       (max.x <= this.max.x) &&\r\n\t\t\t       (min.y >= this.min.y) &&\r\n\t\t\t       (max.y <= this.max.y);\r\n\t\t},\r\n\t\r\n\t\tintersects: function (bounds) { // (Bounds) -> Boolean\r\n\t\t\tbounds = L.bounds(bounds);\r\n\t\r\n\t\t\tvar min = this.min,\r\n\t\t\t    max = this.max,\r\n\t\t\t    min2 = bounds.min,\r\n\t\t\t    max2 = bounds.max,\r\n\t\t\t    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),\r\n\t\t\t    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);\r\n\t\r\n\t\t\treturn xIntersects && yIntersects;\r\n\t\t},\r\n\t\r\n\t\tisValid: function () {\r\n\t\t\treturn !!(this.min && this.max);\r\n\t\t}\r\n\t};\r\n\t\r\n\tL.bounds = function (a, b) { // (Bounds) or (Point, Point) or (Point[])\r\n\t\tif (!a || a instanceof L.Bounds) {\r\n\t\t\treturn a;\r\n\t\t}\r\n\t\treturn new L.Bounds(a, b);\r\n\t};\r\n\t\n\t\n\t/*\r\n\t * L.Transformation is an utility class to perform simple point transformations through a 2d-matrix.\r\n\t */\r\n\t\r\n\tL.Transformation = function (a, b, c, d) {\r\n\t\tthis._a = a;\r\n\t\tthis._b = b;\r\n\t\tthis._c = c;\r\n\t\tthis._d = d;\r\n\t};\r\n\t\r\n\tL.Transformation.prototype = {\r\n\t\ttransform: function (point, scale) { // (Point, Number) -> Point\r\n\t\t\treturn this._transform(point.clone(), scale);\r\n\t\t},\r\n\t\r\n\t\t// destructive transform (faster)\r\n\t\t_transform: function (point, scale) {\r\n\t\t\tscale = scale || 1;\r\n\t\t\tpoint.x = scale * (this._a * point.x + this._b);\r\n\t\t\tpoint.y = scale * (this._c * point.y + this._d);\r\n\t\t\treturn point;\r\n\t\t},\r\n\t\r\n\t\tuntransform: function (point, scale) {\r\n\t\t\tscale = scale || 1;\r\n\t\t\treturn new L.Point(\r\n\t\t\t        (point.x / scale - this._b) / this._a,\r\n\t\t\t        (point.y / scale - this._d) / this._c);\r\n\t\t}\r\n\t};\r\n\t\n\t\n\t/*\r\n\t * L.DomUtil contains various utility functions for working with DOM.\r\n\t */\r\n\t\r\n\tL.DomUtil = {\r\n\t\tget: function (id) {\r\n\t\t\treturn (typeof id === 'string' ? document.getElementById(id) : id);\r\n\t\t},\r\n\t\r\n\t\tgetStyle: function (el, style) {\r\n\t\r\n\t\t\tvar value = el.style[style];\r\n\t\r\n\t\t\tif (!value && el.currentStyle) {\r\n\t\t\t\tvalue = el.currentStyle[style];\r\n\t\t\t}\r\n\t\r\n\t\t\tif ((!value || value === 'auto') && document.defaultView) {\r\n\t\t\t\tvar css = document.defaultView.getComputedStyle(el, null);\r\n\t\t\t\tvalue = css ? css[style] : null;\r\n\t\t\t}\r\n\t\r\n\t\t\treturn value === 'auto' ? null : value;\r\n\t\t},\r\n\t\r\n\t\tgetViewportOffset: function (element) {\r\n\t\r\n\t\t\tvar top = 0,\r\n\t\t\t    left = 0,\r\n\t\t\t    el = element,\r\n\t\t\t    docBody = document.body,\r\n\t\t\t    docEl = document.documentElement,\r\n\t\t\t    pos;\r\n\t\r\n\t\t\tdo {\r\n\t\t\t\ttop  += el.offsetTop  || 0;\r\n\t\t\t\tleft += el.offsetLeft || 0;\r\n\t\r\n\t\t\t\t//add borders\r\n\t\t\t\ttop += parseInt(L.DomUtil.getStyle(el, 'borderTopWidth'), 10) || 0;\r\n\t\t\t\tleft += parseInt(L.DomUtil.getStyle(el, 'borderLeftWidth'), 10) || 0;\r\n\t\r\n\t\t\t\tpos = L.DomUtil.getStyle(el, 'position');\r\n\t\r\n\t\t\t\tif (el.offsetParent === docBody && pos === 'absolute') { break; }\r\n\t\r\n\t\t\t\tif (pos === 'fixed') {\r\n\t\t\t\t\ttop  += docBody.scrollTop  || docEl.scrollTop  || 0;\r\n\t\t\t\t\tleft += docBody.scrollLeft || docEl.scrollLeft || 0;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif (pos === 'relative' && !el.offsetLeft) {\r\n\t\t\t\t\tvar width = L.DomUtil.getStyle(el, 'width'),\r\n\t\t\t\t\t    maxWidth = L.DomUtil.getStyle(el, 'max-width'),\r\n\t\t\t\t\t    r = el.getBoundingClientRect();\r\n\t\r\n\t\t\t\t\tif (width !== 'none' || maxWidth !== 'none') {\r\n\t\t\t\t\t\tleft += r.left + el.clientLeft;\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t//calculate full y offset since we're breaking out of the loop\r\n\t\t\t\t\ttop += r.top + (docBody.scrollTop  || docEl.scrollTop  || 0);\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tel = el.offsetParent;\r\n\t\r\n\t\t\t} while (el);\r\n\t\r\n\t\t\tel = element;\r\n\t\r\n\t\t\tdo {\r\n\t\t\t\tif (el === docBody) { break; }\r\n\t\r\n\t\t\t\ttop  -= el.scrollTop  || 0;\r\n\t\t\t\tleft -= el.scrollLeft || 0;\r\n\t\r\n\t\t\t\tel = el.parentNode;\r\n\t\t\t} while (el);\r\n\t\r\n\t\t\treturn new L.Point(left, top);\r\n\t\t},\r\n\t\r\n\t\tdocumentIsLtr: function () {\r\n\t\t\tif (!L.DomUtil._docIsLtrCached) {\r\n\t\t\t\tL.DomUtil._docIsLtrCached = true;\r\n\t\t\t\tL.DomUtil._docIsLtr = L.DomUtil.getStyle(document.body, 'direction') === 'ltr';\r\n\t\t\t}\r\n\t\t\treturn L.DomUtil._docIsLtr;\r\n\t\t},\r\n\t\r\n\t\tcreate: function (tagName, className, container) {\r\n\t\r\n\t\t\tvar el = document.createElement(tagName);\r\n\t\t\tel.className = className;\r\n\t\r\n\t\t\tif (container) {\r\n\t\t\t\tcontainer.appendChild(el);\r\n\t\t\t}\r\n\t\r\n\t\t\treturn el;\r\n\t\t},\r\n\t\r\n\t\thasClass: function (el, name) {\r\n\t\t\tif (el.classList !== undefined) {\r\n\t\t\t\treturn el.classList.contains(name);\r\n\t\t\t}\r\n\t\t\tvar className = L.DomUtil._getClass(el);\r\n\t\t\treturn className.length > 0 && new RegExp('(^|\\\\s)' + name + '(\\\\s|$)').test(className);\r\n\t\t},\r\n\t\r\n\t\taddClass: function (el, name) {\r\n\t\t\tif (el.classList !== undefined) {\r\n\t\t\t\tvar classes = L.Util.splitWords(name);\r\n\t\t\t\tfor (var i = 0, len = classes.length; i < len; i++) {\r\n\t\t\t\t\tel.classList.add(classes[i]);\r\n\t\t\t\t}\r\n\t\t\t} else if (!L.DomUtil.hasClass(el, name)) {\r\n\t\t\t\tvar className = L.DomUtil._getClass(el);\r\n\t\t\t\tL.DomUtil._setClass(el, (className ? className + ' ' : '') + name);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\tremoveClass: function (el, name) {\r\n\t\t\tif (el.classList !== undefined) {\r\n\t\t\t\tel.classList.remove(name);\r\n\t\t\t} else {\r\n\t\t\t\tL.DomUtil._setClass(el, L.Util.trim((' ' + L.DomUtil._getClass(el) + ' ').replace(' ' + name + ' ', ' ')));\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_setClass: function (el, name) {\r\n\t\t\tif (el.className.baseVal === undefined) {\r\n\t\t\t\tel.className = name;\r\n\t\t\t} else {\r\n\t\t\t\t// in case of SVG element\r\n\t\t\t\tel.className.baseVal = name;\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_getClass: function (el) {\r\n\t\t\treturn el.className.baseVal === undefined ? el.className : el.className.baseVal;\r\n\t\t},\r\n\t\r\n\t\tsetOpacity: function (el, value) {\r\n\t\r\n\t\t\tif ('opacity' in el.style) {\r\n\t\t\t\tel.style.opacity = value;\r\n\t\r\n\t\t\t} else if ('filter' in el.style) {\r\n\t\r\n\t\t\t\tvar filter = false,\r\n\t\t\t\t    filterName = 'DXImageTransform.Microsoft.Alpha';\r\n\t\r\n\t\t\t\t// filters collection throws an error if we try to retrieve a filter that doesn't exist\r\n\t\t\t\ttry {\r\n\t\t\t\t\tfilter = el.filters.item(filterName);\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\t// don't set opacity to 1 if we haven't already set an opacity,\r\n\t\t\t\t\t// it isn't needed and breaks transparent pngs.\r\n\t\t\t\t\tif (value === 1) { return; }\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvalue = Math.round(value * 100);\r\n\t\r\n\t\t\t\tif (filter) {\r\n\t\t\t\t\tfilter.Enabled = (value !== 100);\r\n\t\t\t\t\tfilter.Opacity = value;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tel.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\ttestProp: function (props) {\r\n\t\r\n\t\t\tvar style = document.documentElement.style;\r\n\t\r\n\t\t\tfor (var i = 0; i < props.length; i++) {\r\n\t\t\t\tif (props[i] in style) {\r\n\t\t\t\t\treturn props[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t},\r\n\t\r\n\t\tgetTranslateString: function (point) {\r\n\t\t\t// on WebKit browsers (Chrome/Safari/iOS Safari/Android) using translate3d instead of translate\r\n\t\t\t// makes animation smoother as it ensures HW accel is used. Firefox 13 doesn't care\r\n\t\t\t// (same speed either way), Opera 12 doesn't support translate3d\r\n\t\r\n\t\t\tvar is3d = L.Browser.webkit3d,\r\n\t\t\t    open = 'translate' + (is3d ? '3d' : '') + '(',\r\n\t\t\t    close = (is3d ? ',0' : '') + ')';\r\n\t\r\n\t\t\treturn open + point.x + 'px,' + point.y + 'px' + close;\r\n\t\t},\r\n\t\r\n\t\tgetScaleString: function (scale, origin) {\r\n\t\r\n\t\t\tvar preTranslateStr = L.DomUtil.getTranslateString(origin.add(origin.multiplyBy(-1 * scale))),\r\n\t\t\t    scaleStr = ' scale(' + scale + ') ';\r\n\t\r\n\t\t\treturn preTranslateStr + scaleStr;\r\n\t\t},\r\n\t\r\n\t\tsetPosition: function (el, point, disable3D) { // (HTMLElement, Point[, Boolean])\r\n\t\r\n\t\t\t// jshint camelcase: false\r\n\t\t\tel._leaflet_pos = point;\r\n\t\r\n\t\t\tif (!disable3D && L.Browser.any3d) {\r\n\t\t\t\tel.style[L.DomUtil.TRANSFORM] =  L.DomUtil.getTranslateString(point);\r\n\t\t\t} else {\r\n\t\t\t\tel.style.left = point.x + 'px';\r\n\t\t\t\tel.style.top = point.y + 'px';\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\tgetPosition: function (el) {\r\n\t\t\t// this method is only used for elements previously positioned using setPosition,\r\n\t\t\t// so it's safe to cache the position for performance\r\n\t\r\n\t\t\t// jshint camelcase: false\r\n\t\t\treturn el._leaflet_pos;\r\n\t\t}\r\n\t};\r\n\t\r\n\t\r\n\t// prefix style property names\r\n\t\r\n\tL.DomUtil.TRANSFORM = L.DomUtil.testProp(\r\n\t        ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);\r\n\t\r\n\t// webkitTransition comes first because some browser versions that drop vendor prefix don't do\r\n\t// the same for the transitionend event, in particular the Android 4.1 stock browser\r\n\t\r\n\tL.DomUtil.TRANSITION = L.DomUtil.testProp(\r\n\t        ['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);\r\n\t\r\n\tL.DomUtil.TRANSITION_END =\r\n\t        L.DomUtil.TRANSITION === 'webkitTransition' || L.DomUtil.TRANSITION === 'OTransition' ?\r\n\t        L.DomUtil.TRANSITION + 'End' : 'transitionend';\r\n\t\r\n\t(function () {\r\n\t    if ('onselectstart' in document) {\r\n\t        L.extend(L.DomUtil, {\r\n\t            disableTextSelection: function () {\r\n\t                L.DomEvent.on(window, 'selectstart', L.DomEvent.preventDefault);\r\n\t            },\r\n\t\r\n\t            enableTextSelection: function () {\r\n\t                L.DomEvent.off(window, 'selectstart', L.DomEvent.preventDefault);\r\n\t            }\r\n\t        });\r\n\t    } else {\r\n\t        var userSelectProperty = L.DomUtil.testProp(\r\n\t            ['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);\r\n\t\r\n\t        L.extend(L.DomUtil, {\r\n\t            disableTextSelection: function () {\r\n\t                if (userSelectProperty) {\r\n\t                    var style = document.documentElement.style;\r\n\t                    this._userSelect = style[userSelectProperty];\r\n\t                    style[userSelectProperty] = 'none';\r\n\t                }\r\n\t            },\r\n\t\r\n\t            enableTextSelection: function () {\r\n\t                if (userSelectProperty) {\r\n\t                    document.documentElement.style[userSelectProperty] = this._userSelect;\r\n\t                    delete this._userSelect;\r\n\t                }\r\n\t            }\r\n\t        });\r\n\t    }\r\n\t\r\n\t\tL.extend(L.DomUtil, {\r\n\t\t\tdisableImageDrag: function () {\r\n\t\t\t\tL.DomEvent.on(window, 'dragstart', L.DomEvent.preventDefault);\r\n\t\t\t},\r\n\t\r\n\t\t\tenableImageDrag: function () {\r\n\t\t\t\tL.DomEvent.off(window, 'dragstart', L.DomEvent.preventDefault);\r\n\t\t\t}\r\n\t\t});\r\n\t})();\r\n\t\n\t\n\t/*\r\n\t * L.LatLng represents a geographical point with latitude and longitude coordinates.\r\n\t */\r\n\t\r\n\tL.LatLng = function (lat, lng, alt) { // (Number, Number, Number)\r\n\t\tlat = parseFloat(lat);\r\n\t\tlng = parseFloat(lng);\r\n\t\r\n\t\tif (isNaN(lat) || isNaN(lng)) {\r\n\t\t\tthrow new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');\r\n\t\t}\r\n\t\r\n\t\tthis.lat = lat;\r\n\t\tthis.lng = lng;\r\n\t\r\n\t\tif (alt !== undefined) {\r\n\t\t\tthis.alt = parseFloat(alt);\r\n\t\t}\r\n\t};\r\n\t\r\n\tL.extend(L.LatLng, {\r\n\t\tDEG_TO_RAD: Math.PI / 180,\r\n\t\tRAD_TO_DEG: 180 / Math.PI,\r\n\t\tMAX_MARGIN: 1.0E-9 // max margin of error for the \"equals\" check\r\n\t});\r\n\t\r\n\tL.LatLng.prototype = {\r\n\t\tequals: function (obj) { // (LatLng) -> Boolean\r\n\t\t\tif (!obj) { return false; }\r\n\t\r\n\t\t\tobj = L.latLng(obj);\r\n\t\r\n\t\t\tvar margin = Math.max(\r\n\t\t\t        Math.abs(this.lat - obj.lat),\r\n\t\t\t        Math.abs(this.lng - obj.lng));\r\n\t\r\n\t\t\treturn margin <= L.LatLng.MAX_MARGIN;\r\n\t\t},\r\n\t\r\n\t\ttoString: function (precision) { // (Number) -> String\r\n\t\t\treturn 'LatLng(' +\r\n\t\t\t        L.Util.formatNum(this.lat, precision) + ', ' +\r\n\t\t\t        L.Util.formatNum(this.lng, precision) + ')';\r\n\t\t},\r\n\t\r\n\t\t// Haversine distance formula, see http://en.wikipedia.org/wiki/Haversine_formula\r\n\t\t// TODO move to projection code, LatLng shouldn't know about Earth\r\n\t\tdistanceTo: function (other) { // (LatLng) -> Number\r\n\t\t\tother = L.latLng(other);\r\n\t\r\n\t\t\tvar R = 6378137, // earth radius in meters\r\n\t\t\t    d2r = L.LatLng.DEG_TO_RAD,\r\n\t\t\t    dLat = (other.lat - this.lat) * d2r,\r\n\t\t\t    dLon = (other.lng - this.lng) * d2r,\r\n\t\t\t    lat1 = this.lat * d2r,\r\n\t\t\t    lat2 = other.lat * d2r,\r\n\t\t\t    sin1 = Math.sin(dLat / 2),\r\n\t\t\t    sin2 = Math.sin(dLon / 2);\r\n\t\r\n\t\t\tvar a = sin1 * sin1 + sin2 * sin2 * Math.cos(lat1) * Math.cos(lat2);\r\n\t\r\n\t\t\treturn R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n\t\t},\r\n\t\r\n\t\twrap: function (a, b) { // (Number, Number) -> LatLng\r\n\t\t\tvar lng = this.lng;\r\n\t\r\n\t\t\ta = a || -180;\r\n\t\t\tb = b ||  180;\r\n\t\r\n\t\t\tlng = (lng + b) % (b - a) + (lng < a || lng === b ? b : a);\r\n\t\r\n\t\t\treturn new L.LatLng(this.lat, lng);\r\n\t\t}\r\n\t};\r\n\t\r\n\tL.latLng = function (a, b) { // (LatLng) or ([Number, Number]) or (Number, Number)\r\n\t\tif (a instanceof L.LatLng) {\r\n\t\t\treturn a;\r\n\t\t}\r\n\t\tif (L.Util.isArray(a)) {\r\n\t\t\tif (typeof a[0] === 'number' || typeof a[0] === 'string') {\r\n\t\t\t\treturn new L.LatLng(a[0], a[1], a[2]);\r\n\t\t\t} else {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (a === undefined || a === null) {\r\n\t\t\treturn a;\r\n\t\t}\r\n\t\tif (typeof a === 'object' && 'lat' in a) {\r\n\t\t\treturn new L.LatLng(a.lat, 'lng' in a ? a.lng : a.lon);\r\n\t\t}\r\n\t\tif (b === undefined) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\treturn new L.LatLng(a, b);\r\n\t};\r\n\t\r\n\t\n\t\n\t/*\r\n\t * L.LatLngBounds represents a rectangular area on the map in geographical coordinates.\r\n\t */\r\n\t\r\n\tL.LatLngBounds = function (southWest, northEast) { // (LatLng, LatLng) or (LatLng[])\r\n\t\tif (!southWest) { return; }\r\n\t\r\n\t\tvar latlngs = northEast ? [southWest, northEast] : southWest;\r\n\t\r\n\t\tfor (var i = 0, len = latlngs.length; i < len; i++) {\r\n\t\t\tthis.extend(latlngs[i]);\r\n\t\t}\r\n\t};\r\n\t\r\n\tL.LatLngBounds.prototype = {\r\n\t\t// extend the bounds to contain the given point or bounds\r\n\t\textend: function (obj) { // (LatLng) or (LatLngBounds)\r\n\t\t\tif (!obj) { return this; }\r\n\t\r\n\t\t\tvar latLng = L.latLng(obj);\r\n\t\t\tif (latLng !== null) {\r\n\t\t\t\tobj = latLng;\r\n\t\t\t} else {\r\n\t\t\t\tobj = L.latLngBounds(obj);\r\n\t\t\t}\r\n\t\r\n\t\t\tif (obj instanceof L.LatLng) {\r\n\t\t\t\tif (!this._southWest && !this._northEast) {\r\n\t\t\t\t\tthis._southWest = new L.LatLng(obj.lat, obj.lng);\r\n\t\t\t\t\tthis._northEast = new L.LatLng(obj.lat, obj.lng);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis._southWest.lat = Math.min(obj.lat, this._southWest.lat);\r\n\t\t\t\t\tthis._southWest.lng = Math.min(obj.lng, this._southWest.lng);\r\n\t\r\n\t\t\t\t\tthis._northEast.lat = Math.max(obj.lat, this._northEast.lat);\r\n\t\t\t\t\tthis._northEast.lng = Math.max(obj.lng, this._northEast.lng);\r\n\t\t\t\t}\r\n\t\t\t} else if (obj instanceof L.LatLngBounds) {\r\n\t\t\t\tthis.extend(obj._southWest);\r\n\t\t\t\tthis.extend(obj._northEast);\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\t// extend the bounds by a percentage\r\n\t\tpad: function (bufferRatio) { // (Number) -> LatLngBounds\r\n\t\t\tvar sw = this._southWest,\r\n\t\t\t    ne = this._northEast,\r\n\t\t\t    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,\r\n\t\t\t    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;\r\n\t\r\n\t\t\treturn new L.LatLngBounds(\r\n\t\t\t        new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),\r\n\t\t\t        new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));\r\n\t\t},\r\n\t\r\n\t\tgetCenter: function () { // -> LatLng\r\n\t\t\treturn new L.LatLng(\r\n\t\t\t        (this._southWest.lat + this._northEast.lat) / 2,\r\n\t\t\t        (this._southWest.lng + this._northEast.lng) / 2);\r\n\t\t},\r\n\t\r\n\t\tgetSouthWest: function () {\r\n\t\t\treturn this._southWest;\r\n\t\t},\r\n\t\r\n\t\tgetNorthEast: function () {\r\n\t\t\treturn this._northEast;\r\n\t\t},\r\n\t\r\n\t\tgetNorthWest: function () {\r\n\t\t\treturn new L.LatLng(this.getNorth(), this.getWest());\r\n\t\t},\r\n\t\r\n\t\tgetSouthEast: function () {\r\n\t\t\treturn new L.LatLng(this.getSouth(), this.getEast());\r\n\t\t},\r\n\t\r\n\t\tgetWest: function () {\r\n\t\t\treturn this._southWest.lng;\r\n\t\t},\r\n\t\r\n\t\tgetSouth: function () {\r\n\t\t\treturn this._southWest.lat;\r\n\t\t},\r\n\t\r\n\t\tgetEast: function () {\r\n\t\t\treturn this._northEast.lng;\r\n\t\t},\r\n\t\r\n\t\tgetNorth: function () {\r\n\t\t\treturn this._northEast.lat;\r\n\t\t},\r\n\t\r\n\t\tcontains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean\r\n\t\t\tif (typeof obj[0] === 'number' || obj instanceof L.LatLng) {\r\n\t\t\t\tobj = L.latLng(obj);\r\n\t\t\t} else {\r\n\t\t\t\tobj = L.latLngBounds(obj);\r\n\t\t\t}\r\n\t\r\n\t\t\tvar sw = this._southWest,\r\n\t\t\t    ne = this._northEast,\r\n\t\t\t    sw2, ne2;\r\n\t\r\n\t\t\tif (obj instanceof L.LatLngBounds) {\r\n\t\t\t\tsw2 = obj.getSouthWest();\r\n\t\t\t\tne2 = obj.getNorthEast();\r\n\t\t\t} else {\r\n\t\t\t\tsw2 = ne2 = obj;\r\n\t\t\t}\r\n\t\r\n\t\t\treturn (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&\r\n\t\t\t       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);\r\n\t\t},\r\n\t\r\n\t\tintersects: function (bounds) { // (LatLngBounds)\r\n\t\t\tbounds = L.latLngBounds(bounds);\r\n\t\r\n\t\t\tvar sw = this._southWest,\r\n\t\t\t    ne = this._northEast,\r\n\t\t\t    sw2 = bounds.getSouthWest(),\r\n\t\t\t    ne2 = bounds.getNorthEast(),\r\n\t\r\n\t\t\t    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),\r\n\t\t\t    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);\r\n\t\r\n\t\t\treturn latIntersects && lngIntersects;\r\n\t\t},\r\n\t\r\n\t\ttoBBoxString: function () {\r\n\t\t\treturn [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');\r\n\t\t},\r\n\t\r\n\t\tequals: function (bounds) { // (LatLngBounds)\r\n\t\t\tif (!bounds) { return false; }\r\n\t\r\n\t\t\tbounds = L.latLngBounds(bounds);\r\n\t\r\n\t\t\treturn this._southWest.equals(bounds.getSouthWest()) &&\r\n\t\t\t       this._northEast.equals(bounds.getNorthEast());\r\n\t\t},\r\n\t\r\n\t\tisValid: function () {\r\n\t\t\treturn !!(this._southWest && this._northEast);\r\n\t\t}\r\n\t};\r\n\t\r\n\t//TODO International date line?\r\n\t\r\n\tL.latLngBounds = function (a, b) { // (LatLngBounds) or (LatLng, LatLng)\r\n\t\tif (!a || a instanceof L.LatLngBounds) {\r\n\t\t\treturn a;\r\n\t\t}\r\n\t\treturn new L.LatLngBounds(a, b);\r\n\t};\r\n\t\n\t\n\t/*\r\n\t * L.Projection contains various geographical projections used by CRS classes.\r\n\t */\r\n\t\r\n\tL.Projection = {};\r\n\t\n\t\n\t/*\r\n\t * Spherical Mercator is the most popular map projection, used by EPSG:3857 CRS used by default.\r\n\t */\r\n\t\r\n\tL.Projection.SphericalMercator = {\r\n\t\tMAX_LATITUDE: 85.0511287798,\r\n\t\r\n\t\tproject: function (latlng) { // (LatLng) -> Point\r\n\t\t\tvar d = L.LatLng.DEG_TO_RAD,\r\n\t\t\t    max = this.MAX_LATITUDE,\r\n\t\t\t    lat = Math.max(Math.min(max, latlng.lat), -max),\r\n\t\t\t    x = latlng.lng * d,\r\n\t\t\t    y = lat * d;\r\n\t\r\n\t\t\ty = Math.log(Math.tan((Math.PI / 4) + (y / 2)));\r\n\t\r\n\t\t\treturn new L.Point(x, y);\r\n\t\t},\r\n\t\r\n\t\tunproject: function (point) { // (Point, Boolean) -> LatLng\r\n\t\t\tvar d = L.LatLng.RAD_TO_DEG,\r\n\t\t\t    lng = point.x * d,\r\n\t\t\t    lat = (2 * Math.atan(Math.exp(point.y)) - (Math.PI / 2)) * d;\r\n\t\r\n\t\t\treturn new L.LatLng(lat, lng);\r\n\t\t}\r\n\t};\r\n\t\n\t\n\t/*\r\n\t * Simple equirectangular (Plate Carree) projection, used by CRS like EPSG:4326 and Simple.\r\n\t */\r\n\t\r\n\tL.Projection.LonLat = {\r\n\t\tproject: function (latlng) {\r\n\t\t\treturn new L.Point(latlng.lng, latlng.lat);\r\n\t\t},\r\n\t\r\n\t\tunproject: function (point) {\r\n\t\t\treturn new L.LatLng(point.y, point.x);\r\n\t\t}\r\n\t};\r\n\t\n\t\n\t/*\r\n\t * L.CRS is a base object for all defined CRS (Coordinate Reference Systems) in Leaflet.\r\n\t */\r\n\t\r\n\tL.CRS = {\r\n\t\tlatLngToPoint: function (latlng, zoom) { // (LatLng, Number) -> Point\r\n\t\t\tvar projectedPoint = this.projection.project(latlng),\r\n\t\t\t    scale = this.scale(zoom);\r\n\t\r\n\t\t\treturn this.transformation._transform(projectedPoint, scale);\r\n\t\t},\r\n\t\r\n\t\tpointToLatLng: function (point, zoom) { // (Point, Number[, Boolean]) -> LatLng\r\n\t\t\tvar scale = this.scale(zoom),\r\n\t\t\t    untransformedPoint = this.transformation.untransform(point, scale);\r\n\t\r\n\t\t\treturn this.projection.unproject(untransformedPoint);\r\n\t\t},\r\n\t\r\n\t\tproject: function (latlng) {\r\n\t\t\treturn this.projection.project(latlng);\r\n\t\t},\r\n\t\r\n\t\tscale: function (zoom) {\r\n\t\t\treturn 256 * Math.pow(2, zoom);\r\n\t\t},\r\n\t\r\n\t\tgetSize: function (zoom) {\r\n\t\t\tvar s = this.scale(zoom);\r\n\t\t\treturn L.point(s, s);\r\n\t\t}\r\n\t};\r\n\t\n\t\n\t/*\n\t * A simple CRS that can be used for flat non-Earth maps like panoramas or game maps.\n\t */\n\t\n\tL.CRS.Simple = L.extend({}, L.CRS, {\n\t\tprojection: L.Projection.LonLat,\n\t\ttransformation: new L.Transformation(1, 0, -1, 0),\n\t\n\t\tscale: function (zoom) {\n\t\t\treturn Math.pow(2, zoom);\n\t\t}\n\t});\n\t\n\t\n\t/*\r\n\t * L.CRS.EPSG3857 (Spherical Mercator) is the most common CRS for web mapping\r\n\t * and is used by Leaflet by default.\r\n\t */\r\n\t\r\n\tL.CRS.EPSG3857 = L.extend({}, L.CRS, {\r\n\t\tcode: 'EPSG:3857',\r\n\t\r\n\t\tprojection: L.Projection.SphericalMercator,\r\n\t\ttransformation: new L.Transformation(0.5 / Math.PI, 0.5, -0.5 / Math.PI, 0.5),\r\n\t\r\n\t\tproject: function (latlng) { // (LatLng) -> Point\r\n\t\t\tvar projectedPoint = this.projection.project(latlng),\r\n\t\t\t    earthRadius = 6378137;\r\n\t\t\treturn projectedPoint.multiplyBy(earthRadius);\r\n\t\t}\r\n\t});\r\n\t\r\n\tL.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {\r\n\t\tcode: 'EPSG:900913'\r\n\t});\r\n\t\n\t\n\t/*\r\n\t * L.CRS.EPSG4326 is a CRS popular among advanced GIS specialists.\r\n\t */\r\n\t\r\n\tL.CRS.EPSG4326 = L.extend({}, L.CRS, {\r\n\t\tcode: 'EPSG:4326',\r\n\t\r\n\t\tprojection: L.Projection.LonLat,\r\n\t\ttransformation: new L.Transformation(1 / 360, 0.5, -1 / 360, 0.5)\r\n\t});\r\n\t\n\t\n\t/*\r\n\t * L.Map is the central class of the API - it is used to create a map.\r\n\t */\r\n\t\r\n\tL.Map = L.Class.extend({\r\n\t\r\n\t\tincludes: L.Mixin.Events,\r\n\t\r\n\t\toptions: {\r\n\t\t\tcrs: L.CRS.EPSG3857,\r\n\t\r\n\t\t\t/*\r\n\t\t\tcenter: LatLng,\r\n\t\t\tzoom: Number,\r\n\t\t\tlayers: Array,\r\n\t\t\t*/\r\n\t\r\n\t\t\tfadeAnimation: L.DomUtil.TRANSITION && !L.Browser.android23,\r\n\t\t\ttrackResize: true,\r\n\t\t\tmarkerZoomAnimation: L.DomUtil.TRANSITION && L.Browser.any3d\r\n\t\t},\r\n\t\r\n\t\tinitialize: function (id, options) { // (HTMLElement or String, Object)\r\n\t\t\toptions = L.setOptions(this, options);\r\n\t\r\n\t\r\n\t\t\tthis._initContainer(id);\r\n\t\t\tthis._initLayout();\r\n\t\r\n\t\t\t// hack for https://github.com/Leaflet/Leaflet/issues/1980\r\n\t\t\tthis._onResize = L.bind(this._onResize, this);\r\n\t\r\n\t\t\tthis._initEvents();\r\n\t\r\n\t\t\tif (options.maxBounds) {\r\n\t\t\t\tthis.setMaxBounds(options.maxBounds);\r\n\t\t\t}\r\n\t\r\n\t\t\tif (options.center && options.zoom !== undefined) {\r\n\t\t\t\tthis.setView(L.latLng(options.center), options.zoom, {reset: true});\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._handlers = [];\r\n\t\r\n\t\t\tthis._layers = {};\r\n\t\t\tthis._zoomBoundLayers = {};\r\n\t\t\tthis._tileLayersNum = 0;\r\n\t\r\n\t\t\tthis.callInitHooks();\r\n\t\r\n\t\t\tthis._addLayers(options.layers);\r\n\t\t},\r\n\t\r\n\t\r\n\t\t// public methods that modify map state\r\n\t\r\n\t\t// replaced by animation-powered implementation in Map.PanAnimation.js\r\n\t\tsetView: function (center, zoom) {\r\n\t\t\tzoom = zoom === undefined ? this.getZoom() : zoom;\r\n\t\t\tthis._resetView(L.latLng(center), this._limitZoom(zoom));\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tsetZoom: function (zoom, options) {\r\n\t\t\tif (!this._loaded) {\r\n\t\t\t\tthis._zoom = this._limitZoom(zoom);\r\n\t\t\t\treturn this;\r\n\t\t\t}\r\n\t\t\treturn this.setView(this.getCenter(), zoom, {zoom: options});\r\n\t\t},\r\n\t\r\n\t\tzoomIn: function (delta, options) {\r\n\t\t\treturn this.setZoom(this._zoom + (delta || 1), options);\r\n\t\t},\r\n\t\r\n\t\tzoomOut: function (delta, options) {\r\n\t\t\treturn this.setZoom(this._zoom - (delta || 1), options);\r\n\t\t},\r\n\t\r\n\t\tsetZoomAround: function (latlng, zoom, options) {\r\n\t\t\tvar scale = this.getZoomScale(zoom),\r\n\t\t\t    viewHalf = this.getSize().divideBy(2),\r\n\t\t\t    containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng),\r\n\t\r\n\t\t\t    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),\r\n\t\t\t    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));\r\n\t\r\n\t\t\treturn this.setView(newCenter, zoom, {zoom: options});\r\n\t\t},\r\n\t\r\n\t\tfitBounds: function (bounds, options) {\r\n\t\r\n\t\t\toptions = options || {};\r\n\t\t\tbounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);\r\n\t\r\n\t\t\tvar paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),\r\n\t\t\t    paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),\r\n\t\r\n\t\t\t    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));\r\n\t\r\n\t\t\tzoom = (options.maxZoom) ? Math.min(options.maxZoom, zoom) : zoom;\r\n\t\r\n\t\t\tvar paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),\r\n\t\r\n\t\t\t    swPoint = this.project(bounds.getSouthWest(), zoom),\r\n\t\t\t    nePoint = this.project(bounds.getNorthEast(), zoom),\r\n\t\t\t    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);\r\n\t\r\n\t\t\treturn this.setView(center, zoom, options);\r\n\t\t},\r\n\t\r\n\t\tfitWorld: function (options) {\r\n\t\t\treturn this.fitBounds([[-90, -180], [90, 180]], options);\r\n\t\t},\r\n\t\r\n\t\tpanTo: function (center, options) { // (LatLng)\r\n\t\t\treturn this.setView(center, this._zoom, {pan: options});\r\n\t\t},\r\n\t\r\n\t\tpanBy: function (offset) { // (Point)\r\n\t\t\t// replaced with animated panBy in Map.PanAnimation.js\r\n\t\t\tthis.fire('movestart');\r\n\t\r\n\t\t\tthis._rawPanBy(L.point(offset));\r\n\t\r\n\t\t\tthis.fire('move');\r\n\t\t\treturn this.fire('moveend');\r\n\t\t},\r\n\t\r\n\t\tsetMaxBounds: function (bounds) {\r\n\t\t\tbounds = L.latLngBounds(bounds);\r\n\t\r\n\t\t\tthis.options.maxBounds = bounds;\r\n\t\r\n\t\t\tif (!bounds) {\r\n\t\t\t\treturn this.off('moveend', this._panInsideMaxBounds, this);\r\n\t\t\t}\r\n\t\r\n\t\t\tif (this._loaded) {\r\n\t\t\t\tthis._panInsideMaxBounds();\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this.on('moveend', this._panInsideMaxBounds, this);\r\n\t\t},\r\n\t\r\n\t\tpanInsideBounds: function (bounds, options) {\r\n\t\t\tvar center = this.getCenter(),\r\n\t\t\t\tnewCenter = this._limitCenter(center, this._zoom, bounds);\r\n\t\r\n\t\t\tif (center.equals(newCenter)) { return this; }\r\n\t\r\n\t\t\treturn this.panTo(newCenter, options);\r\n\t\t},\r\n\t\r\n\t\taddLayer: function (layer) {\r\n\t\t\t// TODO method is too big, refactor\r\n\t\r\n\t\t\tvar id = L.stamp(layer);\r\n\t\r\n\t\t\tif (this._layers[id]) { return this; }\r\n\t\r\n\t\t\tthis._layers[id] = layer;\r\n\t\r\n\t\t\t// TODO getMaxZoom, getMinZoom in ILayer (instead of options)\r\n\t\t\tif (layer.options && (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom))) {\r\n\t\t\t\tthis._zoomBoundLayers[id] = layer;\r\n\t\t\t\tthis._updateZoomLevels();\r\n\t\t\t}\r\n\t\r\n\t\t\t// TODO looks ugly, refactor!!!\r\n\t\t\tif (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {\r\n\t\t\t\tthis._tileLayersNum++;\r\n\t\t\t\tthis._tileLayersToLoad++;\r\n\t\t\t\tlayer.on('load', this._onTileLayerLoad, this);\r\n\t\t\t}\r\n\t\r\n\t\t\tif (this._loaded) {\r\n\t\t\t\tthis._layerAdd(layer);\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tremoveLayer: function (layer) {\r\n\t\t\tvar id = L.stamp(layer);\r\n\t\r\n\t\t\tif (!this._layers[id]) { return this; }\r\n\t\r\n\t\t\tif (this._loaded) {\r\n\t\t\t\tlayer.onRemove(this);\r\n\t\t\t}\r\n\t\r\n\t\t\tdelete this._layers[id];\r\n\t\r\n\t\t\tif (this._loaded) {\r\n\t\t\t\tthis.fire('layerremove', {layer: layer});\r\n\t\t\t}\r\n\t\r\n\t\t\tif (this._zoomBoundLayers[id]) {\r\n\t\t\t\tdelete this._zoomBoundLayers[id];\r\n\t\t\t\tthis._updateZoomLevels();\r\n\t\t\t}\r\n\t\r\n\t\t\t// TODO looks ugly, refactor\r\n\t\t\tif (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {\r\n\t\t\t\tthis._tileLayersNum--;\r\n\t\t\t\tthis._tileLayersToLoad--;\r\n\t\t\t\tlayer.off('load', this._onTileLayerLoad, this);\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\thasLayer: function (layer) {\r\n\t\t\tif (!layer) { return false; }\r\n\t\r\n\t\t\treturn (L.stamp(layer) in this._layers);\r\n\t\t},\r\n\t\r\n\t\teachLayer: function (method, context) {\r\n\t\t\tfor (var i in this._layers) {\r\n\t\t\t\tmethod.call(context, this._layers[i]);\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tinvalidateSize: function (options) {\r\n\t\t\tif (!this._loaded) { return this; }\r\n\t\r\n\t\t\toptions = L.extend({\r\n\t\t\t\tanimate: false,\r\n\t\t\t\tpan: true\r\n\t\t\t}, options === true ? {animate: true} : options);\r\n\t\r\n\t\t\tvar oldSize = this.getSize();\r\n\t\t\tthis._sizeChanged = true;\r\n\t\t\tthis._initialCenter = null;\r\n\t\r\n\t\t\tvar newSize = this.getSize(),\r\n\t\t\t    oldCenter = oldSize.divideBy(2).round(),\r\n\t\t\t    newCenter = newSize.divideBy(2).round(),\r\n\t\t\t    offset = oldCenter.subtract(newCenter);\r\n\t\r\n\t\t\tif (!offset.x && !offset.y) { return this; }\r\n\t\r\n\t\t\tif (options.animate && options.pan) {\r\n\t\t\t\tthis.panBy(offset);\r\n\t\r\n\t\t\t} else {\r\n\t\t\t\tif (options.pan) {\r\n\t\t\t\t\tthis._rawPanBy(offset);\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.fire('move');\r\n\t\r\n\t\t\t\tif (options.debounceMoveend) {\r\n\t\t\t\t\tclearTimeout(this._sizeTimer);\r\n\t\t\t\t\tthis._sizeTimer = setTimeout(L.bind(this.fire, this, 'moveend'), 200);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.fire('moveend');\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this.fire('resize', {\r\n\t\t\t\toldSize: oldSize,\r\n\t\t\t\tnewSize: newSize\r\n\t\t\t});\r\n\t\t},\r\n\t\r\n\t\t// TODO handler.addTo\r\n\t\taddHandler: function (name, HandlerClass) {\r\n\t\t\tif (!HandlerClass) { return this; }\r\n\t\r\n\t\t\tvar handler = this[name] = new HandlerClass(this);\r\n\t\r\n\t\t\tthis._handlers.push(handler);\r\n\t\r\n\t\t\tif (this.options[name]) {\r\n\t\t\t\thandler.enable();\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tremove: function () {\r\n\t\t\tif (this._loaded) {\r\n\t\t\t\tthis.fire('unload');\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._initEvents('off');\r\n\t\r\n\t\t\ttry {\r\n\t\t\t\t// throws error in IE6-8\r\n\t\t\t\tdelete this._container._leaflet;\r\n\t\t\t} catch (e) {\r\n\t\t\t\tthis._container._leaflet = undefined;\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._clearPanes();\r\n\t\t\tif (this._clearControlPos) {\r\n\t\t\t\tthis._clearControlPos();\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._clearHandlers();\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\r\n\t\t// public methods for getting map state\r\n\t\r\n\t\tgetCenter: function () { // (Boolean) -> LatLng\r\n\t\t\tthis._checkIfLoaded();\r\n\t\r\n\t\t\tif (this._initialCenter && !this._moved()) {\r\n\t\t\t\treturn this._initialCenter;\r\n\t\t\t}\r\n\t\t\treturn this.layerPointToLatLng(this._getCenterLayerPoint());\r\n\t\t},\r\n\t\r\n\t\tgetZoom: function () {\r\n\t\t\treturn this._zoom;\r\n\t\t},\r\n\t\r\n\t\tgetBounds: function () {\r\n\t\t\tvar bounds = this.getPixelBounds(),\r\n\t\t\t    sw = this.unproject(bounds.getBottomLeft()),\r\n\t\t\t    ne = this.unproject(bounds.getTopRight());\r\n\t\r\n\t\t\treturn new L.LatLngBounds(sw, ne);\r\n\t\t},\r\n\t\r\n\t\tgetMinZoom: function () {\r\n\t\t\treturn this.options.minZoom === undefined ?\r\n\t\t\t\t(this._layersMinZoom === undefined ? 0 : this._layersMinZoom) :\r\n\t\t\t\tthis.options.minZoom;\r\n\t\t},\r\n\t\r\n\t\tgetMaxZoom: function () {\r\n\t\t\treturn this.options.maxZoom === undefined ?\r\n\t\t\t\t(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :\r\n\t\t\t\tthis.options.maxZoom;\r\n\t\t},\r\n\t\r\n\t\tgetBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number\r\n\t\t\tbounds = L.latLngBounds(bounds);\r\n\t\r\n\t\t\tvar zoom = this.getMinZoom() - (inside ? 1 : 0),\r\n\t\t\t    maxZoom = this.getMaxZoom(),\r\n\t\t\t    size = this.getSize(),\r\n\t\r\n\t\t\t    nw = bounds.getNorthWest(),\r\n\t\t\t    se = bounds.getSouthEast(),\r\n\t\r\n\t\t\t    zoomNotFound = true,\r\n\t\t\t    boundsSize;\r\n\t\r\n\t\t\tpadding = L.point(padding || [0, 0]);\r\n\t\r\n\t\t\tdo {\r\n\t\t\t\tzoom++;\r\n\t\t\t\tboundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)).add(padding);\r\n\t\t\t\tzoomNotFound = !inside ? size.contains(boundsSize) : boundsSize.x < size.x || boundsSize.y < size.y;\r\n\t\r\n\t\t\t} while (zoomNotFound && zoom <= maxZoom);\r\n\t\r\n\t\t\tif (zoomNotFound && inside) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\r\n\t\t\treturn inside ? zoom : zoom - 1;\r\n\t\t},\r\n\t\r\n\t\tgetSize: function () {\r\n\t\t\tif (!this._size || this._sizeChanged) {\r\n\t\t\t\tthis._size = new L.Point(\r\n\t\t\t\t\tthis._container.clientWidth,\r\n\t\t\t\t\tthis._container.clientHeight);\r\n\t\r\n\t\t\t\tthis._sizeChanged = false;\r\n\t\t\t}\r\n\t\t\treturn this._size.clone();\r\n\t\t},\r\n\t\r\n\t\tgetPixelBounds: function () {\r\n\t\t\tvar topLeftPoint = this._getTopLeftPoint();\r\n\t\t\treturn new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));\r\n\t\t},\r\n\t\r\n\t\tgetPixelOrigin: function () {\r\n\t\t\tthis._checkIfLoaded();\r\n\t\t\treturn this._initialTopLeftPoint;\r\n\t\t},\r\n\t\r\n\t\tgetPanes: function () {\r\n\t\t\treturn this._panes;\r\n\t\t},\r\n\t\r\n\t\tgetContainer: function () {\r\n\t\t\treturn this._container;\r\n\t\t},\r\n\t\r\n\t\r\n\t\t// TODO replace with universal implementation after refactoring projections\r\n\t\r\n\t\tgetZoomScale: function (toZoom) {\r\n\t\t\tvar crs = this.options.crs;\r\n\t\t\treturn crs.scale(toZoom) / crs.scale(this._zoom);\r\n\t\t},\r\n\t\r\n\t\tgetScaleZoom: function (scale) {\r\n\t\t\treturn this._zoom + (Math.log(scale) / Math.LN2);\r\n\t\t},\r\n\t\r\n\t\r\n\t\t// conversion methods\r\n\t\r\n\t\tproject: function (latlng, zoom) { // (LatLng[, Number]) -> Point\r\n\t\t\tzoom = zoom === undefined ? this._zoom : zoom;\r\n\t\t\treturn this.options.crs.latLngToPoint(L.latLng(latlng), zoom);\r\n\t\t},\r\n\t\r\n\t\tunproject: function (point, zoom) { // (Point[, Number]) -> LatLng\r\n\t\t\tzoom = zoom === undefined ? this._zoom : zoom;\r\n\t\t\treturn this.options.crs.pointToLatLng(L.point(point), zoom);\r\n\t\t},\r\n\t\r\n\t\tlayerPointToLatLng: function (point) { // (Point)\r\n\t\t\tvar projectedPoint = L.point(point).add(this.getPixelOrigin());\r\n\t\t\treturn this.unproject(projectedPoint);\r\n\t\t},\r\n\t\r\n\t\tlatLngToLayerPoint: function (latlng) { // (LatLng)\r\n\t\t\tvar projectedPoint = this.project(L.latLng(latlng))._round();\r\n\t\t\treturn projectedPoint._subtract(this.getPixelOrigin());\r\n\t\t},\r\n\t\r\n\t\tcontainerPointToLayerPoint: function (point) { // (Point)\r\n\t\t\treturn L.point(point).subtract(this._getMapPanePos());\r\n\t\t},\r\n\t\r\n\t\tlayerPointToContainerPoint: function (point) { // (Point)\r\n\t\t\treturn L.point(point).add(this._getMapPanePos());\r\n\t\t},\r\n\t\r\n\t\tcontainerPointToLatLng: function (point) {\r\n\t\t\tvar layerPoint = this.containerPointToLayerPoint(L.point(point));\r\n\t\t\treturn this.layerPointToLatLng(layerPoint);\r\n\t\t},\r\n\t\r\n\t\tlatLngToContainerPoint: function (latlng) {\r\n\t\t\treturn this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)));\r\n\t\t},\r\n\t\r\n\t\tmouseEventToContainerPoint: function (e) { // (MouseEvent)\r\n\t\t\treturn L.DomEvent.getMousePosition(e, this._container);\r\n\t\t},\r\n\t\r\n\t\tmouseEventToLayerPoint: function (e) { // (MouseEvent)\r\n\t\t\treturn this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));\r\n\t\t},\r\n\t\r\n\t\tmouseEventToLatLng: function (e) { // (MouseEvent)\r\n\t\t\treturn this.layerPointToLatLng(this.mouseEventToLayerPoint(e));\r\n\t\t},\r\n\t\r\n\t\r\n\t\t// map initialization methods\r\n\t\r\n\t\t_initContainer: function (id) {\r\n\t\t\tvar container = this._container = L.DomUtil.get(id);\r\n\t\r\n\t\t\tif (!container) {\r\n\t\t\t\tthrow new Error('Map container not found.');\r\n\t\t\t} else if (container._leaflet) {\r\n\t\t\t\tthrow new Error('Map container is already initialized.');\r\n\t\t\t}\r\n\t\r\n\t\t\tcontainer._leaflet = true;\r\n\t\t},\r\n\t\r\n\t\t_initLayout: function () {\r\n\t\t\tvar container = this._container;\r\n\t\r\n\t\t\tL.DomUtil.addClass(container, 'leaflet-container' +\r\n\t\t\t\t(L.Browser.touch ? ' leaflet-touch' : '') +\r\n\t\t\t\t(L.Browser.retina ? ' leaflet-retina' : '') +\r\n\t\t\t\t(L.Browser.ielt9 ? ' leaflet-oldie' : '') +\r\n\t\t\t\t(this.options.fadeAnimation ? ' leaflet-fade-anim' : ''));\r\n\t\r\n\t\t\tvar position = L.DomUtil.getStyle(container, 'position');\r\n\t\r\n\t\t\tif (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {\r\n\t\t\t\tcontainer.style.position = 'relative';\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._initPanes();\r\n\t\r\n\t\t\tif (this._initControlPos) {\r\n\t\t\t\tthis._initControlPos();\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_initPanes: function () {\r\n\t\t\tvar panes = this._panes = {};\r\n\t\r\n\t\t\tthis._mapPane = panes.mapPane = this._createPane('leaflet-map-pane', this._container);\r\n\t\r\n\t\t\tthis._tilePane = panes.tilePane = this._createPane('leaflet-tile-pane', this._mapPane);\r\n\t\t\tpanes.objectsPane = this._createPane('leaflet-objects-pane', this._mapPane);\r\n\t\t\tpanes.shadowPane = this._createPane('leaflet-shadow-pane');\r\n\t\t\tpanes.overlayPane = this._createPane('leaflet-overlay-pane');\r\n\t\t\tpanes.markerPane = this._createPane('leaflet-marker-pane');\r\n\t\t\tpanes.popupPane = this._createPane('leaflet-popup-pane');\r\n\t\r\n\t\t\tvar zoomHide = ' leaflet-zoom-hide';\r\n\t\r\n\t\t\tif (!this.options.markerZoomAnimation) {\r\n\t\t\t\tL.DomUtil.addClass(panes.markerPane, zoomHide);\r\n\t\t\t\tL.DomUtil.addClass(panes.shadowPane, zoomHide);\r\n\t\t\t\tL.DomUtil.addClass(panes.popupPane, zoomHide);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_createPane: function (className, container) {\r\n\t\t\treturn L.DomUtil.create('div', className, container || this._panes.objectsPane);\r\n\t\t},\r\n\t\r\n\t\t_clearPanes: function () {\r\n\t\t\tthis._container.removeChild(this._mapPane);\r\n\t\t},\r\n\t\r\n\t\t_addLayers: function (layers) {\r\n\t\t\tlayers = layers ? (L.Util.isArray(layers) ? layers : [layers]) : [];\r\n\t\r\n\t\t\tfor (var i = 0, len = layers.length; i < len; i++) {\r\n\t\t\t\tthis.addLayer(layers[i]);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\r\n\t\t// private methods that modify map state\r\n\t\r\n\t\t_resetView: function (center, zoom, preserveMapOffset, afterZoomAnim) {\r\n\t\r\n\t\t\tvar zoomChanged = (this._zoom !== zoom);\r\n\t\r\n\t\t\tif (!afterZoomAnim) {\r\n\t\t\t\tthis.fire('movestart');\r\n\t\r\n\t\t\t\tif (zoomChanged) {\r\n\t\t\t\t\tthis.fire('zoomstart');\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._zoom = zoom;\r\n\t\t\tthis._initialCenter = center;\r\n\t\r\n\t\t\tthis._initialTopLeftPoint = this._getNewTopLeftPoint(center);\r\n\t\r\n\t\t\tif (!preserveMapOffset) {\r\n\t\t\t\tL.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));\r\n\t\t\t} else {\r\n\t\t\t\tthis._initialTopLeftPoint._add(this._getMapPanePos());\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._tileLayersToLoad = this._tileLayersNum;\r\n\t\r\n\t\t\tvar loading = !this._loaded;\r\n\t\t\tthis._loaded = true;\r\n\t\r\n\t\t\tthis.fire('viewreset', {hard: !preserveMapOffset});\r\n\t\r\n\t\t\tif (loading) {\r\n\t\t\t\tthis.fire('load');\r\n\t\t\t\tthis.eachLayer(this._layerAdd, this);\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.fire('move');\r\n\t\r\n\t\t\tif (zoomChanged || afterZoomAnim) {\r\n\t\t\t\tthis.fire('zoomend');\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.fire('moveend', {hard: !preserveMapOffset});\r\n\t\t},\r\n\t\r\n\t\t_rawPanBy: function (offset) {\r\n\t\t\tL.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));\r\n\t\t},\r\n\t\r\n\t\t_getZoomSpan: function () {\r\n\t\t\treturn this.getMaxZoom() - this.getMinZoom();\r\n\t\t},\r\n\t\r\n\t\t_updateZoomLevels: function () {\r\n\t\t\tvar i,\r\n\t\t\t\tminZoom = Infinity,\r\n\t\t\t\tmaxZoom = -Infinity,\r\n\t\t\t\toldZoomSpan = this._getZoomSpan();\r\n\t\r\n\t\t\tfor (i in this._zoomBoundLayers) {\r\n\t\t\t\tvar layer = this._zoomBoundLayers[i];\r\n\t\t\t\tif (!isNaN(layer.options.minZoom)) {\r\n\t\t\t\t\tminZoom = Math.min(minZoom, layer.options.minZoom);\r\n\t\t\t\t}\r\n\t\t\t\tif (!isNaN(layer.options.maxZoom)) {\r\n\t\t\t\t\tmaxZoom = Math.max(maxZoom, layer.options.maxZoom);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\tif (i === undefined) { // we have no tilelayers\r\n\t\t\t\tthis._layersMaxZoom = this._layersMinZoom = undefined;\r\n\t\t\t} else {\r\n\t\t\t\tthis._layersMaxZoom = maxZoom;\r\n\t\t\t\tthis._layersMinZoom = minZoom;\r\n\t\t\t}\r\n\t\r\n\t\t\tif (oldZoomSpan !== this._getZoomSpan()) {\r\n\t\t\t\tthis.fire('zoomlevelschange');\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_panInsideMaxBounds: function () {\r\n\t\t\tthis.panInsideBounds(this.options.maxBounds);\r\n\t\t},\r\n\t\r\n\t\t_checkIfLoaded: function () {\r\n\t\t\tif (!this._loaded) {\r\n\t\t\t\tthrow new Error('Set map center and zoom first.');\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t// map events\r\n\t\r\n\t\t_initEvents: function (onOff) {\r\n\t\t\tif (!L.DomEvent) { return; }\r\n\t\r\n\t\t\tonOff = onOff || 'on';\r\n\t\r\n\t\t\tL.DomEvent[onOff](this._container, 'click', this._onMouseClick, this);\r\n\t\r\n\t\t\tvar events = ['dblclick', 'mousedown', 'mouseup', 'mouseenter',\r\n\t\t\t              'mouseleave', 'mousemove', 'contextmenu'],\r\n\t\t\t    i, len;\r\n\t\r\n\t\t\tfor (i = 0, len = events.length; i < len; i++) {\r\n\t\t\t\tL.DomEvent[onOff](this._container, events[i], this._fireMouseEvent, this);\r\n\t\t\t}\r\n\t\r\n\t\t\tif (this.options.trackResize) {\r\n\t\t\t\tL.DomEvent[onOff](window, 'resize', this._onResize, this);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_onResize: function () {\r\n\t\t\tL.Util.cancelAnimFrame(this._resizeRequest);\r\n\t\t\tthis._resizeRequest = L.Util.requestAnimFrame(\r\n\t\t\t        function () { this.invalidateSize({debounceMoveend: true}); }, this, false, this._container);\r\n\t\t},\r\n\t\r\n\t\t_onMouseClick: function (e) {\r\n\t\t\tif (!this._loaded || (!e._simulated &&\r\n\t\t\t        ((this.dragging && this.dragging.moved()) ||\r\n\t\t\t         (this.boxZoom  && this.boxZoom.moved()))) ||\r\n\t\t\t            L.DomEvent._skipped(e)) { return; }\r\n\t\r\n\t\t\tthis.fire('preclick');\r\n\t\t\tthis._fireMouseEvent(e);\r\n\t\t},\r\n\t\r\n\t\t_fireMouseEvent: function (e) {\r\n\t\t\tif (!this._loaded || L.DomEvent._skipped(e)) { return; }\r\n\t\r\n\t\t\tvar type = e.type;\r\n\t\r\n\t\t\ttype = (type === 'mouseenter' ? 'mouseover' : (type === 'mouseleave' ? 'mouseout' : type));\r\n\t\r\n\t\t\tif (!this.hasEventListeners(type)) { return; }\r\n\t\r\n\t\t\tif (type === 'contextmenu') {\r\n\t\t\t\tL.DomEvent.preventDefault(e);\r\n\t\t\t}\r\n\t\r\n\t\t\tvar containerPoint = this.mouseEventToContainerPoint(e),\r\n\t\t\t    layerPoint = this.containerPointToLayerPoint(containerPoint),\r\n\t\t\t    latlng = this.layerPointToLatLng(layerPoint);\r\n\t\r\n\t\t\tthis.fire(type, {\r\n\t\t\t\tlatlng: latlng,\r\n\t\t\t\tlayerPoint: layerPoint,\r\n\t\t\t\tcontainerPoint: containerPoint,\r\n\t\t\t\toriginalEvent: e\r\n\t\t\t});\r\n\t\t},\r\n\t\r\n\t\t_onTileLayerLoad: function () {\r\n\t\t\tthis._tileLayersToLoad--;\r\n\t\t\tif (this._tileLayersNum && !this._tileLayersToLoad) {\r\n\t\t\t\tthis.fire('tilelayersload');\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_clearHandlers: function () {\r\n\t\t\tfor (var i = 0, len = this._handlers.length; i < len; i++) {\r\n\t\t\t\tthis._handlers[i].disable();\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\twhenReady: function (callback, context) {\r\n\t\t\tif (this._loaded) {\r\n\t\t\t\tcallback.call(context || this, this);\r\n\t\t\t} else {\r\n\t\t\t\tthis.on('load', callback, context);\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\t_layerAdd: function (layer) {\r\n\t\t\tlayer.onAdd(this);\r\n\t\t\tthis.fire('layeradd', {layer: layer});\r\n\t\t},\r\n\t\r\n\t\r\n\t\t// private methods for getting map state\r\n\t\r\n\t\t_getMapPanePos: function () {\r\n\t\t\treturn L.DomUtil.getPosition(this._mapPane);\r\n\t\t},\r\n\t\r\n\t\t_moved: function () {\r\n\t\t\tvar pos = this._getMapPanePos();\r\n\t\t\treturn pos && !pos.equals([0, 0]);\r\n\t\t},\r\n\t\r\n\t\t_getTopLeftPoint: function () {\r\n\t\t\treturn this.getPixelOrigin().subtract(this._getMapPanePos());\r\n\t\t},\r\n\t\r\n\t\t_getNewTopLeftPoint: function (center, zoom) {\r\n\t\t\tvar viewHalf = this.getSize()._divideBy(2);\r\n\t\t\t// TODO round on display, not calculation to increase precision?\r\n\t\t\treturn this.project(center, zoom)._subtract(viewHalf)._round();\r\n\t\t},\r\n\t\r\n\t\t_latLngToNewLayerPoint: function (latlng, newZoom, newCenter) {\r\n\t\t\tvar topLeft = this._getNewTopLeftPoint(newCenter, newZoom).add(this._getMapPanePos());\r\n\t\t\treturn this.project(latlng, newZoom)._subtract(topLeft);\r\n\t\t},\r\n\t\r\n\t\t// layer point of the current center\r\n\t\t_getCenterLayerPoint: function () {\r\n\t\t\treturn this.containerPointToLayerPoint(this.getSize()._divideBy(2));\r\n\t\t},\r\n\t\r\n\t\t// offset of the specified place to the current center in pixels\r\n\t\t_getCenterOffset: function (latlng) {\r\n\t\t\treturn this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());\r\n\t\t},\r\n\t\r\n\t\t// adjust center for view to get inside bounds\r\n\t\t_limitCenter: function (center, zoom, bounds) {\r\n\t\r\n\t\t\tif (!bounds) { return center; }\r\n\t\r\n\t\t\tvar centerPoint = this.project(center, zoom),\r\n\t\t\t    viewHalf = this.getSize().divideBy(2),\r\n\t\t\t    viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),\r\n\t\t\t    offset = this._getBoundsOffset(viewBounds, bounds, zoom);\r\n\t\r\n\t\t\treturn this.unproject(centerPoint.add(offset), zoom);\r\n\t\t},\r\n\t\r\n\t\t// adjust offset for view to get inside bounds\r\n\t\t_limitOffset: function (offset, bounds) {\r\n\t\t\tif (!bounds) { return offset; }\r\n\t\r\n\t\t\tvar viewBounds = this.getPixelBounds(),\r\n\t\t\t    newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));\r\n\t\r\n\t\t\treturn offset.add(this._getBoundsOffset(newBounds, bounds));\r\n\t\t},\r\n\t\r\n\t\t// returns offset needed for pxBounds to get inside maxBounds at a specified zoom\r\n\t\t_getBoundsOffset: function (pxBounds, maxBounds, zoom) {\r\n\t\t\tvar nwOffset = this.project(maxBounds.getNorthWest(), zoom).subtract(pxBounds.min),\r\n\t\t\t    seOffset = this.project(maxBounds.getSouthEast(), zoom).subtract(pxBounds.max),\r\n\t\r\n\t\t\t    dx = this._rebound(nwOffset.x, -seOffset.x),\r\n\t\t\t    dy = this._rebound(nwOffset.y, -seOffset.y);\r\n\t\r\n\t\t\treturn new L.Point(dx, dy);\r\n\t\t},\r\n\t\r\n\t\t_rebound: function (left, right) {\r\n\t\t\treturn left + right > 0 ?\r\n\t\t\t\tMath.round(left - right) / 2 :\r\n\t\t\t\tMath.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));\r\n\t\t},\r\n\t\r\n\t\t_limitZoom: function (zoom) {\r\n\t\t\tvar min = this.getMinZoom(),\r\n\t\t\t    max = this.getMaxZoom();\r\n\t\r\n\t\t\treturn Math.max(min, Math.min(max, zoom));\r\n\t\t}\r\n\t});\r\n\t\r\n\tL.map = function (id, options) {\r\n\t\treturn new L.Map(id, options);\r\n\t};\r\n\t\n\t\n\t/*\r\n\t * Mercator projection that takes into account that the Earth is not a perfect sphere.\r\n\t * Less popular than spherical mercator; used by projections like EPSG:3395.\r\n\t */\r\n\t\r\n\tL.Projection.Mercator = {\r\n\t\tMAX_LATITUDE: 85.0840591556,\r\n\t\r\n\t\tR_MINOR: 6356752.314245179,\r\n\t\tR_MAJOR: 6378137,\r\n\t\r\n\t\tproject: function (latlng) { // (LatLng) -> Point\r\n\t\t\tvar d = L.LatLng.DEG_TO_RAD,\r\n\t\t\t    max = this.MAX_LATITUDE,\r\n\t\t\t    lat = Math.max(Math.min(max, latlng.lat), -max),\r\n\t\t\t    r = this.R_MAJOR,\r\n\t\t\t    r2 = this.R_MINOR,\r\n\t\t\t    x = latlng.lng * d * r,\r\n\t\t\t    y = lat * d,\r\n\t\t\t    tmp = r2 / r,\r\n\t\t\t    eccent = Math.sqrt(1.0 - tmp * tmp),\r\n\t\t\t    con = eccent * Math.sin(y);\r\n\t\r\n\t\t\tcon = Math.pow((1 - con) / (1 + con), eccent * 0.5);\r\n\t\r\n\t\t\tvar ts = Math.tan(0.5 * ((Math.PI * 0.5) - y)) / con;\r\n\t\t\ty = -r * Math.log(ts);\r\n\t\r\n\t\t\treturn new L.Point(x, y);\r\n\t\t},\r\n\t\r\n\t\tunproject: function (point) { // (Point, Boolean) -> LatLng\r\n\t\t\tvar d = L.LatLng.RAD_TO_DEG,\r\n\t\t\t    r = this.R_MAJOR,\r\n\t\t\t    r2 = this.R_MINOR,\r\n\t\t\t    lng = point.x * d / r,\r\n\t\t\t    tmp = r2 / r,\r\n\t\t\t    eccent = Math.sqrt(1 - (tmp * tmp)),\r\n\t\t\t    ts = Math.exp(- point.y / r),\r\n\t\t\t    phi = (Math.PI / 2) - 2 * Math.atan(ts),\r\n\t\t\t    numIter = 15,\r\n\t\t\t    tol = 1e-7,\r\n\t\t\t    i = numIter,\r\n\t\t\t    dphi = 0.1,\r\n\t\t\t    con;\r\n\t\r\n\t\t\twhile ((Math.abs(dphi) > tol) && (--i > 0)) {\r\n\t\t\t\tcon = eccent * Math.sin(phi);\r\n\t\t\t\tdphi = (Math.PI / 2) - 2 * Math.atan(ts *\r\n\t\t\t\t            Math.pow((1.0 - con) / (1.0 + con), 0.5 * eccent)) - phi;\r\n\t\t\t\tphi += dphi;\r\n\t\t\t}\r\n\t\r\n\t\t\treturn new L.LatLng(phi * d, lng);\r\n\t\t}\r\n\t};\r\n\t\n\t\n\t\r\n\tL.CRS.EPSG3395 = L.extend({}, L.CRS, {\r\n\t\tcode: 'EPSG:3395',\r\n\t\r\n\t\tprojection: L.Projection.Mercator,\r\n\t\r\n\t\ttransformation: (function () {\r\n\t\t\tvar m = L.Projection.Mercator,\r\n\t\t\t    r = m.R_MAJOR,\r\n\t\t\t    scale = 0.5 / (Math.PI * r);\r\n\t\r\n\t\t\treturn new L.Transformation(scale, 0.5, -scale, 0.5);\r\n\t\t}())\r\n\t});\r\n\t\n\t\n\t/*\r\n\t * L.TileLayer is used for standard xyz-numbered tile layers.\r\n\t */\r\n\t\r\n\tL.TileLayer = L.Class.extend({\r\n\t\tincludes: L.Mixin.Events,\r\n\t\r\n\t\toptions: {\r\n\t\t\tminZoom: 0,\r\n\t\t\tmaxZoom: 18,\r\n\t\t\ttileSize: 256,\r\n\t\t\tsubdomains: 'abc',\r\n\t\t\terrorTileUrl: '',\r\n\t\t\tattribution: '',\r\n\t\t\tzoomOffset: 0,\r\n\t\t\topacity: 1,\r\n\t\t\t/*\r\n\t\t\tmaxNativeZoom: null,\r\n\t\t\tzIndex: null,\r\n\t\t\ttms: false,\r\n\t\t\tcontinuousWorld: false,\r\n\t\t\tnoWrap: false,\r\n\t\t\tzoomReverse: false,\r\n\t\t\tdetectRetina: false,\r\n\t\t\treuseTiles: false,\r\n\t\t\tbounds: false,\r\n\t\t\t*/\r\n\t\t\tunloadInvisibleTiles: L.Browser.mobile,\r\n\t\t\tupdateWhenIdle: L.Browser.mobile\r\n\t\t},\r\n\t\r\n\t\tinitialize: function (url, options) {\r\n\t\t\toptions = L.setOptions(this, options);\r\n\t\r\n\t\t\t// detecting retina displays, adjusting tileSize and zoom levels\r\n\t\t\tif (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {\r\n\t\r\n\t\t\t\toptions.tileSize = Math.floor(options.tileSize / 2);\r\n\t\t\t\toptions.zoomOffset++;\r\n\t\r\n\t\t\t\tif (options.minZoom > 0) {\r\n\t\t\t\t\toptions.minZoom--;\r\n\t\t\t\t}\r\n\t\t\t\tthis.options.maxZoom--;\r\n\t\t\t}\r\n\t\r\n\t\t\tif (options.bounds) {\r\n\t\t\t\toptions.bounds = L.latLngBounds(options.bounds);\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._url = url;\r\n\t\r\n\t\t\tvar subdomains = this.options.subdomains;\r\n\t\r\n\t\t\tif (typeof subdomains === 'string') {\r\n\t\t\t\tthis.options.subdomains = subdomains.split('');\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\tonAdd: function (map) {\r\n\t\t\tthis._map = map;\r\n\t\t\tthis._animated = map._zoomAnimated;\r\n\t\r\n\t\t\t// create a container div for tiles\r\n\t\t\tthis._initContainer();\r\n\t\r\n\t\t\t// set up events\r\n\t\t\tmap.on({\r\n\t\t\t\t'viewreset': this._reset,\r\n\t\t\t\t'moveend': this._update\r\n\t\t\t}, this);\r\n\t\r\n\t\t\tif (this._animated) {\r\n\t\t\t\tmap.on({\r\n\t\t\t\t\t'zoomanim': this._animateZoom,\r\n\t\t\t\t\t'zoomend': this._endZoomAnim\r\n\t\t\t\t}, this);\r\n\t\t\t}\r\n\t\r\n\t\t\tif (!this.options.updateWhenIdle) {\r\n\t\t\t\tthis._limitedUpdate = L.Util.limitExecByInterval(this._update, 150, this);\r\n\t\t\t\tmap.on('move', this._limitedUpdate, this);\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._reset();\r\n\t\t\tthis._update();\r\n\t\t},\r\n\t\r\n\t\taddTo: function (map) {\r\n\t\t\tmap.addLayer(this);\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tonRemove: function (map) {\r\n\t\t\tthis._container.parentNode.removeChild(this._container);\r\n\t\r\n\t\t\tmap.off({\r\n\t\t\t\t'viewreset': this._reset,\r\n\t\t\t\t'moveend': this._update\r\n\t\t\t}, this);\r\n\t\r\n\t\t\tif (this._animated) {\r\n\t\t\t\tmap.off({\r\n\t\t\t\t\t'zoomanim': this._animateZoom,\r\n\t\t\t\t\t'zoomend': this._endZoomAnim\r\n\t\t\t\t}, this);\r\n\t\t\t}\r\n\t\r\n\t\t\tif (!this.options.updateWhenIdle) {\r\n\t\t\t\tmap.off('move', this._limitedUpdate, this);\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._container = null;\r\n\t\t\tthis._map = null;\r\n\t\t},\r\n\t\r\n\t\tbringToFront: function () {\r\n\t\t\tvar pane = this._map._panes.tilePane;\r\n\t\r\n\t\t\tif (this._container) {\r\n\t\t\t\tpane.appendChild(this._container);\r\n\t\t\t\tthis._setAutoZIndex(pane, Math.max);\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tbringToBack: function () {\r\n\t\t\tvar pane = this._map._panes.tilePane;\r\n\t\r\n\t\t\tif (this._container) {\r\n\t\t\t\tpane.insertBefore(this._container, pane.firstChild);\r\n\t\t\t\tthis._setAutoZIndex(pane, Math.min);\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tgetAttribution: function () {\r\n\t\t\treturn this.options.attribution;\r\n\t\t},\r\n\t\r\n\t\tgetContainer: function () {\r\n\t\t\treturn this._container;\r\n\t\t},\r\n\t\r\n\t\tsetOpacity: function (opacity) {\r\n\t\t\tthis.options.opacity = opacity;\r\n\t\r\n\t\t\tif (this._map) {\r\n\t\t\t\tthis._updateOpacity();\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tsetZIndex: function (zIndex) {\r\n\t\t\tthis.options.zIndex = zIndex;\r\n\t\t\tthis._updateZIndex();\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tsetUrl: function (url, noRedraw) {\r\n\t\t\tthis._url = url;\r\n\t\r\n\t\t\tif (!noRedraw) {\r\n\t\t\t\tthis.redraw();\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tredraw: function () {\r\n\t\t\tif (this._map) {\r\n\t\t\t\tthis._reset({hard: true});\r\n\t\t\t\tthis._update();\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\t_updateZIndex: function () {\r\n\t\t\tif (this._container && this.options.zIndex !== undefined) {\r\n\t\t\t\tthis._container.style.zIndex = this.options.zIndex;\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_setAutoZIndex: function (pane, compare) {\r\n\t\r\n\t\t\tvar layers = pane.children,\r\n\t\t\t    edgeZIndex = -compare(Infinity, -Infinity), // -Infinity for max, Infinity for min\r\n\t\t\t    zIndex, i, len;\r\n\t\r\n\t\t\tfor (i = 0, len = layers.length; i < len; i++) {\r\n\t\r\n\t\t\t\tif (layers[i] !== this._container) {\r\n\t\t\t\t\tzIndex = parseInt(layers[i].style.zIndex, 10);\r\n\t\r\n\t\t\t\t\tif (!isNaN(zIndex)) {\r\n\t\t\t\t\t\tedgeZIndex = compare(edgeZIndex, zIndex);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.options.zIndex = this._container.style.zIndex =\r\n\t\t\t        (isFinite(edgeZIndex) ? edgeZIndex : 0) + compare(1, -1);\r\n\t\t},\r\n\t\r\n\t\t_updateOpacity: function () {\r\n\t\t\tvar i,\r\n\t\t\t    tiles = this._tiles;\r\n\t\r\n\t\t\tif (L.Browser.ielt9) {\r\n\t\t\t\tfor (i in tiles) {\r\n\t\t\t\t\tL.DomUtil.setOpacity(tiles[i], this.options.opacity);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tL.DomUtil.setOpacity(this._container, this.options.opacity);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_initContainer: function () {\r\n\t\t\tvar tilePane = this._map._panes.tilePane;\r\n\t\r\n\t\t\tif (!this._container) {\r\n\t\t\t\tthis._container = L.DomUtil.create('div', 'leaflet-layer');\r\n\t\r\n\t\t\t\tthis._updateZIndex();\r\n\t\r\n\t\t\t\tif (this._animated) {\r\n\t\t\t\t\tvar className = 'leaflet-tile-container';\r\n\t\r\n\t\t\t\t\tthis._bgBuffer = L.DomUtil.create('div', className, this._container);\r\n\t\t\t\t\tthis._tileContainer = L.DomUtil.create('div', className, this._container);\r\n\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis._tileContainer = this._container;\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\ttilePane.appendChild(this._container);\r\n\t\r\n\t\t\t\tif (this.options.opacity < 1) {\r\n\t\t\t\t\tthis._updateOpacity();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_reset: function (e) {\r\n\t\t\tfor (var key in this._tiles) {\r\n\t\t\t\tthis.fire('tileunload', {tile: this._tiles[key]});\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._tiles = {};\r\n\t\t\tthis._tilesToLoad = 0;\r\n\t\r\n\t\t\tif (this.options.reuseTiles) {\r\n\t\t\t\tthis._unusedTiles = [];\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._tileContainer.innerHTML = '';\r\n\t\r\n\t\t\tif (this._animated && e && e.hard) {\r\n\t\t\t\tthis._clearBgBuffer();\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._initContainer();\r\n\t\t},\r\n\t\r\n\t\t_getTileSize: function () {\r\n\t\t\tvar map = this._map,\r\n\t\t\t    zoom = map.getZoom() + this.options.zoomOffset,\r\n\t\t\t    zoomN = this.options.maxNativeZoom,\r\n\t\t\t    tileSize = this.options.tileSize;\r\n\t\r\n\t\t\tif (zoomN && zoom > zoomN) {\r\n\t\t\t\ttileSize = Math.round(map.getZoomScale(zoom) / map.getZoomScale(zoomN) * tileSize);\r\n\t\t\t}\r\n\t\r\n\t\t\treturn tileSize;\r\n\t\t},\r\n\t\r\n\t\t_update: function () {\r\n\t\r\n\t\t\tif (!this._map) { return; }\r\n\t\r\n\t\t\tvar map = this._map,\r\n\t\t\t    bounds = map.getPixelBounds(),\r\n\t\t\t    zoom = map.getZoom(),\r\n\t\t\t    tileSize = this._getTileSize();\r\n\t\r\n\t\t\tif (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\r\n\t\t\tvar tileBounds = L.bounds(\r\n\t\t\t        bounds.min.divideBy(tileSize)._floor(),\r\n\t\t\t        bounds.max.divideBy(tileSize)._floor());\r\n\t\r\n\t\t\tthis._addTilesFromCenterOut(tileBounds);\r\n\t\r\n\t\t\tif (this.options.unloadInvisibleTiles || this.options.reuseTiles) {\r\n\t\t\t\tthis._removeOtherTiles(tileBounds);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_addTilesFromCenterOut: function (bounds) {\r\n\t\t\tvar queue = [],\r\n\t\t\t    center = bounds.getCenter();\r\n\t\r\n\t\t\tvar j, i, point;\r\n\t\r\n\t\t\tfor (j = bounds.min.y; j <= bounds.max.y; j++) {\r\n\t\t\t\tfor (i = bounds.min.x; i <= bounds.max.x; i++) {\r\n\t\t\t\t\tpoint = new L.Point(i, j);\r\n\t\r\n\t\t\t\t\tif (this._tileShouldBeLoaded(point)) {\r\n\t\t\t\t\t\tqueue.push(point);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\tvar tilesToLoad = queue.length;\r\n\t\r\n\t\t\tif (tilesToLoad === 0) { return; }\r\n\t\r\n\t\t\t// load tiles in order of their distance to center\r\n\t\t\tqueue.sort(function (a, b) {\r\n\t\t\t\treturn a.distanceTo(center) - b.distanceTo(center);\r\n\t\t\t});\r\n\t\r\n\t\t\tvar fragment = document.createDocumentFragment();\r\n\t\r\n\t\t\t// if its the first batch of tiles to load\r\n\t\t\tif (!this._tilesToLoad) {\r\n\t\t\t\tthis.fire('loading');\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._tilesToLoad += tilesToLoad;\r\n\t\r\n\t\t\tfor (i = 0; i < tilesToLoad; i++) {\r\n\t\t\t\tthis._addTile(queue[i], fragment);\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._tileContainer.appendChild(fragment);\r\n\t\t},\r\n\t\r\n\t\t_tileShouldBeLoaded: function (tilePoint) {\r\n\t\t\tif ((tilePoint.x + ':' + tilePoint.y) in this._tiles) {\r\n\t\t\t\treturn false; // already loaded\r\n\t\t\t}\r\n\t\r\n\t\t\tvar options = this.options;\r\n\t\r\n\t\t\tif (!options.continuousWorld) {\r\n\t\t\t\tvar limit = this._getWrapTileNum();\r\n\t\r\n\t\t\t\t// don't load if exceeds world bounds\r\n\t\t\t\tif ((options.noWrap && (tilePoint.x < 0 || tilePoint.x >= limit.x)) ||\r\n\t\t\t\t\ttilePoint.y < 0 || tilePoint.y >= limit.y) { return false; }\r\n\t\t\t}\r\n\t\r\n\t\t\tif (options.bounds) {\r\n\t\t\t\tvar tileSize = this._getTileSize(),\r\n\t\t\t\t    nwPoint = tilePoint.multiplyBy(tileSize),\r\n\t\t\t\t    sePoint = nwPoint.add([tileSize, tileSize]),\r\n\t\t\t\t    nw = this._map.unproject(nwPoint),\r\n\t\t\t\t    se = this._map.unproject(sePoint);\r\n\t\r\n\t\t\t\t// TODO temporary hack, will be removed after refactoring projections\r\n\t\t\t\t// https://github.com/Leaflet/Leaflet/issues/1618\r\n\t\t\t\tif (!options.continuousWorld && !options.noWrap) {\r\n\t\t\t\t\tnw = nw.wrap();\r\n\t\t\t\t\tse = se.wrap();\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif (!options.bounds.intersects([nw, se])) { return false; }\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\t},\r\n\t\r\n\t\t_removeOtherTiles: function (bounds) {\r\n\t\t\tvar kArr, x, y, key;\r\n\t\r\n\t\t\tfor (key in this._tiles) {\r\n\t\t\t\tkArr = key.split(':');\r\n\t\t\t\tx = parseInt(kArr[0], 10);\r\n\t\t\t\ty = parseInt(kArr[1], 10);\r\n\t\r\n\t\t\t\t// remove tile if it's out of bounds\r\n\t\t\t\tif (x < bounds.min.x || x > bounds.max.x || y < bounds.min.y || y > bounds.max.y) {\r\n\t\t\t\t\tthis._removeTile(key);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_removeTile: function (key) {\r\n\t\t\tvar tile = this._tiles[key];\r\n\t\r\n\t\t\tthis.fire('tileunload', {tile: tile, url: tile.src});\r\n\t\r\n\t\t\tif (this.options.reuseTiles) {\r\n\t\t\t\tL.DomUtil.removeClass(tile, 'leaflet-tile-loaded');\r\n\t\t\t\tthis._unusedTiles.push(tile);\r\n\t\r\n\t\t\t} else if (tile.parentNode === this._tileContainer) {\r\n\t\t\t\tthis._tileContainer.removeChild(tile);\r\n\t\t\t}\r\n\t\r\n\t\t\t// for https://github.com/CloudMade/Leaflet/issues/137\r\n\t\t\tif (!L.Browser.android) {\r\n\t\t\t\ttile.onload = null;\r\n\t\t\t\ttile.src = L.Util.emptyImageUrl;\r\n\t\t\t}\r\n\t\r\n\t\t\tdelete this._tiles[key];\r\n\t\t},\r\n\t\r\n\t\t_addTile: function (tilePoint, container) {\r\n\t\t\tvar tilePos = this._getTilePos(tilePoint);\r\n\t\r\n\t\t\t// get unused tile - or create a new tile\r\n\t\t\tvar tile = this._getTile();\r\n\t\r\n\t\t\t/*\r\n\t\t\tChrome 20 layouts much faster with top/left (verify with timeline, frames)\r\n\t\t\tAndroid 4 browser has display issues with top/left and requires transform instead\r\n\t\t\t(other browsers don't currently care) - see debug/hacks/jitter.html for an example\r\n\t\t\t*/\r\n\t\t\tL.DomUtil.setPosition(tile, tilePos, L.Browser.chrome);\r\n\t\r\n\t\t\tthis._tiles[tilePoint.x + ':' + tilePoint.y] = tile;\r\n\t\r\n\t\t\tthis._loadTile(tile, tilePoint);\r\n\t\r\n\t\t\tif (tile.parentNode !== this._tileContainer) {\r\n\t\t\t\tcontainer.appendChild(tile);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_getZoomForUrl: function () {\r\n\t\r\n\t\t\tvar options = this.options,\r\n\t\t\t    zoom = this._map.getZoom();\r\n\t\r\n\t\t\tif (options.zoomReverse) {\r\n\t\t\t\tzoom = options.maxZoom - zoom;\r\n\t\t\t}\r\n\t\r\n\t\t\tzoom += options.zoomOffset;\r\n\t\r\n\t\t\treturn options.maxNativeZoom ? Math.min(zoom, options.maxNativeZoom) : zoom;\r\n\t\t},\r\n\t\r\n\t\t_getTilePos: function (tilePoint) {\r\n\t\t\tvar origin = this._map.getPixelOrigin(),\r\n\t\t\t    tileSize = this._getTileSize();\r\n\t\r\n\t\t\treturn tilePoint.multiplyBy(tileSize).subtract(origin);\r\n\t\t},\r\n\t\r\n\t\t// image-specific code (override to implement e.g. Canvas or SVG tile layer)\r\n\t\r\n\t\tgetTileUrl: function (tilePoint) {\r\n\t\t\treturn L.Util.template(this._url, L.extend({\r\n\t\t\t\ts: this._getSubdomain(tilePoint),\r\n\t\t\t\tz: tilePoint.z,\r\n\t\t\t\tx: tilePoint.x,\r\n\t\t\t\ty: tilePoint.y\r\n\t\t\t}, this.options));\r\n\t\t},\r\n\t\r\n\t\t_getWrapTileNum: function () {\r\n\t\t\tvar crs = this._map.options.crs,\r\n\t\t\t    size = crs.getSize(this._map.getZoom());\r\n\t\t\treturn size.divideBy(this._getTileSize())._floor();\r\n\t\t},\r\n\t\r\n\t\t_adjustTilePoint: function (tilePoint) {\r\n\t\r\n\t\t\tvar limit = this._getWrapTileNum();\r\n\t\r\n\t\t\t// wrap tile coordinates\r\n\t\t\tif (!this.options.continuousWorld && !this.options.noWrap) {\r\n\t\t\t\ttilePoint.x = ((tilePoint.x % limit.x) + limit.x) % limit.x;\r\n\t\t\t}\r\n\t\r\n\t\t\tif (this.options.tms) {\r\n\t\t\t\ttilePoint.y = limit.y - tilePoint.y - 1;\r\n\t\t\t}\r\n\t\r\n\t\t\ttilePoint.z = this._getZoomForUrl();\r\n\t\t},\r\n\t\r\n\t\t_getSubdomain: function (tilePoint) {\r\n\t\t\tvar index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;\r\n\t\t\treturn this.options.subdomains[index];\r\n\t\t},\r\n\t\r\n\t\t_getTile: function () {\r\n\t\t\tif (this.options.reuseTiles && this._unusedTiles.length > 0) {\r\n\t\t\t\tvar tile = this._unusedTiles.pop();\r\n\t\t\t\tthis._resetTile(tile);\r\n\t\t\t\treturn tile;\r\n\t\t\t}\r\n\t\t\treturn this._createTile();\r\n\t\t},\r\n\t\r\n\t\t// Override if data stored on a tile needs to be cleaned up before reuse\r\n\t\t_resetTile: function (/*tile*/) {},\r\n\t\r\n\t\t_createTile: function () {\r\n\t\t\tvar tile = L.DomUtil.create('img', 'leaflet-tile');\r\n\t\t\ttile.style.width = tile.style.height = this._getTileSize() + 'px';\r\n\t\t\ttile.galleryimg = 'no';\r\n\t\r\n\t\t\ttile.onselectstart = tile.onmousemove = L.Util.falseFn;\r\n\t\r\n\t\t\tif (L.Browser.ielt9 && this.options.opacity !== undefined) {\r\n\t\t\t\tL.DomUtil.setOpacity(tile, this.options.opacity);\r\n\t\t\t}\r\n\t\t\t// without this hack, tiles disappear after zoom on Chrome for Android\r\n\t\t\t// https://github.com/Leaflet/Leaflet/issues/2078\r\n\t\t\tif (L.Browser.mobileWebkit3d) {\r\n\t\t\t\ttile.style.WebkitBackfaceVisibility = 'hidden';\r\n\t\t\t}\r\n\t\t\treturn tile;\r\n\t\t},\r\n\t\r\n\t\t_loadTile: function (tile, tilePoint) {\r\n\t\t\ttile._layer  = this;\r\n\t\t\ttile.onload  = this._tileOnLoad;\r\n\t\t\ttile.onerror = this._tileOnError;\r\n\t\r\n\t\t\tthis._adjustTilePoint(tilePoint);\r\n\t\t\ttile.src     = this.getTileUrl(tilePoint);\r\n\t\r\n\t\t\tthis.fire('tileloadstart', {\r\n\t\t\t\ttile: tile,\r\n\t\t\t\turl: tile.src\r\n\t\t\t});\r\n\t\t},\r\n\t\r\n\t\t_tileLoaded: function () {\r\n\t\t\tthis._tilesToLoad--;\r\n\t\r\n\t\t\tif (this._animated) {\r\n\t\t\t\tL.DomUtil.addClass(this._tileContainer, 'leaflet-zoom-animated');\r\n\t\t\t}\r\n\t\r\n\t\t\tif (!this._tilesToLoad) {\r\n\t\t\t\tthis.fire('load');\r\n\t\r\n\t\t\t\tif (this._animated) {\r\n\t\t\t\t\t// clear scaled tiles after all new tiles are loaded (for performance)\r\n\t\t\t\t\tclearTimeout(this._clearBgBufferTimer);\r\n\t\t\t\t\tthis._clearBgBufferTimer = setTimeout(L.bind(this._clearBgBuffer, this), 500);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_tileOnLoad: function () {\r\n\t\t\tvar layer = this._layer;\r\n\t\r\n\t\t\t//Only if we are loading an actual image\r\n\t\t\tif (this.src !== L.Util.emptyImageUrl) {\r\n\t\t\t\tL.DomUtil.addClass(this, 'leaflet-tile-loaded');\r\n\t\r\n\t\t\t\tlayer.fire('tileload', {\r\n\t\t\t\t\ttile: this,\r\n\t\t\t\t\turl: this.src\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\r\n\t\t\tlayer._tileLoaded();\r\n\t\t},\r\n\t\r\n\t\t_tileOnError: function () {\r\n\t\t\tvar layer = this._layer;\r\n\t\r\n\t\t\tlayer.fire('tileerror', {\r\n\t\t\t\ttile: this,\r\n\t\t\t\turl: this.src\r\n\t\t\t});\r\n\t\r\n\t\t\tvar newUrl = layer.options.errorTileUrl;\r\n\t\t\tif (newUrl) {\r\n\t\t\t\tthis.src = newUrl;\r\n\t\t\t}\r\n\t\r\n\t\t\tlayer._tileLoaded();\r\n\t\t}\r\n\t});\r\n\t\r\n\tL.tileLayer = function (url, options) {\r\n\t\treturn new L.TileLayer(url, options);\r\n\t};\r\n\t\n\t\n\t/*\r\n\t * L.TileLayer.WMS is used for putting WMS tile layers on the map.\r\n\t */\r\n\t\r\n\tL.TileLayer.WMS = L.TileLayer.extend({\r\n\t\r\n\t\tdefaultWmsParams: {\r\n\t\t\tservice: 'WMS',\r\n\t\t\trequest: 'GetMap',\r\n\t\t\tversion: '1.1.1',\r\n\t\t\tlayers: '',\r\n\t\t\tstyles: '',\r\n\t\t\tformat: 'image/jpeg',\r\n\t\t\ttransparent: false\r\n\t\t},\r\n\t\r\n\t\tinitialize: function (url, options) { // (String, Object)\r\n\t\r\n\t\t\tthis._url = url;\r\n\t\r\n\t\t\tvar wmsParams = L.extend({}, this.defaultWmsParams),\r\n\t\t\t    tileSize = options.tileSize || this.options.tileSize;\r\n\t\r\n\t\t\tif (options.detectRetina && L.Browser.retina) {\r\n\t\t\t\twmsParams.width = wmsParams.height = tileSize * 2;\r\n\t\t\t} else {\r\n\t\t\t\twmsParams.width = wmsParams.height = tileSize;\r\n\t\t\t}\r\n\t\r\n\t\t\tfor (var i in options) {\r\n\t\t\t\t// all keys that are not TileLayer options go to WMS params\r\n\t\t\t\tif (!this.options.hasOwnProperty(i) && i !== 'crs') {\r\n\t\t\t\t\twmsParams[i] = options[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.wmsParams = wmsParams;\r\n\t\r\n\t\t\tL.setOptions(this, options);\r\n\t\t},\r\n\t\r\n\t\tonAdd: function (map) {\r\n\t\r\n\t\t\tthis._crs = this.options.crs || map.options.crs;\r\n\t\r\n\t\t\tthis._wmsVersion = parseFloat(this.wmsParams.version);\r\n\t\r\n\t\t\tvar projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';\r\n\t\t\tthis.wmsParams[projectionKey] = this._crs.code;\r\n\t\r\n\t\t\tL.TileLayer.prototype.onAdd.call(this, map);\r\n\t\t},\r\n\t\r\n\t\tgetTileUrl: function (tilePoint) { // (Point, Number) -> String\r\n\t\r\n\t\t\tvar map = this._map,\r\n\t\t\t    tileSize = this.options.tileSize,\r\n\t\r\n\t\t\t    nwPoint = tilePoint.multiplyBy(tileSize),\r\n\t\t\t    sePoint = nwPoint.add([tileSize, tileSize]),\r\n\t\r\n\t\t\t    nw = this._crs.project(map.unproject(nwPoint, tilePoint.z)),\r\n\t\t\t    se = this._crs.project(map.unproject(sePoint, tilePoint.z)),\r\n\t\t\t    bbox = this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ?\r\n\t\t\t        [se.y, nw.x, nw.y, se.x].join(',') :\r\n\t\t\t        [nw.x, se.y, se.x, nw.y].join(','),\r\n\t\r\n\t\t\t    url = L.Util.template(this._url, {s: this._getSubdomain(tilePoint)});\r\n\t\r\n\t\t\treturn url + L.Util.getParamString(this.wmsParams, url, true) + '&BBOX=' + bbox;\r\n\t\t},\r\n\t\r\n\t\tsetParams: function (params, noRedraw) {\r\n\t\r\n\t\t\tL.extend(this.wmsParams, params);\r\n\t\r\n\t\t\tif (!noRedraw) {\r\n\t\t\t\tthis.redraw();\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\t}\r\n\t});\r\n\t\r\n\tL.tileLayer.wms = function (url, options) {\r\n\t\treturn new L.TileLayer.WMS(url, options);\r\n\t};\r\n\t\n\t\n\t/*\r\n\t * L.TileLayer.Canvas is a class that you can use as a base for creating\r\n\t * dynamically drawn Canvas-based tile layers.\r\n\t */\r\n\t\r\n\tL.TileLayer.Canvas = L.TileLayer.extend({\r\n\t\toptions: {\r\n\t\t\tasync: false\r\n\t\t},\r\n\t\r\n\t\tinitialize: function (options) {\r\n\t\t\tL.setOptions(this, options);\r\n\t\t},\r\n\t\r\n\t\tredraw: function () {\r\n\t\t\tif (this._map) {\r\n\t\t\t\tthis._reset({hard: true});\r\n\t\t\t\tthis._update();\r\n\t\t\t}\r\n\t\r\n\t\t\tfor (var i in this._tiles) {\r\n\t\t\t\tthis._redrawTile(this._tiles[i]);\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\t_redrawTile: function (tile) {\r\n\t\t\tthis.drawTile(tile, tile._tilePoint, this._map._zoom);\r\n\t\t},\r\n\t\r\n\t\t_createTile: function () {\r\n\t\t\tvar tile = L.DomUtil.create('canvas', 'leaflet-tile');\r\n\t\t\ttile.width = tile.height = this.options.tileSize;\r\n\t\t\ttile.onselectstart = tile.onmousemove = L.Util.falseFn;\r\n\t\t\treturn tile;\r\n\t\t},\r\n\t\r\n\t\t_loadTile: function (tile, tilePoint) {\r\n\t\t\ttile._layer = this;\r\n\t\t\ttile._tilePoint = tilePoint;\r\n\t\r\n\t\t\tthis._redrawTile(tile);\r\n\t\r\n\t\t\tif (!this.options.async) {\r\n\t\t\t\tthis.tileDrawn(tile);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\tdrawTile: function (/*tile, tilePoint*/) {\r\n\t\t\t// override with rendering code\r\n\t\t},\r\n\t\r\n\t\ttileDrawn: function (tile) {\r\n\t\t\tthis._tileOnLoad.call(tile);\r\n\t\t}\r\n\t});\r\n\t\r\n\t\r\n\tL.tileLayer.canvas = function (options) {\r\n\t\treturn new L.TileLayer.Canvas(options);\r\n\t};\r\n\t\n\t\n\t/*\r\n\t * L.ImageOverlay is used to overlay images over the map (to specific geographical bounds).\r\n\t */\r\n\t\r\n\tL.ImageOverlay = L.Class.extend({\r\n\t\tincludes: L.Mixin.Events,\r\n\t\r\n\t\toptions: {\r\n\t\t\topacity: 1\r\n\t\t},\r\n\t\r\n\t\tinitialize: function (url, bounds, options) { // (String, LatLngBounds, Object)\r\n\t\t\tthis._url = url;\r\n\t\t\tthis._bounds = L.latLngBounds(bounds);\r\n\t\r\n\t\t\tL.setOptions(this, options);\r\n\t\t},\r\n\t\r\n\t\tonAdd: function (map) {\r\n\t\t\tthis._map = map;\r\n\t\r\n\t\t\tif (!this._image) {\r\n\t\t\t\tthis._initImage();\r\n\t\t\t}\r\n\t\r\n\t\t\tmap._panes.overlayPane.appendChild(this._image);\r\n\t\r\n\t\t\tmap.on('viewreset', this._reset, this);\r\n\t\r\n\t\t\tif (map.options.zoomAnimation && L.Browser.any3d) {\r\n\t\t\t\tmap.on('zoomanim', this._animateZoom, this);\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._reset();\r\n\t\t},\r\n\t\r\n\t\tonRemove: function (map) {\r\n\t\t\tmap.getPanes().overlayPane.removeChild(this._image);\r\n\t\r\n\t\t\tmap.off('viewreset', this._reset, this);\r\n\t\r\n\t\t\tif (map.options.zoomAnimation) {\r\n\t\t\t\tmap.off('zoomanim', this._animateZoom, this);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\taddTo: function (map) {\r\n\t\t\tmap.addLayer(this);\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tsetOpacity: function (opacity) {\r\n\t\t\tthis.options.opacity = opacity;\r\n\t\t\tthis._updateOpacity();\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\t// TODO remove bringToFront/bringToBack duplication from TileLayer/Path\r\n\t\tbringToFront: function () {\r\n\t\t\tif (this._image) {\r\n\t\t\t\tthis._map._panes.overlayPane.appendChild(this._image);\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tbringToBack: function () {\r\n\t\t\tvar pane = this._map._panes.overlayPane;\r\n\t\t\tif (this._image) {\r\n\t\t\t\tpane.insertBefore(this._image, pane.firstChild);\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tsetUrl: function (url) {\r\n\t\t\tthis._url = url;\r\n\t\t\tthis._image.src = this._url;\r\n\t\t},\r\n\t\r\n\t\tgetAttribution: function () {\r\n\t\t\treturn this.options.attribution;\r\n\t\t},\r\n\t\r\n\t\t_initImage: function () {\r\n\t\t\tthis._image = L.DomUtil.create('img', 'leaflet-image-layer');\r\n\t\r\n\t\t\tif (this._map.options.zoomAnimation && L.Browser.any3d) {\r\n\t\t\t\tL.DomUtil.addClass(this._image, 'leaflet-zoom-animated');\r\n\t\t\t} else {\r\n\t\t\t\tL.DomUtil.addClass(this._image, 'leaflet-zoom-hide');\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._updateOpacity();\r\n\t\r\n\t\t\t//TODO createImage util method to remove duplication\r\n\t\t\tL.extend(this._image, {\r\n\t\t\t\tgalleryimg: 'no',\r\n\t\t\t\tonselectstart: L.Util.falseFn,\r\n\t\t\t\tonmousemove: L.Util.falseFn,\r\n\t\t\t\tonload: L.bind(this._onImageLoad, this),\r\n\t\t\t\tsrc: this._url\r\n\t\t\t});\r\n\t\t},\r\n\t\r\n\t\t_animateZoom: function (e) {\r\n\t\t\tvar map = this._map,\r\n\t\t\t    image = this._image,\r\n\t\t\t    scale = map.getZoomScale(e.zoom),\r\n\t\t\t    nw = this._bounds.getNorthWest(),\r\n\t\t\t    se = this._bounds.getSouthEast(),\r\n\t\r\n\t\t\t    topLeft = map._latLngToNewLayerPoint(nw, e.zoom, e.center),\r\n\t\t\t    size = map._latLngToNewLayerPoint(se, e.zoom, e.center)._subtract(topLeft),\r\n\t\t\t    origin = topLeft._add(size._multiplyBy((1 / 2) * (1 - 1 / scale)));\r\n\t\r\n\t\t\timage.style[L.DomUtil.TRANSFORM] =\r\n\t\t\t        L.DomUtil.getTranslateString(origin) + ' scale(' + scale + ') ';\r\n\t\t},\r\n\t\r\n\t\t_reset: function () {\r\n\t\t\tvar image   = this._image,\r\n\t\t\t    topLeft = this._map.latLngToLayerPoint(this._bounds.getNorthWest()),\r\n\t\t\t    size = this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(topLeft);\r\n\t\r\n\t\t\tL.DomUtil.setPosition(image, topLeft);\r\n\t\r\n\t\t\timage.style.width  = size.x + 'px';\r\n\t\t\timage.style.height = size.y + 'px';\r\n\t\t},\r\n\t\r\n\t\t_onImageLoad: function () {\r\n\t\t\tthis.fire('load');\r\n\t\t},\r\n\t\r\n\t\t_updateOpacity: function () {\r\n\t\t\tL.DomUtil.setOpacity(this._image, this.options.opacity);\r\n\t\t}\r\n\t});\r\n\t\r\n\tL.imageOverlay = function (url, bounds, options) {\r\n\t\treturn new L.ImageOverlay(url, bounds, options);\r\n\t};\r\n\t\n\t\n\t/*\r\n\t * L.Icon is an image-based icon class that you can use with L.Marker for custom markers.\r\n\t */\r\n\t\r\n\tL.Icon = L.Class.extend({\r\n\t\toptions: {\r\n\t\t\t/*\r\n\t\t\ticonUrl: (String) (required)\r\n\t\t\ticonRetinaUrl: (String) (optional, used for retina devices if detected)\r\n\t\t\ticonSize: (Point) (can be set through CSS)\r\n\t\t\ticonAnchor: (Point) (centered by default, can be set in CSS with negative margins)\r\n\t\t\tpopupAnchor: (Point) (if not specified, popup opens in the anchor point)\r\n\t\t\tshadowUrl: (String) (no shadow by default)\r\n\t\t\tshadowRetinaUrl: (String) (optional, used for retina devices if detected)\r\n\t\t\tshadowSize: (Point)\r\n\t\t\tshadowAnchor: (Point)\r\n\t\t\t*/\r\n\t\t\tclassName: ''\r\n\t\t},\r\n\t\r\n\t\tinitialize: function (options) {\r\n\t\t\tL.setOptions(this, options);\r\n\t\t},\r\n\t\r\n\t\tcreateIcon: function (oldIcon) {\r\n\t\t\treturn this._createIcon('icon', oldIcon);\r\n\t\t},\r\n\t\r\n\t\tcreateShadow: function (oldIcon) {\r\n\t\t\treturn this._createIcon('shadow', oldIcon);\r\n\t\t},\r\n\t\r\n\t\t_createIcon: function (name, oldIcon) {\r\n\t\t\tvar src = this._getIconUrl(name);\r\n\t\r\n\t\t\tif (!src) {\r\n\t\t\t\tif (name === 'icon') {\r\n\t\t\t\t\tthrow new Error('iconUrl not set in Icon options (see the docs).');\r\n\t\t\t\t}\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\r\n\t\t\tvar img;\r\n\t\t\tif (!oldIcon || oldIcon.tagName !== 'IMG') {\r\n\t\t\t\timg = this._createImg(src);\r\n\t\t\t} else {\r\n\t\t\t\timg = this._createImg(src, oldIcon);\r\n\t\t\t}\r\n\t\t\tthis._setIconStyles(img, name);\r\n\t\r\n\t\t\treturn img;\r\n\t\t},\r\n\t\r\n\t\t_setIconStyles: function (img, name) {\r\n\t\t\tvar options = this.options,\r\n\t\t\t    size = L.point(options[name + 'Size']),\r\n\t\t\t    anchor;\r\n\t\r\n\t\t\tif (name === 'shadow') {\r\n\t\t\t\tanchor = L.point(options.shadowAnchor || options.iconAnchor);\r\n\t\t\t} else {\r\n\t\t\t\tanchor = L.point(options.iconAnchor);\r\n\t\t\t}\r\n\t\r\n\t\t\tif (!anchor && size) {\r\n\t\t\t\tanchor = size.divideBy(2, true);\r\n\t\t\t}\r\n\t\r\n\t\t\timg.className = 'leaflet-marker-' + name + ' ' + options.className;\r\n\t\r\n\t\t\tif (anchor) {\r\n\t\t\t\timg.style.marginLeft = (-anchor.x) + 'px';\r\n\t\t\t\timg.style.marginTop  = (-anchor.y) + 'px';\r\n\t\t\t}\r\n\t\r\n\t\t\tif (size) {\r\n\t\t\t\timg.style.width  = size.x + 'px';\r\n\t\t\t\timg.style.height = size.y + 'px';\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_createImg: function (src, el) {\r\n\t\t\tel = el || document.createElement('img');\r\n\t\t\tel.src = src;\r\n\t\t\treturn el;\r\n\t\t},\r\n\t\r\n\t\t_getIconUrl: function (name) {\r\n\t\t\tif (L.Browser.retina && this.options[name + 'RetinaUrl']) {\r\n\t\t\t\treturn this.options[name + 'RetinaUrl'];\r\n\t\t\t}\r\n\t\t\treturn this.options[name + 'Url'];\r\n\t\t}\r\n\t});\r\n\t\r\n\tL.icon = function (options) {\r\n\t\treturn new L.Icon(options);\r\n\t};\r\n\t\n\t\n\t/*\n\t * L.Icon.Default is the blue marker icon used by default in Leaflet.\n\t */\n\t\n\tL.Icon.Default = L.Icon.extend({\n\t\n\t\toptions: {\n\t\t\ticonSize: [25, 41],\n\t\t\ticonAnchor: [12, 41],\n\t\t\tpopupAnchor: [1, -34],\n\t\n\t\t\tshadowSize: [41, 41]\n\t\t},\n\t\n\t\t_getIconUrl: function (name) {\n\t\t\tvar key = name + 'Url';\n\t\n\t\t\tif (this.options[key]) {\n\t\t\t\treturn this.options[key];\n\t\t\t}\n\t\n\t\t\tif (L.Browser.retina && name === 'icon') {\n\t\t\t\tname += '-2x';\n\t\t\t}\n\t\n\t\t\tvar path = L.Icon.Default.imagePath;\n\t\n\t\t\tif (!path) {\n\t\t\t\tthrow new Error('Couldn\\'t autodetect L.Icon.Default.imagePath, set it manually.');\n\t\t\t}\n\t\n\t\t\treturn path + '/marker-' + name + '.png';\n\t\t}\n\t});\n\t\n\tL.Icon.Default.imagePath = (function () {\n\t\tvar scripts = document.getElementsByTagName('script'),\n\t\t    leafletRe = /[\\/^]leaflet[\\-\\._]?([\\w\\-\\._]*)\\.js\\??/;\n\t\n\t\tvar i, len, src, matches, path;\n\t\n\t\tfor (i = 0, len = scripts.length; i < len; i++) {\n\t\t\tsrc = scripts[i].src;\n\t\t\tmatches = src.match(leafletRe);\n\t\n\t\t\tif (matches) {\n\t\t\t\tpath = src.split(leafletRe)[0];\n\t\t\t\treturn (path ? path + '/' : '') + 'images';\n\t\t\t}\n\t\t}\n\t}());\n\t\n\t\n\t/*\r\n\t * L.Marker is used to display clickable/draggable icons on the map.\r\n\t */\r\n\t\r\n\tL.Marker = L.Class.extend({\r\n\t\r\n\t\tincludes: L.Mixin.Events,\r\n\t\r\n\t\toptions: {\r\n\t\t\ticon: new L.Icon.Default(),\r\n\t\t\ttitle: '',\r\n\t\t\talt: '',\r\n\t\t\tclickable: true,\r\n\t\t\tdraggable: false,\r\n\t\t\tkeyboard: true,\r\n\t\t\tzIndexOffset: 0,\r\n\t\t\topacity: 1,\r\n\t\t\triseOnHover: false,\r\n\t\t\triseOffset: 250\r\n\t\t},\r\n\t\r\n\t\tinitialize: function (latlng, options) {\r\n\t\t\tL.setOptions(this, options);\r\n\t\t\tthis._latlng = L.latLng(latlng);\r\n\t\t},\r\n\t\r\n\t\tonAdd: function (map) {\r\n\t\t\tthis._map = map;\r\n\t\r\n\t\t\tmap.on('viewreset', this.update, this);\r\n\t\r\n\t\t\tthis._initIcon();\r\n\t\t\tthis.update();\r\n\t\t\tthis.fire('add');\r\n\t\r\n\t\t\tif (map.options.zoomAnimation && map.options.markerZoomAnimation) {\r\n\t\t\t\tmap.on('zoomanim', this._animateZoom, this);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\taddTo: function (map) {\r\n\t\t\tmap.addLayer(this);\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tonRemove: function (map) {\r\n\t\t\tif (this.dragging) {\r\n\t\t\t\tthis.dragging.disable();\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._removeIcon();\r\n\t\t\tthis._removeShadow();\r\n\t\r\n\t\t\tthis.fire('remove');\r\n\t\r\n\t\t\tmap.off({\r\n\t\t\t\t'viewreset': this.update,\r\n\t\t\t\t'zoomanim': this._animateZoom\r\n\t\t\t}, this);\r\n\t\r\n\t\t\tthis._map = null;\r\n\t\t},\r\n\t\r\n\t\tgetLatLng: function () {\r\n\t\t\treturn this._latlng;\r\n\t\t},\r\n\t\r\n\t\tsetLatLng: function (latlng) {\r\n\t\t\tthis._latlng = L.latLng(latlng);\r\n\t\r\n\t\t\tthis.update();\r\n\t\r\n\t\t\treturn this.fire('move', { latlng: this._latlng });\r\n\t\t},\r\n\t\r\n\t\tsetZIndexOffset: function (offset) {\r\n\t\t\tthis.options.zIndexOffset = offset;\r\n\t\t\tthis.update();\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tsetIcon: function (icon) {\r\n\t\r\n\t\t\tthis.options.icon = icon;\r\n\t\r\n\t\t\tif (this._map) {\r\n\t\t\t\tthis._initIcon();\r\n\t\t\t\tthis.update();\r\n\t\t\t}\r\n\t\r\n\t\t\tif (this._popup) {\r\n\t\t\t\tthis.bindPopup(this._popup);\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tupdate: function () {\r\n\t\t\tif (this._icon) {\r\n\t\t\t\tthis._setPos(this._map.latLngToLayerPoint(this._latlng).round());\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\t_initIcon: function () {\r\n\t\t\tvar options = this.options,\r\n\t\t\t    map = this._map,\r\n\t\t\t    animation = (map.options.zoomAnimation && map.options.markerZoomAnimation),\r\n\t\t\t    classToAdd = animation ? 'leaflet-zoom-animated' : 'leaflet-zoom-hide';\r\n\t\r\n\t\t\tvar icon = options.icon.createIcon(this._icon),\r\n\t\t\t\taddIcon = false;\r\n\t\r\n\t\t\t// if we're not reusing the icon, remove the old one and init new one\r\n\t\t\tif (icon !== this._icon) {\r\n\t\t\t\tif (this._icon) {\r\n\t\t\t\t\tthis._removeIcon();\r\n\t\t\t\t}\r\n\t\t\t\taddIcon = true;\r\n\t\r\n\t\t\t\tif (options.title) {\r\n\t\t\t\t\ticon.title = options.title;\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif (options.alt) {\r\n\t\t\t\t\ticon.alt = options.alt;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\tL.DomUtil.addClass(icon, classToAdd);\r\n\t\r\n\t\t\tif (options.keyboard) {\r\n\t\t\t\ticon.tabIndex = '0';\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._icon = icon;\r\n\t\r\n\t\t\tthis._initInteraction();\r\n\t\r\n\t\t\tif (options.riseOnHover) {\r\n\t\t\t\tL.DomEvent\r\n\t\t\t\t\t.on(icon, 'mouseover', this._bringToFront, this)\r\n\t\t\t\t\t.on(icon, 'mouseout', this._resetZIndex, this);\r\n\t\t\t}\r\n\t\r\n\t\t\tvar newShadow = options.icon.createShadow(this._shadow),\r\n\t\t\t\taddShadow = false;\r\n\t\r\n\t\t\tif (newShadow !== this._shadow) {\r\n\t\t\t\tthis._removeShadow();\r\n\t\t\t\taddShadow = true;\r\n\t\t\t}\r\n\t\r\n\t\t\tif (newShadow) {\r\n\t\t\t\tL.DomUtil.addClass(newShadow, classToAdd);\r\n\t\t\t}\r\n\t\t\tthis._shadow = newShadow;\r\n\t\r\n\t\r\n\t\t\tif (options.opacity < 1) {\r\n\t\t\t\tthis._updateOpacity();\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t\tvar panes = this._map._panes;\r\n\t\r\n\t\t\tif (addIcon) {\r\n\t\t\t\tpanes.markerPane.appendChild(this._icon);\r\n\t\t\t}\r\n\t\r\n\t\t\tif (newShadow && addShadow) {\r\n\t\t\t\tpanes.shadowPane.appendChild(this._shadow);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_removeIcon: function () {\r\n\t\t\tif (this.options.riseOnHover) {\r\n\t\t\t\tL.DomEvent\r\n\t\t\t\t    .off(this._icon, 'mouseover', this._bringToFront)\r\n\t\t\t\t    .off(this._icon, 'mouseout', this._resetZIndex);\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._map._panes.markerPane.removeChild(this._icon);\r\n\t\r\n\t\t\tthis._icon = null;\r\n\t\t},\r\n\t\r\n\t\t_removeShadow: function () {\r\n\t\t\tif (this._shadow) {\r\n\t\t\t\tthis._map._panes.shadowPane.removeChild(this._shadow);\r\n\t\t\t}\r\n\t\t\tthis._shadow = null;\r\n\t\t},\r\n\t\r\n\t\t_setPos: function (pos) {\r\n\t\t\tL.DomUtil.setPosition(this._icon, pos);\r\n\t\r\n\t\t\tif (this._shadow) {\r\n\t\t\t\tL.DomUtil.setPosition(this._shadow, pos);\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._zIndex = pos.y + this.options.zIndexOffset;\r\n\t\r\n\t\t\tthis._resetZIndex();\r\n\t\t},\r\n\t\r\n\t\t_updateZIndex: function (offset) {\r\n\t\t\tthis._icon.style.zIndex = this._zIndex + offset;\r\n\t\t},\r\n\t\r\n\t\t_animateZoom: function (opt) {\r\n\t\t\tvar pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();\r\n\t\r\n\t\t\tthis._setPos(pos);\r\n\t\t},\r\n\t\r\n\t\t_initInteraction: function () {\r\n\t\r\n\t\t\tif (!this.options.clickable) { return; }\r\n\t\r\n\t\t\t// TODO refactor into something shared with Map/Path/etc. to DRY it up\r\n\t\r\n\t\t\tvar icon = this._icon,\r\n\t\t\t    events = ['dblclick', 'mousedown', 'mouseover', 'mouseout', 'contextmenu'];\r\n\t\r\n\t\t\tL.DomUtil.addClass(icon, 'leaflet-clickable');\r\n\t\t\tL.DomEvent.on(icon, 'click', this._onMouseClick, this);\r\n\t\t\tL.DomEvent.on(icon, 'keypress', this._onKeyPress, this);\r\n\t\r\n\t\t\tfor (var i = 0; i < events.length; i++) {\r\n\t\t\t\tL.DomEvent.on(icon, events[i], this._fireMouseEvent, this);\r\n\t\t\t}\r\n\t\r\n\t\t\tif (L.Handler.MarkerDrag) {\r\n\t\t\t\tthis.dragging = new L.Handler.MarkerDrag(this);\r\n\t\r\n\t\t\t\tif (this.options.draggable) {\r\n\t\t\t\t\tthis.dragging.enable();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_onMouseClick: function (e) {\r\n\t\t\tvar wasDragged = this.dragging && this.dragging.moved();\r\n\t\r\n\t\t\tif (this.hasEventListeners(e.type) || wasDragged) {\r\n\t\t\t\tL.DomEvent.stopPropagation(e);\r\n\t\t\t}\r\n\t\r\n\t\t\tif (wasDragged) { return; }\r\n\t\r\n\t\t\tif ((!this.dragging || !this.dragging._enabled) && this._map.dragging && this._map.dragging.moved()) { return; }\r\n\t\r\n\t\t\tthis.fire(e.type, {\r\n\t\t\t\toriginalEvent: e,\r\n\t\t\t\tlatlng: this._latlng\r\n\t\t\t});\r\n\t\t},\r\n\t\r\n\t\t_onKeyPress: function (e) {\r\n\t\t\tif (e.keyCode === 13) {\r\n\t\t\t\tthis.fire('click', {\r\n\t\t\t\t\toriginalEvent: e,\r\n\t\t\t\t\tlatlng: this._latlng\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_fireMouseEvent: function (e) {\r\n\t\r\n\t\t\tthis.fire(e.type, {\r\n\t\t\t\toriginalEvent: e,\r\n\t\t\t\tlatlng: this._latlng\r\n\t\t\t});\r\n\t\r\n\t\t\t// TODO proper custom event propagation\r\n\t\t\t// this line will always be called if marker is in a FeatureGroup\r\n\t\t\tif (e.type === 'contextmenu' && this.hasEventListeners(e.type)) {\r\n\t\t\t\tL.DomEvent.preventDefault(e);\r\n\t\t\t}\r\n\t\t\tif (e.type !== 'mousedown') {\r\n\t\t\t\tL.DomEvent.stopPropagation(e);\r\n\t\t\t} else {\r\n\t\t\t\tL.DomEvent.preventDefault(e);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\tsetOpacity: function (opacity) {\r\n\t\t\tthis.options.opacity = opacity;\r\n\t\t\tif (this._map) {\r\n\t\t\t\tthis._updateOpacity();\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\t_updateOpacity: function () {\r\n\t\t\tL.DomUtil.setOpacity(this._icon, this.options.opacity);\r\n\t\t\tif (this._shadow) {\r\n\t\t\t\tL.DomUtil.setOpacity(this._shadow, this.options.opacity);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_bringToFront: function () {\r\n\t\t\tthis._updateZIndex(this.options.riseOffset);\r\n\t\t},\r\n\t\r\n\t\t_resetZIndex: function () {\r\n\t\t\tthis._updateZIndex(0);\r\n\t\t}\r\n\t});\r\n\t\r\n\tL.marker = function (latlng, options) {\r\n\t\treturn new L.Marker(latlng, options);\r\n\t};\r\n\t\n\t\n\t/*\n\t * L.DivIcon is a lightweight HTML-based icon class (as opposed to the image-based L.Icon)\n\t * to use with L.Marker.\n\t */\n\t\n\tL.DivIcon = L.Icon.extend({\n\t\toptions: {\n\t\t\ticonSize: [12, 12], // also can be set through CSS\n\t\t\t/*\n\t\t\ticonAnchor: (Point)\n\t\t\tpopupAnchor: (Point)\n\t\t\thtml: (String)\n\t\t\tbgPos: (Point)\n\t\t\t*/\n\t\t\tclassName: 'leaflet-div-icon',\n\t\t\thtml: false\n\t\t},\n\t\n\t\tcreateIcon: function (oldIcon) {\n\t\t\tvar div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),\n\t\t\t    options = this.options;\n\t\n\t\t\tif (options.html !== false) {\n\t\t\t\tdiv.innerHTML = options.html;\n\t\t\t} else {\n\t\t\t\tdiv.innerHTML = '';\n\t\t\t}\n\t\n\t\t\tif (options.bgPos) {\n\t\t\t\tdiv.style.backgroundPosition =\n\t\t\t\t        (-options.bgPos.x) + 'px ' + (-options.bgPos.y) + 'px';\n\t\t\t}\n\t\n\t\t\tthis._setIconStyles(div, 'icon');\n\t\t\treturn div;\n\t\t},\n\t\n\t\tcreateShadow: function () {\n\t\t\treturn null;\n\t\t}\n\t});\n\t\n\tL.divIcon = function (options) {\n\t\treturn new L.DivIcon(options);\n\t};\n\t\n\t\n\t/*\r\n\t * L.Popup is used for displaying popups on the map.\r\n\t */\r\n\t\r\n\tL.Map.mergeOptions({\r\n\t\tclosePopupOnClick: true\r\n\t});\r\n\t\r\n\tL.Popup = L.Class.extend({\r\n\t\tincludes: L.Mixin.Events,\r\n\t\r\n\t\toptions: {\r\n\t\t\tminWidth: 50,\r\n\t\t\tmaxWidth: 300,\r\n\t\t\t// maxHeight: null,\r\n\t\t\tautoPan: true,\r\n\t\t\tcloseButton: true,\r\n\t\t\toffset: [0, 7],\r\n\t\t\tautoPanPadding: [5, 5],\r\n\t\t\t// autoPanPaddingTopLeft: null,\r\n\t\t\t// autoPanPaddingBottomRight: null,\r\n\t\t\tkeepInView: false,\r\n\t\t\tclassName: '',\r\n\t\t\tzoomAnimation: true\r\n\t\t},\r\n\t\r\n\t\tinitialize: function (options, source) {\r\n\t\t\tL.setOptions(this, options);\r\n\t\r\n\t\t\tthis._source = source;\r\n\t\t\tthis._animated = L.Browser.any3d && this.options.zoomAnimation;\r\n\t\t\tthis._isOpen = false;\r\n\t\t},\r\n\t\r\n\t\tonAdd: function (map) {\r\n\t\t\tthis._map = map;\r\n\t\r\n\t\t\tif (!this._container) {\r\n\t\t\t\tthis._initLayout();\r\n\t\t\t}\r\n\t\r\n\t\t\tvar animFade = map.options.fadeAnimation;\r\n\t\r\n\t\t\tif (animFade) {\r\n\t\t\t\tL.DomUtil.setOpacity(this._container, 0);\r\n\t\t\t}\r\n\t\t\tmap._panes.popupPane.appendChild(this._container);\r\n\t\r\n\t\t\tmap.on(this._getEvents(), this);\r\n\t\r\n\t\t\tthis.update();\r\n\t\r\n\t\t\tif (animFade) {\r\n\t\t\t\tL.DomUtil.setOpacity(this._container, 1);\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.fire('open');\r\n\t\r\n\t\t\tmap.fire('popupopen', {popup: this});\r\n\t\r\n\t\t\tif (this._source) {\r\n\t\t\t\tthis._source.fire('popupopen', {popup: this});\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\taddTo: function (map) {\r\n\t\t\tmap.addLayer(this);\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\topenOn: function (map) {\r\n\t\t\tmap.openPopup(this);\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tonRemove: function (map) {\r\n\t\t\tmap._panes.popupPane.removeChild(this._container);\r\n\t\r\n\t\t\tL.Util.falseFn(this._container.offsetWidth); // force reflow\r\n\t\r\n\t\t\tmap.off(this._getEvents(), this);\r\n\t\r\n\t\t\tif (map.options.fadeAnimation) {\r\n\t\t\t\tL.DomUtil.setOpacity(this._container, 0);\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._map = null;\r\n\t\r\n\t\t\tthis.fire('close');\r\n\t\r\n\t\t\tmap.fire('popupclose', {popup: this});\r\n\t\r\n\t\t\tif (this._source) {\r\n\t\t\t\tthis._source.fire('popupclose', {popup: this});\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\tgetLatLng: function () {\r\n\t\t\treturn this._latlng;\r\n\t\t},\r\n\t\r\n\t\tsetLatLng: function (latlng) {\r\n\t\t\tthis._latlng = L.latLng(latlng);\r\n\t\t\tif (this._map) {\r\n\t\t\t\tthis._updatePosition();\r\n\t\t\t\tthis._adjustPan();\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tgetContent: function () {\r\n\t\t\treturn this._content;\r\n\t\t},\r\n\t\r\n\t\tsetContent: function (content) {\r\n\t\t\tthis._content = content;\r\n\t\t\tthis.update();\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tupdate: function () {\r\n\t\t\tif (!this._map) { return; }\r\n\t\r\n\t\t\tthis._container.style.visibility = 'hidden';\r\n\t\r\n\t\t\tthis._updateContent();\r\n\t\t\tthis._updateLayout();\r\n\t\t\tthis._updatePosition();\r\n\t\r\n\t\t\tthis._container.style.visibility = '';\r\n\t\r\n\t\t\tthis._adjustPan();\r\n\t\t},\r\n\t\r\n\t\t_getEvents: function () {\r\n\t\t\tvar events = {\r\n\t\t\t\tviewreset: this._updatePosition\r\n\t\t\t};\r\n\t\r\n\t\t\tif (this._animated) {\r\n\t\t\t\tevents.zoomanim = this._zoomAnimation;\r\n\t\t\t}\r\n\t\t\tif ('closeOnClick' in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) {\r\n\t\t\t\tevents.preclick = this._close;\r\n\t\t\t}\r\n\t\t\tif (this.options.keepInView) {\r\n\t\t\t\tevents.moveend = this._adjustPan;\r\n\t\t\t}\r\n\t\r\n\t\t\treturn events;\r\n\t\t},\r\n\t\r\n\t\t_close: function () {\r\n\t\t\tif (this._map) {\r\n\t\t\t\tthis._map.closePopup(this);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_initLayout: function () {\r\n\t\t\tvar prefix = 'leaflet-popup',\r\n\t\t\t\tcontainerClass = prefix + ' ' + this.options.className + ' leaflet-zoom-' +\r\n\t\t\t\t        (this._animated ? 'animated' : 'hide'),\r\n\t\t\t\tcontainer = this._container = L.DomUtil.create('div', containerClass),\r\n\t\t\t\tcloseButton;\r\n\t\r\n\t\t\tif (this.options.closeButton) {\r\n\t\t\t\tcloseButton = this._closeButton =\r\n\t\t\t\t        L.DomUtil.create('a', prefix + '-close-button', container);\r\n\t\t\t\tcloseButton.href = '#close';\r\n\t\t\t\tcloseButton.innerHTML = '&#215;';\r\n\t\t\t\tL.DomEvent.disableClickPropagation(closeButton);\r\n\t\r\n\t\t\t\tL.DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);\r\n\t\t\t}\r\n\t\r\n\t\t\tvar wrapper = this._wrapper =\r\n\t\t\t        L.DomUtil.create('div', prefix + '-content-wrapper', container);\r\n\t\t\tL.DomEvent.disableClickPropagation(wrapper);\r\n\t\r\n\t\t\tthis._contentNode = L.DomUtil.create('div', prefix + '-content', wrapper);\r\n\t\r\n\t\t\tL.DomEvent.disableScrollPropagation(this._contentNode);\r\n\t\t\tL.DomEvent.on(wrapper, 'contextmenu', L.DomEvent.stopPropagation);\r\n\t\r\n\t\t\tthis._tipContainer = L.DomUtil.create('div', prefix + '-tip-container', container);\r\n\t\t\tthis._tip = L.DomUtil.create('div', prefix + '-tip', this._tipContainer);\r\n\t\t},\r\n\t\r\n\t\t_updateContent: function () {\r\n\t\t\tif (!this._content) { return; }\r\n\t\r\n\t\t\tif (typeof this._content === 'string') {\r\n\t\t\t\tthis._contentNode.innerHTML = this._content;\r\n\t\t\t} else {\r\n\t\t\t\twhile (this._contentNode.hasChildNodes()) {\r\n\t\t\t\t\tthis._contentNode.removeChild(this._contentNode.firstChild);\r\n\t\t\t\t}\r\n\t\t\t\tthis._contentNode.appendChild(this._content);\r\n\t\t\t}\r\n\t\t\tthis.fire('contentupdate');\r\n\t\t},\r\n\t\r\n\t\t_updateLayout: function () {\r\n\t\t\tvar container = this._contentNode,\r\n\t\t\t    style = container.style;\r\n\t\r\n\t\t\tstyle.width = '';\r\n\t\t\tstyle.whiteSpace = 'nowrap';\r\n\t\r\n\t\t\tvar width = container.offsetWidth;\r\n\t\t\twidth = Math.min(width, this.options.maxWidth);\r\n\t\t\twidth = Math.max(width, this.options.minWidth);\r\n\t\r\n\t\t\tstyle.width = (width + 1) + 'px';\r\n\t\t\tstyle.whiteSpace = '';\r\n\t\r\n\t\t\tstyle.height = '';\r\n\t\r\n\t\t\tvar height = container.offsetHeight,\r\n\t\t\t    maxHeight = this.options.maxHeight,\r\n\t\t\t    scrolledClass = 'leaflet-popup-scrolled';\r\n\t\r\n\t\t\tif (maxHeight && height > maxHeight) {\r\n\t\t\t\tstyle.height = maxHeight + 'px';\r\n\t\t\t\tL.DomUtil.addClass(container, scrolledClass);\r\n\t\t\t} else {\r\n\t\t\t\tL.DomUtil.removeClass(container, scrolledClass);\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._containerWidth = this._container.offsetWidth;\r\n\t\t},\r\n\t\r\n\t\t_updatePosition: function () {\r\n\t\t\tif (!this._map) { return; }\r\n\t\r\n\t\t\tvar pos = this._map.latLngToLayerPoint(this._latlng),\r\n\t\t\t    animated = this._animated,\r\n\t\t\t    offset = L.point(this.options.offset);\r\n\t\r\n\t\t\tif (animated) {\r\n\t\t\t\tL.DomUtil.setPosition(this._container, pos);\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._containerBottom = -offset.y - (animated ? 0 : pos.y);\r\n\t\t\tthis._containerLeft = -Math.round(this._containerWidth / 2) + offset.x + (animated ? 0 : pos.x);\r\n\t\r\n\t\t\t// bottom position the popup in case the height of the popup changes (images loading etc)\r\n\t\t\tthis._container.style.bottom = this._containerBottom + 'px';\r\n\t\t\tthis._container.style.left = this._containerLeft + 'px';\r\n\t\t},\r\n\t\r\n\t\t_zoomAnimation: function (opt) {\r\n\t\t\tvar pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center);\r\n\t\r\n\t\t\tL.DomUtil.setPosition(this._container, pos);\r\n\t\t},\r\n\t\r\n\t\t_adjustPan: function () {\r\n\t\t\tif (!this.options.autoPan) { return; }\r\n\t\r\n\t\t\tvar map = this._map,\r\n\t\t\t    containerHeight = this._container.offsetHeight,\r\n\t\t\t    containerWidth = this._containerWidth,\r\n\t\r\n\t\t\t    layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);\r\n\t\r\n\t\t\tif (this._animated) {\r\n\t\t\t\tlayerPos._add(L.DomUtil.getPosition(this._container));\r\n\t\t\t}\r\n\t\r\n\t\t\tvar containerPos = map.layerPointToContainerPoint(layerPos),\r\n\t\t\t    padding = L.point(this.options.autoPanPadding),\r\n\t\t\t    paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),\r\n\t\t\t    paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),\r\n\t\t\t    size = map.getSize(),\r\n\t\t\t    dx = 0,\r\n\t\t\t    dy = 0;\r\n\t\r\n\t\t\tif (containerPos.x + containerWidth + paddingBR.x > size.x) { // right\r\n\t\t\t\tdx = containerPos.x + containerWidth - size.x + paddingBR.x;\r\n\t\t\t}\r\n\t\t\tif (containerPos.x - dx - paddingTL.x < 0) { // left\r\n\t\t\t\tdx = containerPos.x - paddingTL.x;\r\n\t\t\t}\r\n\t\t\tif (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom\r\n\t\t\t\tdy = containerPos.y + containerHeight - size.y + paddingBR.y;\r\n\t\t\t}\r\n\t\t\tif (containerPos.y - dy - paddingTL.y < 0) { // top\r\n\t\t\t\tdy = containerPos.y - paddingTL.y;\r\n\t\t\t}\r\n\t\r\n\t\t\tif (dx || dy) {\r\n\t\t\t\tmap\r\n\t\t\t\t    .fire('autopanstart')\r\n\t\t\t\t    .panBy([dx, dy]);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_onCloseButtonClick: function (e) {\r\n\t\t\tthis._close();\r\n\t\t\tL.DomEvent.stop(e);\r\n\t\t}\r\n\t});\r\n\t\r\n\tL.popup = function (options, source) {\r\n\t\treturn new L.Popup(options, source);\r\n\t};\r\n\t\r\n\t\r\n\tL.Map.include({\r\n\t\topenPopup: function (popup, latlng, options) { // (Popup) or (String || HTMLElement, LatLng[, Object])\r\n\t\t\tthis.closePopup();\r\n\t\r\n\t\t\tif (!(popup instanceof L.Popup)) {\r\n\t\t\t\tvar content = popup;\r\n\t\r\n\t\t\t\tpopup = new L.Popup(options)\r\n\t\t\t\t    .setLatLng(latlng)\r\n\t\t\t\t    .setContent(content);\r\n\t\t\t}\r\n\t\t\tpopup._isOpen = true;\r\n\t\r\n\t\t\tthis._popup = popup;\r\n\t\t\treturn this.addLayer(popup);\r\n\t\t},\r\n\t\r\n\t\tclosePopup: function (popup) {\r\n\t\t\tif (!popup || popup === this._popup) {\r\n\t\t\t\tpopup = this._popup;\r\n\t\t\t\tthis._popup = null;\r\n\t\t\t}\r\n\t\t\tif (popup) {\r\n\t\t\t\tthis.removeLayer(popup);\r\n\t\t\t\tpopup._isOpen = false;\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t}\r\n\t});\r\n\t\n\t\n\t/*\r\n\t * Popup extension to L.Marker, adding popup-related methods.\r\n\t */\r\n\t\r\n\tL.Marker.include({\r\n\t\topenPopup: function () {\r\n\t\t\tif (this._popup && this._map && !this._map.hasLayer(this._popup)) {\r\n\t\t\t\tthis._popup.setLatLng(this._latlng);\r\n\t\t\t\tthis._map.openPopup(this._popup);\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tclosePopup: function () {\r\n\t\t\tif (this._popup) {\r\n\t\t\t\tthis._popup._close();\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\ttogglePopup: function () {\r\n\t\t\tif (this._popup) {\r\n\t\t\t\tif (this._popup._isOpen) {\r\n\t\t\t\t\tthis.closePopup();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.openPopup();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tbindPopup: function (content, options) {\r\n\t\t\tvar anchor = L.point(this.options.icon.options.popupAnchor || [0, 0]);\r\n\t\r\n\t\t\tanchor = anchor.add(L.Popup.prototype.options.offset);\r\n\t\r\n\t\t\tif (options && options.offset) {\r\n\t\t\t\tanchor = anchor.add(options.offset);\r\n\t\t\t}\r\n\t\r\n\t\t\toptions = L.extend({offset: anchor}, options);\r\n\t\r\n\t\t\tif (!this._popupHandlersAdded) {\r\n\t\t\t\tthis\r\n\t\t\t\t    .on('click', this.togglePopup, this)\r\n\t\t\t\t    .on('remove', this.closePopup, this)\r\n\t\t\t\t    .on('move', this._movePopup, this);\r\n\t\t\t\tthis._popupHandlersAdded = true;\r\n\t\t\t}\r\n\t\r\n\t\t\tif (content instanceof L.Popup) {\r\n\t\t\t\tL.setOptions(content, options);\r\n\t\t\t\tthis._popup = content;\r\n\t\t\t\tcontent._source = this;\r\n\t\t\t} else {\r\n\t\t\t\tthis._popup = new L.Popup(options, this)\r\n\t\t\t\t\t.setContent(content);\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tsetPopupContent: function (content) {\r\n\t\t\tif (this._popup) {\r\n\t\t\t\tthis._popup.setContent(content);\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tunbindPopup: function () {\r\n\t\t\tif (this._popup) {\r\n\t\t\t\tthis._popup = null;\r\n\t\t\t\tthis\r\n\t\t\t\t    .off('click', this.togglePopup, this)\r\n\t\t\t\t    .off('remove', this.closePopup, this)\r\n\t\t\t\t    .off('move', this._movePopup, this);\r\n\t\t\t\tthis._popupHandlersAdded = false;\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tgetPopup: function () {\r\n\t\t\treturn this._popup;\r\n\t\t},\r\n\t\r\n\t\t_movePopup: function (e) {\r\n\t\t\tthis._popup.setLatLng(e.latlng);\r\n\t\t}\r\n\t});\r\n\t\n\t\n\t/*\r\n\t * L.LayerGroup is a class to combine several layers into one so that\r\n\t * you can manipulate the group (e.g. add/remove it) as one layer.\r\n\t */\r\n\t\r\n\tL.LayerGroup = L.Class.extend({\r\n\t\tinitialize: function (layers) {\r\n\t\t\tthis._layers = {};\r\n\t\r\n\t\t\tvar i, len;\r\n\t\r\n\t\t\tif (layers) {\r\n\t\t\t\tfor (i = 0, len = layers.length; i < len; i++) {\r\n\t\t\t\t\tthis.addLayer(layers[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\taddLayer: function (layer) {\r\n\t\t\tvar id = this.getLayerId(layer);\r\n\t\r\n\t\t\tthis._layers[id] = layer;\r\n\t\r\n\t\t\tif (this._map) {\r\n\t\t\t\tthis._map.addLayer(layer);\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tremoveLayer: function (layer) {\r\n\t\t\tvar id = layer in this._layers ? layer : this.getLayerId(layer);\r\n\t\r\n\t\t\tif (this._map && this._layers[id]) {\r\n\t\t\t\tthis._map.removeLayer(this._layers[id]);\r\n\t\t\t}\r\n\t\r\n\t\t\tdelete this._layers[id];\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\thasLayer: function (layer) {\r\n\t\t\tif (!layer) { return false; }\r\n\t\r\n\t\t\treturn (layer in this._layers || this.getLayerId(layer) in this._layers);\r\n\t\t},\r\n\t\r\n\t\tclearLayers: function () {\r\n\t\t\tthis.eachLayer(this.removeLayer, this);\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tinvoke: function (methodName) {\r\n\t\t\tvar args = Array.prototype.slice.call(arguments, 1),\r\n\t\t\t    i, layer;\r\n\t\r\n\t\t\tfor (i in this._layers) {\r\n\t\t\t\tlayer = this._layers[i];\r\n\t\r\n\t\t\t\tif (layer[methodName]) {\r\n\t\t\t\t\tlayer[methodName].apply(layer, args);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tonAdd: function (map) {\r\n\t\t\tthis._map = map;\r\n\t\t\tthis.eachLayer(map.addLayer, map);\r\n\t\t},\r\n\t\r\n\t\tonRemove: function (map) {\r\n\t\t\tthis.eachLayer(map.removeLayer, map);\r\n\t\t\tthis._map = null;\r\n\t\t},\r\n\t\r\n\t\taddTo: function (map) {\r\n\t\t\tmap.addLayer(this);\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\teachLayer: function (method, context) {\r\n\t\t\tfor (var i in this._layers) {\r\n\t\t\t\tmethod.call(context, this._layers[i]);\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tgetLayer: function (id) {\r\n\t\t\treturn this._layers[id];\r\n\t\t},\r\n\t\r\n\t\tgetLayers: function () {\r\n\t\t\tvar layers = [];\r\n\t\r\n\t\t\tfor (var i in this._layers) {\r\n\t\t\t\tlayers.push(this._layers[i]);\r\n\t\t\t}\r\n\t\t\treturn layers;\r\n\t\t},\r\n\t\r\n\t\tsetZIndex: function (zIndex) {\r\n\t\t\treturn this.invoke('setZIndex', zIndex);\r\n\t\t},\r\n\t\r\n\t\tgetLayerId: function (layer) {\r\n\t\t\treturn L.stamp(layer);\r\n\t\t}\r\n\t});\r\n\t\r\n\tL.layerGroup = function (layers) {\r\n\t\treturn new L.LayerGroup(layers);\r\n\t};\r\n\t\n\t\n\t/*\r\n\t * L.FeatureGroup extends L.LayerGroup by introducing mouse events and additional methods\r\n\t * shared between a group of interactive layers (like vectors or markers).\r\n\t */\r\n\t\r\n\tL.FeatureGroup = L.LayerGroup.extend({\r\n\t\tincludes: L.Mixin.Events,\r\n\t\r\n\t\tstatics: {\r\n\t\t\tEVENTS: 'click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose'\r\n\t\t},\r\n\t\r\n\t\taddLayer: function (layer) {\r\n\t\t\tif (this.hasLayer(layer)) {\r\n\t\t\t\treturn this;\r\n\t\t\t}\r\n\t\r\n\t\t\tif ('on' in layer) {\r\n\t\t\t\tlayer.on(L.FeatureGroup.EVENTS, this._propagateEvent, this);\r\n\t\t\t}\r\n\t\r\n\t\t\tL.LayerGroup.prototype.addLayer.call(this, layer);\r\n\t\r\n\t\t\tif (this._popupContent && layer.bindPopup) {\r\n\t\t\t\tlayer.bindPopup(this._popupContent, this._popupOptions);\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this.fire('layeradd', {layer: layer});\r\n\t\t},\r\n\t\r\n\t\tremoveLayer: function (layer) {\r\n\t\t\tif (!this.hasLayer(layer)) {\r\n\t\t\t\treturn this;\r\n\t\t\t}\r\n\t\t\tif (layer in this._layers) {\r\n\t\t\t\tlayer = this._layers[layer];\r\n\t\t\t}\r\n\t\r\n\t\t\tif ('off' in layer) {\r\n\t\t\t\tlayer.off(L.FeatureGroup.EVENTS, this._propagateEvent, this);\r\n\t\t\t}\r\n\t\r\n\t\t\tL.LayerGroup.prototype.removeLayer.call(this, layer);\r\n\t\r\n\t\t\tif (this._popupContent) {\r\n\t\t\t\tthis.invoke('unbindPopup');\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this.fire('layerremove', {layer: layer});\r\n\t\t},\r\n\t\r\n\t\tbindPopup: function (content, options) {\r\n\t\t\tthis._popupContent = content;\r\n\t\t\tthis._popupOptions = options;\r\n\t\t\treturn this.invoke('bindPopup', content, options);\r\n\t\t},\r\n\t\r\n\t\topenPopup: function (latlng) {\r\n\t\t\t// open popup on the first layer\r\n\t\t\tfor (var id in this._layers) {\r\n\t\t\t\tthis._layers[id].openPopup(latlng);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tsetStyle: function (style) {\r\n\t\t\treturn this.invoke('setStyle', style);\r\n\t\t},\r\n\t\r\n\t\tbringToFront: function () {\r\n\t\t\treturn this.invoke('bringToFront');\r\n\t\t},\r\n\t\r\n\t\tbringToBack: function () {\r\n\t\t\treturn this.invoke('bringToBack');\r\n\t\t},\r\n\t\r\n\t\tgetBounds: function () {\r\n\t\t\tvar bounds = new L.LatLngBounds();\r\n\t\r\n\t\t\tthis.eachLayer(function (layer) {\r\n\t\t\t\tbounds.extend(layer instanceof L.Marker ? layer.getLatLng() : layer.getBounds());\r\n\t\t\t});\r\n\t\r\n\t\t\treturn bounds;\r\n\t\t},\r\n\t\r\n\t\t_propagateEvent: function (e) {\r\n\t\t\te = L.extend({\r\n\t\t\t\tlayer: e.target,\r\n\t\t\t\ttarget: this\r\n\t\t\t}, e);\r\n\t\t\tthis.fire(e.type, e);\r\n\t\t}\r\n\t});\r\n\t\r\n\tL.featureGroup = function (layers) {\r\n\t\treturn new L.FeatureGroup(layers);\r\n\t};\r\n\t\n\t\n\t/*\r\n\t * L.Path is a base class for rendering vector paths on a map. Inherited by Polyline, Circle, etc.\r\n\t */\r\n\t\r\n\tL.Path = L.Class.extend({\r\n\t\tincludes: [L.Mixin.Events],\r\n\t\r\n\t\tstatics: {\r\n\t\t\t// how much to extend the clip area around the map view\r\n\t\t\t// (relative to its size, e.g. 0.5 is half the screen in each direction)\r\n\t\t\t// set it so that SVG element doesn't exceed 1280px (vectors flicker on dragend if it is)\r\n\t\t\tCLIP_PADDING: (function () {\r\n\t\t\t\tvar max = L.Browser.mobile ? 1280 : 2000,\r\n\t\t\t\t    target = (max / Math.max(window.outerWidth, window.outerHeight) - 1) / 2;\r\n\t\t\t\treturn Math.max(0, Math.min(0.5, target));\r\n\t\t\t})()\r\n\t\t},\r\n\t\r\n\t\toptions: {\r\n\t\t\tstroke: true,\r\n\t\t\tcolor: '#0033ff',\r\n\t\t\tdashArray: null,\r\n\t\t\tlineCap: null,\r\n\t\t\tlineJoin: null,\r\n\t\t\tweight: 5,\r\n\t\t\topacity: 0.5,\r\n\t\r\n\t\t\tfill: false,\r\n\t\t\tfillColor: null, //same as color by default\r\n\t\t\tfillOpacity: 0.2,\r\n\t\r\n\t\t\tclickable: true\r\n\t\t},\r\n\t\r\n\t\tinitialize: function (options) {\r\n\t\t\tL.setOptions(this, options);\r\n\t\t},\r\n\t\r\n\t\tonAdd: function (map) {\r\n\t\t\tthis._map = map;\r\n\t\r\n\t\t\tif (!this._container) {\r\n\t\t\t\tthis._initElements();\r\n\t\t\t\tthis._initEvents();\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.projectLatlngs();\r\n\t\t\tthis._updatePath();\r\n\t\r\n\t\t\tif (this._container) {\r\n\t\t\t\tthis._map._pathRoot.appendChild(this._container);\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.fire('add');\r\n\t\r\n\t\t\tmap.on({\r\n\t\t\t\t'viewreset': this.projectLatlngs,\r\n\t\t\t\t'moveend': this._updatePath\r\n\t\t\t}, this);\r\n\t\t},\r\n\t\r\n\t\taddTo: function (map) {\r\n\t\t\tmap.addLayer(this);\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tonRemove: function (map) {\r\n\t\t\tmap._pathRoot.removeChild(this._container);\r\n\t\r\n\t\t\t// Need to fire remove event before we set _map to null as the event hooks might need the object\r\n\t\t\tthis.fire('remove');\r\n\t\t\tthis._map = null;\r\n\t\r\n\t\t\tif (L.Browser.vml) {\r\n\t\t\t\tthis._container = null;\r\n\t\t\t\tthis._stroke = null;\r\n\t\t\t\tthis._fill = null;\r\n\t\t\t}\r\n\t\r\n\t\t\tmap.off({\r\n\t\t\t\t'viewreset': this.projectLatlngs,\r\n\t\t\t\t'moveend': this._updatePath\r\n\t\t\t}, this);\r\n\t\t},\r\n\t\r\n\t\tprojectLatlngs: function () {\r\n\t\t\t// do all projection stuff here\r\n\t\t},\r\n\t\r\n\t\tsetStyle: function (style) {\r\n\t\t\tL.setOptions(this, style);\r\n\t\r\n\t\t\tif (this._container) {\r\n\t\t\t\tthis._updateStyle();\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tredraw: function () {\r\n\t\t\tif (this._map) {\r\n\t\t\t\tthis.projectLatlngs();\r\n\t\t\t\tthis._updatePath();\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t}\r\n\t});\r\n\t\r\n\tL.Map.include({\r\n\t\t_updatePathViewport: function () {\r\n\t\t\tvar p = L.Path.CLIP_PADDING,\r\n\t\t\t    size = this.getSize(),\r\n\t\t\t    panePos = L.DomUtil.getPosition(this._mapPane),\r\n\t\t\t    min = panePos.multiplyBy(-1)._subtract(size.multiplyBy(p)._round()),\r\n\t\t\t    max = min.add(size.multiplyBy(1 + p * 2)._round());\r\n\t\r\n\t\t\tthis._pathViewport = new L.Bounds(min, max);\r\n\t\t}\r\n\t});\r\n\t\n\t\n\t/*\r\n\t * Extends L.Path with SVG-specific rendering code.\r\n\t */\r\n\t\r\n\tL.Path.SVG_NS = 'http://www.w3.org/2000/svg';\r\n\t\r\n\tL.Browser.svg = !!(document.createElementNS && document.createElementNS(L.Path.SVG_NS, 'svg').createSVGRect);\r\n\t\r\n\tL.Path = L.Path.extend({\r\n\t\tstatics: {\r\n\t\t\tSVG: L.Browser.svg\r\n\t\t},\r\n\t\r\n\t\tbringToFront: function () {\r\n\t\t\tvar root = this._map._pathRoot,\r\n\t\t\t    path = this._container;\r\n\t\r\n\t\t\tif (path && root.lastChild !== path) {\r\n\t\t\t\troot.appendChild(path);\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tbringToBack: function () {\r\n\t\t\tvar root = this._map._pathRoot,\r\n\t\t\t    path = this._container,\r\n\t\t\t    first = root.firstChild;\r\n\t\r\n\t\t\tif (path && first !== path) {\r\n\t\t\t\troot.insertBefore(path, first);\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tgetPathString: function () {\r\n\t\t\t// form path string here\r\n\t\t},\r\n\t\r\n\t\t_createElement: function (name) {\r\n\t\t\treturn document.createElementNS(L.Path.SVG_NS, name);\r\n\t\t},\r\n\t\r\n\t\t_initElements: function () {\r\n\t\t\tthis._map._initPathRoot();\r\n\t\t\tthis._initPath();\r\n\t\t\tthis._initStyle();\r\n\t\t},\r\n\t\r\n\t\t_initPath: function () {\r\n\t\t\tthis._container = this._createElement('g');\r\n\t\r\n\t\t\tthis._path = this._createElement('path');\r\n\t\r\n\t\t\tif (this.options.className) {\r\n\t\t\t\tL.DomUtil.addClass(this._path, this.options.className);\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._container.appendChild(this._path);\r\n\t\t},\r\n\t\r\n\t\t_initStyle: function () {\r\n\t\t\tif (this.options.stroke) {\r\n\t\t\t\tthis._path.setAttribute('stroke-linejoin', 'round');\r\n\t\t\t\tthis._path.setAttribute('stroke-linecap', 'round');\r\n\t\t\t}\r\n\t\t\tif (this.options.fill) {\r\n\t\t\t\tthis._path.setAttribute('fill-rule', 'evenodd');\r\n\t\t\t}\r\n\t\t\tif (this.options.pointerEvents) {\r\n\t\t\t\tthis._path.setAttribute('pointer-events', this.options.pointerEvents);\r\n\t\t\t}\r\n\t\t\tif (!this.options.clickable && !this.options.pointerEvents) {\r\n\t\t\t\tthis._path.setAttribute('pointer-events', 'none');\r\n\t\t\t}\r\n\t\t\tthis._updateStyle();\r\n\t\t},\r\n\t\r\n\t\t_updateStyle: function () {\r\n\t\t\tif (this.options.stroke) {\r\n\t\t\t\tthis._path.setAttribute('stroke', this.options.color);\r\n\t\t\t\tthis._path.setAttribute('stroke-opacity', this.options.opacity);\r\n\t\t\t\tthis._path.setAttribute('stroke-width', this.options.weight);\r\n\t\t\t\tif (this.options.dashArray) {\r\n\t\t\t\t\tthis._path.setAttribute('stroke-dasharray', this.options.dashArray);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis._path.removeAttribute('stroke-dasharray');\r\n\t\t\t\t}\r\n\t\t\t\tif (this.options.lineCap) {\r\n\t\t\t\t\tthis._path.setAttribute('stroke-linecap', this.options.lineCap);\r\n\t\t\t\t}\r\n\t\t\t\tif (this.options.lineJoin) {\r\n\t\t\t\t\tthis._path.setAttribute('stroke-linejoin', this.options.lineJoin);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthis._path.setAttribute('stroke', 'none');\r\n\t\t\t}\r\n\t\t\tif (this.options.fill) {\r\n\t\t\t\tthis._path.setAttribute('fill', this.options.fillColor || this.options.color);\r\n\t\t\t\tthis._path.setAttribute('fill-opacity', this.options.fillOpacity);\r\n\t\t\t} else {\r\n\t\t\t\tthis._path.setAttribute('fill', 'none');\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_updatePath: function () {\r\n\t\t\tvar str = this.getPathString();\r\n\t\t\tif (!str) {\r\n\t\t\t\t// fix webkit empty string parsing bug\r\n\t\t\t\tstr = 'M0 0';\r\n\t\t\t}\r\n\t\t\tthis._path.setAttribute('d', str);\r\n\t\t},\r\n\t\r\n\t\t// TODO remove duplication with L.Map\r\n\t\t_initEvents: function () {\r\n\t\t\tif (this.options.clickable) {\r\n\t\t\t\tif (L.Browser.svg || !L.Browser.vml) {\r\n\t\t\t\t\tL.DomUtil.addClass(this._path, 'leaflet-clickable');\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tL.DomEvent.on(this._container, 'click', this._onMouseClick, this);\r\n\t\r\n\t\t\t\tvar events = ['dblclick', 'mousedown', 'mouseover',\r\n\t\t\t\t              'mouseout', 'mousemove', 'contextmenu'];\r\n\t\t\t\tfor (var i = 0; i < events.length; i++) {\r\n\t\t\t\t\tL.DomEvent.on(this._container, events[i], this._fireMouseEvent, this);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_onMouseClick: function (e) {\r\n\t\t\tif (this._map.dragging && this._map.dragging.moved()) { return; }\r\n\t\r\n\t\t\tthis._fireMouseEvent(e);\r\n\t\t},\r\n\t\r\n\t\t_fireMouseEvent: function (e) {\r\n\t\t\tif (!this._map || !this.hasEventListeners(e.type)) { return; }\r\n\t\r\n\t\t\tvar map = this._map,\r\n\t\t\t    containerPoint = map.mouseEventToContainerPoint(e),\r\n\t\t\t    layerPoint = map.containerPointToLayerPoint(containerPoint),\r\n\t\t\t    latlng = map.layerPointToLatLng(layerPoint);\r\n\t\r\n\t\t\tthis.fire(e.type, {\r\n\t\t\t\tlatlng: latlng,\r\n\t\t\t\tlayerPoint: layerPoint,\r\n\t\t\t\tcontainerPoint: containerPoint,\r\n\t\t\t\toriginalEvent: e\r\n\t\t\t});\r\n\t\r\n\t\t\tif (e.type === 'contextmenu') {\r\n\t\t\t\tL.DomEvent.preventDefault(e);\r\n\t\t\t}\r\n\t\t\tif (e.type !== 'mousemove') {\r\n\t\t\t\tL.DomEvent.stopPropagation(e);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\t\r\n\tL.Map.include({\r\n\t\t_initPathRoot: function () {\r\n\t\t\tif (!this._pathRoot) {\r\n\t\t\t\tthis._pathRoot = L.Path.prototype._createElement('svg');\r\n\t\t\t\tthis._panes.overlayPane.appendChild(this._pathRoot);\r\n\t\r\n\t\t\t\tif (this.options.zoomAnimation && L.Browser.any3d) {\r\n\t\t\t\t\tL.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-animated');\r\n\t\r\n\t\t\t\t\tthis.on({\r\n\t\t\t\t\t\t'zoomanim': this._animatePathZoom,\r\n\t\t\t\t\t\t'zoomend': this._endPathZoom\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\tL.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-hide');\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.on('moveend', this._updateSvgViewport);\r\n\t\t\t\tthis._updateSvgViewport();\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_animatePathZoom: function (e) {\r\n\t\t\tvar scale = this.getZoomScale(e.zoom),\r\n\t\t\t    offset = this._getCenterOffset(e.center)._multiplyBy(-scale)._add(this._pathViewport.min);\r\n\t\r\n\t\t\tthis._pathRoot.style[L.DomUtil.TRANSFORM] =\r\n\t\t\t        L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ') ';\r\n\t\r\n\t\t\tthis._pathZooming = true;\r\n\t\t},\r\n\t\r\n\t\t_endPathZoom: function () {\r\n\t\t\tthis._pathZooming = false;\r\n\t\t},\r\n\t\r\n\t\t_updateSvgViewport: function () {\r\n\t\r\n\t\t\tif (this._pathZooming) {\r\n\t\t\t\t// Do not update SVGs while a zoom animation is going on otherwise the animation will break.\r\n\t\t\t\t// When the zoom animation ends we will be updated again anyway\r\n\t\t\t\t// This fixes the case where you do a momentum move and zoom while the move is still ongoing.\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._updatePathViewport();\r\n\t\r\n\t\t\tvar vp = this._pathViewport,\r\n\t\t\t    min = vp.min,\r\n\t\t\t    max = vp.max,\r\n\t\t\t    width = max.x - min.x,\r\n\t\t\t    height = max.y - min.y,\r\n\t\t\t    root = this._pathRoot,\r\n\t\t\t    pane = this._panes.overlayPane;\r\n\t\r\n\t\t\t// Hack to make flicker on drag end on mobile webkit less irritating\r\n\t\t\tif (L.Browser.mobileWebkit) {\r\n\t\t\t\tpane.removeChild(root);\r\n\t\t\t}\r\n\t\r\n\t\t\tL.DomUtil.setPosition(root, min);\r\n\t\t\troot.setAttribute('width', width);\r\n\t\t\troot.setAttribute('height', height);\r\n\t\t\troot.setAttribute('viewBox', [min.x, min.y, width, height].join(' '));\r\n\t\r\n\t\t\tif (L.Browser.mobileWebkit) {\r\n\t\t\t\tpane.appendChild(root);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\t\n\t\n\t/*\r\n\t * Popup extension to L.Path (polylines, polygons, circles), adding popup-related methods.\r\n\t */\r\n\t\r\n\tL.Path.include({\r\n\t\r\n\t\tbindPopup: function (content, options) {\r\n\t\r\n\t\t\tif (content instanceof L.Popup) {\r\n\t\t\t\tthis._popup = content;\r\n\t\t\t} else {\r\n\t\t\t\tif (!this._popup || options) {\r\n\t\t\t\t\tthis._popup = new L.Popup(options, this);\r\n\t\t\t\t}\r\n\t\t\t\tthis._popup.setContent(content);\r\n\t\t\t}\r\n\t\r\n\t\t\tif (!this._popupHandlersAdded) {\r\n\t\t\t\tthis\r\n\t\t\t\t    .on('click', this._openPopup, this)\r\n\t\t\t\t    .on('remove', this.closePopup, this);\r\n\t\r\n\t\t\t\tthis._popupHandlersAdded = true;\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tunbindPopup: function () {\r\n\t\t\tif (this._popup) {\r\n\t\t\t\tthis._popup = null;\r\n\t\t\t\tthis\r\n\t\t\t\t    .off('click', this._openPopup)\r\n\t\t\t\t    .off('remove', this.closePopup);\r\n\t\r\n\t\t\t\tthis._popupHandlersAdded = false;\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\topenPopup: function (latlng) {\r\n\t\r\n\t\t\tif (this._popup) {\r\n\t\t\t\t// open the popup from one of the path's points if not specified\r\n\t\t\t\tlatlng = latlng || this._latlng ||\r\n\t\t\t\t         this._latlngs[Math.floor(this._latlngs.length / 2)];\r\n\t\r\n\t\t\t\tthis._openPopup({latlng: latlng});\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tclosePopup: function () {\r\n\t\t\tif (this._popup) {\r\n\t\t\t\tthis._popup._close();\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\t_openPopup: function (e) {\r\n\t\t\tthis._popup.setLatLng(e.latlng);\r\n\t\t\tthis._map.openPopup(this._popup);\r\n\t\t}\r\n\t});\r\n\t\n\t\n\t/*\r\n\t * Vector rendering for IE6-8 through VML.\r\n\t * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!\r\n\t */\r\n\t\r\n\tL.Browser.vml = !L.Browser.svg && (function () {\r\n\t\ttry {\r\n\t\t\tvar div = document.createElement('div');\r\n\t\t\tdiv.innerHTML = '<v:shape adj=\"1\"/>';\r\n\t\r\n\t\t\tvar shape = div.firstChild;\r\n\t\t\tshape.style.behavior = 'url(#default#VML)';\r\n\t\r\n\t\t\treturn shape && (typeof shape.adj === 'object');\r\n\t\r\n\t\t} catch (e) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}());\r\n\t\r\n\tL.Path = L.Browser.svg || !L.Browser.vml ? L.Path : L.Path.extend({\r\n\t\tstatics: {\r\n\t\t\tVML: true,\r\n\t\t\tCLIP_PADDING: 0.02\r\n\t\t},\r\n\t\r\n\t\t_createElement: (function () {\r\n\t\t\ttry {\r\n\t\t\t\tdocument.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');\r\n\t\t\t\treturn function (name) {\r\n\t\t\t\t\treturn document.createElement('<lvml:' + name + ' class=\"lvml\">');\r\n\t\t\t\t};\r\n\t\t\t} catch (e) {\r\n\t\t\t\treturn function (name) {\r\n\t\t\t\t\treturn document.createElement(\r\n\t\t\t\t\t        '<' + name + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"lvml\">');\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}()),\r\n\t\r\n\t\t_initPath: function () {\r\n\t\t\tvar container = this._container = this._createElement('shape');\r\n\t\r\n\t\t\tL.DomUtil.addClass(container, 'leaflet-vml-shape' +\r\n\t\t\t\t(this.options.className ? ' ' + this.options.className : ''));\r\n\t\r\n\t\t\tif (this.options.clickable) {\r\n\t\t\t\tL.DomUtil.addClass(container, 'leaflet-clickable');\r\n\t\t\t}\r\n\t\r\n\t\t\tcontainer.coordsize = '1 1';\r\n\t\r\n\t\t\tthis._path = this._createElement('path');\r\n\t\t\tcontainer.appendChild(this._path);\r\n\t\r\n\t\t\tthis._map._pathRoot.appendChild(container);\r\n\t\t},\r\n\t\r\n\t\t_initStyle: function () {\r\n\t\t\tthis._updateStyle();\r\n\t\t},\r\n\t\r\n\t\t_updateStyle: function () {\r\n\t\t\tvar stroke = this._stroke,\r\n\t\t\t    fill = this._fill,\r\n\t\t\t    options = this.options,\r\n\t\t\t    container = this._container;\r\n\t\r\n\t\t\tcontainer.stroked = options.stroke;\r\n\t\t\tcontainer.filled = options.fill;\r\n\t\r\n\t\t\tif (options.stroke) {\r\n\t\t\t\tif (!stroke) {\r\n\t\t\t\t\tstroke = this._stroke = this._createElement('stroke');\r\n\t\t\t\t\tstroke.endcap = 'round';\r\n\t\t\t\t\tcontainer.appendChild(stroke);\r\n\t\t\t\t}\r\n\t\t\t\tstroke.weight = options.weight + 'px';\r\n\t\t\t\tstroke.color = options.color;\r\n\t\t\t\tstroke.opacity = options.opacity;\r\n\t\r\n\t\t\t\tif (options.dashArray) {\r\n\t\t\t\t\tstroke.dashStyle = L.Util.isArray(options.dashArray) ?\r\n\t\t\t\t\t    options.dashArray.join(' ') :\r\n\t\t\t\t\t    options.dashArray.replace(/( *, *)/g, ' ');\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstroke.dashStyle = '';\r\n\t\t\t\t}\r\n\t\t\t\tif (options.lineCap) {\r\n\t\t\t\t\tstroke.endcap = options.lineCap.replace('butt', 'flat');\r\n\t\t\t\t}\r\n\t\t\t\tif (options.lineJoin) {\r\n\t\t\t\t\tstroke.joinstyle = options.lineJoin;\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if (stroke) {\r\n\t\t\t\tcontainer.removeChild(stroke);\r\n\t\t\t\tthis._stroke = null;\r\n\t\t\t}\r\n\t\r\n\t\t\tif (options.fill) {\r\n\t\t\t\tif (!fill) {\r\n\t\t\t\t\tfill = this._fill = this._createElement('fill');\r\n\t\t\t\t\tcontainer.appendChild(fill);\r\n\t\t\t\t}\r\n\t\t\t\tfill.color = options.fillColor || options.color;\r\n\t\t\t\tfill.opacity = options.fillOpacity;\r\n\t\r\n\t\t\t} else if (fill) {\r\n\t\t\t\tcontainer.removeChild(fill);\r\n\t\t\t\tthis._fill = null;\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_updatePath: function () {\r\n\t\t\tvar style = this._container.style;\r\n\t\r\n\t\t\tstyle.display = 'none';\r\n\t\t\tthis._path.v = this.getPathString() + ' '; // the space fixes IE empty path string bug\r\n\t\t\tstyle.display = '';\r\n\t\t}\r\n\t});\r\n\t\r\n\tL.Map.include(L.Browser.svg || !L.Browser.vml ? {} : {\r\n\t\t_initPathRoot: function () {\r\n\t\t\tif (this._pathRoot) { return; }\r\n\t\r\n\t\t\tvar root = this._pathRoot = document.createElement('div');\r\n\t\t\troot.className = 'leaflet-vml-container';\r\n\t\t\tthis._panes.overlayPane.appendChild(root);\r\n\t\r\n\t\t\tthis.on('moveend', this._updatePathViewport);\r\n\t\t\tthis._updatePathViewport();\r\n\t\t}\r\n\t});\r\n\t\n\t\n\t/*\r\n\t * Vector rendering for all browsers that support canvas.\r\n\t */\r\n\t\r\n\tL.Browser.canvas = (function () {\r\n\t\treturn !!document.createElement('canvas').getContext;\r\n\t}());\r\n\t\r\n\tL.Path = (L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? L.Path : L.Path.extend({\r\n\t\tstatics: {\r\n\t\t\t//CLIP_PADDING: 0.02, // not sure if there's a need to set it to a small value\r\n\t\t\tCANVAS: true,\r\n\t\t\tSVG: false\r\n\t\t},\r\n\t\r\n\t\tredraw: function () {\r\n\t\t\tif (this._map) {\r\n\t\t\t\tthis.projectLatlngs();\r\n\t\t\t\tthis._requestUpdate();\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tsetStyle: function (style) {\r\n\t\t\tL.setOptions(this, style);\r\n\t\r\n\t\t\tif (this._map) {\r\n\t\t\t\tthis._updateStyle();\r\n\t\t\t\tthis._requestUpdate();\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tonRemove: function (map) {\r\n\t\t\tmap\r\n\t\t\t    .off('viewreset', this.projectLatlngs, this)\r\n\t\t\t    .off('moveend', this._updatePath, this);\r\n\t\r\n\t\t\tif (this.options.clickable) {\r\n\t\t\t\tthis._map.off('click', this._onClick, this);\r\n\t\t\t\tthis._map.off('mousemove', this._onMouseMove, this);\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._requestUpdate();\r\n\t\t\t\r\n\t\t\tthis.fire('remove');\r\n\t\t\tthis._map = null;\r\n\t\t},\r\n\t\r\n\t\t_requestUpdate: function () {\r\n\t\t\tif (this._map && !L.Path._updateRequest) {\r\n\t\t\t\tL.Path._updateRequest = L.Util.requestAnimFrame(this._fireMapMoveEnd, this._map);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_fireMapMoveEnd: function () {\r\n\t\t\tL.Path._updateRequest = null;\r\n\t\t\tthis.fire('moveend');\r\n\t\t},\r\n\t\r\n\t\t_initElements: function () {\r\n\t\t\tthis._map._initPathRoot();\r\n\t\t\tthis._ctx = this._map._canvasCtx;\r\n\t\t},\r\n\t\r\n\t\t_updateStyle: function () {\r\n\t\t\tvar options = this.options;\r\n\t\r\n\t\t\tif (options.stroke) {\r\n\t\t\t\tthis._ctx.lineWidth = options.weight;\r\n\t\t\t\tthis._ctx.strokeStyle = options.color;\r\n\t\t\t}\r\n\t\t\tif (options.fill) {\r\n\t\t\t\tthis._ctx.fillStyle = options.fillColor || options.color;\r\n\t\t\t}\r\n\t\r\n\t\t\tif (options.lineCap) {\r\n\t\t\t\tthis._ctx.lineCap = options.lineCap;\r\n\t\t\t}\r\n\t\t\tif (options.lineJoin) {\r\n\t\t\t\tthis._ctx.lineJoin = options.lineJoin;\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_drawPath: function () {\r\n\t\t\tvar i, j, len, len2, point, drawMethod;\r\n\t\r\n\t\t\tthis._ctx.beginPath();\r\n\t\r\n\t\t\tfor (i = 0, len = this._parts.length; i < len; i++) {\r\n\t\t\t\tfor (j = 0, len2 = this._parts[i].length; j < len2; j++) {\r\n\t\t\t\t\tpoint = this._parts[i][j];\r\n\t\t\t\t\tdrawMethod = (j === 0 ? 'move' : 'line') + 'To';\r\n\t\r\n\t\t\t\t\tthis._ctx[drawMethod](point.x, point.y);\r\n\t\t\t\t}\r\n\t\t\t\t// TODO refactor ugly hack\r\n\t\t\t\tif (this instanceof L.Polygon) {\r\n\t\t\t\t\tthis._ctx.closePath();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_checkIfEmpty: function () {\r\n\t\t\treturn !this._parts.length;\r\n\t\t},\r\n\t\r\n\t\t_updatePath: function () {\r\n\t\t\tif (this._checkIfEmpty()) { return; }\r\n\t\r\n\t\t\tvar ctx = this._ctx,\r\n\t\t\t    options = this.options;\r\n\t\r\n\t\t\tthis._drawPath();\r\n\t\t\tctx.save();\r\n\t\t\tthis._updateStyle();\r\n\t\r\n\t\t\tif (options.fill) {\r\n\t\t\t\tctx.globalAlpha = options.fillOpacity;\r\n\t\t\t\tctx.fill(options.fillRule || 'evenodd');\r\n\t\t\t}\r\n\t\r\n\t\t\tif (options.stroke) {\r\n\t\t\t\tctx.globalAlpha = options.opacity;\r\n\t\t\t\tctx.stroke();\r\n\t\t\t}\r\n\t\r\n\t\t\tctx.restore();\r\n\t\r\n\t\t\t// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature\r\n\t\t},\r\n\t\r\n\t\t_initEvents: function () {\r\n\t\t\tif (this.options.clickable) {\r\n\t\t\t\tthis._map.on('mousemove', this._onMouseMove, this);\r\n\t\t\t\tthis._map.on('click dblclick contextmenu', this._fireMouseEvent, this);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_fireMouseEvent: function (e) {\r\n\t\t\tif (this._containsPoint(e.layerPoint)) {\r\n\t\t\t\tthis.fire(e.type, e);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_onMouseMove: function (e) {\r\n\t\t\tif (!this._map || this._map._animatingZoom) { return; }\r\n\t\r\n\t\t\t// TODO don't do on each move\r\n\t\t\tif (this._containsPoint(e.layerPoint)) {\r\n\t\t\t\tthis._ctx.canvas.style.cursor = 'pointer';\r\n\t\t\t\tthis._mouseInside = true;\r\n\t\t\t\tthis.fire('mouseover', e);\r\n\t\r\n\t\t\t} else if (this._mouseInside) {\r\n\t\t\t\tthis._ctx.canvas.style.cursor = '';\r\n\t\t\t\tthis._mouseInside = false;\r\n\t\t\t\tthis.fire('mouseout', e);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\t\r\n\tL.Map.include((L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? {} : {\r\n\t\t_initPathRoot: function () {\r\n\t\t\tvar root = this._pathRoot,\r\n\t\t\t    ctx;\r\n\t\r\n\t\t\tif (!root) {\r\n\t\t\t\troot = this._pathRoot = document.createElement('canvas');\r\n\t\t\t\troot.style.position = 'absolute';\r\n\t\t\t\tctx = this._canvasCtx = root.getContext('2d');\r\n\t\r\n\t\t\t\tctx.lineCap = 'round';\r\n\t\t\t\tctx.lineJoin = 'round';\r\n\t\r\n\t\t\t\tthis._panes.overlayPane.appendChild(root);\r\n\t\r\n\t\t\t\tif (this.options.zoomAnimation) {\r\n\t\t\t\t\tthis._pathRoot.className = 'leaflet-zoom-animated';\r\n\t\t\t\t\tthis.on('zoomanim', this._animatePathZoom);\r\n\t\t\t\t\tthis.on('zoomend', this._endPathZoom);\r\n\t\t\t\t}\r\n\t\t\t\tthis.on('moveend', this._updateCanvasViewport);\r\n\t\t\t\tthis._updateCanvasViewport();\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_updateCanvasViewport: function () {\r\n\t\t\t// don't redraw while zooming. See _updateSvgViewport for more details\r\n\t\t\tif (this._pathZooming) { return; }\r\n\t\t\tthis._updatePathViewport();\r\n\t\r\n\t\t\tvar vp = this._pathViewport,\r\n\t\t\t    min = vp.min,\r\n\t\t\t    size = vp.max.subtract(min),\r\n\t\t\t    root = this._pathRoot;\r\n\t\r\n\t\t\t//TODO check if this works properly on mobile webkit\r\n\t\t\tL.DomUtil.setPosition(root, min);\r\n\t\t\troot.width = size.x;\r\n\t\t\troot.height = size.y;\r\n\t\t\troot.getContext('2d').translate(-min.x, -min.y);\r\n\t\t}\r\n\t});\r\n\t\n\t\n\t/*\r\n\t * L.LineUtil contains different utility functions for line segments\r\n\t * and polylines (clipping, simplification, distances, etc.)\r\n\t */\r\n\t\r\n\t/*jshint bitwise:false */ // allow bitwise operations for this file\r\n\t\r\n\tL.LineUtil = {\r\n\t\r\n\t\t// Simplify polyline with vertex reduction and Douglas-Peucker simplification.\r\n\t\t// Improves rendering performance dramatically by lessening the number of points to draw.\r\n\t\r\n\t\tsimplify: function (/*Point[]*/ points, /*Number*/ tolerance) {\r\n\t\t\tif (!tolerance || !points.length) {\r\n\t\t\t\treturn points.slice();\r\n\t\t\t}\r\n\t\r\n\t\t\tvar sqTolerance = tolerance * tolerance;\r\n\t\r\n\t\t\t// stage 1: vertex reduction\r\n\t\t\tpoints = this._reducePoints(points, sqTolerance);\r\n\t\r\n\t\t\t// stage 2: Douglas-Peucker simplification\r\n\t\t\tpoints = this._simplifyDP(points, sqTolerance);\r\n\t\r\n\t\t\treturn points;\r\n\t\t},\r\n\t\r\n\t\t// distance from a point to a segment between two points\r\n\t\tpointToSegmentDistance:  function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {\r\n\t\t\treturn Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));\r\n\t\t},\r\n\t\r\n\t\tclosestPointOnSegment: function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {\r\n\t\t\treturn this._sqClosestPointOnSegment(p, p1, p2);\r\n\t\t},\r\n\t\r\n\t\t// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm\r\n\t\t_simplifyDP: function (points, sqTolerance) {\r\n\t\r\n\t\t\tvar len = points.length,\r\n\t\t\t    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,\r\n\t\t\t    markers = new ArrayConstructor(len);\r\n\t\r\n\t\t\tmarkers[0] = markers[len - 1] = 1;\r\n\t\r\n\t\t\tthis._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);\r\n\t\r\n\t\t\tvar i,\r\n\t\t\t    newPoints = [];\r\n\t\r\n\t\t\tfor (i = 0; i < len; i++) {\r\n\t\t\t\tif (markers[i]) {\r\n\t\t\t\t\tnewPoints.push(points[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\treturn newPoints;\r\n\t\t},\r\n\t\r\n\t\t_simplifyDPStep: function (points, markers, sqTolerance, first, last) {\r\n\t\r\n\t\t\tvar maxSqDist = 0,\r\n\t\t\t    index, i, sqDist;\r\n\t\r\n\t\t\tfor (i = first + 1; i <= last - 1; i++) {\r\n\t\t\t\tsqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);\r\n\t\r\n\t\t\t\tif (sqDist > maxSqDist) {\r\n\t\t\t\t\tindex = i;\r\n\t\t\t\t\tmaxSqDist = sqDist;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\tif (maxSqDist > sqTolerance) {\r\n\t\t\t\tmarkers[index] = 1;\r\n\t\r\n\t\t\t\tthis._simplifyDPStep(points, markers, sqTolerance, first, index);\r\n\t\t\t\tthis._simplifyDPStep(points, markers, sqTolerance, index, last);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t// reduce points that are too close to each other to a single point\r\n\t\t_reducePoints: function (points, sqTolerance) {\r\n\t\t\tvar reducedPoints = [points[0]];\r\n\t\r\n\t\t\tfor (var i = 1, prev = 0, len = points.length; i < len; i++) {\r\n\t\t\t\tif (this._sqDist(points[i], points[prev]) > sqTolerance) {\r\n\t\t\t\t\treducedPoints.push(points[i]);\r\n\t\t\t\t\tprev = i;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (prev < len - 1) {\r\n\t\t\t\treducedPoints.push(points[len - 1]);\r\n\t\t\t}\r\n\t\t\treturn reducedPoints;\r\n\t\t},\r\n\t\r\n\t\t// Cohen-Sutherland line clipping algorithm.\r\n\t\t// Used to avoid rendering parts of a polyline that are not currently visible.\r\n\t\r\n\t\tclipSegment: function (a, b, bounds, useLastCode) {\r\n\t\t\tvar codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds),\r\n\t\t\t    codeB = this._getBitCode(b, bounds),\r\n\t\r\n\t\t\t    codeOut, p, newCode;\r\n\t\r\n\t\t\t// save 2nd code to avoid calculating it on the next segment\r\n\t\t\tthis._lastCode = codeB;\r\n\t\r\n\t\t\twhile (true) {\r\n\t\t\t\t// if a,b is inside the clip window (trivial accept)\r\n\t\t\t\tif (!(codeA | codeB)) {\r\n\t\t\t\t\treturn [a, b];\r\n\t\t\t\t// if a,b is outside the clip window (trivial reject)\r\n\t\t\t\t} else if (codeA & codeB) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t// other cases\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcodeOut = codeA || codeB;\r\n\t\t\t\t\tp = this._getEdgeIntersection(a, b, codeOut, bounds);\r\n\t\t\t\t\tnewCode = this._getBitCode(p, bounds);\r\n\t\r\n\t\t\t\t\tif (codeOut === codeA) {\r\n\t\t\t\t\t\ta = p;\r\n\t\t\t\t\t\tcodeA = newCode;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tb = p;\r\n\t\t\t\t\t\tcodeB = newCode;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_getEdgeIntersection: function (a, b, code, bounds) {\r\n\t\t\tvar dx = b.x - a.x,\r\n\t\t\t    dy = b.y - a.y,\r\n\t\t\t    min = bounds.min,\r\n\t\t\t    max = bounds.max;\r\n\t\r\n\t\t\tif (code & 8) { // top\r\n\t\t\t\treturn new L.Point(a.x + dx * (max.y - a.y) / dy, max.y);\r\n\t\t\t} else if (code & 4) { // bottom\r\n\t\t\t\treturn new L.Point(a.x + dx * (min.y - a.y) / dy, min.y);\r\n\t\t\t} else if (code & 2) { // right\r\n\t\t\t\treturn new L.Point(max.x, a.y + dy * (max.x - a.x) / dx);\r\n\t\t\t} else if (code & 1) { // left\r\n\t\t\t\treturn new L.Point(min.x, a.y + dy * (min.x - a.x) / dx);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_getBitCode: function (/*Point*/ p, bounds) {\r\n\t\t\tvar code = 0;\r\n\t\r\n\t\t\tif (p.x < bounds.min.x) { // left\r\n\t\t\t\tcode |= 1;\r\n\t\t\t} else if (p.x > bounds.max.x) { // right\r\n\t\t\t\tcode |= 2;\r\n\t\t\t}\r\n\t\t\tif (p.y < bounds.min.y) { // bottom\r\n\t\t\t\tcode |= 4;\r\n\t\t\t} else if (p.y > bounds.max.y) { // top\r\n\t\t\t\tcode |= 8;\r\n\t\t\t}\r\n\t\r\n\t\t\treturn code;\r\n\t\t},\r\n\t\r\n\t\t// square distance (to avoid unnecessary Math.sqrt calls)\r\n\t\t_sqDist: function (p1, p2) {\r\n\t\t\tvar dx = p2.x - p1.x,\r\n\t\t\t    dy = p2.y - p1.y;\r\n\t\t\treturn dx * dx + dy * dy;\r\n\t\t},\r\n\t\r\n\t\t// return closest point on segment or distance to that point\r\n\t\t_sqClosestPointOnSegment: function (p, p1, p2, sqDist) {\r\n\t\t\tvar x = p1.x,\r\n\t\t\t    y = p1.y,\r\n\t\t\t    dx = p2.x - x,\r\n\t\t\t    dy = p2.y - y,\r\n\t\t\t    dot = dx * dx + dy * dy,\r\n\t\t\t    t;\r\n\t\r\n\t\t\tif (dot > 0) {\r\n\t\t\t\tt = ((p.x - x) * dx + (p.y - y) * dy) / dot;\r\n\t\r\n\t\t\t\tif (t > 1) {\r\n\t\t\t\t\tx = p2.x;\r\n\t\t\t\t\ty = p2.y;\r\n\t\t\t\t} else if (t > 0) {\r\n\t\t\t\t\tx += dx * t;\r\n\t\t\t\t\ty += dy * t;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\tdx = p.x - x;\r\n\t\t\tdy = p.y - y;\r\n\t\r\n\t\t\treturn sqDist ? dx * dx + dy * dy : new L.Point(x, y);\r\n\t\t}\r\n\t};\r\n\t\n\t\n\t/*\r\n\t * L.Polyline is used to display polylines on a map.\r\n\t */\r\n\t\r\n\tL.Polyline = L.Path.extend({\r\n\t\tinitialize: function (latlngs, options) {\r\n\t\t\tL.Path.prototype.initialize.call(this, options);\r\n\t\r\n\t\t\tthis._latlngs = this._convertLatLngs(latlngs);\r\n\t\t},\r\n\t\r\n\t\toptions: {\r\n\t\t\t// how much to simplify the polyline on each zoom level\r\n\t\t\t// more = better performance and smoother look, less = more accurate\r\n\t\t\tsmoothFactor: 1.0,\r\n\t\t\tnoClip: false\r\n\t\t},\r\n\t\r\n\t\tprojectLatlngs: function () {\r\n\t\t\tthis._originalPoints = [];\r\n\t\r\n\t\t\tfor (var i = 0, len = this._latlngs.length; i < len; i++) {\r\n\t\t\t\tthis._originalPoints[i] = this._map.latLngToLayerPoint(this._latlngs[i]);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\tgetPathString: function () {\r\n\t\t\tfor (var i = 0, len = this._parts.length, str = ''; i < len; i++) {\r\n\t\t\t\tstr += this._getPathPartStr(this._parts[i]);\r\n\t\t\t}\r\n\t\t\treturn str;\r\n\t\t},\r\n\t\r\n\t\tgetLatLngs: function () {\r\n\t\t\treturn this._latlngs;\r\n\t\t},\r\n\t\r\n\t\tsetLatLngs: function (latlngs) {\r\n\t\t\tthis._latlngs = this._convertLatLngs(latlngs);\r\n\t\t\treturn this.redraw();\r\n\t\t},\r\n\t\r\n\t\taddLatLng: function (latlng) {\r\n\t\t\tthis._latlngs.push(L.latLng(latlng));\r\n\t\t\treturn this.redraw();\r\n\t\t},\r\n\t\r\n\t\tspliceLatLngs: function () { // (Number index, Number howMany)\r\n\t\t\tvar removed = [].splice.apply(this._latlngs, arguments);\r\n\t\t\tthis._convertLatLngs(this._latlngs, true);\r\n\t\t\tthis.redraw();\r\n\t\t\treturn removed;\r\n\t\t},\r\n\t\r\n\t\tclosestLayerPoint: function (p) {\r\n\t\t\tvar minDistance = Infinity, parts = this._parts, p1, p2, minPoint = null;\r\n\t\r\n\t\t\tfor (var j = 0, jLen = parts.length; j < jLen; j++) {\r\n\t\t\t\tvar points = parts[j];\r\n\t\t\t\tfor (var i = 1, len = points.length; i < len; i++) {\r\n\t\t\t\t\tp1 = points[i - 1];\r\n\t\t\t\t\tp2 = points[i];\r\n\t\t\t\t\tvar sqDist = L.LineUtil._sqClosestPointOnSegment(p, p1, p2, true);\r\n\t\t\t\t\tif (sqDist < minDistance) {\r\n\t\t\t\t\t\tminDistance = sqDist;\r\n\t\t\t\t\t\tminPoint = L.LineUtil._sqClosestPointOnSegment(p, p1, p2);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (minPoint) {\r\n\t\t\t\tminPoint.distance = Math.sqrt(minDistance);\r\n\t\t\t}\r\n\t\t\treturn minPoint;\r\n\t\t},\r\n\t\r\n\t\tgetBounds: function () {\r\n\t\t\treturn new L.LatLngBounds(this.getLatLngs());\r\n\t\t},\r\n\t\r\n\t\t_convertLatLngs: function (latlngs, overwrite) {\r\n\t\t\tvar i, len, target = overwrite ? latlngs : [];\r\n\t\r\n\t\t\tfor (i = 0, len = latlngs.length; i < len; i++) {\r\n\t\t\t\tif (L.Util.isArray(latlngs[i]) && typeof latlngs[i][0] !== 'number') {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\ttarget[i] = L.latLng(latlngs[i]);\r\n\t\t\t}\r\n\t\t\treturn target;\r\n\t\t},\r\n\t\r\n\t\t_initEvents: function () {\r\n\t\t\tL.Path.prototype._initEvents.call(this);\r\n\t\t},\r\n\t\r\n\t\t_getPathPartStr: function (points) {\r\n\t\t\tvar round = L.Path.VML;\r\n\t\r\n\t\t\tfor (var j = 0, len2 = points.length, str = '', p; j < len2; j++) {\r\n\t\t\t\tp = points[j];\r\n\t\t\t\tif (round) {\r\n\t\t\t\t\tp._round();\r\n\t\t\t\t}\r\n\t\t\t\tstr += (j ? 'L' : 'M') + p.x + ' ' + p.y;\r\n\t\t\t}\r\n\t\t\treturn str;\r\n\t\t},\r\n\t\r\n\t\t_clipPoints: function () {\r\n\t\t\tvar points = this._originalPoints,\r\n\t\t\t    len = points.length,\r\n\t\t\t    i, k, segment;\r\n\t\r\n\t\t\tif (this.options.noClip) {\r\n\t\t\t\tthis._parts = [points];\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._parts = [];\r\n\t\r\n\t\t\tvar parts = this._parts,\r\n\t\t\t    vp = this._map._pathViewport,\r\n\t\t\t    lu = L.LineUtil;\r\n\t\r\n\t\t\tfor (i = 0, k = 0; i < len - 1; i++) {\r\n\t\t\t\tsegment = lu.clipSegment(points[i], points[i + 1], vp, i);\r\n\t\t\t\tif (!segment) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tparts[k] = parts[k] || [];\r\n\t\t\t\tparts[k].push(segment[0]);\r\n\t\r\n\t\t\t\t// if segment goes out of screen, or it's the last one, it's the end of the line part\r\n\t\t\t\tif ((segment[1] !== points[i + 1]) || (i === len - 2)) {\r\n\t\t\t\t\tparts[k].push(segment[1]);\r\n\t\t\t\t\tk++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t// simplify each clipped part of the polyline\r\n\t\t_simplifyPoints: function () {\r\n\t\t\tvar parts = this._parts,\r\n\t\t\t    lu = L.LineUtil;\r\n\t\r\n\t\t\tfor (var i = 0, len = parts.length; i < len; i++) {\r\n\t\t\t\tparts[i] = lu.simplify(parts[i], this.options.smoothFactor);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_updatePath: function () {\r\n\t\t\tif (!this._map) { return; }\r\n\t\r\n\t\t\tthis._clipPoints();\r\n\t\t\tthis._simplifyPoints();\r\n\t\r\n\t\t\tL.Path.prototype._updatePath.call(this);\r\n\t\t}\r\n\t});\r\n\t\r\n\tL.polyline = function (latlngs, options) {\r\n\t\treturn new L.Polyline(latlngs, options);\r\n\t};\r\n\t\n\t\n\t/*\r\n\t * L.PolyUtil contains utility functions for polygons (clipping, etc.).\r\n\t */\r\n\t\r\n\t/*jshint bitwise:false */ // allow bitwise operations here\r\n\t\r\n\tL.PolyUtil = {};\r\n\t\r\n\t/*\r\n\t * Sutherland-Hodgeman polygon clipping algorithm.\r\n\t * Used to avoid rendering parts of a polygon that are not currently visible.\r\n\t */\r\n\tL.PolyUtil.clipPolygon = function (points, bounds) {\r\n\t\tvar clippedPoints,\r\n\t\t    edges = [1, 4, 2, 8],\r\n\t\t    i, j, k,\r\n\t\t    a, b,\r\n\t\t    len, edge, p,\r\n\t\t    lu = L.LineUtil;\r\n\t\r\n\t\tfor (i = 0, len = points.length; i < len; i++) {\r\n\t\t\tpoints[i]._code = lu._getBitCode(points[i], bounds);\r\n\t\t}\r\n\t\r\n\t\t// for each edge (left, bottom, right, top)\r\n\t\tfor (k = 0; k < 4; k++) {\r\n\t\t\tedge = edges[k];\r\n\t\t\tclippedPoints = [];\r\n\t\r\n\t\t\tfor (i = 0, len = points.length, j = len - 1; i < len; j = i++) {\r\n\t\t\t\ta = points[i];\r\n\t\t\t\tb = points[j];\r\n\t\r\n\t\t\t\t// if a is inside the clip window\r\n\t\t\t\tif (!(a._code & edge)) {\r\n\t\t\t\t\t// if b is outside the clip window (a->b goes out of screen)\r\n\t\t\t\t\tif (b._code & edge) {\r\n\t\t\t\t\t\tp = lu._getEdgeIntersection(b, a, edge, bounds);\r\n\t\t\t\t\t\tp._code = lu._getBitCode(p, bounds);\r\n\t\t\t\t\t\tclippedPoints.push(p);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tclippedPoints.push(a);\r\n\t\r\n\t\t\t\t// else if b is inside the clip window (a->b enters the screen)\r\n\t\t\t\t} else if (!(b._code & edge)) {\r\n\t\t\t\t\tp = lu._getEdgeIntersection(b, a, edge, bounds);\r\n\t\t\t\t\tp._code = lu._getBitCode(p, bounds);\r\n\t\t\t\t\tclippedPoints.push(p);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tpoints = clippedPoints;\r\n\t\t}\r\n\t\r\n\t\treturn points;\r\n\t};\r\n\t\n\t\n\t/*\r\n\t * L.Polygon is used to display polygons on a map.\r\n\t */\r\n\t\r\n\tL.Polygon = L.Polyline.extend({\r\n\t\toptions: {\r\n\t\t\tfill: true\r\n\t\t},\r\n\t\r\n\t\tinitialize: function (latlngs, options) {\r\n\t\t\tL.Polyline.prototype.initialize.call(this, latlngs, options);\r\n\t\t\tthis._initWithHoles(latlngs);\r\n\t\t},\r\n\t\r\n\t\t_initWithHoles: function (latlngs) {\r\n\t\t\tvar i, len, hole;\r\n\t\t\tif (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {\r\n\t\t\t\tthis._latlngs = this._convertLatLngs(latlngs[0]);\r\n\t\t\t\tthis._holes = latlngs.slice(1);\r\n\t\r\n\t\t\t\tfor (i = 0, len = this._holes.length; i < len; i++) {\r\n\t\t\t\t\thole = this._holes[i] = this._convertLatLngs(this._holes[i]);\r\n\t\t\t\t\tif (hole[0].equals(hole[hole.length - 1])) {\r\n\t\t\t\t\t\thole.pop();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\t// filter out last point if its equal to the first one\r\n\t\t\tlatlngs = this._latlngs;\r\n\t\r\n\t\t\tif (latlngs.length >= 2 && latlngs[0].equals(latlngs[latlngs.length - 1])) {\r\n\t\t\t\tlatlngs.pop();\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\tprojectLatlngs: function () {\r\n\t\t\tL.Polyline.prototype.projectLatlngs.call(this);\r\n\t\r\n\t\t\t// project polygon holes points\r\n\t\t\t// TODO move this logic to Polyline to get rid of duplication\r\n\t\t\tthis._holePoints = [];\r\n\t\r\n\t\t\tif (!this._holes) { return; }\r\n\t\r\n\t\t\tvar i, j, len, len2;\r\n\t\r\n\t\t\tfor (i = 0, len = this._holes.length; i < len; i++) {\r\n\t\t\t\tthis._holePoints[i] = [];\r\n\t\r\n\t\t\t\tfor (j = 0, len2 = this._holes[i].length; j < len2; j++) {\r\n\t\t\t\t\tthis._holePoints[i][j] = this._map.latLngToLayerPoint(this._holes[i][j]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\tsetLatLngs: function (latlngs) {\r\n\t\t\tif (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {\r\n\t\t\t\tthis._initWithHoles(latlngs);\r\n\t\t\t\treturn this.redraw();\r\n\t\t\t} else {\r\n\t\t\t\treturn L.Polyline.prototype.setLatLngs.call(this, latlngs);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_clipPoints: function () {\r\n\t\t\tvar points = this._originalPoints,\r\n\t\t\t    newParts = [];\r\n\t\r\n\t\t\tthis._parts = [points].concat(this._holePoints);\r\n\t\r\n\t\t\tif (this.options.noClip) { return; }\r\n\t\r\n\t\t\tfor (var i = 0, len = this._parts.length; i < len; i++) {\r\n\t\t\t\tvar clipped = L.PolyUtil.clipPolygon(this._parts[i], this._map._pathViewport);\r\n\t\t\t\tif (clipped.length) {\r\n\t\t\t\t\tnewParts.push(clipped);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._parts = newParts;\r\n\t\t},\r\n\t\r\n\t\t_getPathPartStr: function (points) {\r\n\t\t\tvar str = L.Polyline.prototype._getPathPartStr.call(this, points);\r\n\t\t\treturn str + (L.Browser.svg ? 'z' : 'x');\r\n\t\t}\r\n\t});\r\n\t\r\n\tL.polygon = function (latlngs, options) {\r\n\t\treturn new L.Polygon(latlngs, options);\r\n\t};\r\n\t\n\t\n\t/*\r\n\t * Contains L.MultiPolyline and L.MultiPolygon layers.\r\n\t */\r\n\t\r\n\t(function () {\r\n\t\tfunction createMulti(Klass) {\r\n\t\r\n\t\t\treturn L.FeatureGroup.extend({\r\n\t\r\n\t\t\t\tinitialize: function (latlngs, options) {\r\n\t\t\t\t\tthis._layers = {};\r\n\t\t\t\t\tthis._options = options;\r\n\t\t\t\t\tthis.setLatLngs(latlngs);\r\n\t\t\t\t},\r\n\t\r\n\t\t\t\tsetLatLngs: function (latlngs) {\r\n\t\t\t\t\tvar i = 0,\r\n\t\t\t\t\t    len = latlngs.length;\r\n\t\r\n\t\t\t\t\tthis.eachLayer(function (layer) {\r\n\t\t\t\t\t\tif (i < len) {\r\n\t\t\t\t\t\t\tlayer.setLatLngs(latlngs[i++]);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthis.removeLayer(layer);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, this);\r\n\t\r\n\t\t\t\t\twhile (i < len) {\r\n\t\t\t\t\t\tthis.addLayer(new Klass(latlngs[i++], this._options));\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\treturn this;\r\n\t\t\t\t},\r\n\t\r\n\t\t\t\tgetLatLngs: function () {\r\n\t\t\t\t\tvar latlngs = [];\r\n\t\r\n\t\t\t\t\tthis.eachLayer(function (layer) {\r\n\t\t\t\t\t\tlatlngs.push(layer.getLatLngs());\r\n\t\t\t\t\t});\r\n\t\r\n\t\t\t\t\treturn latlngs;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t\r\n\t\tL.MultiPolyline = createMulti(L.Polyline);\r\n\t\tL.MultiPolygon = createMulti(L.Polygon);\r\n\t\r\n\t\tL.multiPolyline = function (latlngs, options) {\r\n\t\t\treturn new L.MultiPolyline(latlngs, options);\r\n\t\t};\r\n\t\r\n\t\tL.multiPolygon = function (latlngs, options) {\r\n\t\t\treturn new L.MultiPolygon(latlngs, options);\r\n\t\t};\r\n\t}());\r\n\t\n\t\n\t/*\r\n\t * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.\r\n\t */\r\n\t\r\n\tL.Rectangle = L.Polygon.extend({\r\n\t\tinitialize: function (latLngBounds, options) {\r\n\t\t\tL.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);\r\n\t\t},\r\n\t\r\n\t\tsetBounds: function (latLngBounds) {\r\n\t\t\tthis.setLatLngs(this._boundsToLatLngs(latLngBounds));\r\n\t\t},\r\n\t\r\n\t\t_boundsToLatLngs: function (latLngBounds) {\r\n\t\t\tlatLngBounds = L.latLngBounds(latLngBounds);\r\n\t\t\treturn [\r\n\t\t\t\tlatLngBounds.getSouthWest(),\r\n\t\t\t\tlatLngBounds.getNorthWest(),\r\n\t\t\t\tlatLngBounds.getNorthEast(),\r\n\t\t\t\tlatLngBounds.getSouthEast()\r\n\t\t\t];\r\n\t\t}\r\n\t});\r\n\t\r\n\tL.rectangle = function (latLngBounds, options) {\r\n\t\treturn new L.Rectangle(latLngBounds, options);\r\n\t};\r\n\t\n\t\n\t/*\r\n\t * L.Circle is a circle overlay (with a certain radius in meters).\r\n\t */\r\n\t\r\n\tL.Circle = L.Path.extend({\r\n\t\tinitialize: function (latlng, radius, options) {\r\n\t\t\tL.Path.prototype.initialize.call(this, options);\r\n\t\r\n\t\t\tthis._latlng = L.latLng(latlng);\r\n\t\t\tthis._mRadius = radius;\r\n\t\t},\r\n\t\r\n\t\toptions: {\r\n\t\t\tfill: true\r\n\t\t},\r\n\t\r\n\t\tsetLatLng: function (latlng) {\r\n\t\t\tthis._latlng = L.latLng(latlng);\r\n\t\t\treturn this.redraw();\r\n\t\t},\r\n\t\r\n\t\tsetRadius: function (radius) {\r\n\t\t\tthis._mRadius = radius;\r\n\t\t\treturn this.redraw();\r\n\t\t},\r\n\t\r\n\t\tprojectLatlngs: function () {\r\n\t\t\tvar lngRadius = this._getLngRadius(),\r\n\t\t\t    latlng = this._latlng,\r\n\t\t\t    pointLeft = this._map.latLngToLayerPoint([latlng.lat, latlng.lng - lngRadius]);\r\n\t\r\n\t\t\tthis._point = this._map.latLngToLayerPoint(latlng);\r\n\t\t\tthis._radius = Math.max(this._point.x - pointLeft.x, 1);\r\n\t\t},\r\n\t\r\n\t\tgetBounds: function () {\r\n\t\t\tvar lngRadius = this._getLngRadius(),\r\n\t\t\t    latRadius = (this._mRadius / 40075017) * 360,\r\n\t\t\t    latlng = this._latlng;\r\n\t\r\n\t\t\treturn new L.LatLngBounds(\r\n\t\t\t        [latlng.lat - latRadius, latlng.lng - lngRadius],\r\n\t\t\t        [latlng.lat + latRadius, latlng.lng + lngRadius]);\r\n\t\t},\r\n\t\r\n\t\tgetLatLng: function () {\r\n\t\t\treturn this._latlng;\r\n\t\t},\r\n\t\r\n\t\tgetPathString: function () {\r\n\t\t\tvar p = this._point,\r\n\t\t\t    r = this._radius;\r\n\t\r\n\t\t\tif (this._checkIfEmpty()) {\r\n\t\t\t\treturn '';\r\n\t\t\t}\r\n\t\r\n\t\t\tif (L.Browser.svg) {\r\n\t\t\t\treturn 'M' + p.x + ',' + (p.y - r) +\r\n\t\t\t\t       'A' + r + ',' + r + ',0,1,1,' +\r\n\t\t\t\t       (p.x - 0.1) + ',' + (p.y - r) + ' z';\r\n\t\t\t} else {\r\n\t\t\t\tp._round();\r\n\t\t\t\tr = Math.round(r);\r\n\t\t\t\treturn 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r + ' 0,' + (65535 * 360);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\tgetRadius: function () {\r\n\t\t\treturn this._mRadius;\r\n\t\t},\r\n\t\r\n\t\t// TODO Earth hardcoded, move into projection code!\r\n\t\r\n\t\t_getLatRadius: function () {\r\n\t\t\treturn (this._mRadius / 40075017) * 360;\r\n\t\t},\r\n\t\r\n\t\t_getLngRadius: function () {\r\n\t\t\treturn this._getLatRadius() / Math.cos(L.LatLng.DEG_TO_RAD * this._latlng.lat);\r\n\t\t},\r\n\t\r\n\t\t_checkIfEmpty: function () {\r\n\t\t\tif (!this._map) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tvar vp = this._map._pathViewport,\r\n\t\t\t    r = this._radius,\r\n\t\t\t    p = this._point;\r\n\t\r\n\t\t\treturn p.x - r > vp.max.x || p.y - r > vp.max.y ||\r\n\t\t\t       p.x + r < vp.min.x || p.y + r < vp.min.y;\r\n\t\t}\r\n\t});\r\n\t\r\n\tL.circle = function (latlng, radius, options) {\r\n\t\treturn new L.Circle(latlng, radius, options);\r\n\t};\r\n\t\n\t\n\t/*\r\n\t * L.CircleMarker is a circle overlay with a permanent pixel radius.\r\n\t */\r\n\t\r\n\tL.CircleMarker = L.Circle.extend({\r\n\t\toptions: {\r\n\t\t\tradius: 10,\r\n\t\t\tweight: 2\r\n\t\t},\r\n\t\r\n\t\tinitialize: function (latlng, options) {\r\n\t\t\tL.Circle.prototype.initialize.call(this, latlng, null, options);\r\n\t\t\tthis._radius = this.options.radius;\r\n\t\t},\r\n\t\r\n\t\tprojectLatlngs: function () {\r\n\t\t\tthis._point = this._map.latLngToLayerPoint(this._latlng);\r\n\t\t},\r\n\t\r\n\t\t_updateStyle : function () {\r\n\t\t\tL.Circle.prototype._updateStyle.call(this);\r\n\t\t\tthis.setRadius(this.options.radius);\r\n\t\t},\r\n\t\r\n\t\tsetLatLng: function (latlng) {\r\n\t\t\tL.Circle.prototype.setLatLng.call(this, latlng);\r\n\t\t\tif (this._popup && this._popup._isOpen) {\r\n\t\t\t\tthis._popup.setLatLng(latlng);\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tsetRadius: function (radius) {\r\n\t\t\tthis.options.radius = this._radius = radius;\r\n\t\t\treturn this.redraw();\r\n\t\t},\r\n\t\r\n\t\tgetRadius: function () {\r\n\t\t\treturn this._radius;\r\n\t\t}\r\n\t});\r\n\t\r\n\tL.circleMarker = function (latlng, options) {\r\n\t\treturn new L.CircleMarker(latlng, options);\r\n\t};\r\n\t\n\t\n\t/*\r\n\t * Extends L.Polyline to be able to manually detect clicks on Canvas-rendered polylines.\r\n\t */\r\n\t\r\n\tL.Polyline.include(!L.Path.CANVAS ? {} : {\r\n\t\t_containsPoint: function (p, closed) {\r\n\t\t\tvar i, j, k, len, len2, dist, part,\r\n\t\t\t    w = this.options.weight / 2;\r\n\t\r\n\t\t\tif (L.Browser.touch) {\r\n\t\t\t\tw += 10; // polyline click tolerance on touch devices\r\n\t\t\t}\r\n\t\r\n\t\t\tfor (i = 0, len = this._parts.length; i < len; i++) {\r\n\t\t\t\tpart = this._parts[i];\r\n\t\t\t\tfor (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\r\n\t\t\t\t\tif (!closed && (j === 0)) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tdist = L.LineUtil.pointToSegmentDistance(p, part[k], part[j]);\r\n\t\r\n\t\t\t\t\tif (dist <= w) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t});\r\n\t\n\t\n\t/*\r\n\t * Extends L.Polygon to be able to manually detect clicks on Canvas-rendered polygons.\r\n\t */\r\n\t\r\n\tL.Polygon.include(!L.Path.CANVAS ? {} : {\r\n\t\t_containsPoint: function (p) {\r\n\t\t\tvar inside = false,\r\n\t\t\t    part, p1, p2,\r\n\t\t\t    i, j, k,\r\n\t\t\t    len, len2;\r\n\t\r\n\t\t\t// TODO optimization: check if within bounds first\r\n\t\r\n\t\t\tif (L.Polyline.prototype._containsPoint.call(this, p, true)) {\r\n\t\t\t\t// click on polygon border\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\r\n\t\t\t// ray casting algorithm for detecting if point is in polygon\r\n\t\r\n\t\t\tfor (i = 0, len = this._parts.length; i < len; i++) {\r\n\t\t\t\tpart = this._parts[i];\r\n\t\r\n\t\t\t\tfor (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\r\n\t\t\t\t\tp1 = part[j];\r\n\t\t\t\t\tp2 = part[k];\r\n\t\r\n\t\t\t\t\tif (((p1.y > p.y) !== (p2.y > p.y)) &&\r\n\t\t\t\t\t\t\t(p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {\r\n\t\t\t\t\t\tinside = !inside;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\treturn inside;\r\n\t\t}\r\n\t});\r\n\t\n\t\n\t/*\r\n\t * Extends L.Circle with Canvas-specific code.\r\n\t */\r\n\t\r\n\tL.Circle.include(!L.Path.CANVAS ? {} : {\r\n\t\t_drawPath: function () {\r\n\t\t\tvar p = this._point;\r\n\t\t\tthis._ctx.beginPath();\r\n\t\t\tthis._ctx.arc(p.x, p.y, this._radius, 0, Math.PI * 2, false);\r\n\t\t},\r\n\t\r\n\t\t_containsPoint: function (p) {\r\n\t\t\tvar center = this._point,\r\n\t\t\t    w2 = this.options.stroke ? this.options.weight / 2 : 0;\r\n\t\r\n\t\t\treturn (p.distanceTo(center) <= this._radius + w2);\r\n\t\t}\r\n\t});\r\n\t\n\t\n\t/*\n\t * CircleMarker canvas specific drawing parts.\n\t */\n\t\n\tL.CircleMarker.include(!L.Path.CANVAS ? {} : {\n\t\t_updateStyle: function () {\n\t\t\tL.Path.prototype._updateStyle.call(this);\n\t\t}\n\t});\n\t\n\t\n\t/*\r\n\t * L.GeoJSON turns any GeoJSON data into a Leaflet layer.\r\n\t */\r\n\t\r\n\tL.GeoJSON = L.FeatureGroup.extend({\r\n\t\r\n\t\tinitialize: function (geojson, options) {\r\n\t\t\tL.setOptions(this, options);\r\n\t\r\n\t\t\tthis._layers = {};\r\n\t\r\n\t\t\tif (geojson) {\r\n\t\t\t\tthis.addData(geojson);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\taddData: function (geojson) {\r\n\t\t\tvar features = L.Util.isArray(geojson) ? geojson : geojson.features,\r\n\t\t\t    i, len, feature;\r\n\t\r\n\t\t\tif (features) {\r\n\t\t\t\tfor (i = 0, len = features.length; i < len; i++) {\r\n\t\t\t\t\t// Only add this if geometry or geometries are set and not null\r\n\t\t\t\t\tfeature = features[i];\r\n\t\t\t\t\tif (feature.geometries || feature.geometry || feature.features || feature.coordinates) {\r\n\t\t\t\t\t\tthis.addData(features[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t}\r\n\t\r\n\t\t\tvar options = this.options;\r\n\t\r\n\t\t\tif (options.filter && !options.filter(geojson)) { return; }\r\n\t\r\n\t\t\tvar layer = L.GeoJSON.geometryToLayer(geojson, options.pointToLayer, options.coordsToLatLng, options);\r\n\t\t\tlayer.feature = L.GeoJSON.asFeature(geojson);\r\n\t\r\n\t\t\tlayer.defaultOptions = layer.options;\r\n\t\t\tthis.resetStyle(layer);\r\n\t\r\n\t\t\tif (options.onEachFeature) {\r\n\t\t\t\toptions.onEachFeature(geojson, layer);\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this.addLayer(layer);\r\n\t\t},\r\n\t\r\n\t\tresetStyle: function (layer) {\r\n\t\t\tvar style = this.options.style;\r\n\t\t\tif (style) {\r\n\t\t\t\t// reset any custom styles\r\n\t\t\t\tL.Util.extend(layer.options, layer.defaultOptions);\r\n\t\r\n\t\t\t\tthis._setLayerStyle(layer, style);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\tsetStyle: function (style) {\r\n\t\t\tthis.eachLayer(function (layer) {\r\n\t\t\t\tthis._setLayerStyle(layer, style);\r\n\t\t\t}, this);\r\n\t\t},\r\n\t\r\n\t\t_setLayerStyle: function (layer, style) {\r\n\t\t\tif (typeof style === 'function') {\r\n\t\t\t\tstyle = style(layer.feature);\r\n\t\t\t}\r\n\t\t\tif (layer.setStyle) {\r\n\t\t\t\tlayer.setStyle(style);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\t\r\n\tL.extend(L.GeoJSON, {\r\n\t\tgeometryToLayer: function (geojson, pointToLayer, coordsToLatLng, vectorOptions) {\r\n\t\t\tvar geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,\r\n\t\t\t    coords = geometry.coordinates,\r\n\t\t\t    layers = [],\r\n\t\t\t    latlng, latlngs, i, len;\r\n\t\r\n\t\t\tcoordsToLatLng = coordsToLatLng || this.coordsToLatLng;\r\n\t\r\n\t\t\tswitch (geometry.type) {\r\n\t\t\tcase 'Point':\r\n\t\t\t\tlatlng = coordsToLatLng(coords);\r\n\t\t\t\treturn pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);\r\n\t\r\n\t\t\tcase 'MultiPoint':\r\n\t\t\t\tfor (i = 0, len = coords.length; i < len; i++) {\r\n\t\t\t\t\tlatlng = coordsToLatLng(coords[i]);\r\n\t\t\t\t\tlayers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));\r\n\t\t\t\t}\r\n\t\t\t\treturn new L.FeatureGroup(layers);\r\n\t\r\n\t\t\tcase 'LineString':\r\n\t\t\t\tlatlngs = this.coordsToLatLngs(coords, 0, coordsToLatLng);\r\n\t\t\t\treturn new L.Polyline(latlngs, vectorOptions);\r\n\t\r\n\t\t\tcase 'Polygon':\r\n\t\t\t\tif (coords.length === 2 && !coords[1].length) {\r\n\t\t\t\t\tthrow new Error('Invalid GeoJSON object.');\r\n\t\t\t\t}\r\n\t\t\t\tlatlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);\r\n\t\t\t\treturn new L.Polygon(latlngs, vectorOptions);\r\n\t\r\n\t\t\tcase 'MultiLineString':\r\n\t\t\t\tlatlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);\r\n\t\t\t\treturn new L.MultiPolyline(latlngs, vectorOptions);\r\n\t\r\n\t\t\tcase 'MultiPolygon':\r\n\t\t\t\tlatlngs = this.coordsToLatLngs(coords, 2, coordsToLatLng);\r\n\t\t\t\treturn new L.MultiPolygon(latlngs, vectorOptions);\r\n\t\r\n\t\t\tcase 'GeometryCollection':\r\n\t\t\t\tfor (i = 0, len = geometry.geometries.length; i < len; i++) {\r\n\t\r\n\t\t\t\t\tlayers.push(this.geometryToLayer({\r\n\t\t\t\t\t\tgeometry: geometry.geometries[i],\r\n\t\t\t\t\t\ttype: 'Feature',\r\n\t\t\t\t\t\tproperties: geojson.properties\r\n\t\t\t\t\t}, pointToLayer, coordsToLatLng, vectorOptions));\r\n\t\t\t\t}\r\n\t\t\t\treturn new L.FeatureGroup(layers);\r\n\t\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error('Invalid GeoJSON object.');\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\tcoordsToLatLng: function (coords) { // (Array[, Boolean]) -> LatLng\r\n\t\t\treturn new L.LatLng(coords[1], coords[0], coords[2]);\r\n\t\t},\r\n\t\r\n\t\tcoordsToLatLngs: function (coords, levelsDeep, coordsToLatLng) { // (Array[, Number, Function]) -> Array\r\n\t\t\tvar latlng, i, len,\r\n\t\t\t    latlngs = [];\r\n\t\r\n\t\t\tfor (i = 0, len = coords.length; i < len; i++) {\r\n\t\t\t\tlatlng = levelsDeep ?\r\n\t\t\t\t        this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) :\r\n\t\t\t\t        (coordsToLatLng || this.coordsToLatLng)(coords[i]);\r\n\t\r\n\t\t\t\tlatlngs.push(latlng);\r\n\t\t\t}\r\n\t\r\n\t\t\treturn latlngs;\r\n\t\t},\r\n\t\r\n\t\tlatLngToCoords: function (latlng) {\r\n\t\t\tvar coords = [latlng.lng, latlng.lat];\r\n\t\r\n\t\t\tif (latlng.alt !== undefined) {\r\n\t\t\t\tcoords.push(latlng.alt);\r\n\t\t\t}\r\n\t\t\treturn coords;\r\n\t\t},\r\n\t\r\n\t\tlatLngsToCoords: function (latLngs) {\r\n\t\t\tvar coords = [];\r\n\t\r\n\t\t\tfor (var i = 0, len = latLngs.length; i < len; i++) {\r\n\t\t\t\tcoords.push(L.GeoJSON.latLngToCoords(latLngs[i]));\r\n\t\t\t}\r\n\t\r\n\t\t\treturn coords;\r\n\t\t},\r\n\t\r\n\t\tgetFeature: function (layer, newGeometry) {\r\n\t\t\treturn layer.feature ? L.extend({}, layer.feature, {geometry: newGeometry}) : L.GeoJSON.asFeature(newGeometry);\r\n\t\t},\r\n\t\r\n\t\tasFeature: function (geoJSON) {\r\n\t\t\tif (geoJSON.type === 'Feature') {\r\n\t\t\t\treturn geoJSON;\r\n\t\t\t}\r\n\t\r\n\t\t\treturn {\r\n\t\t\t\ttype: 'Feature',\r\n\t\t\t\tproperties: {},\r\n\t\t\t\tgeometry: geoJSON\r\n\t\t\t};\r\n\t\t}\r\n\t});\r\n\t\r\n\tvar PointToGeoJSON = {\r\n\t\ttoGeoJSON: function () {\r\n\t\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\t\ttype: 'Point',\r\n\t\t\t\tcoordinates: L.GeoJSON.latLngToCoords(this.getLatLng())\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n\t\r\n\tL.Marker.include(PointToGeoJSON);\r\n\tL.Circle.include(PointToGeoJSON);\r\n\tL.CircleMarker.include(PointToGeoJSON);\r\n\t\r\n\tL.Polyline.include({\r\n\t\ttoGeoJSON: function () {\r\n\t\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\t\ttype: 'LineString',\r\n\t\t\t\tcoordinates: L.GeoJSON.latLngsToCoords(this.getLatLngs())\r\n\t\t\t});\r\n\t\t}\r\n\t});\r\n\t\r\n\tL.Polygon.include({\r\n\t\ttoGeoJSON: function () {\r\n\t\t\tvar coords = [L.GeoJSON.latLngsToCoords(this.getLatLngs())],\r\n\t\t\t    i, len, hole;\r\n\t\r\n\t\t\tcoords[0].push(coords[0][0]);\r\n\t\r\n\t\t\tif (this._holes) {\r\n\t\t\t\tfor (i = 0, len = this._holes.length; i < len; i++) {\r\n\t\t\t\t\thole = L.GeoJSON.latLngsToCoords(this._holes[i]);\r\n\t\t\t\t\thole.push(hole[0]);\r\n\t\t\t\t\tcoords.push(hole);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\t\ttype: 'Polygon',\r\n\t\t\t\tcoordinates: coords\r\n\t\t\t});\r\n\t\t}\r\n\t});\r\n\t\r\n\t(function () {\r\n\t\tfunction multiToGeoJSON(type) {\r\n\t\t\treturn function () {\r\n\t\t\t\tvar coords = [];\r\n\t\r\n\t\t\t\tthis.eachLayer(function (layer) {\r\n\t\t\t\t\tcoords.push(layer.toGeoJSON().geometry.coordinates);\r\n\t\t\t\t});\r\n\t\r\n\t\t\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\t\t\ttype: type,\r\n\t\t\t\t\tcoordinates: coords\r\n\t\t\t\t});\r\n\t\t\t};\r\n\t\t}\r\n\t\r\n\t\tL.MultiPolyline.include({toGeoJSON: multiToGeoJSON('MultiLineString')});\r\n\t\tL.MultiPolygon.include({toGeoJSON: multiToGeoJSON('MultiPolygon')});\r\n\t\r\n\t\tL.LayerGroup.include({\r\n\t\t\ttoGeoJSON: function () {\r\n\t\r\n\t\t\t\tvar geometry = this.feature && this.feature.geometry,\r\n\t\t\t\t\tjsons = [],\r\n\t\t\t\t\tjson;\r\n\t\r\n\t\t\t\tif (geometry && geometry.type === 'MultiPoint') {\r\n\t\t\t\t\treturn multiToGeoJSON('MultiPoint').call(this);\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar isGeometryCollection = geometry && geometry.type === 'GeometryCollection';\r\n\t\r\n\t\t\t\tthis.eachLayer(function (layer) {\r\n\t\t\t\t\tif (layer.toGeoJSON) {\r\n\t\t\t\t\t\tjson = layer.toGeoJSON();\r\n\t\t\t\t\t\tjsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json));\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\r\n\t\t\t\tif (isGeometryCollection) {\r\n\t\t\t\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\t\t\t\tgeometries: jsons,\r\n\t\t\t\t\t\ttype: 'GeometryCollection'\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn {\r\n\t\t\t\t\ttype: 'FeatureCollection',\r\n\t\t\t\t\tfeatures: jsons\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t});\r\n\t}());\r\n\t\r\n\tL.geoJson = function (geojson, options) {\r\n\t\treturn new L.GeoJSON(geojson, options);\r\n\t};\r\n\t\n\t\n\t/*\r\n\t * L.DomEvent contains functions for working with DOM events.\r\n\t */\r\n\t\r\n\tL.DomEvent = {\r\n\t\t/* inspired by John Resig, Dean Edwards and YUI addEvent implementations */\r\n\t\taddListener: function (obj, type, fn, context) { // (HTMLElement, String, Function[, Object])\r\n\t\r\n\t\t\tvar id = L.stamp(fn),\r\n\t\t\t    key = '_leaflet_' + type + id,\r\n\t\t\t    handler, originalHandler, newType;\r\n\t\r\n\t\t\tif (obj[key]) { return this; }\r\n\t\r\n\t\t\thandler = function (e) {\r\n\t\t\t\treturn fn.call(context || obj, e || L.DomEvent._getEvent());\r\n\t\t\t};\r\n\t\r\n\t\t\tif (L.Browser.pointer && type.indexOf('touch') === 0) {\r\n\t\t\t\treturn this.addPointerListener(obj, type, handler, id);\r\n\t\t\t}\r\n\t\t\tif (L.Browser.touch && (type === 'dblclick') && this.addDoubleTapListener) {\r\n\t\t\t\tthis.addDoubleTapListener(obj, handler, id);\r\n\t\t\t}\r\n\t\r\n\t\t\tif ('addEventListener' in obj) {\r\n\t\r\n\t\t\t\tif (type === 'mousewheel') {\r\n\t\t\t\t\tobj.addEventListener('DOMMouseScroll', handler, false);\r\n\t\t\t\t\tobj.addEventListener(type, handler, false);\r\n\t\r\n\t\t\t\t} else if ((type === 'mouseenter') || (type === 'mouseleave')) {\r\n\t\r\n\t\t\t\t\toriginalHandler = handler;\r\n\t\t\t\t\tnewType = (type === 'mouseenter' ? 'mouseover' : 'mouseout');\r\n\t\r\n\t\t\t\t\thandler = function (e) {\r\n\t\t\t\t\t\tif (!L.DomEvent._checkMouse(obj, e)) { return; }\r\n\t\t\t\t\t\treturn originalHandler(e);\r\n\t\t\t\t\t};\r\n\t\r\n\t\t\t\t\tobj.addEventListener(newType, handler, false);\r\n\t\r\n\t\t\t\t} else if (type === 'click' && L.Browser.android) {\r\n\t\t\t\t\toriginalHandler = handler;\r\n\t\t\t\t\thandler = function (e) {\r\n\t\t\t\t\t\treturn L.DomEvent._filterClick(e, originalHandler);\r\n\t\t\t\t\t};\r\n\t\r\n\t\t\t\t\tobj.addEventListener(type, handler, false);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tobj.addEventListener(type, handler, false);\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ('attachEvent' in obj) {\r\n\t\t\t\tobj.attachEvent('on' + type, handler);\r\n\t\t\t}\r\n\t\r\n\t\t\tobj[key] = handler;\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tremoveListener: function (obj, type, fn) {  // (HTMLElement, String, Function)\r\n\t\r\n\t\t\tvar id = L.stamp(fn),\r\n\t\t\t    key = '_leaflet_' + type + id,\r\n\t\t\t    handler = obj[key];\r\n\t\r\n\t\t\tif (!handler) { return this; }\r\n\t\r\n\t\t\tif (L.Browser.pointer && type.indexOf('touch') === 0) {\r\n\t\t\t\tthis.removePointerListener(obj, type, id);\r\n\t\t\t} else if (L.Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {\r\n\t\t\t\tthis.removeDoubleTapListener(obj, id);\r\n\t\r\n\t\t\t} else if ('removeEventListener' in obj) {\r\n\t\r\n\t\t\t\tif (type === 'mousewheel') {\r\n\t\t\t\t\tobj.removeEventListener('DOMMouseScroll', handler, false);\r\n\t\t\t\t\tobj.removeEventListener(type, handler, false);\r\n\t\r\n\t\t\t\t} else if ((type === 'mouseenter') || (type === 'mouseleave')) {\r\n\t\t\t\t\tobj.removeEventListener((type === 'mouseenter' ? 'mouseover' : 'mouseout'), handler, false);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tobj.removeEventListener(type, handler, false);\r\n\t\t\t\t}\r\n\t\t\t} else if ('detachEvent' in obj) {\r\n\t\t\t\tobj.detachEvent('on' + type, handler);\r\n\t\t\t}\r\n\t\r\n\t\t\tobj[key] = null;\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tstopPropagation: function (e) {\r\n\t\r\n\t\t\tif (e.stopPropagation) {\r\n\t\t\t\te.stopPropagation();\r\n\t\t\t} else {\r\n\t\t\t\te.cancelBubble = true;\r\n\t\t\t}\r\n\t\t\tL.DomEvent._skipped(e);\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tdisableScrollPropagation: function (el) {\r\n\t\t\tvar stop = L.DomEvent.stopPropagation;\r\n\t\r\n\t\t\treturn L.DomEvent\r\n\t\t\t\t.on(el, 'mousewheel', stop)\r\n\t\t\t\t.on(el, 'MozMousePixelScroll', stop);\r\n\t\t},\r\n\t\r\n\t\tdisableClickPropagation: function (el) {\r\n\t\t\tvar stop = L.DomEvent.stopPropagation;\r\n\t\r\n\t\t\tfor (var i = L.Draggable.START.length - 1; i >= 0; i--) {\r\n\t\t\t\tL.DomEvent.on(el, L.Draggable.START[i], stop);\r\n\t\t\t}\r\n\t\r\n\t\t\treturn L.DomEvent\r\n\t\t\t\t.on(el, 'click', L.DomEvent._fakeStop)\r\n\t\t\t\t.on(el, 'dblclick', stop);\r\n\t\t},\r\n\t\r\n\t\tpreventDefault: function (e) {\r\n\t\r\n\t\t\tif (e.preventDefault) {\r\n\t\t\t\te.preventDefault();\r\n\t\t\t} else {\r\n\t\t\t\te.returnValue = false;\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tstop: function (e) {\r\n\t\t\treturn L.DomEvent\r\n\t\t\t\t.preventDefault(e)\r\n\t\t\t\t.stopPropagation(e);\r\n\t\t},\r\n\t\r\n\t\tgetMousePosition: function (e, container) {\r\n\t\t\tif (!container) {\r\n\t\t\t\treturn new L.Point(e.clientX, e.clientY);\r\n\t\t\t}\r\n\t\r\n\t\t\tvar rect = container.getBoundingClientRect();\r\n\t\r\n\t\t\treturn new L.Point(\r\n\t\t\t\te.clientX - rect.left - container.clientLeft,\r\n\t\t\t\te.clientY - rect.top - container.clientTop);\r\n\t\t},\r\n\t\r\n\t\tgetWheelDelta: function (e) {\r\n\t\r\n\t\t\tvar delta = 0;\r\n\t\r\n\t\t\tif (e.wheelDelta) {\r\n\t\t\t\tdelta = e.wheelDelta / 120;\r\n\t\t\t}\r\n\t\t\tif (e.detail) {\r\n\t\t\t\tdelta = -e.detail / 3;\r\n\t\t\t}\r\n\t\t\treturn delta;\r\n\t\t},\r\n\t\r\n\t\t_skipEvents: {},\r\n\t\r\n\t\t_fakeStop: function (e) {\r\n\t\t\t// fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)\r\n\t\t\tL.DomEvent._skipEvents[e.type] = true;\r\n\t\t},\r\n\t\r\n\t\t_skipped: function (e) {\r\n\t\t\tvar skipped = this._skipEvents[e.type];\r\n\t\t\t// reset when checking, as it's only used in map container and propagates outside of the map\r\n\t\t\tthis._skipEvents[e.type] = false;\r\n\t\t\treturn skipped;\r\n\t\t},\r\n\t\r\n\t\t// check if element really left/entered the event target (for mouseenter/mouseleave)\r\n\t\t_checkMouse: function (el, e) {\r\n\t\r\n\t\t\tvar related = e.relatedTarget;\r\n\t\r\n\t\t\tif (!related) { return true; }\r\n\t\r\n\t\t\ttry {\r\n\t\t\t\twhile (related && (related !== el)) {\r\n\t\t\t\t\trelated = related.parentNode;\r\n\t\t\t\t}\r\n\t\t\t} catch (err) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\treturn (related !== el);\r\n\t\t},\r\n\t\r\n\t\t_getEvent: function () { // evil magic for IE\r\n\t\t\t/*jshint noarg:false */\r\n\t\t\tvar e = window.event;\r\n\t\t\tif (!e) {\r\n\t\t\t\tvar caller = arguments.callee.caller;\r\n\t\t\t\twhile (caller) {\r\n\t\t\t\t\te = caller['arguments'][0];\r\n\t\t\t\t\tif (e && window.Event === e.constructor) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcaller = caller.caller;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn e;\r\n\t\t},\r\n\t\r\n\t\t// this is a horrible workaround for a bug in Android where a single touch triggers two click events\r\n\t\t_filterClick: function (e, handler) {\r\n\t\t\tvar timeStamp = (e.timeStamp || e.originalEvent.timeStamp),\r\n\t\t\t\telapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);\r\n\t\r\n\t\t\t// are they closer together than 500ms yet more than 100ms?\r\n\t\t\t// Android typically triggers them ~300ms apart while multiple listeners\r\n\t\t\t// on the same event should be triggered far faster;\r\n\t\t\t// or check if click is simulated on the element, and if it is, reject any non-simulated events\r\n\t\r\n\t\t\tif ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {\r\n\t\t\t\tL.DomEvent.stop(e);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tL.DomEvent._lastClick = timeStamp;\r\n\t\r\n\t\t\treturn handler(e);\r\n\t\t}\r\n\t};\r\n\t\r\n\tL.DomEvent.on = L.DomEvent.addListener;\r\n\tL.DomEvent.off = L.DomEvent.removeListener;\r\n\t\n\t\n\t/*\r\n\t * L.Draggable allows you to add dragging capabilities to any element. Supports mobile devices too.\r\n\t */\r\n\t\r\n\tL.Draggable = L.Class.extend({\r\n\t\tincludes: L.Mixin.Events,\r\n\t\r\n\t\tstatics: {\r\n\t\t\tSTART: L.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],\r\n\t\t\tEND: {\r\n\t\t\t\tmousedown: 'mouseup',\r\n\t\t\t\ttouchstart: 'touchend',\r\n\t\t\t\tpointerdown: 'touchend',\r\n\t\t\t\tMSPointerDown: 'touchend'\r\n\t\t\t},\r\n\t\t\tMOVE: {\r\n\t\t\t\tmousedown: 'mousemove',\r\n\t\t\t\ttouchstart: 'touchmove',\r\n\t\t\t\tpointerdown: 'touchmove',\r\n\t\t\t\tMSPointerDown: 'touchmove'\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\tinitialize: function (element, dragStartTarget) {\r\n\t\t\tthis._element = element;\r\n\t\t\tthis._dragStartTarget = dragStartTarget || element;\r\n\t\t},\r\n\t\r\n\t\tenable: function () {\r\n\t\t\tif (this._enabled) { return; }\r\n\t\r\n\t\t\tfor (var i = L.Draggable.START.length - 1; i >= 0; i--) {\r\n\t\t\t\tL.DomEvent.on(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._enabled = true;\r\n\t\t},\r\n\t\r\n\t\tdisable: function () {\r\n\t\t\tif (!this._enabled) { return; }\r\n\t\r\n\t\t\tfor (var i = L.Draggable.START.length - 1; i >= 0; i--) {\r\n\t\t\t\tL.DomEvent.off(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._enabled = false;\r\n\t\t\tthis._moved = false;\r\n\t\t},\r\n\t\r\n\t\t_onDown: function (e) {\r\n\t\t\tthis._moved = false;\r\n\t\r\n\t\t\tif (e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }\r\n\t\r\n\t\t\tL.DomEvent.stopPropagation(e);\r\n\t\r\n\t\t\tif (L.Draggable._disabled) { return; }\r\n\t\r\n\t\t\tL.DomUtil.disableImageDrag();\r\n\t\t\tL.DomUtil.disableTextSelection();\r\n\t\r\n\t\t\tif (this._moving) { return; }\r\n\t\r\n\t\t\tvar first = e.touches ? e.touches[0] : e;\r\n\t\r\n\t\t\tthis._startPoint = new L.Point(first.clientX, first.clientY);\r\n\t\t\tthis._startPos = this._newPos = L.DomUtil.getPosition(this._element);\r\n\t\r\n\t\t\tL.DomEvent\r\n\t\t\t    .on(document, L.Draggable.MOVE[e.type], this._onMove, this)\r\n\t\t\t    .on(document, L.Draggable.END[e.type], this._onUp, this);\r\n\t\t},\r\n\t\r\n\t\t_onMove: function (e) {\r\n\t\t\tif (e.touches && e.touches.length > 1) {\r\n\t\t\t\tthis._moved = true;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\r\n\t\t\tvar first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),\r\n\t\t\t    newPoint = new L.Point(first.clientX, first.clientY),\r\n\t\t\t    offset = newPoint.subtract(this._startPoint);\r\n\t\r\n\t\t\tif (!offset.x && !offset.y) { return; }\r\n\t\t\tif (L.Browser.touch && Math.abs(offset.x) + Math.abs(offset.y) < 3) { return; }\r\n\t\r\n\t\t\tL.DomEvent.preventDefault(e);\r\n\t\r\n\t\t\tif (!this._moved) {\r\n\t\t\t\tthis.fire('dragstart');\r\n\t\r\n\t\t\t\tthis._moved = true;\r\n\t\t\t\tthis._startPos = L.DomUtil.getPosition(this._element).subtract(offset);\r\n\t\r\n\t\t\t\tL.DomUtil.addClass(document.body, 'leaflet-dragging');\r\n\t\t\t\tthis._lastTarget = e.target || e.srcElement;\r\n\t\t\t\tL.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._newPos = this._startPos.add(offset);\r\n\t\t\tthis._moving = true;\r\n\t\r\n\t\t\tL.Util.cancelAnimFrame(this._animRequest);\r\n\t\t\tthis._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true, this._dragStartTarget);\r\n\t\t},\r\n\t\r\n\t\t_updatePosition: function () {\r\n\t\t\tthis.fire('predrag');\r\n\t\t\tL.DomUtil.setPosition(this._element, this._newPos);\r\n\t\t\tthis.fire('drag');\r\n\t\t},\r\n\t\r\n\t\t_onUp: function () {\r\n\t\t\tL.DomUtil.removeClass(document.body, 'leaflet-dragging');\r\n\t\r\n\t\t\tif (this._lastTarget) {\r\n\t\t\t\tL.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');\r\n\t\t\t\tthis._lastTarget = null;\r\n\t\t\t}\r\n\t\r\n\t\t\tfor (var i in L.Draggable.MOVE) {\r\n\t\t\t\tL.DomEvent\r\n\t\t\t\t    .off(document, L.Draggable.MOVE[i], this._onMove)\r\n\t\t\t\t    .off(document, L.Draggable.END[i], this._onUp);\r\n\t\t\t}\r\n\t\r\n\t\t\tL.DomUtil.enableImageDrag();\r\n\t\t\tL.DomUtil.enableTextSelection();\r\n\t\r\n\t\t\tif (this._moved && this._moving) {\r\n\t\t\t\t// ensure drag is not fired after dragend\r\n\t\t\t\tL.Util.cancelAnimFrame(this._animRequest);\r\n\t\r\n\t\t\t\tthis.fire('dragend', {\r\n\t\t\t\t\tdistance: this._newPos.distanceTo(this._startPos)\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._moving = false;\r\n\t\t}\r\n\t});\r\n\t\n\t\n\t/*\n\t\tL.Handler is a base class for handler classes that are used internally to inject\n\t\tinteraction features like dragging to classes like Map and Marker.\n\t*/\n\t\n\tL.Handler = L.Class.extend({\n\t\tinitialize: function (map) {\n\t\t\tthis._map = map;\n\t\t},\n\t\n\t\tenable: function () {\n\t\t\tif (this._enabled) { return; }\n\t\n\t\t\tthis._enabled = true;\n\t\t\tthis.addHooks();\n\t\t},\n\t\n\t\tdisable: function () {\n\t\t\tif (!this._enabled) { return; }\n\t\n\t\t\tthis._enabled = false;\n\t\t\tthis.removeHooks();\n\t\t},\n\t\n\t\tenabled: function () {\n\t\t\treturn !!this._enabled;\n\t\t}\n\t});\n\t\n\t\n\t/*\n\t * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.\n\t */\n\t\n\tL.Map.mergeOptions({\n\t\tdragging: true,\n\t\n\t\tinertia: !L.Browser.android23,\n\t\tinertiaDeceleration: 3400, // px/s^2\n\t\tinertiaMaxSpeed: Infinity, // px/s\n\t\tinertiaThreshold: L.Browser.touch ? 32 : 18, // ms\n\t\teaseLinearity: 0.25,\n\t\n\t\t// TODO refactor, move to CRS\n\t\tworldCopyJump: false\n\t});\n\t\n\tL.Map.Drag = L.Handler.extend({\n\t\taddHooks: function () {\n\t\t\tif (!this._draggable) {\n\t\t\t\tvar map = this._map;\n\t\n\t\t\t\tthis._draggable = new L.Draggable(map._mapPane, map._container);\n\t\n\t\t\t\tthis._draggable.on({\n\t\t\t\t\t'dragstart': this._onDragStart,\n\t\t\t\t\t'drag': this._onDrag,\n\t\t\t\t\t'dragend': this._onDragEnd\n\t\t\t\t}, this);\n\t\n\t\t\t\tif (map.options.worldCopyJump) {\n\t\t\t\t\tthis._draggable.on('predrag', this._onPreDrag, this);\n\t\t\t\t\tmap.on('viewreset', this._onViewReset, this);\n\t\n\t\t\t\t\tmap.whenReady(this._onViewReset, this);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._draggable.enable();\n\t\t},\n\t\n\t\tremoveHooks: function () {\n\t\t\tthis._draggable.disable();\n\t\t},\n\t\n\t\tmoved: function () {\n\t\t\treturn this._draggable && this._draggable._moved;\n\t\t},\n\t\n\t\t_onDragStart: function () {\n\t\t\tvar map = this._map;\n\t\n\t\t\tif (map._panAnim) {\n\t\t\t\tmap._panAnim.stop();\n\t\t\t}\n\t\n\t\t\tmap\n\t\t\t    .fire('movestart')\n\t\t\t    .fire('dragstart');\n\t\n\t\t\tif (map.options.inertia) {\n\t\t\t\tthis._positions = [];\n\t\t\t\tthis._times = [];\n\t\t\t}\n\t\t},\n\t\n\t\t_onDrag: function () {\n\t\t\tif (this._map.options.inertia) {\n\t\t\t\tvar time = this._lastTime = +new Date(),\n\t\t\t\t    pos = this._lastPos = this._draggable._newPos;\n\t\n\t\t\t\tthis._positions.push(pos);\n\t\t\t\tthis._times.push(time);\n\t\n\t\t\t\tif (time - this._times[0] > 200) {\n\t\t\t\t\tthis._positions.shift();\n\t\t\t\t\tthis._times.shift();\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tthis._map\n\t\t\t    .fire('move')\n\t\t\t    .fire('drag');\n\t\t},\n\t\n\t\t_onViewReset: function () {\n\t\t\t// TODO fix hardcoded Earth values\n\t\t\tvar pxCenter = this._map.getSize()._divideBy(2),\n\t\t\t    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);\n\t\n\t\t\tthis._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;\n\t\t\tthis._worldWidth = this._map.project([0, 180]).x;\n\t\t},\n\t\n\t\t_onPreDrag: function () {\n\t\t\t// TODO refactor to be able to adjust map pane position after zoom\n\t\t\tvar worldWidth = this._worldWidth,\n\t\t\t    halfWidth = Math.round(worldWidth / 2),\n\t\t\t    dx = this._initialWorldOffset,\n\t\t\t    x = this._draggable._newPos.x,\n\t\t\t    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,\n\t\t\t    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,\n\t\t\t    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;\n\t\n\t\t\tthis._draggable._newPos.x = newX;\n\t\t},\n\t\n\t\t_onDragEnd: function (e) {\n\t\t\tvar map = this._map,\n\t\t\t    options = map.options,\n\t\t\t    delay = +new Date() - this._lastTime,\n\t\n\t\t\t    noInertia = !options.inertia || delay > options.inertiaThreshold || !this._positions[0];\n\t\n\t\t\tmap.fire('dragend', e);\n\t\n\t\t\tif (noInertia) {\n\t\t\t\tmap.fire('moveend');\n\t\n\t\t\t} else {\n\t\n\t\t\t\tvar direction = this._lastPos.subtract(this._positions[0]),\n\t\t\t\t    duration = (this._lastTime + delay - this._times[0]) / 1000,\n\t\t\t\t    ease = options.easeLinearity,\n\t\n\t\t\t\t    speedVector = direction.multiplyBy(ease / duration),\n\t\t\t\t    speed = speedVector.distanceTo([0, 0]),\n\t\n\t\t\t\t    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),\n\t\t\t\t    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),\n\t\n\t\t\t\t    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),\n\t\t\t\t    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();\n\t\n\t\t\t\tif (!offset.x || !offset.y) {\n\t\t\t\t\tmap.fire('moveend');\n\t\n\t\t\t\t} else {\n\t\t\t\t\toffset = map._limitOffset(offset, map.options.maxBounds);\n\t\n\t\t\t\t\tL.Util.requestAnimFrame(function () {\n\t\t\t\t\t\tmap.panBy(offset, {\n\t\t\t\t\t\t\tduration: decelerationDuration,\n\t\t\t\t\t\t\teaseLinearity: ease,\n\t\t\t\t\t\t\tnoMoveStart: true\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\t\n\tL.Map.addInitHook('addHandler', 'dragging', L.Map.Drag);\n\t\n\t\n\t/*\n\t * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.\n\t */\n\t\n\tL.Map.mergeOptions({\n\t\tdoubleClickZoom: true\n\t});\n\t\n\tL.Map.DoubleClickZoom = L.Handler.extend({\n\t\taddHooks: function () {\n\t\t\tthis._map.on('dblclick', this._onDoubleClick, this);\n\t\t},\n\t\n\t\tremoveHooks: function () {\n\t\t\tthis._map.off('dblclick', this._onDoubleClick, this);\n\t\t},\n\t\n\t\t_onDoubleClick: function (e) {\n\t\t\tvar map = this._map,\n\t\t\t    zoom = map.getZoom() + (e.originalEvent.shiftKey ? -1 : 1);\n\t\n\t\t\tif (map.options.doubleClickZoom === 'center') {\n\t\t\t\tmap.setZoom(zoom);\n\t\t\t} else {\n\t\t\t\tmap.setZoomAround(e.containerPoint, zoom);\n\t\t\t}\n\t\t}\n\t});\n\t\n\tL.Map.addInitHook('addHandler', 'doubleClickZoom', L.Map.DoubleClickZoom);\n\t\n\t\n\t/*\n\t * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.\n\t */\n\t\n\tL.Map.mergeOptions({\n\t\tscrollWheelZoom: true\n\t});\n\t\n\tL.Map.ScrollWheelZoom = L.Handler.extend({\n\t\taddHooks: function () {\n\t\t\tL.DomEvent.on(this._map._container, 'mousewheel', this._onWheelScroll, this);\n\t\t\tL.DomEvent.on(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);\n\t\t\tthis._delta = 0;\n\t\t},\n\t\n\t\tremoveHooks: function () {\n\t\t\tL.DomEvent.off(this._map._container, 'mousewheel', this._onWheelScroll);\n\t\t\tL.DomEvent.off(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);\n\t\t},\n\t\n\t\t_onWheelScroll: function (e) {\n\t\t\tvar delta = L.DomEvent.getWheelDelta(e);\n\t\n\t\t\tthis._delta += delta;\n\t\t\tthis._lastMousePos = this._map.mouseEventToContainerPoint(e);\n\t\n\t\t\tif (!this._startTime) {\n\t\t\t\tthis._startTime = +new Date();\n\t\t\t}\n\t\n\t\t\tvar left = Math.max(40 - (+new Date() - this._startTime), 0);\n\t\n\t\t\tclearTimeout(this._timer);\n\t\t\tthis._timer = setTimeout(L.bind(this._performZoom, this), left);\n\t\n\t\t\tL.DomEvent.preventDefault(e);\n\t\t\tL.DomEvent.stopPropagation(e);\n\t\t},\n\t\n\t\t_performZoom: function () {\n\t\t\tvar map = this._map,\n\t\t\t    delta = this._delta,\n\t\t\t    zoom = map.getZoom();\n\t\n\t\t\tdelta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);\n\t\t\tdelta = Math.max(Math.min(delta, 4), -4);\n\t\t\tdelta = map._limitZoom(zoom + delta) - zoom;\n\t\n\t\t\tthis._delta = 0;\n\t\t\tthis._startTime = null;\n\t\n\t\t\tif (!delta) { return; }\n\t\n\t\t\tif (map.options.scrollWheelZoom === 'center') {\n\t\t\t\tmap.setZoom(zoom + delta);\n\t\t\t} else {\n\t\t\t\tmap.setZoomAround(this._lastMousePos, zoom + delta);\n\t\t\t}\n\t\t}\n\t});\n\t\n\tL.Map.addInitHook('addHandler', 'scrollWheelZoom', L.Map.ScrollWheelZoom);\n\t\n\t\n\t/*\r\n\t * Extends the event handling code with double tap support for mobile browsers.\r\n\t */\r\n\t\r\n\tL.extend(L.DomEvent, {\r\n\t\r\n\t\t_touchstart: L.Browser.msPointer ? 'MSPointerDown' : L.Browser.pointer ? 'pointerdown' : 'touchstart',\r\n\t\t_touchend: L.Browser.msPointer ? 'MSPointerUp' : L.Browser.pointer ? 'pointerup' : 'touchend',\r\n\t\r\n\t\t// inspired by Zepto touch code by Thomas Fuchs\r\n\t\taddDoubleTapListener: function (obj, handler, id) {\r\n\t\t\tvar last,\r\n\t\t\t    doubleTap = false,\r\n\t\t\t    delay = 250,\r\n\t\t\t    touch,\r\n\t\t\t    pre = '_leaflet_',\r\n\t\t\t    touchstart = this._touchstart,\r\n\t\t\t    touchend = this._touchend,\r\n\t\t\t    trackedTouches = [];\r\n\t\r\n\t\t\tfunction onTouchStart(e) {\r\n\t\t\t\tvar count;\r\n\t\r\n\t\t\t\tif (L.Browser.pointer) {\r\n\t\t\t\t\ttrackedTouches.push(e.pointerId);\r\n\t\t\t\t\tcount = trackedTouches.length;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcount = e.touches.length;\r\n\t\t\t\t}\r\n\t\t\t\tif (count > 1) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar now = Date.now(),\r\n\t\t\t\t\tdelta = now - (last || now);\r\n\t\r\n\t\t\t\ttouch = e.touches ? e.touches[0] : e;\r\n\t\t\t\tdoubleTap = (delta > 0 && delta <= delay);\r\n\t\t\t\tlast = now;\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction onTouchEnd(e) {\r\n\t\t\t\tif (L.Browser.pointer) {\r\n\t\t\t\t\tvar idx = trackedTouches.indexOf(e.pointerId);\r\n\t\t\t\t\tif (idx === -1) {\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttrackedTouches.splice(idx, 1);\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif (doubleTap) {\r\n\t\t\t\t\tif (L.Browser.pointer) {\r\n\t\t\t\t\t\t// work around .type being readonly with MSPointer* events\r\n\t\t\t\t\t\tvar newTouch = { },\r\n\t\t\t\t\t\t\tprop;\r\n\t\r\n\t\t\t\t\t\t// jshint forin:false\r\n\t\t\t\t\t\tfor (var i in touch) {\r\n\t\t\t\t\t\t\tprop = touch[i];\r\n\t\t\t\t\t\t\tif (typeof prop === 'function') {\r\n\t\t\t\t\t\t\t\tnewTouch[i] = prop.bind(touch);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tnewTouch[i] = prop;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttouch = newTouch;\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttouch.type = 'dblclick';\r\n\t\t\t\t\thandler(touch);\r\n\t\t\t\t\tlast = null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tobj[pre + touchstart + id] = onTouchStart;\r\n\t\t\tobj[pre + touchend + id] = onTouchEnd;\r\n\t\r\n\t\t\t// on pointer we need to listen on the document, otherwise a drag starting on the map and moving off screen\r\n\t\t\t// will not come through to us, so we will lose track of how many touches are ongoing\r\n\t\t\tvar endElement = L.Browser.pointer ? document.documentElement : obj;\r\n\t\r\n\t\t\tobj.addEventListener(touchstart, onTouchStart, false);\r\n\t\t\tendElement.addEventListener(touchend, onTouchEnd, false);\r\n\t\r\n\t\t\tif (L.Browser.pointer) {\r\n\t\t\t\tendElement.addEventListener(L.DomEvent.POINTER_CANCEL, onTouchEnd, false);\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tremoveDoubleTapListener: function (obj, id) {\r\n\t\t\tvar pre = '_leaflet_';\r\n\t\r\n\t\t\tobj.removeEventListener(this._touchstart, obj[pre + this._touchstart + id], false);\r\n\t\t\t(L.Browser.pointer ? document.documentElement : obj).removeEventListener(\r\n\t\t\t        this._touchend, obj[pre + this._touchend + id], false);\r\n\t\r\n\t\t\tif (L.Browser.pointer) {\r\n\t\t\t\tdocument.documentElement.removeEventListener(L.DomEvent.POINTER_CANCEL, obj[pre + this._touchend + id],\r\n\t\t\t\t\tfalse);\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\t}\r\n\t});\r\n\t\n\t\n\t/*\n\t * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.\n\t */\n\t\n\tL.extend(L.DomEvent, {\n\t\n\t\t//static\n\t\tPOINTER_DOWN: L.Browser.msPointer ? 'MSPointerDown' : 'pointerdown',\n\t\tPOINTER_MOVE: L.Browser.msPointer ? 'MSPointerMove' : 'pointermove',\n\t\tPOINTER_UP: L.Browser.msPointer ? 'MSPointerUp' : 'pointerup',\n\t\tPOINTER_CANCEL: L.Browser.msPointer ? 'MSPointerCancel' : 'pointercancel',\n\t\n\t\t_pointers: [],\n\t\t_pointerDocumentListener: false,\n\t\n\t\t// Provides a touch events wrapper for (ms)pointer events.\n\t\t// Based on changes by veproza https://github.com/CloudMade/Leaflet/pull/1019\n\t\t//ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890\n\t\n\t\taddPointerListener: function (obj, type, handler, id) {\n\t\n\t\t\tswitch (type) {\n\t\t\tcase 'touchstart':\n\t\t\t\treturn this.addPointerListenerStart(obj, type, handler, id);\n\t\t\tcase 'touchend':\n\t\t\t\treturn this.addPointerListenerEnd(obj, type, handler, id);\n\t\t\tcase 'touchmove':\n\t\t\t\treturn this.addPointerListenerMove(obj, type, handler, id);\n\t\t\tdefault:\n\t\t\t\tthrow 'Unknown touch event type';\n\t\t\t}\n\t\t},\n\t\n\t\taddPointerListenerStart: function (obj, type, handler, id) {\n\t\t\tvar pre = '_leaflet_',\n\t\t\t    pointers = this._pointers;\n\t\n\t\t\tvar cb = function (e) {\n\t\t\t\tif (e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {\n\t\t\t\t\tL.DomEvent.preventDefault(e);\n\t\t\t\t}\n\t\n\t\t\t\tvar alreadyInArray = false;\n\t\t\t\tfor (var i = 0; i < pointers.length; i++) {\n\t\t\t\t\tif (pointers[i].pointerId === e.pointerId) {\n\t\t\t\t\t\talreadyInArray = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!alreadyInArray) {\n\t\t\t\t\tpointers.push(e);\n\t\t\t\t}\n\t\n\t\t\t\te.touches = pointers.slice();\n\t\t\t\te.changedTouches = [e];\n\t\n\t\t\t\thandler(e);\n\t\t\t};\n\t\n\t\t\tobj[pre + 'touchstart' + id] = cb;\n\t\t\tobj.addEventListener(this.POINTER_DOWN, cb, false);\n\t\n\t\t\t// need to also listen for end events to keep the _pointers list accurate\n\t\t\t// this needs to be on the body and never go away\n\t\t\tif (!this._pointerDocumentListener) {\n\t\t\t\tvar internalCb = function (e) {\n\t\t\t\t\tfor (var i = 0; i < pointers.length; i++) {\n\t\t\t\t\t\tif (pointers[i].pointerId === e.pointerId) {\n\t\t\t\t\t\t\tpointers.splice(i, 1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\t//We listen on the documentElement as any drags that end by moving the touch off the screen get fired there\n\t\t\t\tdocument.documentElement.addEventListener(this.POINTER_UP, internalCb, false);\n\t\t\t\tdocument.documentElement.addEventListener(this.POINTER_CANCEL, internalCb, false);\n\t\n\t\t\t\tthis._pointerDocumentListener = true;\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t},\n\t\n\t\taddPointerListenerMove: function (obj, type, handler, id) {\n\t\t\tvar pre = '_leaflet_',\n\t\t\t    touches = this._pointers;\n\t\n\t\t\tfunction cb(e) {\n\t\n\t\t\t\t// don't fire touch moves when mouse isn't down\n\t\t\t\tif ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }\n\t\n\t\t\t\tfor (var i = 0; i < touches.length; i++) {\n\t\t\t\t\tif (touches[i].pointerId === e.pointerId) {\n\t\t\t\t\t\ttouches[i] = e;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\te.touches = touches.slice();\n\t\t\t\te.changedTouches = [e];\n\t\n\t\t\t\thandler(e);\n\t\t\t}\n\t\n\t\t\tobj[pre + 'touchmove' + id] = cb;\n\t\t\tobj.addEventListener(this.POINTER_MOVE, cb, false);\n\t\n\t\t\treturn this;\n\t\t},\n\t\n\t\taddPointerListenerEnd: function (obj, type, handler, id) {\n\t\t\tvar pre = '_leaflet_',\n\t\t\t    touches = this._pointers;\n\t\n\t\t\tvar cb = function (e) {\n\t\t\t\tfor (var i = 0; i < touches.length; i++) {\n\t\t\t\t\tif (touches[i].pointerId === e.pointerId) {\n\t\t\t\t\t\ttouches.splice(i, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\te.touches = touches.slice();\n\t\t\t\te.changedTouches = [e];\n\t\n\t\t\t\thandler(e);\n\t\t\t};\n\t\n\t\t\tobj[pre + 'touchend' + id] = cb;\n\t\t\tobj.addEventListener(this.POINTER_UP, cb, false);\n\t\t\tobj.addEventListener(this.POINTER_CANCEL, cb, false);\n\t\n\t\t\treturn this;\n\t\t},\n\t\n\t\tremovePointerListener: function (obj, type, id) {\n\t\t\tvar pre = '_leaflet_',\n\t\t\t    cb = obj[pre + type + id];\n\t\n\t\t\tswitch (type) {\n\t\t\tcase 'touchstart':\n\t\t\t\tobj.removeEventListener(this.POINTER_DOWN, cb, false);\n\t\t\t\tbreak;\n\t\t\tcase 'touchmove':\n\t\t\t\tobj.removeEventListener(this.POINTER_MOVE, cb, false);\n\t\t\t\tbreak;\n\t\t\tcase 'touchend':\n\t\t\t\tobj.removeEventListener(this.POINTER_UP, cb, false);\n\t\t\t\tobj.removeEventListener(this.POINTER_CANCEL, cb, false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t}\n\t});\n\t\n\t\n\t/*\n\t * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.\n\t */\n\t\n\tL.Map.mergeOptions({\n\t\ttouchZoom: L.Browser.touch && !L.Browser.android23,\n\t\tbounceAtZoomLimits: true\n\t});\n\t\n\tL.Map.TouchZoom = L.Handler.extend({\n\t\taddHooks: function () {\n\t\t\tL.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);\n\t\t},\n\t\n\t\tremoveHooks: function () {\n\t\t\tL.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);\n\t\t},\n\t\n\t\t_onTouchStart: function (e) {\n\t\t\tvar map = this._map;\n\t\n\t\t\tif (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }\n\t\n\t\t\tvar p1 = map.mouseEventToLayerPoint(e.touches[0]),\n\t\t\t    p2 = map.mouseEventToLayerPoint(e.touches[1]),\n\t\t\t    viewCenter = map._getCenterLayerPoint();\n\t\n\t\t\tthis._startCenter = p1.add(p2)._divideBy(2);\n\t\t\tthis._startDist = p1.distanceTo(p2);\n\t\n\t\t\tthis._moved = false;\n\t\t\tthis._zooming = true;\n\t\n\t\t\tthis._centerOffset = viewCenter.subtract(this._startCenter);\n\t\n\t\t\tif (map._panAnim) {\n\t\t\t\tmap._panAnim.stop();\n\t\t\t}\n\t\n\t\t\tL.DomEvent\n\t\t\t    .on(document, 'touchmove', this._onTouchMove, this)\n\t\t\t    .on(document, 'touchend', this._onTouchEnd, this);\n\t\n\t\t\tL.DomEvent.preventDefault(e);\n\t\t},\n\t\n\t\t_onTouchMove: function (e) {\n\t\t\tvar map = this._map;\n\t\n\t\t\tif (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }\n\t\n\t\t\tvar p1 = map.mouseEventToLayerPoint(e.touches[0]),\n\t\t\t    p2 = map.mouseEventToLayerPoint(e.touches[1]);\n\t\n\t\t\tthis._scale = p1.distanceTo(p2) / this._startDist;\n\t\t\tthis._delta = p1._add(p2)._divideBy(2)._subtract(this._startCenter);\n\t\n\t\t\tif (this._scale === 1) { return; }\n\t\n\t\t\tif (!map.options.bounceAtZoomLimits) {\n\t\t\t\tif ((map.getZoom() === map.getMinZoom() && this._scale < 1) ||\n\t\t\t\t    (map.getZoom() === map.getMaxZoom() && this._scale > 1)) { return; }\n\t\t\t}\n\t\n\t\t\tif (!this._moved) {\n\t\t\t\tL.DomUtil.addClass(map._mapPane, 'leaflet-touching');\n\t\n\t\t\t\tmap\n\t\t\t\t    .fire('movestart')\n\t\t\t\t    .fire('zoomstart');\n\t\n\t\t\t\tthis._moved = true;\n\t\t\t}\n\t\n\t\t\tL.Util.cancelAnimFrame(this._animRequest);\n\t\t\tthis._animRequest = L.Util.requestAnimFrame(\n\t\t\t        this._updateOnMove, this, true, this._map._container);\n\t\n\t\t\tL.DomEvent.preventDefault(e);\n\t\t},\n\t\n\t\t_updateOnMove: function () {\n\t\t\tvar map = this._map,\n\t\t\t    origin = this._getScaleOrigin(),\n\t\t\t    center = map.layerPointToLatLng(origin),\n\t\t\t    zoom = map.getScaleZoom(this._scale);\n\t\n\t\t\tmap._animateZoom(center, zoom, this._startCenter, this._scale, this._delta, false, true);\n\t\t},\n\t\n\t\t_onTouchEnd: function () {\n\t\t\tif (!this._moved || !this._zooming) {\n\t\t\t\tthis._zooming = false;\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tvar map = this._map;\n\t\n\t\t\tthis._zooming = false;\n\t\t\tL.DomUtil.removeClass(map._mapPane, 'leaflet-touching');\n\t\t\tL.Util.cancelAnimFrame(this._animRequest);\n\t\n\t\t\tL.DomEvent\n\t\t\t    .off(document, 'touchmove', this._onTouchMove)\n\t\t\t    .off(document, 'touchend', this._onTouchEnd);\n\t\n\t\t\tvar origin = this._getScaleOrigin(),\n\t\t\t    center = map.layerPointToLatLng(origin),\n\t\n\t\t\t    oldZoom = map.getZoom(),\n\t\t\t    floatZoomDelta = map.getScaleZoom(this._scale) - oldZoom,\n\t\t\t    roundZoomDelta = (floatZoomDelta > 0 ?\n\t\t\t            Math.ceil(floatZoomDelta) : Math.floor(floatZoomDelta)),\n\t\n\t\t\t    zoom = map._limitZoom(oldZoom + roundZoomDelta),\n\t\t\t    scale = map.getZoomScale(zoom) / this._scale;\n\t\n\t\t\tmap._animateZoom(center, zoom, origin, scale);\n\t\t},\n\t\n\t\t_getScaleOrigin: function () {\n\t\t\tvar centerOffset = this._centerOffset.subtract(this._delta).divideBy(this._scale);\n\t\t\treturn this._startCenter.add(centerOffset);\n\t\t}\n\t});\n\t\n\tL.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);\n\t\n\t\n\t/*\n\t * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.\n\t */\n\t\n\tL.Map.mergeOptions({\n\t\ttap: true,\n\t\ttapTolerance: 15\n\t});\n\t\n\tL.Map.Tap = L.Handler.extend({\n\t\taddHooks: function () {\n\t\t\tL.DomEvent.on(this._map._container, 'touchstart', this._onDown, this);\n\t\t},\n\t\n\t\tremoveHooks: function () {\n\t\t\tL.DomEvent.off(this._map._container, 'touchstart', this._onDown, this);\n\t\t},\n\t\n\t\t_onDown: function (e) {\n\t\t\tif (!e.touches) { return; }\n\t\n\t\t\tL.DomEvent.preventDefault(e);\n\t\n\t\t\tthis._fireClick = true;\n\t\n\t\t\t// don't simulate click or track longpress if more than 1 touch\n\t\t\tif (e.touches.length > 1) {\n\t\t\t\tthis._fireClick = false;\n\t\t\t\tclearTimeout(this._holdTimeout);\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tvar first = e.touches[0],\n\t\t\t    el = first.target;\n\t\n\t\t\tthis._startPos = this._newPos = new L.Point(first.clientX, first.clientY);\n\t\n\t\t\t// if touching a link, highlight it\n\t\t\tif (el.tagName && el.tagName.toLowerCase() === 'a') {\n\t\t\t\tL.DomUtil.addClass(el, 'leaflet-active');\n\t\t\t}\n\t\n\t\t\t// simulate long hold but setting a timeout\n\t\t\tthis._holdTimeout = setTimeout(L.bind(function () {\n\t\t\t\tif (this._isTapValid()) {\n\t\t\t\t\tthis._fireClick = false;\n\t\t\t\t\tthis._onUp();\n\t\t\t\t\tthis._simulateEvent('contextmenu', first);\n\t\t\t\t}\n\t\t\t}, this), 1000);\n\t\n\t\t\tL.DomEvent\n\t\t\t\t.on(document, 'touchmove', this._onMove, this)\n\t\t\t\t.on(document, 'touchend', this._onUp, this);\n\t\t},\n\t\n\t\t_onUp: function (e) {\n\t\t\tclearTimeout(this._holdTimeout);\n\t\n\t\t\tL.DomEvent\n\t\t\t\t.off(document, 'touchmove', this._onMove, this)\n\t\t\t\t.off(document, 'touchend', this._onUp, this);\n\t\n\t\t\tif (this._fireClick && e && e.changedTouches) {\n\t\n\t\t\t\tvar first = e.changedTouches[0],\n\t\t\t\t    el = first.target;\n\t\n\t\t\t\tif (el && el.tagName && el.tagName.toLowerCase() === 'a') {\n\t\t\t\t\tL.DomUtil.removeClass(el, 'leaflet-active');\n\t\t\t\t}\n\t\n\t\t\t\t// simulate click if the touch didn't move too much\n\t\t\t\tif (this._isTapValid()) {\n\t\t\t\t\tthis._simulateEvent('click', first);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\t_isTapValid: function () {\n\t\t\treturn this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;\n\t\t},\n\t\n\t\t_onMove: function (e) {\n\t\t\tvar first = e.touches[0];\n\t\t\tthis._newPos = new L.Point(first.clientX, first.clientY);\n\t\t},\n\t\n\t\t_simulateEvent: function (type, e) {\n\t\t\tvar simulatedEvent = document.createEvent('MouseEvents');\n\t\n\t\t\tsimulatedEvent._simulated = true;\n\t\t\te.target._simulatedClick = true;\n\t\n\t\t\tsimulatedEvent.initMouseEvent(\n\t\t\t        type, true, true, window, 1,\n\t\t\t        e.screenX, e.screenY,\n\t\t\t        e.clientX, e.clientY,\n\t\t\t        false, false, false, false, 0, null);\n\t\n\t\t\te.target.dispatchEvent(simulatedEvent);\n\t\t}\n\t});\n\t\n\tif (L.Browser.touch && !L.Browser.pointer) {\n\t\tL.Map.addInitHook('addHandler', 'tap', L.Map.Tap);\n\t}\n\t\n\t\n\t/*\n\t * L.Handler.ShiftDragZoom is used to add shift-drag zoom interaction to the map\n\t  * (zoom to a selected bounding box), enabled by default.\n\t */\n\t\n\tL.Map.mergeOptions({\n\t\tboxZoom: true\n\t});\n\t\n\tL.Map.BoxZoom = L.Handler.extend({\n\t\tinitialize: function (map) {\n\t\t\tthis._map = map;\n\t\t\tthis._container = map._container;\n\t\t\tthis._pane = map._panes.overlayPane;\n\t\t\tthis._moved = false;\n\t\t},\n\t\n\t\taddHooks: function () {\n\t\t\tL.DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);\n\t\t},\n\t\n\t\tremoveHooks: function () {\n\t\t\tL.DomEvent.off(this._container, 'mousedown', this._onMouseDown);\n\t\t\tthis._moved = false;\n\t\t},\n\t\n\t\tmoved: function () {\n\t\t\treturn this._moved;\n\t\t},\n\t\n\t\t_onMouseDown: function (e) {\n\t\t\tthis._moved = false;\n\t\n\t\t\tif (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }\n\t\n\t\t\tL.DomUtil.disableTextSelection();\n\t\t\tL.DomUtil.disableImageDrag();\n\t\n\t\t\tthis._startLayerPoint = this._map.mouseEventToLayerPoint(e);\n\t\n\t\t\tL.DomEvent\n\t\t\t    .on(document, 'mousemove', this._onMouseMove, this)\n\t\t\t    .on(document, 'mouseup', this._onMouseUp, this)\n\t\t\t    .on(document, 'keydown', this._onKeyDown, this);\n\t\t},\n\t\n\t\t_onMouseMove: function (e) {\n\t\t\tif (!this._moved) {\n\t\t\t\tthis._box = L.DomUtil.create('div', 'leaflet-zoom-box', this._pane);\n\t\t\t\tL.DomUtil.setPosition(this._box, this._startLayerPoint);\n\t\n\t\t\t\t//TODO refactor: move cursor to styles\n\t\t\t\tthis._container.style.cursor = 'crosshair';\n\t\t\t\tthis._map.fire('boxzoomstart');\n\t\t\t}\n\t\n\t\t\tvar startPoint = this._startLayerPoint,\n\t\t\t    box = this._box,\n\t\n\t\t\t    layerPoint = this._map.mouseEventToLayerPoint(e),\n\t\t\t    offset = layerPoint.subtract(startPoint),\n\t\n\t\t\t    newPos = new L.Point(\n\t\t\t        Math.min(layerPoint.x, startPoint.x),\n\t\t\t        Math.min(layerPoint.y, startPoint.y));\n\t\n\t\t\tL.DomUtil.setPosition(box, newPos);\n\t\n\t\t\tthis._moved = true;\n\t\n\t\t\t// TODO refactor: remove hardcoded 4 pixels\n\t\t\tbox.style.width  = (Math.max(0, Math.abs(offset.x) - 4)) + 'px';\n\t\t\tbox.style.height = (Math.max(0, Math.abs(offset.y) - 4)) + 'px';\n\t\t},\n\t\n\t\t_finish: function () {\n\t\t\tif (this._moved) {\n\t\t\t\tthis._pane.removeChild(this._box);\n\t\t\t\tthis._container.style.cursor = '';\n\t\t\t}\n\t\n\t\t\tL.DomUtil.enableTextSelection();\n\t\t\tL.DomUtil.enableImageDrag();\n\t\n\t\t\tL.DomEvent\n\t\t\t    .off(document, 'mousemove', this._onMouseMove)\n\t\t\t    .off(document, 'mouseup', this._onMouseUp)\n\t\t\t    .off(document, 'keydown', this._onKeyDown);\n\t\t},\n\t\n\t\t_onMouseUp: function (e) {\n\t\n\t\t\tthis._finish();\n\t\n\t\t\tvar map = this._map,\n\t\t\t    layerPoint = map.mouseEventToLayerPoint(e);\n\t\n\t\t\tif (this._startLayerPoint.equals(layerPoint)) { return; }\n\t\n\t\t\tvar bounds = new L.LatLngBounds(\n\t\t\t        map.layerPointToLatLng(this._startLayerPoint),\n\t\t\t        map.layerPointToLatLng(layerPoint));\n\t\n\t\t\tmap.fitBounds(bounds);\n\t\n\t\t\tmap.fire('boxzoomend', {\n\t\t\t\tboxZoomBounds: bounds\n\t\t\t});\n\t\t},\n\t\n\t\t_onKeyDown: function (e) {\n\t\t\tif (e.keyCode === 27) {\n\t\t\t\tthis._finish();\n\t\t\t}\n\t\t}\n\t});\n\t\n\tL.Map.addInitHook('addHandler', 'boxZoom', L.Map.BoxZoom);\n\t\n\t\n\t/*\n\t * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.\n\t */\n\t\n\tL.Map.mergeOptions({\n\t\tkeyboard: true,\n\t\tkeyboardPanOffset: 80,\n\t\tkeyboardZoomOffset: 1\n\t});\n\t\n\tL.Map.Keyboard = L.Handler.extend({\n\t\n\t\tkeyCodes: {\n\t\t\tleft:    [37],\n\t\t\tright:   [39],\n\t\t\tdown:    [40],\n\t\t\tup:      [38],\n\t\t\tzoomIn:  [187, 107, 61, 171],\n\t\t\tzoomOut: [189, 109, 173]\n\t\t},\n\t\n\t\tinitialize: function (map) {\n\t\t\tthis._map = map;\n\t\n\t\t\tthis._setPanOffset(map.options.keyboardPanOffset);\n\t\t\tthis._setZoomOffset(map.options.keyboardZoomOffset);\n\t\t},\n\t\n\t\taddHooks: function () {\n\t\t\tvar container = this._map._container;\n\t\n\t\t\t// make the container focusable by tabbing\n\t\t\tif (container.tabIndex === -1) {\n\t\t\t\tcontainer.tabIndex = '0';\n\t\t\t}\n\t\n\t\t\tL.DomEvent\n\t\t\t    .on(container, 'focus', this._onFocus, this)\n\t\t\t    .on(container, 'blur', this._onBlur, this)\n\t\t\t    .on(container, 'mousedown', this._onMouseDown, this);\n\t\n\t\t\tthis._map\n\t\t\t    .on('focus', this._addHooks, this)\n\t\t\t    .on('blur', this._removeHooks, this);\n\t\t},\n\t\n\t\tremoveHooks: function () {\n\t\t\tthis._removeHooks();\n\t\n\t\t\tvar container = this._map._container;\n\t\n\t\t\tL.DomEvent\n\t\t\t    .off(container, 'focus', this._onFocus, this)\n\t\t\t    .off(container, 'blur', this._onBlur, this)\n\t\t\t    .off(container, 'mousedown', this._onMouseDown, this);\n\t\n\t\t\tthis._map\n\t\t\t    .off('focus', this._addHooks, this)\n\t\t\t    .off('blur', this._removeHooks, this);\n\t\t},\n\t\n\t\t_onMouseDown: function () {\n\t\t\tif (this._focused) { return; }\n\t\n\t\t\tvar body = document.body,\n\t\t\t    docEl = document.documentElement,\n\t\t\t    top = body.scrollTop || docEl.scrollTop,\n\t\t\t    left = body.scrollLeft || docEl.scrollLeft;\n\t\n\t\t\tthis._map._container.focus();\n\t\n\t\t\twindow.scrollTo(left, top);\n\t\t},\n\t\n\t\t_onFocus: function () {\n\t\t\tthis._focused = true;\n\t\t\tthis._map.fire('focus');\n\t\t},\n\t\n\t\t_onBlur: function () {\n\t\t\tthis._focused = false;\n\t\t\tthis._map.fire('blur');\n\t\t},\n\t\n\t\t_setPanOffset: function (pan) {\n\t\t\tvar keys = this._panKeys = {},\n\t\t\t    codes = this.keyCodes,\n\t\t\t    i, len;\n\t\n\t\t\tfor (i = 0, len = codes.left.length; i < len; i++) {\n\t\t\t\tkeys[codes.left[i]] = [-1 * pan, 0];\n\t\t\t}\n\t\t\tfor (i = 0, len = codes.right.length; i < len; i++) {\n\t\t\t\tkeys[codes.right[i]] = [pan, 0];\n\t\t\t}\n\t\t\tfor (i = 0, len = codes.down.length; i < len; i++) {\n\t\t\t\tkeys[codes.down[i]] = [0, pan];\n\t\t\t}\n\t\t\tfor (i = 0, len = codes.up.length; i < len; i++) {\n\t\t\t\tkeys[codes.up[i]] = [0, -1 * pan];\n\t\t\t}\n\t\t},\n\t\n\t\t_setZoomOffset: function (zoom) {\n\t\t\tvar keys = this._zoomKeys = {},\n\t\t\t    codes = this.keyCodes,\n\t\t\t    i, len;\n\t\n\t\t\tfor (i = 0, len = codes.zoomIn.length; i < len; i++) {\n\t\t\t\tkeys[codes.zoomIn[i]] = zoom;\n\t\t\t}\n\t\t\tfor (i = 0, len = codes.zoomOut.length; i < len; i++) {\n\t\t\t\tkeys[codes.zoomOut[i]] = -zoom;\n\t\t\t}\n\t\t},\n\t\n\t\t_addHooks: function () {\n\t\t\tL.DomEvent.on(document, 'keydown', this._onKeyDown, this);\n\t\t},\n\t\n\t\t_removeHooks: function () {\n\t\t\tL.DomEvent.off(document, 'keydown', this._onKeyDown, this);\n\t\t},\n\t\n\t\t_onKeyDown: function (e) {\n\t\t\tvar key = e.keyCode,\n\t\t\t    map = this._map;\n\t\n\t\t\tif (key in this._panKeys) {\n\t\n\t\t\t\tif (map._panAnim && map._panAnim._inProgress) { return; }\n\t\n\t\t\t\tmap.panBy(this._panKeys[key]);\n\t\n\t\t\t\tif (map.options.maxBounds) {\n\t\t\t\t\tmap.panInsideBounds(map.options.maxBounds);\n\t\t\t\t}\n\t\n\t\t\t} else if (key in this._zoomKeys) {\n\t\t\t\tmap.setZoom(map.getZoom() + this._zoomKeys[key]);\n\t\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tL.DomEvent.stop(e);\n\t\t}\n\t});\n\t\n\tL.Map.addInitHook('addHandler', 'keyboard', L.Map.Keyboard);\n\t\n\t\n\t/*\n\t * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.\n\t */\n\t\n\tL.Handler.MarkerDrag = L.Handler.extend({\n\t\tinitialize: function (marker) {\n\t\t\tthis._marker = marker;\n\t\t},\n\t\n\t\taddHooks: function () {\n\t\t\tvar icon = this._marker._icon;\n\t\t\tif (!this._draggable) {\n\t\t\t\tthis._draggable = new L.Draggable(icon, icon);\n\t\t\t}\n\t\n\t\t\tthis._draggable\n\t\t\t\t.on('dragstart', this._onDragStart, this)\n\t\t\t\t.on('drag', this._onDrag, this)\n\t\t\t\t.on('dragend', this._onDragEnd, this);\n\t\t\tthis._draggable.enable();\n\t\t\tL.DomUtil.addClass(this._marker._icon, 'leaflet-marker-draggable');\n\t\t},\n\t\n\t\tremoveHooks: function () {\n\t\t\tthis._draggable\n\t\t\t\t.off('dragstart', this._onDragStart, this)\n\t\t\t\t.off('drag', this._onDrag, this)\n\t\t\t\t.off('dragend', this._onDragEnd, this);\n\t\n\t\t\tthis._draggable.disable();\n\t\t\tL.DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');\n\t\t},\n\t\n\t\tmoved: function () {\n\t\t\treturn this._draggable && this._draggable._moved;\n\t\t},\n\t\n\t\t_onDragStart: function () {\n\t\t\tthis._marker\n\t\t\t    .closePopup()\n\t\t\t    .fire('movestart')\n\t\t\t    .fire('dragstart');\n\t\t},\n\t\n\t\t_onDrag: function () {\n\t\t\tvar marker = this._marker,\n\t\t\t    shadow = marker._shadow,\n\t\t\t    iconPos = L.DomUtil.getPosition(marker._icon),\n\t\t\t    latlng = marker._map.layerPointToLatLng(iconPos);\n\t\n\t\t\t// update shadow position\n\t\t\tif (shadow) {\n\t\t\t\tL.DomUtil.setPosition(shadow, iconPos);\n\t\t\t}\n\t\n\t\t\tmarker._latlng = latlng;\n\t\n\t\t\tmarker\n\t\t\t    .fire('move', {latlng: latlng})\n\t\t\t    .fire('drag');\n\t\t},\n\t\n\t\t_onDragEnd: function (e) {\n\t\t\tthis._marker\n\t\t\t    .fire('moveend')\n\t\t\t    .fire('dragend', e);\n\t\t}\n\t});\n\t\n\t\n\t/*\r\n\t * L.Control is a base class for implementing map controls. Handles positioning.\r\n\t * All other controls extend from this class.\r\n\t */\r\n\t\r\n\tL.Control = L.Class.extend({\r\n\t\toptions: {\r\n\t\t\tposition: 'topright'\r\n\t\t},\r\n\t\r\n\t\tinitialize: function (options) {\r\n\t\t\tL.setOptions(this, options);\r\n\t\t},\r\n\t\r\n\t\tgetPosition: function () {\r\n\t\t\treturn this.options.position;\r\n\t\t},\r\n\t\r\n\t\tsetPosition: function (position) {\r\n\t\t\tvar map = this._map;\r\n\t\r\n\t\t\tif (map) {\r\n\t\t\t\tmap.removeControl(this);\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.options.position = position;\r\n\t\r\n\t\t\tif (map) {\r\n\t\t\t\tmap.addControl(this);\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tgetContainer: function () {\r\n\t\t\treturn this._container;\r\n\t\t},\r\n\t\r\n\t\taddTo: function (map) {\r\n\t\t\tthis._map = map;\r\n\t\r\n\t\t\tvar container = this._container = this.onAdd(map),\r\n\t\t\t    pos = this.getPosition(),\r\n\t\t\t    corner = map._controlCorners[pos];\r\n\t\r\n\t\t\tL.DomUtil.addClass(container, 'leaflet-control');\r\n\t\r\n\t\t\tif (pos.indexOf('bottom') !== -1) {\r\n\t\t\t\tcorner.insertBefore(container, corner.firstChild);\r\n\t\t\t} else {\r\n\t\t\t\tcorner.appendChild(container);\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tremoveFrom: function (map) {\r\n\t\t\tvar pos = this.getPosition(),\r\n\t\t\t    corner = map._controlCorners[pos];\r\n\t\r\n\t\t\tcorner.removeChild(this._container);\r\n\t\t\tthis._map = null;\r\n\t\r\n\t\t\tif (this.onRemove) {\r\n\t\t\t\tthis.onRemove(map);\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\t_refocusOnMap: function () {\r\n\t\t\tif (this._map) {\r\n\t\t\t\tthis._map.getContainer().focus();\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\t\r\n\tL.control = function (options) {\r\n\t\treturn new L.Control(options);\r\n\t};\r\n\t\r\n\t\r\n\t// adds control-related methods to L.Map\r\n\t\r\n\tL.Map.include({\r\n\t\taddControl: function (control) {\r\n\t\t\tcontrol.addTo(this);\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tremoveControl: function (control) {\r\n\t\t\tcontrol.removeFrom(this);\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\t_initControlPos: function () {\r\n\t\t\tvar corners = this._controlCorners = {},\r\n\t\t\t    l = 'leaflet-',\r\n\t\t\t    container = this._controlContainer =\r\n\t\t\t            L.DomUtil.create('div', l + 'control-container', this._container);\r\n\t\r\n\t\t\tfunction createCorner(vSide, hSide) {\r\n\t\t\t\tvar className = l + vSide + ' ' + l + hSide;\r\n\t\r\n\t\t\t\tcorners[vSide + hSide] = L.DomUtil.create('div', className, container);\r\n\t\t\t}\r\n\t\r\n\t\t\tcreateCorner('top', 'left');\r\n\t\t\tcreateCorner('top', 'right');\r\n\t\t\tcreateCorner('bottom', 'left');\r\n\t\t\tcreateCorner('bottom', 'right');\r\n\t\t},\r\n\t\r\n\t\t_clearControlPos: function () {\r\n\t\t\tthis._container.removeChild(this._controlContainer);\r\n\t\t}\r\n\t});\r\n\t\n\t\n\t/*\r\n\t * L.Control.Zoom is used for the default zoom buttons on the map.\r\n\t */\r\n\t\r\n\tL.Control.Zoom = L.Control.extend({\r\n\t\toptions: {\r\n\t\t\tposition: 'topleft',\r\n\t\t\tzoomInText: '+',\r\n\t\t\tzoomInTitle: 'Zoom in',\r\n\t\t\tzoomOutText: '-',\r\n\t\t\tzoomOutTitle: 'Zoom out'\r\n\t\t},\r\n\t\r\n\t\tonAdd: function (map) {\r\n\t\t\tvar zoomName = 'leaflet-control-zoom',\r\n\t\t\t    container = L.DomUtil.create('div', zoomName + ' leaflet-bar');\r\n\t\r\n\t\t\tthis._map = map;\r\n\t\r\n\t\t\tthis._zoomInButton  = this._createButton(\r\n\t\t\t        this.options.zoomInText, this.options.zoomInTitle,\r\n\t\t\t        zoomName + '-in',  container, this._zoomIn,  this);\r\n\t\t\tthis._zoomOutButton = this._createButton(\r\n\t\t\t        this.options.zoomOutText, this.options.zoomOutTitle,\r\n\t\t\t        zoomName + '-out', container, this._zoomOut, this);\r\n\t\r\n\t\t\tthis._updateDisabled();\r\n\t\t\tmap.on('zoomend zoomlevelschange', this._updateDisabled, this);\r\n\t\r\n\t\t\treturn container;\r\n\t\t},\r\n\t\r\n\t\tonRemove: function (map) {\r\n\t\t\tmap.off('zoomend zoomlevelschange', this._updateDisabled, this);\r\n\t\t},\r\n\t\r\n\t\t_zoomIn: function (e) {\r\n\t\t\tthis._map.zoomIn(e.shiftKey ? 3 : 1);\r\n\t\t},\r\n\t\r\n\t\t_zoomOut: function (e) {\r\n\t\t\tthis._map.zoomOut(e.shiftKey ? 3 : 1);\r\n\t\t},\r\n\t\r\n\t\t_createButton: function (html, title, className, container, fn, context) {\r\n\t\t\tvar link = L.DomUtil.create('a', className, container);\r\n\t\t\tlink.innerHTML = html;\r\n\t\t\tlink.href = '#';\r\n\t\t\tlink.title = title;\r\n\t\r\n\t\t\tvar stop = L.DomEvent.stopPropagation;\r\n\t\r\n\t\t\tL.DomEvent\r\n\t\t\t    .on(link, 'click', stop)\r\n\t\t\t    .on(link, 'mousedown', stop)\r\n\t\t\t    .on(link, 'dblclick', stop)\r\n\t\t\t    .on(link, 'click', L.DomEvent.preventDefault)\r\n\t\t\t    .on(link, 'click', fn, context)\r\n\t\t\t    .on(link, 'click', this._refocusOnMap, context);\r\n\t\r\n\t\t\treturn link;\r\n\t\t},\r\n\t\r\n\t\t_updateDisabled: function () {\r\n\t\t\tvar map = this._map,\r\n\t\t\t\tclassName = 'leaflet-disabled';\r\n\t\r\n\t\t\tL.DomUtil.removeClass(this._zoomInButton, className);\r\n\t\t\tL.DomUtil.removeClass(this._zoomOutButton, className);\r\n\t\r\n\t\t\tif (map._zoom === map.getMinZoom()) {\r\n\t\t\t\tL.DomUtil.addClass(this._zoomOutButton, className);\r\n\t\t\t}\r\n\t\t\tif (map._zoom === map.getMaxZoom()) {\r\n\t\t\t\tL.DomUtil.addClass(this._zoomInButton, className);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\t\r\n\tL.Map.mergeOptions({\r\n\t\tzoomControl: true\r\n\t});\r\n\t\r\n\tL.Map.addInitHook(function () {\r\n\t\tif (this.options.zoomControl) {\r\n\t\t\tthis.zoomControl = new L.Control.Zoom();\r\n\t\t\tthis.addControl(this.zoomControl);\r\n\t\t}\r\n\t});\r\n\t\r\n\tL.control.zoom = function (options) {\r\n\t\treturn new L.Control.Zoom(options);\r\n\t};\r\n\t\r\n\t\n\t\n\t/*\r\n\t * L.Control.Attribution is used for displaying attribution on the map (added by default).\r\n\t */\r\n\t\r\n\tL.Control.Attribution = L.Control.extend({\r\n\t\toptions: {\r\n\t\t\tposition: 'bottomright',\r\n\t\t\tprefix: '<a href=\"http://leafletjs.com\" title=\"A JS library for interactive maps\">Leaflet</a>'\r\n\t\t},\r\n\t\r\n\t\tinitialize: function (options) {\r\n\t\t\tL.setOptions(this, options);\r\n\t\r\n\t\t\tthis._attributions = {};\r\n\t\t},\r\n\t\r\n\t\tonAdd: function (map) {\r\n\t\t\tthis._container = L.DomUtil.create('div', 'leaflet-control-attribution');\r\n\t\t\tL.DomEvent.disableClickPropagation(this._container);\r\n\t\r\n\t\t\tfor (var i in map._layers) {\r\n\t\t\t\tif (map._layers[i].getAttribution) {\r\n\t\t\t\t\tthis.addAttribution(map._layers[i].getAttribution());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tmap\r\n\t\t\t    .on('layeradd', this._onLayerAdd, this)\r\n\t\t\t    .on('layerremove', this._onLayerRemove, this);\r\n\t\r\n\t\t\tthis._update();\r\n\t\r\n\t\t\treturn this._container;\r\n\t\t},\r\n\t\r\n\t\tonRemove: function (map) {\r\n\t\t\tmap\r\n\t\t\t    .off('layeradd', this._onLayerAdd)\r\n\t\t\t    .off('layerremove', this._onLayerRemove);\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetPrefix: function (prefix) {\r\n\t\t\tthis.options.prefix = prefix;\r\n\t\t\tthis._update();\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\taddAttribution: function (text) {\r\n\t\t\tif (!text) { return; }\r\n\t\r\n\t\t\tif (!this._attributions[text]) {\r\n\t\t\t\tthis._attributions[text] = 0;\r\n\t\t\t}\r\n\t\t\tthis._attributions[text]++;\r\n\t\r\n\t\t\tthis._update();\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tremoveAttribution: function (text) {\r\n\t\t\tif (!text) { return; }\r\n\t\r\n\t\t\tif (this._attributions[text]) {\r\n\t\t\t\tthis._attributions[text]--;\r\n\t\t\t\tthis._update();\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\t_update: function () {\r\n\t\t\tif (!this._map) { return; }\r\n\t\r\n\t\t\tvar attribs = [];\r\n\t\r\n\t\t\tfor (var i in this._attributions) {\r\n\t\t\t\tif (this._attributions[i]) {\r\n\t\t\t\t\tattribs.push(i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\tvar prefixAndAttribs = [];\r\n\t\r\n\t\t\tif (this.options.prefix) {\r\n\t\t\t\tprefixAndAttribs.push(this.options.prefix);\r\n\t\t\t}\r\n\t\t\tif (attribs.length) {\r\n\t\t\t\tprefixAndAttribs.push(attribs.join(', '));\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._container.innerHTML = prefixAndAttribs.join(' | ');\r\n\t\t},\r\n\t\r\n\t\t_onLayerAdd: function (e) {\r\n\t\t\tif (e.layer.getAttribution) {\r\n\t\t\t\tthis.addAttribution(e.layer.getAttribution());\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_onLayerRemove: function (e) {\r\n\t\t\tif (e.layer.getAttribution) {\r\n\t\t\t\tthis.removeAttribution(e.layer.getAttribution());\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\t\r\n\tL.Map.mergeOptions({\r\n\t\tattributionControl: true\r\n\t});\r\n\t\r\n\tL.Map.addInitHook(function () {\r\n\t\tif (this.options.attributionControl) {\r\n\t\t\tthis.attributionControl = (new L.Control.Attribution()).addTo(this);\r\n\t\t}\r\n\t});\r\n\t\r\n\tL.control.attribution = function (options) {\r\n\t\treturn new L.Control.Attribution(options);\r\n\t};\r\n\t\n\t\n\t/*\n\t * L.Control.Scale is used for displaying metric/imperial scale on the map.\n\t */\n\t\n\tL.Control.Scale = L.Control.extend({\n\t\toptions: {\n\t\t\tposition: 'bottomleft',\n\t\t\tmaxWidth: 100,\n\t\t\tmetric: true,\n\t\t\timperial: true,\n\t\t\tupdateWhenIdle: false\n\t\t},\n\t\n\t\tonAdd: function (map) {\n\t\t\tthis._map = map;\n\t\n\t\t\tvar className = 'leaflet-control-scale',\n\t\t\t    container = L.DomUtil.create('div', className),\n\t\t\t    options = this.options;\n\t\n\t\t\tthis._addScales(options, className, container);\n\t\n\t\t\tmap.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n\t\t\tmap.whenReady(this._update, this);\n\t\n\t\t\treturn container;\n\t\t},\n\t\n\t\tonRemove: function (map) {\n\t\t\tmap.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n\t\t},\n\t\n\t\t_addScales: function (options, className, container) {\n\t\t\tif (options.metric) {\n\t\t\t\tthis._mScale = L.DomUtil.create('div', className + '-line', container);\n\t\t\t}\n\t\t\tif (options.imperial) {\n\t\t\t\tthis._iScale = L.DomUtil.create('div', className + '-line', container);\n\t\t\t}\n\t\t},\n\t\n\t\t_update: function () {\n\t\t\tvar bounds = this._map.getBounds(),\n\t\t\t    centerLat = bounds.getCenter().lat,\n\t\t\t    halfWorldMeters = 6378137 * Math.PI * Math.cos(centerLat * Math.PI / 180),\n\t\t\t    dist = halfWorldMeters * (bounds.getNorthEast().lng - bounds.getSouthWest().lng) / 180,\n\t\n\t\t\t    size = this._map.getSize(),\n\t\t\t    options = this.options,\n\t\t\t    maxMeters = 0;\n\t\n\t\t\tif (size.x > 0) {\n\t\t\t\tmaxMeters = dist * (options.maxWidth / size.x);\n\t\t\t}\n\t\n\t\t\tthis._updateScales(options, maxMeters);\n\t\t},\n\t\n\t\t_updateScales: function (options, maxMeters) {\n\t\t\tif (options.metric && maxMeters) {\n\t\t\t\tthis._updateMetric(maxMeters);\n\t\t\t}\n\t\n\t\t\tif (options.imperial && maxMeters) {\n\t\t\t\tthis._updateImperial(maxMeters);\n\t\t\t}\n\t\t},\n\t\n\t\t_updateMetric: function (maxMeters) {\n\t\t\tvar meters = this._getRoundNum(maxMeters);\n\t\n\t\t\tthis._mScale.style.width = this._getScaleWidth(meters / maxMeters) + 'px';\n\t\t\tthis._mScale.innerHTML = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';\n\t\t},\n\t\n\t\t_updateImperial: function (maxMeters) {\n\t\t\tvar maxFeet = maxMeters * 3.2808399,\n\t\t\t    scale = this._iScale,\n\t\t\t    maxMiles, miles, feet;\n\t\n\t\t\tif (maxFeet > 5280) {\n\t\t\t\tmaxMiles = maxFeet / 5280;\n\t\t\t\tmiles = this._getRoundNum(maxMiles);\n\t\n\t\t\t\tscale.style.width = this._getScaleWidth(miles / maxMiles) + 'px';\n\t\t\t\tscale.innerHTML = miles + ' mi';\n\t\n\t\t\t} else {\n\t\t\t\tfeet = this._getRoundNum(maxFeet);\n\t\n\t\t\t\tscale.style.width = this._getScaleWidth(feet / maxFeet) + 'px';\n\t\t\t\tscale.innerHTML = feet + ' ft';\n\t\t\t}\n\t\t},\n\t\n\t\t_getScaleWidth: function (ratio) {\n\t\t\treturn Math.round(this.options.maxWidth * ratio) - 10;\n\t\t},\n\t\n\t\t_getRoundNum: function (num) {\n\t\t\tvar pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),\n\t\t\t    d = num / pow10;\n\t\n\t\t\td = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;\n\t\n\t\t\treturn pow10 * d;\n\t\t}\n\t});\n\t\n\tL.control.scale = function (options) {\n\t\treturn new L.Control.Scale(options);\n\t};\n\t\n\t\n\t/*\r\n\t * L.Control.Layers is a control to allow users to switch between different layers on the map.\r\n\t */\r\n\t\r\n\tL.Control.Layers = L.Control.extend({\r\n\t\toptions: {\r\n\t\t\tcollapsed: true,\r\n\t\t\tposition: 'topright',\r\n\t\t\tautoZIndex: true\r\n\t\t},\r\n\t\r\n\t\tinitialize: function (baseLayers, overlays, options) {\r\n\t\t\tL.setOptions(this, options);\r\n\t\r\n\t\t\tthis._layers = {};\r\n\t\t\tthis._lastZIndex = 0;\r\n\t\t\tthis._handlingClick = false;\r\n\t\r\n\t\t\tfor (var i in baseLayers) {\r\n\t\t\t\tthis._addLayer(baseLayers[i], i);\r\n\t\t\t}\r\n\t\r\n\t\t\tfor (i in overlays) {\r\n\t\t\t\tthis._addLayer(overlays[i], i, true);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\tonAdd: function (map) {\r\n\t\t\tthis._initLayout();\r\n\t\t\tthis._update();\r\n\t\r\n\t\t\tmap\r\n\t\t\t    .on('layeradd', this._onLayerChange, this)\r\n\t\t\t    .on('layerremove', this._onLayerChange, this);\r\n\t\r\n\t\t\treturn this._container;\r\n\t\t},\r\n\t\r\n\t\tonRemove: function (map) {\r\n\t\t\tmap\r\n\t\t\t    .off('layeradd', this._onLayerChange, this)\r\n\t\t\t    .off('layerremove', this._onLayerChange, this);\r\n\t\t},\r\n\t\r\n\t\taddBaseLayer: function (layer, name) {\r\n\t\t\tthis._addLayer(layer, name);\r\n\t\t\tthis._update();\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\taddOverlay: function (layer, name) {\r\n\t\t\tthis._addLayer(layer, name, true);\r\n\t\t\tthis._update();\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tremoveLayer: function (layer) {\r\n\t\t\tvar id = L.stamp(layer);\r\n\t\t\tdelete this._layers[id];\r\n\t\t\tthis._update();\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\t_initLayout: function () {\r\n\t\t\tvar className = 'leaflet-control-layers',\r\n\t\t\t    container = this._container = L.DomUtil.create('div', className);\r\n\t\r\n\t\t\t//Makes this work on IE10 Touch devices by stopping it from firing a mouseout event when the touch is released\r\n\t\t\tcontainer.setAttribute('aria-haspopup', true);\r\n\t\r\n\t\t\tif (!L.Browser.touch) {\r\n\t\t\t\tL.DomEvent\r\n\t\t\t\t\t.disableClickPropagation(container)\r\n\t\t\t\t\t.disableScrollPropagation(container);\r\n\t\t\t} else {\r\n\t\t\t\tL.DomEvent.on(container, 'click', L.DomEvent.stopPropagation);\r\n\t\t\t}\r\n\t\r\n\t\t\tvar form = this._form = L.DomUtil.create('form', className + '-list');\r\n\t\r\n\t\t\tif (this.options.collapsed) {\r\n\t\t\t\tif (!L.Browser.android) {\r\n\t\t\t\t\tL.DomEvent\r\n\t\t\t\t\t    .on(container, 'mouseover', this._expand, this)\r\n\t\t\t\t\t    .on(container, 'mouseout', this._collapse, this);\r\n\t\t\t\t}\r\n\t\t\t\tvar link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);\r\n\t\t\t\tlink.href = '#';\r\n\t\t\t\tlink.title = 'Layers';\r\n\t\r\n\t\t\t\tif (L.Browser.touch) {\r\n\t\t\t\t\tL.DomEvent\r\n\t\t\t\t\t    .on(link, 'click', L.DomEvent.stop)\r\n\t\t\t\t\t    .on(link, 'click', this._expand, this);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tL.DomEvent.on(link, 'focus', this._expand, this);\r\n\t\t\t\t}\r\n\t\t\t\t//Work around for Firefox android issue https://github.com/Leaflet/Leaflet/issues/2033\r\n\t\t\t\tL.DomEvent.on(form, 'click', function () {\r\n\t\t\t\t\tsetTimeout(L.bind(this._onInputClick, this), 0);\r\n\t\t\t\t}, this);\r\n\t\r\n\t\t\t\tthis._map.on('click', this._collapse, this);\r\n\t\t\t\t// TODO keyboard accessibility\r\n\t\t\t} else {\r\n\t\t\t\tthis._expand();\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._baseLayersList = L.DomUtil.create('div', className + '-base', form);\r\n\t\t\tthis._separator = L.DomUtil.create('div', className + '-separator', form);\r\n\t\t\tthis._overlaysList = L.DomUtil.create('div', className + '-overlays', form);\r\n\t\r\n\t\t\tcontainer.appendChild(form);\r\n\t\t},\r\n\t\r\n\t\t_addLayer: function (layer, name, overlay) {\r\n\t\t\tvar id = L.stamp(layer);\r\n\t\r\n\t\t\tthis._layers[id] = {\r\n\t\t\t\tlayer: layer,\r\n\t\t\t\tname: name,\r\n\t\t\t\toverlay: overlay\r\n\t\t\t};\r\n\t\r\n\t\t\tif (this.options.autoZIndex && layer.setZIndex) {\r\n\t\t\t\tthis._lastZIndex++;\r\n\t\t\t\tlayer.setZIndex(this._lastZIndex);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_update: function () {\r\n\t\t\tif (!this._container) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._baseLayersList.innerHTML = '';\r\n\t\t\tthis._overlaysList.innerHTML = '';\r\n\t\r\n\t\t\tvar baseLayersPresent = false,\r\n\t\t\t    overlaysPresent = false,\r\n\t\t\t    i, obj;\r\n\t\r\n\t\t\tfor (i in this._layers) {\r\n\t\t\t\tobj = this._layers[i];\r\n\t\t\t\tthis._addItem(obj);\r\n\t\t\t\toverlaysPresent = overlaysPresent || obj.overlay;\r\n\t\t\t\tbaseLayersPresent = baseLayersPresent || !obj.overlay;\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';\r\n\t\t},\r\n\t\r\n\t\t_onLayerChange: function (e) {\r\n\t\t\tvar obj = this._layers[L.stamp(e.layer)];\r\n\t\r\n\t\t\tif (!obj) { return; }\r\n\t\r\n\t\t\tif (!this._handlingClick) {\r\n\t\t\t\tthis._update();\r\n\t\t\t}\r\n\t\r\n\t\t\tvar type = obj.overlay ?\r\n\t\t\t\t(e.type === 'layeradd' ? 'overlayadd' : 'overlayremove') :\r\n\t\t\t\t(e.type === 'layeradd' ? 'baselayerchange' : null);\r\n\t\r\n\t\t\tif (type) {\r\n\t\t\t\tthis._map.fire(type, obj);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)\r\n\t\t_createRadioElement: function (name, checked) {\r\n\t\r\n\t\t\tvar radioHtml = '<input type=\"radio\" class=\"leaflet-control-layers-selector\" name=\"' + name + '\"';\r\n\t\t\tif (checked) {\r\n\t\t\t\tradioHtml += ' checked=\"checked\"';\r\n\t\t\t}\r\n\t\t\tradioHtml += '/>';\r\n\t\r\n\t\t\tvar radioFragment = document.createElement('div');\r\n\t\t\tradioFragment.innerHTML = radioHtml;\r\n\t\r\n\t\t\treturn radioFragment.firstChild;\r\n\t\t},\r\n\t\r\n\t\t_addItem: function (obj) {\r\n\t\t\tvar label = document.createElement('label'),\r\n\t\t\t    input,\r\n\t\t\t    checked = this._map.hasLayer(obj.layer);\r\n\t\r\n\t\t\tif (obj.overlay) {\r\n\t\t\t\tinput = document.createElement('input');\r\n\t\t\t\tinput.type = 'checkbox';\r\n\t\t\t\tinput.className = 'leaflet-control-layers-selector';\r\n\t\t\t\tinput.defaultChecked = checked;\r\n\t\t\t} else {\r\n\t\t\t\tinput = this._createRadioElement('leaflet-base-layers', checked);\r\n\t\t\t}\r\n\t\r\n\t\t\tinput.layerId = L.stamp(obj.layer);\r\n\t\r\n\t\t\tL.DomEvent.on(input, 'click', this._onInputClick, this);\r\n\t\r\n\t\t\tvar name = document.createElement('span');\r\n\t\t\tname.innerHTML = ' ' + obj.name;\r\n\t\r\n\t\t\tlabel.appendChild(input);\r\n\t\t\tlabel.appendChild(name);\r\n\t\r\n\t\t\tvar container = obj.overlay ? this._overlaysList : this._baseLayersList;\r\n\t\t\tcontainer.appendChild(label);\r\n\t\r\n\t\t\treturn label;\r\n\t\t},\r\n\t\r\n\t\t_onInputClick: function () {\r\n\t\t\tvar i, input, obj,\r\n\t\t\t    inputs = this._form.getElementsByTagName('input'),\r\n\t\t\t    inputsLen = inputs.length;\r\n\t\r\n\t\t\tthis._handlingClick = true;\r\n\t\r\n\t\t\tfor (i = 0; i < inputsLen; i++) {\r\n\t\t\t\tinput = inputs[i];\r\n\t\t\t\tobj = this._layers[input.layerId];\r\n\t\r\n\t\t\t\tif (input.checked && !this._map.hasLayer(obj.layer)) {\r\n\t\t\t\t\tthis._map.addLayer(obj.layer);\r\n\t\r\n\t\t\t\t} else if (!input.checked && this._map.hasLayer(obj.layer)) {\r\n\t\t\t\t\tthis._map.removeLayer(obj.layer);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._handlingClick = false;\r\n\t\r\n\t\t\tthis._refocusOnMap();\r\n\t\t},\r\n\t\r\n\t\t_expand: function () {\r\n\t\t\tL.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');\r\n\t\t},\r\n\t\r\n\t\t_collapse: function () {\r\n\t\t\tthis._container.className = this._container.className.replace(' leaflet-control-layers-expanded', '');\r\n\t\t}\r\n\t});\r\n\t\r\n\tL.control.layers = function (baseLayers, overlays, options) {\r\n\t\treturn new L.Control.Layers(baseLayers, overlays, options);\r\n\t};\r\n\t\n\t\n\t/*\n\t * L.PosAnimation is used by Leaflet internally for pan animations.\n\t */\n\t\n\tL.PosAnimation = L.Class.extend({\n\t\tincludes: L.Mixin.Events,\n\t\n\t\trun: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])\n\t\t\tthis.stop();\n\t\n\t\t\tthis._el = el;\n\t\t\tthis._inProgress = true;\n\t\t\tthis._newPos = newPos;\n\t\n\t\t\tthis.fire('start');\n\t\n\t\t\tel.style[L.DomUtil.TRANSITION] = 'all ' + (duration || 0.25) +\n\t\t\t        's cubic-bezier(0,0,' + (easeLinearity || 0.5) + ',1)';\n\t\n\t\t\tL.DomEvent.on(el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);\n\t\t\tL.DomUtil.setPosition(el, newPos);\n\t\n\t\t\t// toggle reflow, Chrome flickers for some reason if you don't do this\n\t\t\tL.Util.falseFn(el.offsetWidth);\n\t\n\t\t\t// there's no native way to track value updates of transitioned properties, so we imitate this\n\t\t\tthis._stepTimer = setInterval(L.bind(this._onStep, this), 50);\n\t\t},\n\t\n\t\tstop: function () {\n\t\t\tif (!this._inProgress) { return; }\n\t\n\t\t\t// if we just removed the transition property, the element would jump to its final position,\n\t\t\t// so we need to make it stay at the current position\n\t\n\t\t\tL.DomUtil.setPosition(this._el, this._getPos());\n\t\t\tthis._onTransitionEnd();\n\t\t\tL.Util.falseFn(this._el.offsetWidth); // force reflow in case we are about to start a new animation\n\t\t},\n\t\n\t\t_onStep: function () {\n\t\t\tvar stepPos = this._getPos();\n\t\t\tif (!stepPos) {\n\t\t\t\tthis._onTransitionEnd();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// jshint camelcase: false\n\t\t\t// make L.DomUtil.getPosition return intermediate position value during animation\n\t\t\tthis._el._leaflet_pos = stepPos;\n\t\n\t\t\tthis.fire('step');\n\t\t},\n\t\n\t\t// you can't easily get intermediate values of properties animated with CSS3 Transitions,\n\t\t// we need to parse computed style (in case of transform it returns matrix string)\n\t\n\t\t_transformRe: /([-+]?(?:\\d*\\.)?\\d+)\\D*, ([-+]?(?:\\d*\\.)?\\d+)\\D*\\)/,\n\t\n\t\t_getPos: function () {\n\t\t\tvar left, top, matches,\n\t\t\t    el = this._el,\n\t\t\t    style = window.getComputedStyle(el);\n\t\n\t\t\tif (L.Browser.any3d) {\n\t\t\t\tmatches = style[L.DomUtil.TRANSFORM].match(this._transformRe);\n\t\t\t\tif (!matches) { return; }\n\t\t\t\tleft = parseFloat(matches[1]);\n\t\t\t\ttop  = parseFloat(matches[2]);\n\t\t\t} else {\n\t\t\t\tleft = parseFloat(style.left);\n\t\t\t\ttop  = parseFloat(style.top);\n\t\t\t}\n\t\n\t\t\treturn new L.Point(left, top, true);\n\t\t},\n\t\n\t\t_onTransitionEnd: function () {\n\t\t\tL.DomEvent.off(this._el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);\n\t\n\t\t\tif (!this._inProgress) { return; }\n\t\t\tthis._inProgress = false;\n\t\n\t\t\tthis._el.style[L.DomUtil.TRANSITION] = '';\n\t\n\t\t\t// jshint camelcase: false\n\t\t\t// make sure L.DomUtil.getPosition returns the final position value after animation\n\t\t\tthis._el._leaflet_pos = this._newPos;\n\t\n\t\t\tclearInterval(this._stepTimer);\n\t\n\t\t\tthis.fire('step').fire('end');\n\t\t}\n\t\n\t});\n\t\n\t\n\t/*\n\t * Extends L.Map to handle panning animations.\n\t */\n\t\n\tL.Map.include({\n\t\n\t\tsetView: function (center, zoom, options) {\n\t\n\t\t\tzoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);\n\t\t\tcenter = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);\n\t\t\toptions = options || {};\n\t\n\t\t\tif (this._panAnim) {\n\t\t\t\tthis._panAnim.stop();\n\t\t\t}\n\t\n\t\t\tif (this._loaded && !options.reset && options !== true) {\n\t\n\t\t\t\tif (options.animate !== undefined) {\n\t\t\t\t\toptions.zoom = L.extend({animate: options.animate}, options.zoom);\n\t\t\t\t\toptions.pan = L.extend({animate: options.animate}, options.pan);\n\t\t\t\t}\n\t\n\t\t\t\t// try animating pan or zoom\n\t\t\t\tvar animated = (this._zoom !== zoom) ?\n\t\t\t\t\tthis._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :\n\t\t\t\t\tthis._tryAnimatedPan(center, options.pan);\n\t\n\t\t\t\tif (animated) {\n\t\t\t\t\t// prevent resize handler call, the view will refresh after animation anyway\n\t\t\t\t\tclearTimeout(this._sizeTimer);\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// animation didn't start, just reset the map view\n\t\t\tthis._resetView(center, zoom);\n\t\n\t\t\treturn this;\n\t\t},\n\t\n\t\tpanBy: function (offset, options) {\n\t\t\toffset = L.point(offset).round();\n\t\t\toptions = options || {};\n\t\n\t\t\tif (!offset.x && !offset.y) {\n\t\t\t\treturn this;\n\t\t\t}\n\t\n\t\t\tif (!this._panAnim) {\n\t\t\t\tthis._panAnim = new L.PosAnimation();\n\t\n\t\t\t\tthis._panAnim.on({\n\t\t\t\t\t'step': this._onPanTransitionStep,\n\t\t\t\t\t'end': this._onPanTransitionEnd\n\t\t\t\t}, this);\n\t\t\t}\n\t\n\t\t\t// don't fire movestart if animating inertia\n\t\t\tif (!options.noMoveStart) {\n\t\t\t\tthis.fire('movestart');\n\t\t\t}\n\t\n\t\t\t// animate pan unless animate: false specified\n\t\t\tif (options.animate !== false) {\n\t\t\t\tL.DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');\n\t\n\t\t\t\tvar newPos = this._getMapPanePos().subtract(offset);\n\t\t\t\tthis._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);\n\t\t\t} else {\n\t\t\t\tthis._rawPanBy(offset);\n\t\t\t\tthis.fire('move').fire('moveend');\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t},\n\t\n\t\t_onPanTransitionStep: function () {\n\t\t\tthis.fire('move');\n\t\t},\n\t\n\t\t_onPanTransitionEnd: function () {\n\t\t\tL.DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');\n\t\t\tthis.fire('moveend');\n\t\t},\n\t\n\t\t_tryAnimatedPan: function (center, options) {\n\t\t\t// difference between the new and current centers in pixels\n\t\t\tvar offset = this._getCenterOffset(center)._floor();\n\t\n\t\t\t// don't animate too far unless animate: true specified in options\n\t\t\tif ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }\n\t\n\t\t\tthis.panBy(offset, options);\n\t\n\t\t\treturn true;\n\t\t}\n\t});\n\t\n\t\n\t/*\n\t * L.PosAnimation fallback implementation that powers Leaflet pan animations\n\t * in browsers that don't support CSS3 Transitions.\n\t */\n\t\n\tL.PosAnimation = L.DomUtil.TRANSITION ? L.PosAnimation : L.PosAnimation.extend({\n\t\n\t\trun: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])\n\t\t\tthis.stop();\n\t\n\t\t\tthis._el = el;\n\t\t\tthis._inProgress = true;\n\t\t\tthis._duration = duration || 0.25;\n\t\t\tthis._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);\n\t\n\t\t\tthis._startPos = L.DomUtil.getPosition(el);\n\t\t\tthis._offset = newPos.subtract(this._startPos);\n\t\t\tthis._startTime = +new Date();\n\t\n\t\t\tthis.fire('start');\n\t\n\t\t\tthis._animate();\n\t\t},\n\t\n\t\tstop: function () {\n\t\t\tif (!this._inProgress) { return; }\n\t\n\t\t\tthis._step();\n\t\t\tthis._complete();\n\t\t},\n\t\n\t\t_animate: function () {\n\t\t\t// animation loop\n\t\t\tthis._animId = L.Util.requestAnimFrame(this._animate, this);\n\t\t\tthis._step();\n\t\t},\n\t\n\t\t_step: function () {\n\t\t\tvar elapsed = (+new Date()) - this._startTime,\n\t\t\t    duration = this._duration * 1000;\n\t\n\t\t\tif (elapsed < duration) {\n\t\t\t\tthis._runFrame(this._easeOut(elapsed / duration));\n\t\t\t} else {\n\t\t\t\tthis._runFrame(1);\n\t\t\t\tthis._complete();\n\t\t\t}\n\t\t},\n\t\n\t\t_runFrame: function (progress) {\n\t\t\tvar pos = this._startPos.add(this._offset.multiplyBy(progress));\n\t\t\tL.DomUtil.setPosition(this._el, pos);\n\t\n\t\t\tthis.fire('step');\n\t\t},\n\t\n\t\t_complete: function () {\n\t\t\tL.Util.cancelAnimFrame(this._animId);\n\t\n\t\t\tthis._inProgress = false;\n\t\t\tthis.fire('end');\n\t\t},\n\t\n\t\t_easeOut: function (t) {\n\t\t\treturn 1 - Math.pow(1 - t, this._easeOutPower);\n\t\t}\n\t});\n\t\n\t\n\t/*\n\t * Extends L.Map to handle zoom animations.\n\t */\n\t\n\tL.Map.mergeOptions({\n\t\tzoomAnimation: true,\n\t\tzoomAnimationThreshold: 4\n\t});\n\t\n\tif (L.DomUtil.TRANSITION) {\n\t\n\t\tL.Map.addInitHook(function () {\n\t\t\t// don't animate on browsers without hardware-accelerated transitions or old Android/Opera\n\t\t\tthis._zoomAnimated = this.options.zoomAnimation && L.DomUtil.TRANSITION &&\n\t\t\t\t\tL.Browser.any3d && !L.Browser.android23 && !L.Browser.mobileOpera;\n\t\n\t\t\t// zoom transitions run with the same duration for all layers, so if one of transitionend events\n\t\t\t// happens after starting zoom animation (propagating to the map pane), we know that it ended globally\n\t\t\tif (this._zoomAnimated) {\n\t\t\t\tL.DomEvent.on(this._mapPane, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);\n\t\t\t}\n\t\t});\n\t}\n\t\n\tL.Map.include(!L.DomUtil.TRANSITION ? {} : {\n\t\n\t\t_catchTransitionEnd: function (e) {\n\t\t\tif (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {\n\t\t\t\tthis._onZoomTransitionEnd();\n\t\t\t}\n\t\t},\n\t\n\t\t_nothingToAnimate: function () {\n\t\t\treturn !this._container.getElementsByClassName('leaflet-zoom-animated').length;\n\t\t},\n\t\n\t\t_tryAnimatedZoom: function (center, zoom, options) {\n\t\n\t\t\tif (this._animatingZoom) { return true; }\n\t\n\t\t\toptions = options || {};\n\t\n\t\t\t// don't animate if disabled, not supported or zoom difference is too large\n\t\t\tif (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||\n\t\t\t        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }\n\t\n\t\t\t// offset is the pixel coords of the zoom origin relative to the current center\n\t\t\tvar scale = this.getZoomScale(zoom),\n\t\t\t    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale),\n\t\t\t\torigin = this._getCenterLayerPoint()._add(offset);\n\t\n\t\t\t// don't animate if the zoom origin isn't within one screen from the current center, unless forced\n\t\t\tif (options.animate !== true && !this.getSize().contains(offset)) { return false; }\n\t\n\t\t\tthis\n\t\t\t    .fire('movestart')\n\t\t\t    .fire('zoomstart');\n\t\n\t\t\tthis._animateZoom(center, zoom, origin, scale, null, true);\n\t\n\t\t\treturn true;\n\t\t},\n\t\n\t\t_animateZoom: function (center, zoom, origin, scale, delta, backwards, forTouchZoom) {\n\t\n\t\t\tif (!forTouchZoom) {\n\t\t\t\tthis._animatingZoom = true;\n\t\t\t}\n\t\n\t\t\t// put transform transition on all layers with leaflet-zoom-animated class\n\t\t\tL.DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');\n\t\n\t\t\t// remember what center/zoom to set after animation\n\t\t\tthis._animateToCenter = center;\n\t\t\tthis._animateToZoom = zoom;\n\t\n\t\t\t// disable any dragging during animation\n\t\t\tif (L.Draggable) {\n\t\t\t\tL.Draggable._disabled = true;\n\t\t\t}\n\t\n\t\t\tL.Util.requestAnimFrame(function () {\n\t\t\t\tthis.fire('zoomanim', {\n\t\t\t\t\tcenter: center,\n\t\t\t\t\tzoom: zoom,\n\t\t\t\t\torigin: origin,\n\t\t\t\t\tscale: scale,\n\t\t\t\t\tdelta: delta,\n\t\t\t\t\tbackwards: backwards\n\t\t\t\t});\n\t\t\t\t// horrible hack to work around a Chrome bug https://github.com/Leaflet/Leaflet/issues/3689\n\t\t\t\tsetTimeout(L.bind(this._onZoomTransitionEnd, this), 250);\n\t\t\t}, this);\n\t\t},\n\t\n\t\t_onZoomTransitionEnd: function () {\n\t\t\tif (!this._animatingZoom) { return; }\n\t\n\t\t\tthis._animatingZoom = false;\n\t\n\t\t\tL.DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');\n\t\n\t\t\tL.Util.requestAnimFrame(function () {\n\t\t\t\tthis._resetView(this._animateToCenter, this._animateToZoom, true, true);\n\t\n\t\t\t\tif (L.Draggable) {\n\t\t\t\t\tL.Draggable._disabled = false;\n\t\t\t\t}\n\t\t\t}, this);\n\t\t}\n\t});\n\t\n\t\n\t/*\n\t\tZoom animation logic for L.TileLayer.\n\t*/\n\t\n\tL.TileLayer.include({\n\t\t_animateZoom: function (e) {\n\t\t\tif (!this._animating) {\n\t\t\t\tthis._animating = true;\n\t\t\t\tthis._prepareBgBuffer();\n\t\t\t}\n\t\n\t\t\tvar bg = this._bgBuffer,\n\t\t\t    transform = L.DomUtil.TRANSFORM,\n\t\t\t    initialTransform = e.delta ? L.DomUtil.getTranslateString(e.delta) : bg.style[transform],\n\t\t\t    scaleStr = L.DomUtil.getScaleString(e.scale, e.origin);\n\t\n\t\t\tbg.style[transform] = e.backwards ?\n\t\t\t\t\tscaleStr + ' ' + initialTransform :\n\t\t\t\t\tinitialTransform + ' ' + scaleStr;\n\t\t},\n\t\n\t\t_endZoomAnim: function () {\n\t\t\tvar front = this._tileContainer,\n\t\t\t    bg = this._bgBuffer;\n\t\n\t\t\tfront.style.visibility = '';\n\t\t\tfront.parentNode.appendChild(front); // Bring to fore\n\t\n\t\t\t// force reflow\n\t\t\tL.Util.falseFn(bg.offsetWidth);\n\t\n\t\t\tvar zoom = this._map.getZoom();\n\t\t\tif (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\n\t\t\t\tthis._clearBgBuffer();\n\t\t\t}\n\t\n\t\t\tthis._animating = false;\n\t\t},\n\t\n\t\t_clearBgBuffer: function () {\n\t\t\tvar map = this._map;\n\t\n\t\t\tif (map && !map._animatingZoom && !map.touchZoom._zooming) {\n\t\t\t\tthis._bgBuffer.innerHTML = '';\n\t\t\t\tthis._bgBuffer.style[L.DomUtil.TRANSFORM] = '';\n\t\t\t}\n\t\t},\n\t\n\t\t_prepareBgBuffer: function () {\n\t\n\t\t\tvar front = this._tileContainer,\n\t\t\t    bg = this._bgBuffer;\n\t\n\t\t\t// if foreground layer doesn't have many tiles but bg layer does,\n\t\t\t// keep the existing bg layer and just zoom it some more\n\t\n\t\t\tvar bgLoaded = this._getLoadedTilesPercentage(bg),\n\t\t\t    frontLoaded = this._getLoadedTilesPercentage(front);\n\t\n\t\t\tif (bg && bgLoaded > 0.5 && frontLoaded < 0.5) {\n\t\n\t\t\t\tfront.style.visibility = 'hidden';\n\t\t\t\tthis._stopLoadingImages(front);\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// prepare the buffer to become the front tile pane\n\t\t\tbg.style.visibility = 'hidden';\n\t\t\tbg.style[L.DomUtil.TRANSFORM] = '';\n\t\n\t\t\t// switch out the current layer to be the new bg layer (and vice-versa)\n\t\t\tthis._tileContainer = bg;\n\t\t\tbg = this._bgBuffer = front;\n\t\n\t\t\tthis._stopLoadingImages(bg);\n\t\n\t\t\t//prevent bg buffer from clearing right after zoom\n\t\t\tclearTimeout(this._clearBgBufferTimer);\n\t\t},\n\t\n\t\t_getLoadedTilesPercentage: function (container) {\n\t\t\tvar tiles = container.getElementsByTagName('img'),\n\t\t\t    i, len, count = 0;\n\t\n\t\t\tfor (i = 0, len = tiles.length; i < len; i++) {\n\t\t\t\tif (tiles[i].complete) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn count / len;\n\t\t},\n\t\n\t\t// stops loading all tiles in the background layer\n\t\t_stopLoadingImages: function (container) {\n\t\t\tvar tiles = Array.prototype.slice.call(container.getElementsByTagName('img')),\n\t\t\t    i, len, tile;\n\t\n\t\t\tfor (i = 0, len = tiles.length; i < len; i++) {\n\t\t\t\ttile = tiles[i];\n\t\n\t\t\t\tif (!tile.complete) {\n\t\t\t\t\ttile.onload = L.Util.falseFn;\n\t\t\t\t\ttile.onerror = L.Util.falseFn;\n\t\t\t\t\ttile.src = L.Util.emptyImageUrl;\n\t\n\t\t\t\t\ttile.parentNode.removeChild(tile);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\t\n\t\n\t/*\r\n\t * Provides L.Map with convenient shortcuts for using browser geolocation features.\r\n\t */\r\n\t\r\n\tL.Map.include({\r\n\t\t_defaultLocateOptions: {\r\n\t\t\twatch: false,\r\n\t\t\tsetView: false,\r\n\t\t\tmaxZoom: Infinity,\r\n\t\t\ttimeout: 10000,\r\n\t\t\tmaximumAge: 0,\r\n\t\t\tenableHighAccuracy: false\r\n\t\t},\r\n\t\r\n\t\tlocate: function (/*Object*/ options) {\r\n\t\r\n\t\t\toptions = this._locateOptions = L.extend(this._defaultLocateOptions, options);\r\n\t\r\n\t\t\tif (!navigator.geolocation) {\r\n\t\t\t\tthis._handleGeolocationError({\r\n\t\t\t\t\tcode: 0,\r\n\t\t\t\t\tmessage: 'Geolocation not supported.'\r\n\t\t\t\t});\r\n\t\t\t\treturn this;\r\n\t\t\t}\r\n\t\r\n\t\t\tvar onResponse = L.bind(this._handleGeolocationResponse, this),\r\n\t\t\t\tonError = L.bind(this._handleGeolocationError, this);\r\n\t\r\n\t\t\tif (options.watch) {\r\n\t\t\t\tthis._locationWatchId =\r\n\t\t\t\t        navigator.geolocation.watchPosition(onResponse, onError, options);\r\n\t\t\t} else {\r\n\t\t\t\tnavigator.geolocation.getCurrentPosition(onResponse, onError, options);\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tstopLocate: function () {\r\n\t\t\tif (navigator.geolocation) {\r\n\t\t\t\tnavigator.geolocation.clearWatch(this._locationWatchId);\r\n\t\t\t}\r\n\t\t\tif (this._locateOptions) {\r\n\t\t\t\tthis._locateOptions.setView = false;\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\t_handleGeolocationError: function (error) {\r\n\t\t\tvar c = error.code,\r\n\t\t\t    message = error.message ||\r\n\t\t\t            (c === 1 ? 'permission denied' :\r\n\t\t\t            (c === 2 ? 'position unavailable' : 'timeout'));\r\n\t\r\n\t\t\tif (this._locateOptions.setView && !this._loaded) {\r\n\t\t\t\tthis.fitWorld();\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.fire('locationerror', {\r\n\t\t\t\tcode: c,\r\n\t\t\t\tmessage: 'Geolocation error: ' + message + '.'\r\n\t\t\t});\r\n\t\t},\r\n\t\r\n\t\t_handleGeolocationResponse: function (pos) {\r\n\t\t\tvar lat = pos.coords.latitude,\r\n\t\t\t    lng = pos.coords.longitude,\r\n\t\t\t    latlng = new L.LatLng(lat, lng),\r\n\t\r\n\t\t\t    latAccuracy = 180 * pos.coords.accuracy / 40075017,\r\n\t\t\t    lngAccuracy = latAccuracy / Math.cos(L.LatLng.DEG_TO_RAD * lat),\r\n\t\r\n\t\t\t    bounds = L.latLngBounds(\r\n\t\t\t            [lat - latAccuracy, lng - lngAccuracy],\r\n\t\t\t            [lat + latAccuracy, lng + lngAccuracy]),\r\n\t\r\n\t\t\t    options = this._locateOptions;\r\n\t\r\n\t\t\tif (options.setView) {\r\n\t\t\t\tvar zoom = Math.min(this.getBoundsZoom(bounds), options.maxZoom);\r\n\t\t\t\tthis.setView(latlng, zoom);\r\n\t\t\t}\r\n\t\r\n\t\t\tvar data = {\r\n\t\t\t\tlatlng: latlng,\r\n\t\t\t\tbounds: bounds,\r\n\t\t\t\ttimestamp: pos.timestamp\r\n\t\t\t};\r\n\t\r\n\t\t\tfor (var i in pos.coords) {\r\n\t\t\t\tif (typeof pos.coords[i] === 'number') {\r\n\t\t\t\t\tdata[i] = pos.coords[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.fire('locationfound', data);\r\n\t\t}\r\n\t});\r\n\t\n\t\n\t}(window, document));\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process, setImmediate) {// vim:ts=4:sts=4:sw=4:\n\t/*!\n\t *\n\t * Copyright 2009-2012 Kris Kowal under the terms of the MIT\n\t * license found at http://github.com/kriskowal/q/raw/master/LICENSE\n\t *\n\t * With parts by Tyler Close\n\t * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found\n\t * at http://www.opensource.org/licenses/mit-license.html\n\t * Forked at ref_send.js version: 2009-05-11\n\t *\n\t * With parts by Mark Miller\n\t * Copyright (C) 2011 Google Inc.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t * http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t *\n\t */\n\t\n\t(function (definition) {\n\t    \"use strict\";\n\t\n\t    // This file will function properly as a <script> tag, or a module\n\t    // using CommonJS and NodeJS or RequireJS module formats.  In\n\t    // Common/Node/RequireJS, the module exports the Q API and when\n\t    // executed as a simple <script>, it creates a Q global instead.\n\t\n\t    // Montage Require\n\t    if (typeof bootstrap === \"function\") {\n\t        bootstrap(\"promise\", definition);\n\t\n\t    // CommonJS\n\t    } else if (true) {\n\t        module.exports = definition();\n\t\n\t    // RequireJS\n\t    } else if (typeof define === \"function\" && define.amd) {\n\t        define(definition);\n\t\n\t    // SES (Secure EcmaScript)\n\t    } else if (typeof ses !== \"undefined\") {\n\t        if (!ses.ok()) {\n\t            return;\n\t        } else {\n\t            ses.makeQ = definition;\n\t        }\n\t\n\t    // <script>\n\t    } else if (typeof window !== \"undefined\" || typeof self !== \"undefined\") {\n\t        // Prefer window over self for add-on scripts. Use self for\n\t        // non-windowed contexts.\n\t        var global = typeof window !== \"undefined\" ? window : self;\n\t\n\t        // Get the `window` object, save the previous Q global\n\t        // and initialize Q as a global.\n\t        var previousQ = global.Q;\n\t        global.Q = definition();\n\t\n\t        // Add a noConflict function so Q can be removed from the\n\t        // global namespace.\n\t        global.Q.noConflict = function () {\n\t            global.Q = previousQ;\n\t            return this;\n\t        };\n\t\n\t    } else {\n\t        throw new Error(\"This environment was not anticipated by Q. Please file a bug.\");\n\t    }\n\t\n\t})(function () {\n\t\"use strict\";\n\t\n\tvar hasStacks = false;\n\ttry {\n\t    throw new Error();\n\t} catch (e) {\n\t    hasStacks = !!e.stack;\n\t}\n\t\n\t// All code after this point will be filtered from stack traces reported\n\t// by Q.\n\tvar qStartingLine = captureLine();\n\tvar qFileName;\n\t\n\t// shims\n\t\n\t// used for fallback in \"allResolved\"\n\tvar noop = function () {};\n\t\n\t// Use the fastest possible means to execute a task in a future turn\n\t// of the event loop.\n\tvar nextTick =(function () {\n\t    // linked list of tasks (single, with head node)\n\t    var head = {task: void 0, next: null};\n\t    var tail = head;\n\t    var flushing = false;\n\t    var requestTick = void 0;\n\t    var isNodeJS = false;\n\t    // queue for late tasks, used by unhandled rejection tracking\n\t    var laterQueue = [];\n\t\n\t    function flush() {\n\t        /* jshint loopfunc: true */\n\t        var task, domain;\n\t\n\t        while (head.next) {\n\t            head = head.next;\n\t            task = head.task;\n\t            head.task = void 0;\n\t            domain = head.domain;\n\t\n\t            if (domain) {\n\t                head.domain = void 0;\n\t                domain.enter();\n\t            }\n\t            runSingle(task, domain);\n\t\n\t        }\n\t        while (laterQueue.length) {\n\t            task = laterQueue.pop();\n\t            runSingle(task);\n\t        }\n\t        flushing = false;\n\t    }\n\t    // runs a single function in the async queue\n\t    function runSingle(task, domain) {\n\t        try {\n\t            task();\n\t\n\t        } catch (e) {\n\t            if (isNodeJS) {\n\t                // In node, uncaught exceptions are considered fatal errors.\n\t                // Re-throw them synchronously to interrupt flushing!\n\t\n\t                // Ensure continuation if the uncaught exception is suppressed\n\t                // listening \"uncaughtException\" events (as domains does).\n\t                // Continue in next event to avoid tick recursion.\n\t                if (domain) {\n\t                    domain.exit();\n\t                }\n\t                setTimeout(flush, 0);\n\t                if (domain) {\n\t                    domain.enter();\n\t                }\n\t\n\t                throw e;\n\t\n\t            } else {\n\t                // In browsers, uncaught exceptions are not fatal.\n\t                // Re-throw them asynchronously to avoid slow-downs.\n\t                setTimeout(function () {\n\t                    throw e;\n\t                }, 0);\n\t            }\n\t        }\n\t\n\t        if (domain) {\n\t            domain.exit();\n\t        }\n\t    }\n\t\n\t    nextTick = function (task) {\n\t        tail = tail.next = {\n\t            task: task,\n\t            domain: isNodeJS && process.domain,\n\t            next: null\n\t        };\n\t\n\t        if (!flushing) {\n\t            flushing = true;\n\t            requestTick();\n\t        }\n\t    };\n\t\n\t    if (typeof process === \"object\" &&\n\t        process.toString() === \"[object process]\" && process.nextTick) {\n\t        // Ensure Q is in a real Node environment, with a `process.nextTick`.\n\t        // To see through fake Node environments:\n\t        // * Mocha test runner - exposes a `process` global without a `nextTick`\n\t        // * Browserify - exposes a `process.nexTick` function that uses\n\t        //   `setTimeout`. In this case `setImmediate` is preferred because\n\t        //    it is faster. Browserify's `process.toString()` yields\n\t        //   \"[object Object]\", while in a real Node environment\n\t        //   `process.nextTick()` yields \"[object process]\".\n\t        isNodeJS = true;\n\t\n\t        requestTick = function () {\n\t            process.nextTick(flush);\n\t        };\n\t\n\t    } else if (typeof setImmediate === \"function\") {\n\t        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\n\t        if (typeof window !== \"undefined\") {\n\t            requestTick = setImmediate.bind(window, flush);\n\t        } else {\n\t            requestTick = function () {\n\t                setImmediate(flush);\n\t            };\n\t        }\n\t\n\t    } else if (typeof MessageChannel !== \"undefined\") {\n\t        // modern browsers\n\t        // http://www.nonblocking.io/2011/06/windownexttick.html\n\t        var channel = new MessageChannel();\n\t        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create\n\t        // working message ports the first time a page loads.\n\t        channel.port1.onmessage = function () {\n\t            requestTick = requestPortTick;\n\t            channel.port1.onmessage = flush;\n\t            flush();\n\t        };\n\t        var requestPortTick = function () {\n\t            // Opera requires us to provide a message payload, regardless of\n\t            // whether we use it.\n\t            channel.port2.postMessage(0);\n\t        };\n\t        requestTick = function () {\n\t            setTimeout(flush, 0);\n\t            requestPortTick();\n\t        };\n\t\n\t    } else {\n\t        // old browsers\n\t        requestTick = function () {\n\t            setTimeout(flush, 0);\n\t        };\n\t    }\n\t    // runs a task after all other tasks have been run\n\t    // this is useful for unhandled rejection tracking that needs to happen\n\t    // after all `then`d tasks have been run.\n\t    nextTick.runAfter = function (task) {\n\t        laterQueue.push(task);\n\t        if (!flushing) {\n\t            flushing = true;\n\t            requestTick();\n\t        }\n\t    };\n\t    return nextTick;\n\t})();\n\t\n\t// Attempt to make generics safe in the face of downstream\n\t// modifications.\n\t// There is no situation where this is necessary.\n\t// If you need a security guarantee, these primordials need to be\n\t// deeply frozen anyway, and if you don’t need a security guarantee,\n\t// this is just plain paranoid.\n\t// However, this **might** have the nice side-effect of reducing the size of\n\t// the minified code by reducing x.call() to merely x()\n\t// See Mark Miller’s explanation of what this does.\n\t// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n\tvar call = Function.call;\n\tfunction uncurryThis(f) {\n\t    return function () {\n\t        return call.apply(f, arguments);\n\t    };\n\t}\n\t// This is equivalent, but slower:\n\t// uncurryThis = Function_bind.bind(Function_bind.call);\n\t// http://jsperf.com/uncurrythis\n\t\n\tvar array_slice = uncurryThis(Array.prototype.slice);\n\t\n\tvar array_reduce = uncurryThis(\n\t    Array.prototype.reduce || function (callback, basis) {\n\t        var index = 0,\n\t            length = this.length;\n\t        // concerning the initial value, if one is not provided\n\t        if (arguments.length === 1) {\n\t            // seek to the first value in the array, accounting\n\t            // for the possibility that is is a sparse array\n\t            do {\n\t                if (index in this) {\n\t                    basis = this[index++];\n\t                    break;\n\t                }\n\t                if (++index >= length) {\n\t                    throw new TypeError();\n\t                }\n\t            } while (1);\n\t        }\n\t        // reduce\n\t        for (; index < length; index++) {\n\t            // account for the possibility that the array is sparse\n\t            if (index in this) {\n\t                basis = callback(basis, this[index], index);\n\t            }\n\t        }\n\t        return basis;\n\t    }\n\t);\n\t\n\tvar array_indexOf = uncurryThis(\n\t    Array.prototype.indexOf || function (value) {\n\t        // not a very good shim, but good enough for our one use of it\n\t        for (var i = 0; i < this.length; i++) {\n\t            if (this[i] === value) {\n\t                return i;\n\t            }\n\t        }\n\t        return -1;\n\t    }\n\t);\n\t\n\tvar array_map = uncurryThis(\n\t    Array.prototype.map || function (callback, thisp) {\n\t        var self = this;\n\t        var collect = [];\n\t        array_reduce(self, function (undefined, value, index) {\n\t            collect.push(callback.call(thisp, value, index, self));\n\t        }, void 0);\n\t        return collect;\n\t    }\n\t);\n\t\n\tvar object_create = Object.create || function (prototype) {\n\t    function Type() { }\n\t    Type.prototype = prototype;\n\t    return new Type();\n\t};\n\t\n\tvar object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\n\t\n\tvar object_keys = Object.keys || function (object) {\n\t    var keys = [];\n\t    for (var key in object) {\n\t        if (object_hasOwnProperty(object, key)) {\n\t            keys.push(key);\n\t        }\n\t    }\n\t    return keys;\n\t};\n\t\n\tvar object_toString = uncurryThis(Object.prototype.toString);\n\t\n\tfunction isObject(value) {\n\t    return value === Object(value);\n\t}\n\t\n\t// generator related shims\n\t\n\t// FIXME: Remove this function once ES6 generators are in SpiderMonkey.\n\tfunction isStopIteration(exception) {\n\t    return (\n\t        object_toString(exception) === \"[object StopIteration]\" ||\n\t        exception instanceof QReturnValue\n\t    );\n\t}\n\t\n\t// FIXME: Remove this helper and Q.return once ES6 generators are in\n\t// SpiderMonkey.\n\tvar QReturnValue;\n\tif (typeof ReturnValue !== \"undefined\") {\n\t    QReturnValue = ReturnValue;\n\t} else {\n\t    QReturnValue = function (value) {\n\t        this.value = value;\n\t    };\n\t}\n\t\n\t// long stack traces\n\t\n\tvar STACK_JUMP_SEPARATOR = \"From previous event:\";\n\t\n\tfunction makeStackTraceLong(error, promise) {\n\t    // If possible, transform the error stack trace by removing Node and Q\n\t    // cruft, then concatenating with the stack trace of `promise`. See #57.\n\t    if (hasStacks &&\n\t        promise.stack &&\n\t        typeof error === \"object\" &&\n\t        error !== null &&\n\t        error.stack &&\n\t        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1\n\t    ) {\n\t        var stacks = [];\n\t        for (var p = promise; !!p; p = p.source) {\n\t            if (p.stack) {\n\t                stacks.unshift(p.stack);\n\t            }\n\t        }\n\t        stacks.unshift(error.stack);\n\t\n\t        var concatedStacks = stacks.join(\"\\n\" + STACK_JUMP_SEPARATOR + \"\\n\");\n\t        error.stack = filterStackString(concatedStacks);\n\t    }\n\t}\n\t\n\tfunction filterStackString(stackString) {\n\t    var lines = stackString.split(\"\\n\");\n\t    var desiredLines = [];\n\t    for (var i = 0; i < lines.length; ++i) {\n\t        var line = lines[i];\n\t\n\t        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {\n\t            desiredLines.push(line);\n\t        }\n\t    }\n\t    return desiredLines.join(\"\\n\");\n\t}\n\t\n\tfunction isNodeFrame(stackLine) {\n\t    return stackLine.indexOf(\"(module.js:\") !== -1 ||\n\t           stackLine.indexOf(\"(node.js:\") !== -1;\n\t}\n\t\n\tfunction getFileNameAndLineNumber(stackLine) {\n\t    // Named functions: \"at functionName (filename:lineNumber:columnNumber)\"\n\t    // In IE10 function name can have spaces (\"Anonymous function\") O_o\n\t    var attempt1 = /at .+ \\((.+):(\\d+):(?:\\d+)\\)$/.exec(stackLine);\n\t    if (attempt1) {\n\t        return [attempt1[1], Number(attempt1[2])];\n\t    }\n\t\n\t    // Anonymous functions: \"at filename:lineNumber:columnNumber\"\n\t    var attempt2 = /at ([^ ]+):(\\d+):(?:\\d+)$/.exec(stackLine);\n\t    if (attempt2) {\n\t        return [attempt2[1], Number(attempt2[2])];\n\t    }\n\t\n\t    // Firefox style: \"function@filename:lineNumber or @filename:lineNumber\"\n\t    var attempt3 = /.*@(.+):(\\d+)$/.exec(stackLine);\n\t    if (attempt3) {\n\t        return [attempt3[1], Number(attempt3[2])];\n\t    }\n\t}\n\t\n\tfunction isInternalFrame(stackLine) {\n\t    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);\n\t\n\t    if (!fileNameAndLineNumber) {\n\t        return false;\n\t    }\n\t\n\t    var fileName = fileNameAndLineNumber[0];\n\t    var lineNumber = fileNameAndLineNumber[1];\n\t\n\t    return fileName === qFileName &&\n\t        lineNumber >= qStartingLine &&\n\t        lineNumber <= qEndingLine;\n\t}\n\t\n\t// discover own file name and line number range for filtering stack\n\t// traces\n\tfunction captureLine() {\n\t    if (!hasStacks) {\n\t        return;\n\t    }\n\t\n\t    try {\n\t        throw new Error();\n\t    } catch (e) {\n\t        var lines = e.stack.split(\"\\n\");\n\t        var firstLine = lines[0].indexOf(\"@\") > 0 ? lines[1] : lines[2];\n\t        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);\n\t        if (!fileNameAndLineNumber) {\n\t            return;\n\t        }\n\t\n\t        qFileName = fileNameAndLineNumber[0];\n\t        return fileNameAndLineNumber[1];\n\t    }\n\t}\n\t\n\tfunction deprecate(callback, name, alternative) {\n\t    return function () {\n\t        if (typeof console !== \"undefined\" &&\n\t            typeof console.warn === \"function\") {\n\t            console.warn(name + \" is deprecated, use \" + alternative +\n\t                         \" instead.\", new Error(\"\").stack);\n\t        }\n\t        return callback.apply(callback, arguments);\n\t    };\n\t}\n\t\n\t// end of shims\n\t// beginning of real work\n\t\n\t/**\n\t * Constructs a promise for an immediate reference, passes promises through, or\n\t * coerces promises from different systems.\n\t * @param value immediate reference or promise\n\t */\n\tfunction Q(value) {\n\t    // If the object is already a Promise, return it directly.  This enables\n\t    // the resolve function to both be used to created references from objects,\n\t    // but to tolerably coerce non-promises to promises.\n\t    if (value instanceof Promise) {\n\t        return value;\n\t    }\n\t\n\t    // assimilate thenables\n\t    if (isPromiseAlike(value)) {\n\t        return coerce(value);\n\t    } else {\n\t        return fulfill(value);\n\t    }\n\t}\n\tQ.resolve = Q;\n\t\n\t/**\n\t * Performs a task in a future turn of the event loop.\n\t * @param {Function} task\n\t */\n\tQ.nextTick = nextTick;\n\t\n\t/**\n\t * Controls whether or not long stack traces will be on\n\t */\n\tQ.longStackSupport = false;\n\t\n\t// enable long stacks if Q_DEBUG is set\n\tif (typeof process === \"object\" && process && ({\"NODE_ENV\":\"production\"}) && ({\"NODE_ENV\":\"production\"}).Q_DEBUG) {\n\t    Q.longStackSupport = true;\n\t}\n\t\n\t/**\n\t * Constructs a {promise, resolve, reject} object.\n\t *\n\t * `resolve` is a callback to invoke with a more resolved value for the\n\t * promise. To fulfill the promise, invoke `resolve` with any value that is\n\t * not a thenable. To reject the promise, invoke `resolve` with a rejected\n\t * thenable, or invoke `reject` with the reason directly. To resolve the\n\t * promise to another thenable, thus putting it in the same state, invoke\n\t * `resolve` with that other thenable.\n\t */\n\tQ.defer = defer;\n\tfunction defer() {\n\t    // if \"messages\" is an \"Array\", that indicates that the promise has not yet\n\t    // been resolved.  If it is \"undefined\", it has been resolved.  Each\n\t    // element of the messages array is itself an array of complete arguments to\n\t    // forward to the resolved promise.  We coerce the resolution value to a\n\t    // promise using the `resolve` function because it handles both fully\n\t    // non-thenable values and other thenables gracefully.\n\t    var messages = [], progressListeners = [], resolvedPromise;\n\t\n\t    var deferred = object_create(defer.prototype);\n\t    var promise = object_create(Promise.prototype);\n\t\n\t    promise.promiseDispatch = function (resolve, op, operands) {\n\t        var args = array_slice(arguments);\n\t        if (messages) {\n\t            messages.push(args);\n\t            if (op === \"when\" && operands[1]) { // progress operand\n\t                progressListeners.push(operands[1]);\n\t            }\n\t        } else {\n\t            Q.nextTick(function () {\n\t                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);\n\t            });\n\t        }\n\t    };\n\t\n\t    // XXX deprecated\n\t    promise.valueOf = function () {\n\t        if (messages) {\n\t            return promise;\n\t        }\n\t        var nearerValue = nearer(resolvedPromise);\n\t        if (isPromise(nearerValue)) {\n\t            resolvedPromise = nearerValue; // shorten chain\n\t        }\n\t        return nearerValue;\n\t    };\n\t\n\t    promise.inspect = function () {\n\t        if (!resolvedPromise) {\n\t            return { state: \"pending\" };\n\t        }\n\t        return resolvedPromise.inspect();\n\t    };\n\t\n\t    if (Q.longStackSupport && hasStacks) {\n\t        try {\n\t            throw new Error();\n\t        } catch (e) {\n\t            // NOTE: don't try to use `Error.captureStackTrace` or transfer the\n\t            // accessor around; that causes memory leaks as per GH-111. Just\n\t            // reify the stack trace as a string ASAP.\n\t            //\n\t            // At the same time, cut off the first line; it's always just\n\t            // \"[object Promise]\\n\", as per the `toString`.\n\t            promise.stack = e.stack.substring(e.stack.indexOf(\"\\n\") + 1);\n\t        }\n\t    }\n\t\n\t    // NOTE: we do the checks for `resolvedPromise` in each method, instead of\n\t    // consolidating them into `become`, since otherwise we'd create new\n\t    // promises with the lines `become(whatever(value))`. See e.g. GH-252.\n\t\n\t    function become(newPromise) {\n\t        resolvedPromise = newPromise;\n\t        promise.source = newPromise;\n\t\n\t        array_reduce(messages, function (undefined, message) {\n\t            Q.nextTick(function () {\n\t                newPromise.promiseDispatch.apply(newPromise, message);\n\t            });\n\t        }, void 0);\n\t\n\t        messages = void 0;\n\t        progressListeners = void 0;\n\t    }\n\t\n\t    deferred.promise = promise;\n\t    deferred.resolve = function (value) {\n\t        if (resolvedPromise) {\n\t            return;\n\t        }\n\t\n\t        become(Q(value));\n\t    };\n\t\n\t    deferred.fulfill = function (value) {\n\t        if (resolvedPromise) {\n\t            return;\n\t        }\n\t\n\t        become(fulfill(value));\n\t    };\n\t    deferred.reject = function (reason) {\n\t        if (resolvedPromise) {\n\t            return;\n\t        }\n\t\n\t        become(reject(reason));\n\t    };\n\t    deferred.notify = function (progress) {\n\t        if (resolvedPromise) {\n\t            return;\n\t        }\n\t\n\t        array_reduce(progressListeners, function (undefined, progressListener) {\n\t            Q.nextTick(function () {\n\t                progressListener(progress);\n\t            });\n\t        }, void 0);\n\t    };\n\t\n\t    return deferred;\n\t}\n\t\n\t/**\n\t * Creates a Node-style callback that will resolve or reject the deferred\n\t * promise.\n\t * @returns a nodeback\n\t */\n\tdefer.prototype.makeNodeResolver = function () {\n\t    var self = this;\n\t    return function (error, value) {\n\t        if (error) {\n\t            self.reject(error);\n\t        } else if (arguments.length > 2) {\n\t            self.resolve(array_slice(arguments, 1));\n\t        } else {\n\t            self.resolve(value);\n\t        }\n\t    };\n\t};\n\t\n\t/**\n\t * @param resolver {Function} a function that returns nothing and accepts\n\t * the resolve, reject, and notify functions for a deferred.\n\t * @returns a promise that may be resolved with the given resolve and reject\n\t * functions, or rejected by a thrown exception in resolver\n\t */\n\tQ.Promise = promise; // ES6\n\tQ.promise = promise;\n\tfunction promise(resolver) {\n\t    if (typeof resolver !== \"function\") {\n\t        throw new TypeError(\"resolver must be a function.\");\n\t    }\n\t    var deferred = defer();\n\t    try {\n\t        resolver(deferred.resolve, deferred.reject, deferred.notify);\n\t    } catch (reason) {\n\t        deferred.reject(reason);\n\t    }\n\t    return deferred.promise;\n\t}\n\t\n\tpromise.race = race; // ES6\n\tpromise.all = all; // ES6\n\tpromise.reject = reject; // ES6\n\tpromise.resolve = Q; // ES6\n\t\n\t// XXX experimental.  This method is a way to denote that a local value is\n\t// serializable and should be immediately dispatched to a remote upon request,\n\t// instead of passing a reference.\n\tQ.passByCopy = function (object) {\n\t    //freeze(object);\n\t    //passByCopies.set(object, true);\n\t    return object;\n\t};\n\t\n\tPromise.prototype.passByCopy = function () {\n\t    //freeze(object);\n\t    //passByCopies.set(object, true);\n\t    return this;\n\t};\n\t\n\t/**\n\t * If two promises eventually fulfill to the same value, promises that value,\n\t * but otherwise rejects.\n\t * @param x {Any*}\n\t * @param y {Any*}\n\t * @returns {Any*} a promise for x and y if they are the same, but a rejection\n\t * otherwise.\n\t *\n\t */\n\tQ.join = function (x, y) {\n\t    return Q(x).join(y);\n\t};\n\t\n\tPromise.prototype.join = function (that) {\n\t    return Q([this, that]).spread(function (x, y) {\n\t        if (x === y) {\n\t            // TODO: \"===\" should be Object.is or equiv\n\t            return x;\n\t        } else {\n\t            throw new Error(\"Can't join: not the same: \" + x + \" \" + y);\n\t        }\n\t    });\n\t};\n\t\n\t/**\n\t * Returns a promise for the first of an array of promises to become settled.\n\t * @param answers {Array[Any*]} promises to race\n\t * @returns {Any*} the first promise to be settled\n\t */\n\tQ.race = race;\n\tfunction race(answerPs) {\n\t    return promise(function (resolve, reject) {\n\t        // Switch to this once we can assume at least ES5\n\t        // answerPs.forEach(function (answerP) {\n\t        //     Q(answerP).then(resolve, reject);\n\t        // });\n\t        // Use this in the meantime\n\t        for (var i = 0, len = answerPs.length; i < len; i++) {\n\t            Q(answerPs[i]).then(resolve, reject);\n\t        }\n\t    });\n\t}\n\t\n\tPromise.prototype.race = function () {\n\t    return this.then(Q.race);\n\t};\n\t\n\t/**\n\t * Constructs a Promise with a promise descriptor object and optional fallback\n\t * function.  The descriptor contains methods like when(rejected), get(name),\n\t * set(name, value), post(name, args), and delete(name), which all\n\t * return either a value, a promise for a value, or a rejection.  The fallback\n\t * accepts the operation name, a resolver, and any further arguments that would\n\t * have been forwarded to the appropriate method above had a method been\n\t * provided with the proper name.  The API makes no guarantees about the nature\n\t * of the returned object, apart from that it is usable whereever promises are\n\t * bought and sold.\n\t */\n\tQ.makePromise = Promise;\n\tfunction Promise(descriptor, fallback, inspect) {\n\t    if (fallback === void 0) {\n\t        fallback = function (op) {\n\t            return reject(new Error(\n\t                \"Promise does not support operation: \" + op\n\t            ));\n\t        };\n\t    }\n\t    if (inspect === void 0) {\n\t        inspect = function () {\n\t            return {state: \"unknown\"};\n\t        };\n\t    }\n\t\n\t    var promise = object_create(Promise.prototype);\n\t\n\t    promise.promiseDispatch = function (resolve, op, args) {\n\t        var result;\n\t        try {\n\t            if (descriptor[op]) {\n\t                result = descriptor[op].apply(promise, args);\n\t            } else {\n\t                result = fallback.call(promise, op, args);\n\t            }\n\t        } catch (exception) {\n\t            result = reject(exception);\n\t        }\n\t        if (resolve) {\n\t            resolve(result);\n\t        }\n\t    };\n\t\n\t    promise.inspect = inspect;\n\t\n\t    // XXX deprecated `valueOf` and `exception` support\n\t    if (inspect) {\n\t        var inspected = inspect();\n\t        if (inspected.state === \"rejected\") {\n\t            promise.exception = inspected.reason;\n\t        }\n\t\n\t        promise.valueOf = function () {\n\t            var inspected = inspect();\n\t            if (inspected.state === \"pending\" ||\n\t                inspected.state === \"rejected\") {\n\t                return promise;\n\t            }\n\t            return inspected.value;\n\t        };\n\t    }\n\t\n\t    return promise;\n\t}\n\t\n\tPromise.prototype.toString = function () {\n\t    return \"[object Promise]\";\n\t};\n\t\n\tPromise.prototype.then = function (fulfilled, rejected, progressed) {\n\t    var self = this;\n\t    var deferred = defer();\n\t    var done = false;   // ensure the untrusted promise makes at most a\n\t                        // single call to one of the callbacks\n\t\n\t    function _fulfilled(value) {\n\t        try {\n\t            return typeof fulfilled === \"function\" ? fulfilled(value) : value;\n\t        } catch (exception) {\n\t            return reject(exception);\n\t        }\n\t    }\n\t\n\t    function _rejected(exception) {\n\t        if (typeof rejected === \"function\") {\n\t            makeStackTraceLong(exception, self);\n\t            try {\n\t                return rejected(exception);\n\t            } catch (newException) {\n\t                return reject(newException);\n\t            }\n\t        }\n\t        return reject(exception);\n\t    }\n\t\n\t    function _progressed(value) {\n\t        return typeof progressed === \"function\" ? progressed(value) : value;\n\t    }\n\t\n\t    Q.nextTick(function () {\n\t        self.promiseDispatch(function (value) {\n\t            if (done) {\n\t                return;\n\t            }\n\t            done = true;\n\t\n\t            deferred.resolve(_fulfilled(value));\n\t        }, \"when\", [function (exception) {\n\t            if (done) {\n\t                return;\n\t            }\n\t            done = true;\n\t\n\t            deferred.resolve(_rejected(exception));\n\t        }]);\n\t    });\n\t\n\t    // Progress propagator need to be attached in the current tick.\n\t    self.promiseDispatch(void 0, \"when\", [void 0, function (value) {\n\t        var newValue;\n\t        var threw = false;\n\t        try {\n\t            newValue = _progressed(value);\n\t        } catch (e) {\n\t            threw = true;\n\t            if (Q.onerror) {\n\t                Q.onerror(e);\n\t            } else {\n\t                throw e;\n\t            }\n\t        }\n\t\n\t        if (!threw) {\n\t            deferred.notify(newValue);\n\t        }\n\t    }]);\n\t\n\t    return deferred.promise;\n\t};\n\t\n\tQ.tap = function (promise, callback) {\n\t    return Q(promise).tap(callback);\n\t};\n\t\n\t/**\n\t * Works almost like \"finally\", but not called for rejections.\n\t * Original resolution value is passed through callback unaffected.\n\t * Callback may return a promise that will be awaited for.\n\t * @param {Function} callback\n\t * @returns {Q.Promise}\n\t * @example\n\t * doSomething()\n\t *   .then(...)\n\t *   .tap(console.log)\n\t *   .then(...);\n\t */\n\tPromise.prototype.tap = function (callback) {\n\t    callback = Q(callback);\n\t\n\t    return this.then(function (value) {\n\t        return callback.fcall(value).thenResolve(value);\n\t    });\n\t};\n\t\n\t/**\n\t * Registers an observer on a promise.\n\t *\n\t * Guarantees:\n\t *\n\t * 1. that fulfilled and rejected will be called only once.\n\t * 2. that either the fulfilled callback or the rejected callback will be\n\t *    called, but not both.\n\t * 3. that fulfilled and rejected will not be called in this turn.\n\t *\n\t * @param value      promise or immediate reference to observe\n\t * @param fulfilled  function to be called with the fulfilled value\n\t * @param rejected   function to be called with the rejection exception\n\t * @param progressed function to be called on any progress notifications\n\t * @return promise for the return value from the invoked callback\n\t */\n\tQ.when = when;\n\tfunction when(value, fulfilled, rejected, progressed) {\n\t    return Q(value).then(fulfilled, rejected, progressed);\n\t}\n\t\n\tPromise.prototype.thenResolve = function (value) {\n\t    return this.then(function () { return value; });\n\t};\n\t\n\tQ.thenResolve = function (promise, value) {\n\t    return Q(promise).thenResolve(value);\n\t};\n\t\n\tPromise.prototype.thenReject = function (reason) {\n\t    return this.then(function () { throw reason; });\n\t};\n\t\n\tQ.thenReject = function (promise, reason) {\n\t    return Q(promise).thenReject(reason);\n\t};\n\t\n\t/**\n\t * If an object is not a promise, it is as \"near\" as possible.\n\t * If a promise is rejected, it is as \"near\" as possible too.\n\t * If it’s a fulfilled promise, the fulfillment value is nearer.\n\t * If it’s a deferred promise and the deferred has been resolved, the\n\t * resolution is \"nearer\".\n\t * @param object\n\t * @returns most resolved (nearest) form of the object\n\t */\n\t\n\t// XXX should we re-do this?\n\tQ.nearer = nearer;\n\tfunction nearer(value) {\n\t    if (isPromise(value)) {\n\t        var inspected = value.inspect();\n\t        if (inspected.state === \"fulfilled\") {\n\t            return inspected.value;\n\t        }\n\t    }\n\t    return value;\n\t}\n\t\n\t/**\n\t * @returns whether the given object is a promise.\n\t * Otherwise it is a fulfilled value.\n\t */\n\tQ.isPromise = isPromise;\n\tfunction isPromise(object) {\n\t    return object instanceof Promise;\n\t}\n\t\n\tQ.isPromiseAlike = isPromiseAlike;\n\tfunction isPromiseAlike(object) {\n\t    return isObject(object) && typeof object.then === \"function\";\n\t}\n\t\n\t/**\n\t * @returns whether the given object is a pending promise, meaning not\n\t * fulfilled or rejected.\n\t */\n\tQ.isPending = isPending;\n\tfunction isPending(object) {\n\t    return isPromise(object) && object.inspect().state === \"pending\";\n\t}\n\t\n\tPromise.prototype.isPending = function () {\n\t    return this.inspect().state === \"pending\";\n\t};\n\t\n\t/**\n\t * @returns whether the given object is a value or fulfilled\n\t * promise.\n\t */\n\tQ.isFulfilled = isFulfilled;\n\tfunction isFulfilled(object) {\n\t    return !isPromise(object) || object.inspect().state === \"fulfilled\";\n\t}\n\t\n\tPromise.prototype.isFulfilled = function () {\n\t    return this.inspect().state === \"fulfilled\";\n\t};\n\t\n\t/**\n\t * @returns whether the given object is a rejected promise.\n\t */\n\tQ.isRejected = isRejected;\n\tfunction isRejected(object) {\n\t    return isPromise(object) && object.inspect().state === \"rejected\";\n\t}\n\t\n\tPromise.prototype.isRejected = function () {\n\t    return this.inspect().state === \"rejected\";\n\t};\n\t\n\t//// BEGIN UNHANDLED REJECTION TRACKING\n\t\n\t// This promise library consumes exceptions thrown in handlers so they can be\n\t// handled by a subsequent promise.  The exceptions get added to this array when\n\t// they are created, and removed when they are handled.  Note that in ES6 or\n\t// shimmed environments, this would naturally be a `Set`.\n\tvar unhandledReasons = [];\n\tvar unhandledRejections = [];\n\tvar reportedUnhandledRejections = [];\n\tvar trackUnhandledRejections = true;\n\t\n\tfunction resetUnhandledRejections() {\n\t    unhandledReasons.length = 0;\n\t    unhandledRejections.length = 0;\n\t\n\t    if (!trackUnhandledRejections) {\n\t        trackUnhandledRejections = true;\n\t    }\n\t}\n\t\n\tfunction trackRejection(promise, reason) {\n\t    if (!trackUnhandledRejections) {\n\t        return;\n\t    }\n\t    if (typeof process === \"object\" && typeof process.emit === \"function\") {\n\t        Q.nextTick.runAfter(function () {\n\t            if (array_indexOf(unhandledRejections, promise) !== -1) {\n\t                process.emit(\"unhandledRejection\", reason, promise);\n\t                reportedUnhandledRejections.push(promise);\n\t            }\n\t        });\n\t    }\n\t\n\t    unhandledRejections.push(promise);\n\t    if (reason && typeof reason.stack !== \"undefined\") {\n\t        unhandledReasons.push(reason.stack);\n\t    } else {\n\t        unhandledReasons.push(\"(no stack) \" + reason);\n\t    }\n\t}\n\t\n\tfunction untrackRejection(promise) {\n\t    if (!trackUnhandledRejections) {\n\t        return;\n\t    }\n\t\n\t    var at = array_indexOf(unhandledRejections, promise);\n\t    if (at !== -1) {\n\t        if (typeof process === \"object\" && typeof process.emit === \"function\") {\n\t            Q.nextTick.runAfter(function () {\n\t                var atReport = array_indexOf(reportedUnhandledRejections, promise);\n\t                if (atReport !== -1) {\n\t                    process.emit(\"rejectionHandled\", unhandledReasons[at], promise);\n\t                    reportedUnhandledRejections.splice(atReport, 1);\n\t                }\n\t            });\n\t        }\n\t        unhandledRejections.splice(at, 1);\n\t        unhandledReasons.splice(at, 1);\n\t    }\n\t}\n\t\n\tQ.resetUnhandledRejections = resetUnhandledRejections;\n\t\n\tQ.getUnhandledReasons = function () {\n\t    // Make a copy so that consumers can't interfere with our internal state.\n\t    return unhandledReasons.slice();\n\t};\n\t\n\tQ.stopUnhandledRejectionTracking = function () {\n\t    resetUnhandledRejections();\n\t    trackUnhandledRejections = false;\n\t};\n\t\n\tresetUnhandledRejections();\n\t\n\t//// END UNHANDLED REJECTION TRACKING\n\t\n\t/**\n\t * Constructs a rejected promise.\n\t * @param reason value describing the failure\n\t */\n\tQ.reject = reject;\n\tfunction reject(reason) {\n\t    var rejection = Promise({\n\t        \"when\": function (rejected) {\n\t            // note that the error has been handled\n\t            if (rejected) {\n\t                untrackRejection(this);\n\t            }\n\t            return rejected ? rejected(reason) : this;\n\t        }\n\t    }, function fallback() {\n\t        return this;\n\t    }, function inspect() {\n\t        return { state: \"rejected\", reason: reason };\n\t    });\n\t\n\t    // Note that the reason has not been handled.\n\t    trackRejection(rejection, reason);\n\t\n\t    return rejection;\n\t}\n\t\n\t/**\n\t * Constructs a fulfilled promise for an immediate reference.\n\t * @param value immediate reference\n\t */\n\tQ.fulfill = fulfill;\n\tfunction fulfill(value) {\n\t    return Promise({\n\t        \"when\": function () {\n\t            return value;\n\t        },\n\t        \"get\": function (name) {\n\t            return value[name];\n\t        },\n\t        \"set\": function (name, rhs) {\n\t            value[name] = rhs;\n\t        },\n\t        \"delete\": function (name) {\n\t            delete value[name];\n\t        },\n\t        \"post\": function (name, args) {\n\t            // Mark Miller proposes that post with no name should apply a\n\t            // promised function.\n\t            if (name === null || name === void 0) {\n\t                return value.apply(void 0, args);\n\t            } else {\n\t                return value[name].apply(value, args);\n\t            }\n\t        },\n\t        \"apply\": function (thisp, args) {\n\t            return value.apply(thisp, args);\n\t        },\n\t        \"keys\": function () {\n\t            return object_keys(value);\n\t        }\n\t    }, void 0, function inspect() {\n\t        return { state: \"fulfilled\", value: value };\n\t    });\n\t}\n\t\n\t/**\n\t * Converts thenables to Q promises.\n\t * @param promise thenable promise\n\t * @returns a Q promise\n\t */\n\tfunction coerce(promise) {\n\t    var deferred = defer();\n\t    Q.nextTick(function () {\n\t        try {\n\t            promise.then(deferred.resolve, deferred.reject, deferred.notify);\n\t        } catch (exception) {\n\t            deferred.reject(exception);\n\t        }\n\t    });\n\t    return deferred.promise;\n\t}\n\t\n\t/**\n\t * Annotates an object such that it will never be\n\t * transferred away from this process over any promise\n\t * communication channel.\n\t * @param object\n\t * @returns promise a wrapping of that object that\n\t * additionally responds to the \"isDef\" message\n\t * without a rejection.\n\t */\n\tQ.master = master;\n\tfunction master(object) {\n\t    return Promise({\n\t        \"isDef\": function () {}\n\t    }, function fallback(op, args) {\n\t        return dispatch(object, op, args);\n\t    }, function () {\n\t        return Q(object).inspect();\n\t    });\n\t}\n\t\n\t/**\n\t * Spreads the values of a promised array of arguments into the\n\t * fulfillment callback.\n\t * @param fulfilled callback that receives variadic arguments from the\n\t * promised array\n\t * @param rejected callback that receives the exception if the promise\n\t * is rejected.\n\t * @returns a promise for the return value or thrown exception of\n\t * either callback.\n\t */\n\tQ.spread = spread;\n\tfunction spread(value, fulfilled, rejected) {\n\t    return Q(value).spread(fulfilled, rejected);\n\t}\n\t\n\tPromise.prototype.spread = function (fulfilled, rejected) {\n\t    return this.all().then(function (array) {\n\t        return fulfilled.apply(void 0, array);\n\t    }, rejected);\n\t};\n\t\n\t/**\n\t * The async function is a decorator for generator functions, turning\n\t * them into asynchronous generators.  Although generators are only part\n\t * of the newest ECMAScript 6 drafts, this code does not cause syntax\n\t * errors in older engines.  This code should continue to work and will\n\t * in fact improve over time as the language improves.\n\t *\n\t * ES6 generators are currently part of V8 version 3.19 with the\n\t * --harmony-generators runtime flag enabled.  SpiderMonkey has had them\n\t * for longer, but under an older Python-inspired form.  This function\n\t * works on both kinds of generators.\n\t *\n\t * Decorates a generator function such that:\n\t *  - it may yield promises\n\t *  - execution will continue when that promise is fulfilled\n\t *  - the value of the yield expression will be the fulfilled value\n\t *  - it returns a promise for the return value (when the generator\n\t *    stops iterating)\n\t *  - the decorated function returns a promise for the return value\n\t *    of the generator or the first rejected promise among those\n\t *    yielded.\n\t *  - if an error is thrown in the generator, it propagates through\n\t *    every following yield until it is caught, or until it escapes\n\t *    the generator function altogether, and is translated into a\n\t *    rejection for the promise returned by the decorated generator.\n\t */\n\tQ.async = async;\n\tfunction async(makeGenerator) {\n\t    return function () {\n\t        // when verb is \"send\", arg is a value\n\t        // when verb is \"throw\", arg is an exception\n\t        function continuer(verb, arg) {\n\t            var result;\n\t\n\t            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only\n\t            // engine that has a deployed base of browsers that support generators.\n\t            // However, SM's generators use the Python-inspired semantics of\n\t            // outdated ES6 drafts.  We would like to support ES6, but we'd also\n\t            // like to make it possible to use generators in deployed browsers, so\n\t            // we also support Python-style generators.  At some point we can remove\n\t            // this block.\n\t\n\t            if (typeof StopIteration === \"undefined\") {\n\t                // ES6 Generators\n\t                try {\n\t                    result = generator[verb](arg);\n\t                } catch (exception) {\n\t                    return reject(exception);\n\t                }\n\t                if (result.done) {\n\t                    return Q(result.value);\n\t                } else {\n\t                    return when(result.value, callback, errback);\n\t                }\n\t            } else {\n\t                // SpiderMonkey Generators\n\t                // FIXME: Remove this case when SM does ES6 generators.\n\t                try {\n\t                    result = generator[verb](arg);\n\t                } catch (exception) {\n\t                    if (isStopIteration(exception)) {\n\t                        return Q(exception.value);\n\t                    } else {\n\t                        return reject(exception);\n\t                    }\n\t                }\n\t                return when(result, callback, errback);\n\t            }\n\t        }\n\t        var generator = makeGenerator.apply(this, arguments);\n\t        var callback = continuer.bind(continuer, \"next\");\n\t        var errback = continuer.bind(continuer, \"throw\");\n\t        return callback();\n\t    };\n\t}\n\t\n\t/**\n\t * The spawn function is a small wrapper around async that immediately\n\t * calls the generator and also ends the promise chain, so that any\n\t * unhandled errors are thrown instead of forwarded to the error\n\t * handler. This is useful because it's extremely common to run\n\t * generators at the top-level to work with libraries.\n\t */\n\tQ.spawn = spawn;\n\tfunction spawn(makeGenerator) {\n\t    Q.done(Q.async(makeGenerator)());\n\t}\n\t\n\t// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.\n\t/**\n\t * Throws a ReturnValue exception to stop an asynchronous generator.\n\t *\n\t * This interface is a stop-gap measure to support generator return\n\t * values in older Firefox/SpiderMonkey.  In browsers that support ES6\n\t * generators like Chromium 29, just use \"return\" in your generator\n\t * functions.\n\t *\n\t * @param value the return value for the surrounding generator\n\t * @throws ReturnValue exception with the value.\n\t * @example\n\t * // ES6 style\n\t * Q.async(function* () {\n\t *      var foo = yield getFooPromise();\n\t *      var bar = yield getBarPromise();\n\t *      return foo + bar;\n\t * })\n\t * // Older SpiderMonkey style\n\t * Q.async(function () {\n\t *      var foo = yield getFooPromise();\n\t *      var bar = yield getBarPromise();\n\t *      Q.return(foo + bar);\n\t * })\n\t */\n\tQ[\"return\"] = _return;\n\tfunction _return(value) {\n\t    throw new QReturnValue(value);\n\t}\n\t\n\t/**\n\t * The promised function decorator ensures that any promise arguments\n\t * are settled and passed as values (`this` is also settled and passed\n\t * as a value).  It will also ensure that the result of a function is\n\t * always a promise.\n\t *\n\t * @example\n\t * var add = Q.promised(function (a, b) {\n\t *     return a + b;\n\t * });\n\t * add(Q(a), Q(B));\n\t *\n\t * @param {function} callback The function to decorate\n\t * @returns {function} a function that has been decorated.\n\t */\n\tQ.promised = promised;\n\tfunction promised(callback) {\n\t    return function () {\n\t        return spread([this, all(arguments)], function (self, args) {\n\t            return callback.apply(self, args);\n\t        });\n\t    };\n\t}\n\t\n\t/**\n\t * sends a message to a value in a future turn\n\t * @param object* the recipient\n\t * @param op the name of the message operation, e.g., \"when\",\n\t * @param args further arguments to be forwarded to the operation\n\t * @returns result {Promise} a promise for the result of the operation\n\t */\n\tQ.dispatch = dispatch;\n\tfunction dispatch(object, op, args) {\n\t    return Q(object).dispatch(op, args);\n\t}\n\t\n\tPromise.prototype.dispatch = function (op, args) {\n\t    var self = this;\n\t    var deferred = defer();\n\t    Q.nextTick(function () {\n\t        self.promiseDispatch(deferred.resolve, op, args);\n\t    });\n\t    return deferred.promise;\n\t};\n\t\n\t/**\n\t * Gets the value of a property in a future turn.\n\t * @param object    promise or immediate reference for target object\n\t * @param name      name of property to get\n\t * @return promise for the property value\n\t */\n\tQ.get = function (object, key) {\n\t    return Q(object).dispatch(\"get\", [key]);\n\t};\n\t\n\tPromise.prototype.get = function (key) {\n\t    return this.dispatch(\"get\", [key]);\n\t};\n\t\n\t/**\n\t * Sets the value of a property in a future turn.\n\t * @param object    promise or immediate reference for object object\n\t * @param name      name of property to set\n\t * @param value     new value of property\n\t * @return promise for the return value\n\t */\n\tQ.set = function (object, key, value) {\n\t    return Q(object).dispatch(\"set\", [key, value]);\n\t};\n\t\n\tPromise.prototype.set = function (key, value) {\n\t    return this.dispatch(\"set\", [key, value]);\n\t};\n\t\n\t/**\n\t * Deletes a property in a future turn.\n\t * @param object    promise or immediate reference for target object\n\t * @param name      name of property to delete\n\t * @return promise for the return value\n\t */\n\tQ.del = // XXX legacy\n\tQ[\"delete\"] = function (object, key) {\n\t    return Q(object).dispatch(\"delete\", [key]);\n\t};\n\t\n\tPromise.prototype.del = // XXX legacy\n\tPromise.prototype[\"delete\"] = function (key) {\n\t    return this.dispatch(\"delete\", [key]);\n\t};\n\t\n\t/**\n\t * Invokes a method in a future turn.\n\t * @param object    promise or immediate reference for target object\n\t * @param name      name of method to invoke\n\t * @param value     a value to post, typically an array of\n\t *                  invocation arguments for promises that\n\t *                  are ultimately backed with `resolve` values,\n\t *                  as opposed to those backed with URLs\n\t *                  wherein the posted value can be any\n\t *                  JSON serializable object.\n\t * @return promise for the return value\n\t */\n\t// bound locally because it is used by other methods\n\tQ.mapply = // XXX As proposed by \"Redsandro\"\n\tQ.post = function (object, name, args) {\n\t    return Q(object).dispatch(\"post\", [name, args]);\n\t};\n\t\n\tPromise.prototype.mapply = // XXX As proposed by \"Redsandro\"\n\tPromise.prototype.post = function (name, args) {\n\t    return this.dispatch(\"post\", [name, args]);\n\t};\n\t\n\t/**\n\t * Invokes a method in a future turn.\n\t * @param object    promise or immediate reference for target object\n\t * @param name      name of method to invoke\n\t * @param ...args   array of invocation arguments\n\t * @return promise for the return value\n\t */\n\tQ.send = // XXX Mark Miller's proposed parlance\n\tQ.mcall = // XXX As proposed by \"Redsandro\"\n\tQ.invoke = function (object, name /*...args*/) {\n\t    return Q(object).dispatch(\"post\", [name, array_slice(arguments, 2)]);\n\t};\n\t\n\tPromise.prototype.send = // XXX Mark Miller's proposed parlance\n\tPromise.prototype.mcall = // XXX As proposed by \"Redsandro\"\n\tPromise.prototype.invoke = function (name /*...args*/) {\n\t    return this.dispatch(\"post\", [name, array_slice(arguments, 1)]);\n\t};\n\t\n\t/**\n\t * Applies the promised function in a future turn.\n\t * @param object    promise or immediate reference for target function\n\t * @param args      array of application arguments\n\t */\n\tQ.fapply = function (object, args) {\n\t    return Q(object).dispatch(\"apply\", [void 0, args]);\n\t};\n\t\n\tPromise.prototype.fapply = function (args) {\n\t    return this.dispatch(\"apply\", [void 0, args]);\n\t};\n\t\n\t/**\n\t * Calls the promised function in a future turn.\n\t * @param object    promise or immediate reference for target function\n\t * @param ...args   array of application arguments\n\t */\n\tQ[\"try\"] =\n\tQ.fcall = function (object /* ...args*/) {\n\t    return Q(object).dispatch(\"apply\", [void 0, array_slice(arguments, 1)]);\n\t};\n\t\n\tPromise.prototype.fcall = function (/*...args*/) {\n\t    return this.dispatch(\"apply\", [void 0, array_slice(arguments)]);\n\t};\n\t\n\t/**\n\t * Binds the promised function, transforming return values into a fulfilled\n\t * promise and thrown errors into a rejected one.\n\t * @param object    promise or immediate reference for target function\n\t * @param ...args   array of application arguments\n\t */\n\tQ.fbind = function (object /*...args*/) {\n\t    var promise = Q(object);\n\t    var args = array_slice(arguments, 1);\n\t    return function fbound() {\n\t        return promise.dispatch(\"apply\", [\n\t            this,\n\t            args.concat(array_slice(arguments))\n\t        ]);\n\t    };\n\t};\n\tPromise.prototype.fbind = function (/*...args*/) {\n\t    var promise = this;\n\t    var args = array_slice(arguments);\n\t    return function fbound() {\n\t        return promise.dispatch(\"apply\", [\n\t            this,\n\t            args.concat(array_slice(arguments))\n\t        ]);\n\t    };\n\t};\n\t\n\t/**\n\t * Requests the names of the owned properties of a promised\n\t * object in a future turn.\n\t * @param object    promise or immediate reference for target object\n\t * @return promise for the keys of the eventually settled object\n\t */\n\tQ.keys = function (object) {\n\t    return Q(object).dispatch(\"keys\", []);\n\t};\n\t\n\tPromise.prototype.keys = function () {\n\t    return this.dispatch(\"keys\", []);\n\t};\n\t\n\t/**\n\t * Turns an array of promises into a promise for an array.  If any of\n\t * the promises gets rejected, the whole array is rejected immediately.\n\t * @param {Array*} an array (or promise for an array) of values (or\n\t * promises for values)\n\t * @returns a promise for an array of the corresponding values\n\t */\n\t// By Mark Miller\n\t// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled\n\tQ.all = all;\n\tfunction all(promises) {\n\t    return when(promises, function (promises) {\n\t        var pendingCount = 0;\n\t        var deferred = defer();\n\t        array_reduce(promises, function (undefined, promise, index) {\n\t            var snapshot;\n\t            if (\n\t                isPromise(promise) &&\n\t                (snapshot = promise.inspect()).state === \"fulfilled\"\n\t            ) {\n\t                promises[index] = snapshot.value;\n\t            } else {\n\t                ++pendingCount;\n\t                when(\n\t                    promise,\n\t                    function (value) {\n\t                        promises[index] = value;\n\t                        if (--pendingCount === 0) {\n\t                            deferred.resolve(promises);\n\t                        }\n\t                    },\n\t                    deferred.reject,\n\t                    function (progress) {\n\t                        deferred.notify({ index: index, value: progress });\n\t                    }\n\t                );\n\t            }\n\t        }, void 0);\n\t        if (pendingCount === 0) {\n\t            deferred.resolve(promises);\n\t        }\n\t        return deferred.promise;\n\t    });\n\t}\n\t\n\tPromise.prototype.all = function () {\n\t    return all(this);\n\t};\n\t\n\t/**\n\t * Returns the first resolved promise of an array. Prior rejected promises are\n\t * ignored.  Rejects only if all promises are rejected.\n\t * @param {Array*} an array containing values or promises for values\n\t * @returns a promise fulfilled with the value of the first resolved promise,\n\t * or a rejected promise if all promises are rejected.\n\t */\n\tQ.any = any;\n\t\n\tfunction any(promises) {\n\t    if (promises.length === 0) {\n\t        return Q.resolve();\n\t    }\n\t\n\t    var deferred = Q.defer();\n\t    var pendingCount = 0;\n\t    array_reduce(promises, function (prev, current, index) {\n\t        var promise = promises[index];\n\t\n\t        pendingCount++;\n\t\n\t        when(promise, onFulfilled, onRejected, onProgress);\n\t        function onFulfilled(result) {\n\t            deferred.resolve(result);\n\t        }\n\t        function onRejected() {\n\t            pendingCount--;\n\t            if (pendingCount === 0) {\n\t                deferred.reject(new Error(\n\t                    \"Can't get fulfillment value from any promise, all \" +\n\t                    \"promises were rejected.\"\n\t                ));\n\t            }\n\t        }\n\t        function onProgress(progress) {\n\t            deferred.notify({\n\t                index: index,\n\t                value: progress\n\t            });\n\t        }\n\t    }, undefined);\n\t\n\t    return deferred.promise;\n\t}\n\t\n\tPromise.prototype.any = function () {\n\t    return any(this);\n\t};\n\t\n\t/**\n\t * Waits for all promises to be settled, either fulfilled or\n\t * rejected.  This is distinct from `all` since that would stop\n\t * waiting at the first rejection.  The promise returned by\n\t * `allResolved` will never be rejected.\n\t * @param promises a promise for an array (or an array) of promises\n\t * (or values)\n\t * @return a promise for an array of promises\n\t */\n\tQ.allResolved = deprecate(allResolved, \"allResolved\", \"allSettled\");\n\tfunction allResolved(promises) {\n\t    return when(promises, function (promises) {\n\t        promises = array_map(promises, Q);\n\t        return when(all(array_map(promises, function (promise) {\n\t            return when(promise, noop, noop);\n\t        })), function () {\n\t            return promises;\n\t        });\n\t    });\n\t}\n\t\n\tPromise.prototype.allResolved = function () {\n\t    return allResolved(this);\n\t};\n\t\n\t/**\n\t * @see Promise#allSettled\n\t */\n\tQ.allSettled = allSettled;\n\tfunction allSettled(promises) {\n\t    return Q(promises).allSettled();\n\t}\n\t\n\t/**\n\t * Turns an array of promises into a promise for an array of their states (as\n\t * returned by `inspect`) when they have all settled.\n\t * @param {Array[Any*]} values an array (or promise for an array) of values (or\n\t * promises for values)\n\t * @returns {Array[State]} an array of states for the respective values.\n\t */\n\tPromise.prototype.allSettled = function () {\n\t    return this.then(function (promises) {\n\t        return all(array_map(promises, function (promise) {\n\t            promise = Q(promise);\n\t            function regardless() {\n\t                return promise.inspect();\n\t            }\n\t            return promise.then(regardless, regardless);\n\t        }));\n\t    });\n\t};\n\t\n\t/**\n\t * Captures the failure of a promise, giving an oportunity to recover\n\t * with a callback.  If the given promise is fulfilled, the returned\n\t * promise is fulfilled.\n\t * @param {Any*} promise for something\n\t * @param {Function} callback to fulfill the returned promise if the\n\t * given promise is rejected\n\t * @returns a promise for the return value of the callback\n\t */\n\tQ.fail = // XXX legacy\n\tQ[\"catch\"] = function (object, rejected) {\n\t    return Q(object).then(void 0, rejected);\n\t};\n\t\n\tPromise.prototype.fail = // XXX legacy\n\tPromise.prototype[\"catch\"] = function (rejected) {\n\t    return this.then(void 0, rejected);\n\t};\n\t\n\t/**\n\t * Attaches a listener that can respond to progress notifications from a\n\t * promise's originating deferred. This listener receives the exact arguments\n\t * passed to ``deferred.notify``.\n\t * @param {Any*} promise for something\n\t * @param {Function} callback to receive any progress notifications\n\t * @returns the given promise, unchanged\n\t */\n\tQ.progress = progress;\n\tfunction progress(object, progressed) {\n\t    return Q(object).then(void 0, void 0, progressed);\n\t}\n\t\n\tPromise.prototype.progress = function (progressed) {\n\t    return this.then(void 0, void 0, progressed);\n\t};\n\t\n\t/**\n\t * Provides an opportunity to observe the settling of a promise,\n\t * regardless of whether the promise is fulfilled or rejected.  Forwards\n\t * the resolution to the returned promise when the callback is done.\n\t * The callback can return a promise to defer completion.\n\t * @param {Any*} promise\n\t * @param {Function} callback to observe the resolution of the given\n\t * promise, takes no arguments.\n\t * @returns a promise for the resolution of the given promise when\n\t * ``fin`` is done.\n\t */\n\tQ.fin = // XXX legacy\n\tQ[\"finally\"] = function (object, callback) {\n\t    return Q(object)[\"finally\"](callback);\n\t};\n\t\n\tPromise.prototype.fin = // XXX legacy\n\tPromise.prototype[\"finally\"] = function (callback) {\n\t    callback = Q(callback);\n\t    return this.then(function (value) {\n\t        return callback.fcall().then(function () {\n\t            return value;\n\t        });\n\t    }, function (reason) {\n\t        // TODO attempt to recycle the rejection with \"this\".\n\t        return callback.fcall().then(function () {\n\t            throw reason;\n\t        });\n\t    });\n\t};\n\t\n\t/**\n\t * Terminates a chain of promises, forcing rejections to be\n\t * thrown as exceptions.\n\t * @param {Any*} promise at the end of a chain of promises\n\t * @returns nothing\n\t */\n\tQ.done = function (object, fulfilled, rejected, progress) {\n\t    return Q(object).done(fulfilled, rejected, progress);\n\t};\n\t\n\tPromise.prototype.done = function (fulfilled, rejected, progress) {\n\t    var onUnhandledError = function (error) {\n\t        // forward to a future turn so that ``when``\n\t        // does not catch it and turn it into a rejection.\n\t        Q.nextTick(function () {\n\t            makeStackTraceLong(error, promise);\n\t            if (Q.onerror) {\n\t                Q.onerror(error);\n\t            } else {\n\t                throw error;\n\t            }\n\t        });\n\t    };\n\t\n\t    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.\n\t    var promise = fulfilled || rejected || progress ?\n\t        this.then(fulfilled, rejected, progress) :\n\t        this;\n\t\n\t    if (typeof process === \"object\" && process && process.domain) {\n\t        onUnhandledError = process.domain.bind(onUnhandledError);\n\t    }\n\t\n\t    promise.then(void 0, onUnhandledError);\n\t};\n\t\n\t/**\n\t * Causes a promise to be rejected if it does not get fulfilled before\n\t * some milliseconds time out.\n\t * @param {Any*} promise\n\t * @param {Number} milliseconds timeout\n\t * @param {Any*} custom error message or Error object (optional)\n\t * @returns a promise for the resolution of the given promise if it is\n\t * fulfilled before the timeout, otherwise rejected.\n\t */\n\tQ.timeout = function (object, ms, error) {\n\t    return Q(object).timeout(ms, error);\n\t};\n\t\n\tPromise.prototype.timeout = function (ms, error) {\n\t    var deferred = defer();\n\t    var timeoutId = setTimeout(function () {\n\t        if (!error || \"string\" === typeof error) {\n\t            error = new Error(error || \"Timed out after \" + ms + \" ms\");\n\t            error.code = \"ETIMEDOUT\";\n\t        }\n\t        deferred.reject(error);\n\t    }, ms);\n\t\n\t    this.then(function (value) {\n\t        clearTimeout(timeoutId);\n\t        deferred.resolve(value);\n\t    }, function (exception) {\n\t        clearTimeout(timeoutId);\n\t        deferred.reject(exception);\n\t    }, deferred.notify);\n\t\n\t    return deferred.promise;\n\t};\n\t\n\t/**\n\t * Returns a promise for the given value (or promised value), some\n\t * milliseconds after it resolved. Passes rejections immediately.\n\t * @param {Any*} promise\n\t * @param {Number} milliseconds\n\t * @returns a promise for the resolution of the given promise after milliseconds\n\t * time has elapsed since the resolution of the given promise.\n\t * If the given promise rejects, that is passed immediately.\n\t */\n\tQ.delay = function (object, timeout) {\n\t    if (timeout === void 0) {\n\t        timeout = object;\n\t        object = void 0;\n\t    }\n\t    return Q(object).delay(timeout);\n\t};\n\t\n\tPromise.prototype.delay = function (timeout) {\n\t    return this.then(function (value) {\n\t        var deferred = defer();\n\t        setTimeout(function () {\n\t            deferred.resolve(value);\n\t        }, timeout);\n\t        return deferred.promise;\n\t    });\n\t};\n\t\n\t/**\n\t * Passes a continuation to a Node function, which is called with the given\n\t * arguments provided as an array, and returns a promise.\n\t *\n\t *      Q.nfapply(FS.readFile, [__filename])\n\t *      .then(function (content) {\n\t *      })\n\t *\n\t */\n\tQ.nfapply = function (callback, args) {\n\t    return Q(callback).nfapply(args);\n\t};\n\t\n\tPromise.prototype.nfapply = function (args) {\n\t    var deferred = defer();\n\t    var nodeArgs = array_slice(args);\n\t    nodeArgs.push(deferred.makeNodeResolver());\n\t    this.fapply(nodeArgs).fail(deferred.reject);\n\t    return deferred.promise;\n\t};\n\t\n\t/**\n\t * Passes a continuation to a Node function, which is called with the given\n\t * arguments provided individually, and returns a promise.\n\t * @example\n\t * Q.nfcall(FS.readFile, __filename)\n\t * .then(function (content) {\n\t * })\n\t *\n\t */\n\tQ.nfcall = function (callback /*...args*/) {\n\t    var args = array_slice(arguments, 1);\n\t    return Q(callback).nfapply(args);\n\t};\n\t\n\tPromise.prototype.nfcall = function (/*...args*/) {\n\t    var nodeArgs = array_slice(arguments);\n\t    var deferred = defer();\n\t    nodeArgs.push(deferred.makeNodeResolver());\n\t    this.fapply(nodeArgs).fail(deferred.reject);\n\t    return deferred.promise;\n\t};\n\t\n\t/**\n\t * Wraps a NodeJS continuation passing function and returns an equivalent\n\t * version that returns a promise.\n\t * @example\n\t * Q.nfbind(FS.readFile, __filename)(\"utf-8\")\n\t * .then(console.log)\n\t * .done()\n\t */\n\tQ.nfbind =\n\tQ.denodeify = function (callback /*...args*/) {\n\t    var baseArgs = array_slice(arguments, 1);\n\t    return function () {\n\t        var nodeArgs = baseArgs.concat(array_slice(arguments));\n\t        var deferred = defer();\n\t        nodeArgs.push(deferred.makeNodeResolver());\n\t        Q(callback).fapply(nodeArgs).fail(deferred.reject);\n\t        return deferred.promise;\n\t    };\n\t};\n\t\n\tPromise.prototype.nfbind =\n\tPromise.prototype.denodeify = function (/*...args*/) {\n\t    var args = array_slice(arguments);\n\t    args.unshift(this);\n\t    return Q.denodeify.apply(void 0, args);\n\t};\n\t\n\tQ.nbind = function (callback, thisp /*...args*/) {\n\t    var baseArgs = array_slice(arguments, 2);\n\t    return function () {\n\t        var nodeArgs = baseArgs.concat(array_slice(arguments));\n\t        var deferred = defer();\n\t        nodeArgs.push(deferred.makeNodeResolver());\n\t        function bound() {\n\t            return callback.apply(thisp, arguments);\n\t        }\n\t        Q(bound).fapply(nodeArgs).fail(deferred.reject);\n\t        return deferred.promise;\n\t    };\n\t};\n\t\n\tPromise.prototype.nbind = function (/*thisp, ...args*/) {\n\t    var args = array_slice(arguments, 0);\n\t    args.unshift(this);\n\t    return Q.nbind.apply(void 0, args);\n\t};\n\t\n\t/**\n\t * Calls a method of a Node-style object that accepts a Node-style\n\t * callback with a given array of arguments, plus a provided callback.\n\t * @param object an object that has the named method\n\t * @param {String} name name of the method of object\n\t * @param {Array} args arguments to pass to the method; the callback\n\t * will be provided by Q and appended to these arguments.\n\t * @returns a promise for the value or error\n\t */\n\tQ.nmapply = // XXX As proposed by \"Redsandro\"\n\tQ.npost = function (object, name, args) {\n\t    return Q(object).npost(name, args);\n\t};\n\t\n\tPromise.prototype.nmapply = // XXX As proposed by \"Redsandro\"\n\tPromise.prototype.npost = function (name, args) {\n\t    var nodeArgs = array_slice(args || []);\n\t    var deferred = defer();\n\t    nodeArgs.push(deferred.makeNodeResolver());\n\t    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n\t    return deferred.promise;\n\t};\n\t\n\t/**\n\t * Calls a method of a Node-style object that accepts a Node-style\n\t * callback, forwarding the given variadic arguments, plus a provided\n\t * callback argument.\n\t * @param object an object that has the named method\n\t * @param {String} name name of the method of object\n\t * @param ...args arguments to pass to the method; the callback will\n\t * be provided by Q and appended to these arguments.\n\t * @returns a promise for the value or error\n\t */\n\tQ.nsend = // XXX Based on Mark Miller's proposed \"send\"\n\tQ.nmcall = // XXX Based on \"Redsandro's\" proposal\n\tQ.ninvoke = function (object, name /*...args*/) {\n\t    var nodeArgs = array_slice(arguments, 2);\n\t    var deferred = defer();\n\t    nodeArgs.push(deferred.makeNodeResolver());\n\t    Q(object).dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n\t    return deferred.promise;\n\t};\n\t\n\tPromise.prototype.nsend = // XXX Based on Mark Miller's proposed \"send\"\n\tPromise.prototype.nmcall = // XXX Based on \"Redsandro's\" proposal\n\tPromise.prototype.ninvoke = function (name /*...args*/) {\n\t    var nodeArgs = array_slice(arguments, 1);\n\t    var deferred = defer();\n\t    nodeArgs.push(deferred.makeNodeResolver());\n\t    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n\t    return deferred.promise;\n\t};\n\t\n\t/**\n\t * If a function would like to support both Node continuation-passing-style and\n\t * promise-returning-style, it can end its internal promise chain with\n\t * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user\n\t * elects to use a nodeback, the result will be sent there.  If they do not\n\t * pass a nodeback, they will receive the result promise.\n\t * @param object a result (or a promise for a result)\n\t * @param {Function} nodeback a Node.js-style callback\n\t * @returns either the promise or nothing\n\t */\n\tQ.nodeify = nodeify;\n\tfunction nodeify(object, nodeback) {\n\t    return Q(object).nodeify(nodeback);\n\t}\n\t\n\tPromise.prototype.nodeify = function (nodeback) {\n\t    if (nodeback) {\n\t        this.then(function (value) {\n\t            Q.nextTick(function () {\n\t                nodeback(null, value);\n\t            });\n\t        }, function (error) {\n\t            Q.nextTick(function () {\n\t                nodeback(error);\n\t            });\n\t        });\n\t    } else {\n\t        return this;\n\t    }\n\t};\n\t\n\tQ.noConflict = function() {\n\t    throw new Error(\"Q.noConflict only works when Q is used as a global\");\n\t};\n\t\n\t// All code before this point will be filtered from stack traces.\n\tvar qEndingLine = captureLine();\n\t\n\treturn Q;\n\t\n\t});\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(31), __webpack_require__(17).setImmediate))\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/*!\n\t * Vue.js v1.0.21\n\t * (c) 2016 Evan You\n\t * Released under the MIT License.\n\t */\n\t'use strict';\n\t\n\tfunction set(obj, key, val) {\n\t  if (hasOwn(obj, key)) {\n\t    obj[key] = val;\n\t    return;\n\t  }\n\t  if (obj._isVue) {\n\t    set(obj._data, key, val);\n\t    return;\n\t  }\n\t  var ob = obj.__ob__;\n\t  if (!ob) {\n\t    obj[key] = val;\n\t    return;\n\t  }\n\t  ob.convert(key, val);\n\t  ob.dep.notify();\n\t  if (ob.vms) {\n\t    var i = ob.vms.length;\n\t    while (i--) {\n\t      var vm = ob.vms[i];\n\t      vm._proxy(key);\n\t      vm._digest();\n\t    }\n\t  }\n\t  return val;\n\t}\n\t\n\t/**\n\t * Delete a property and trigger change if necessary.\n\t *\n\t * @param {Object} obj\n\t * @param {String} key\n\t */\n\t\n\tfunction del(obj, key) {\n\t  if (!hasOwn(obj, key)) {\n\t    return;\n\t  }\n\t  delete obj[key];\n\t  var ob = obj.__ob__;\n\t  if (!ob) {\n\t    return;\n\t  }\n\t  ob.dep.notify();\n\t  if (ob.vms) {\n\t    var i = ob.vms.length;\n\t    while (i--) {\n\t      var vm = ob.vms[i];\n\t      vm._unproxy(key);\n\t      vm._digest();\n\t    }\n\t  }\n\t}\n\t\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\t/**\n\t * Check whether the object has the property.\n\t *\n\t * @param {Object} obj\n\t * @param {String} key\n\t * @return {Boolean}\n\t */\n\t\n\tfunction hasOwn(obj, key) {\n\t  return hasOwnProperty.call(obj, key);\n\t}\n\t\n\t/**\n\t * Check if an expression is a literal value.\n\t *\n\t * @param {String} exp\n\t * @return {Boolean}\n\t */\n\t\n\tvar literalValueRE = /^\\s?(true|false|-?[\\d\\.]+|'[^']*'|\"[^\"]*\")\\s?$/;\n\t\n\tfunction isLiteral(exp) {\n\t  return literalValueRE.test(exp);\n\t}\n\t\n\t/**\n\t * Check if a string starts with $ or _\n\t *\n\t * @param {String} str\n\t * @return {Boolean}\n\t */\n\t\n\tfunction isReserved(str) {\n\t  var c = (str + '').charCodeAt(0);\n\t  return c === 0x24 || c === 0x5F;\n\t}\n\t\n\t/**\n\t * Guard text output, make sure undefined outputs\n\t * empty string\n\t *\n\t * @param {*} value\n\t * @return {String}\n\t */\n\t\n\tfunction _toString(value) {\n\t  return value == null ? '' : value.toString();\n\t}\n\t\n\t/**\n\t * Check and convert possible numeric strings to numbers\n\t * before setting back to data\n\t *\n\t * @param {*} value\n\t * @return {*|Number}\n\t */\n\t\n\tfunction toNumber(value) {\n\t  if (typeof value !== 'string') {\n\t    return value;\n\t  } else {\n\t    var parsed = Number(value);\n\t    return isNaN(parsed) ? value : parsed;\n\t  }\n\t}\n\t\n\t/**\n\t * Convert string boolean literals into real booleans.\n\t *\n\t * @param {*} value\n\t * @return {*|Boolean}\n\t */\n\t\n\tfunction toBoolean(value) {\n\t  return value === 'true' ? true : value === 'false' ? false : value;\n\t}\n\t\n\t/**\n\t * Strip quotes from a string\n\t *\n\t * @param {String} str\n\t * @return {String | false}\n\t */\n\t\n\tfunction stripQuotes(str) {\n\t  var a = str.charCodeAt(0);\n\t  var b = str.charCodeAt(str.length - 1);\n\t  return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;\n\t}\n\t\n\t/**\n\t * Camelize a hyphen-delmited string.\n\t *\n\t * @param {String} str\n\t * @return {String}\n\t */\n\t\n\tvar camelizeRE = /-(\\w)/g;\n\t\n\tfunction camelize(str) {\n\t  return str.replace(camelizeRE, toUpper);\n\t}\n\t\n\tfunction toUpper(_, c) {\n\t  return c ? c.toUpperCase() : '';\n\t}\n\t\n\t/**\n\t * Hyphenate a camelCase string.\n\t *\n\t * @param {String} str\n\t * @return {String}\n\t */\n\t\n\tvar hyphenateRE = /([a-z\\d])([A-Z])/g;\n\t\n\tfunction hyphenate(str) {\n\t  return str.replace(hyphenateRE, '$1-$2').toLowerCase();\n\t}\n\t\n\t/**\n\t * Converts hyphen/underscore/slash delimitered names into\n\t * camelized classNames.\n\t *\n\t * e.g. my-component => MyComponent\n\t *      some_else    => SomeElse\n\t *      some/comp    => SomeComp\n\t *\n\t * @param {String} str\n\t * @return {String}\n\t */\n\t\n\tvar classifyRE = /(?:^|[-_\\/])(\\w)/g;\n\t\n\tfunction classify(str) {\n\t  return str.replace(classifyRE, toUpper);\n\t}\n\t\n\t/**\n\t * Simple bind, faster than native\n\t *\n\t * @param {Function} fn\n\t * @param {Object} ctx\n\t * @return {Function}\n\t */\n\t\n\tfunction bind(fn, ctx) {\n\t  return function (a) {\n\t    var l = arguments.length;\n\t    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n\t  };\n\t}\n\t\n\t/**\n\t * Convert an Array-like object to a real Array.\n\t *\n\t * @param {Array-like} list\n\t * @param {Number} [start] - start index\n\t * @return {Array}\n\t */\n\t\n\tfunction toArray(list, start) {\n\t  start = start || 0;\n\t  var i = list.length - start;\n\t  var ret = new Array(i);\n\t  while (i--) {\n\t    ret[i] = list[i + start];\n\t  }\n\t  return ret;\n\t}\n\t\n\t/**\n\t * Mix properties into target object.\n\t *\n\t * @param {Object} to\n\t * @param {Object} from\n\t */\n\t\n\tfunction extend(to, from) {\n\t  var keys = Object.keys(from);\n\t  var i = keys.length;\n\t  while (i--) {\n\t    to[keys[i]] = from[keys[i]];\n\t  }\n\t  return to;\n\t}\n\t\n\t/**\n\t * Quick object check - this is primarily used to tell\n\t * Objects from primitive values when we know the value\n\t * is a JSON-compliant type.\n\t *\n\t * @param {*} obj\n\t * @return {Boolean}\n\t */\n\t\n\tfunction isObject(obj) {\n\t  return obj !== null && typeof obj === 'object';\n\t}\n\t\n\t/**\n\t * Strict object type check. Only returns true\n\t * for plain JavaScript objects.\n\t *\n\t * @param {*} obj\n\t * @return {Boolean}\n\t */\n\t\n\tvar toString = Object.prototype.toString;\n\tvar OBJECT_STRING = '[object Object]';\n\t\n\tfunction isPlainObject(obj) {\n\t  return toString.call(obj) === OBJECT_STRING;\n\t}\n\t\n\t/**\n\t * Array type check.\n\t *\n\t * @param {*} obj\n\t * @return {Boolean}\n\t */\n\t\n\tvar isArray = Array.isArray;\n\t\n\t/**\n\t * Define a property.\n\t *\n\t * @param {Object} obj\n\t * @param {String} key\n\t * @param {*} val\n\t * @param {Boolean} [enumerable]\n\t */\n\t\n\tfunction def(obj, key, val, enumerable) {\n\t  Object.defineProperty(obj, key, {\n\t    value: val,\n\t    enumerable: !!enumerable,\n\t    writable: true,\n\t    configurable: true\n\t  });\n\t}\n\t\n\t/**\n\t * Debounce a function so it only gets called after the\n\t * input stops arriving after the given wait period.\n\t *\n\t * @param {Function} func\n\t * @param {Number} wait\n\t * @return {Function} - the debounced function\n\t */\n\t\n\tfunction _debounce(func, wait) {\n\t  var timeout, args, context, timestamp, result;\n\t  var later = function later() {\n\t    var last = Date.now() - timestamp;\n\t    if (last < wait && last >= 0) {\n\t      timeout = setTimeout(later, wait - last);\n\t    } else {\n\t      timeout = null;\n\t      result = func.apply(context, args);\n\t      if (!timeout) context = args = null;\n\t    }\n\t  };\n\t  return function () {\n\t    context = this;\n\t    args = arguments;\n\t    timestamp = Date.now();\n\t    if (!timeout) {\n\t      timeout = setTimeout(later, wait);\n\t    }\n\t    return result;\n\t  };\n\t}\n\t\n\t/**\n\t * Manual indexOf because it's slightly faster than\n\t * native.\n\t *\n\t * @param {Array} arr\n\t * @param {*} obj\n\t */\n\t\n\tfunction indexOf(arr, obj) {\n\t  var i = arr.length;\n\t  while (i--) {\n\t    if (arr[i] === obj) return i;\n\t  }\n\t  return -1;\n\t}\n\t\n\t/**\n\t * Make a cancellable version of an async callback.\n\t *\n\t * @param {Function} fn\n\t * @return {Function}\n\t */\n\t\n\tfunction cancellable(fn) {\n\t  var cb = function cb() {\n\t    if (!cb.cancelled) {\n\t      return fn.apply(this, arguments);\n\t    }\n\t  };\n\t  cb.cancel = function () {\n\t    cb.cancelled = true;\n\t  };\n\t  return cb;\n\t}\n\t\n\t/**\n\t * Check if two values are loosely equal - that is,\n\t * if they are plain objects, do they have the same shape?\n\t *\n\t * @param {*} a\n\t * @param {*} b\n\t * @return {Boolean}\n\t */\n\t\n\tfunction looseEqual(a, b) {\n\t  /* eslint-disable eqeqeq */\n\t  return a == b || (isObject(a) && isObject(b) ? JSON.stringify(a) === JSON.stringify(b) : false);\n\t  /* eslint-enable eqeqeq */\n\t}\n\t\n\tvar hasProto = ('__proto__' in {});\n\t\n\t// Browser environment sniffing\n\tvar inBrowser = typeof window !== 'undefined' && Object.prototype.toString.call(window) !== '[object Object]';\n\t\n\t// detect devtools\n\tvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\t\n\t// UA sniffing for working around browser-specific quirks\n\tvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\n\tvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\n\tvar isAndroid = UA && UA.indexOf('android') > 0;\n\t\n\tvar transitionProp = undefined;\n\tvar transitionEndEvent = undefined;\n\tvar animationProp = undefined;\n\tvar animationEndEvent = undefined;\n\t\n\t// Transition property/event sniffing\n\tif (inBrowser && !isIE9) {\n\t  var isWebkitTrans = window.ontransitionend === undefined && window.onwebkittransitionend !== undefined;\n\t  var isWebkitAnim = window.onanimationend === undefined && window.onwebkitanimationend !== undefined;\n\t  transitionProp = isWebkitTrans ? 'WebkitTransition' : 'transition';\n\t  transitionEndEvent = isWebkitTrans ? 'webkitTransitionEnd' : 'transitionend';\n\t  animationProp = isWebkitAnim ? 'WebkitAnimation' : 'animation';\n\t  animationEndEvent = isWebkitAnim ? 'webkitAnimationEnd' : 'animationend';\n\t}\n\t\n\t/**\n\t * Defer a task to execute it asynchronously. Ideally this\n\t * should be executed as a microtask, so we leverage\n\t * MutationObserver if it's available, and fallback to\n\t * setTimeout(0).\n\t *\n\t * @param {Function} cb\n\t * @param {Object} ctx\n\t */\n\t\n\tvar nextTick = (function () {\n\t  var callbacks = [];\n\t  var pending = false;\n\t  var timerFunc;\n\t  function nextTickHandler() {\n\t    pending = false;\n\t    var copies = callbacks.slice(0);\n\t    callbacks = [];\n\t    for (var i = 0; i < copies.length; i++) {\n\t      copies[i]();\n\t    }\n\t  }\n\t\n\t  /* istanbul ignore if */\n\t  if (typeof MutationObserver !== 'undefined') {\n\t    var counter = 1;\n\t    var observer = new MutationObserver(nextTickHandler);\n\t    var textNode = document.createTextNode(counter);\n\t    observer.observe(textNode, {\n\t      characterData: true\n\t    });\n\t    timerFunc = function () {\n\t      counter = (counter + 1) % 2;\n\t      textNode.data = counter;\n\t    };\n\t  } else {\n\t    // webpack attempts to inject a shim for setImmediate\n\t    // if it is used as a global, so we have to work around that to\n\t    // avoid bundling unnecessary code.\n\t    var context = inBrowser ? window : typeof global !== 'undefined' ? global : {};\n\t    timerFunc = context.setImmediate || setTimeout;\n\t  }\n\t  return function (cb, ctx) {\n\t    var func = ctx ? function () {\n\t      cb.call(ctx);\n\t    } : cb;\n\t    callbacks.push(func);\n\t    if (pending) return;\n\t    pending = true;\n\t    timerFunc(nextTickHandler, 0);\n\t  };\n\t})();\n\t\n\tfunction Cache(limit) {\n\t  this.size = 0;\n\t  this.limit = limit;\n\t  this.head = this.tail = undefined;\n\t  this._keymap = Object.create(null);\n\t}\n\t\n\tvar p = Cache.prototype;\n\t\n\t/**\n\t * Put <value> into the cache associated with <key>.\n\t * Returns the entry which was removed to make room for\n\t * the new entry. Otherwise undefined is returned.\n\t * (i.e. if there was enough room already).\n\t *\n\t * @param {String} key\n\t * @param {*} value\n\t * @return {Entry|undefined}\n\t */\n\t\n\tp.put = function (key, value) {\n\t  var removed;\n\t  if (this.size === this.limit) {\n\t    removed = this.shift();\n\t  }\n\t\n\t  var entry = this.get(key, true);\n\t  if (!entry) {\n\t    entry = {\n\t      key: key\n\t    };\n\t    this._keymap[key] = entry;\n\t    if (this.tail) {\n\t      this.tail.newer = entry;\n\t      entry.older = this.tail;\n\t    } else {\n\t      this.head = entry;\n\t    }\n\t    this.tail = entry;\n\t    this.size++;\n\t  }\n\t  entry.value = value;\n\t\n\t  return removed;\n\t};\n\t\n\t/**\n\t * Purge the least recently used (oldest) entry from the\n\t * cache. Returns the removed entry or undefined if the\n\t * cache was empty.\n\t */\n\t\n\tp.shift = function () {\n\t  var entry = this.head;\n\t  if (entry) {\n\t    this.head = this.head.newer;\n\t    this.head.older = undefined;\n\t    entry.newer = entry.older = undefined;\n\t    this._keymap[entry.key] = undefined;\n\t    this.size--;\n\t  }\n\t  return entry;\n\t};\n\t\n\t/**\n\t * Get and register recent use of <key>. Returns the value\n\t * associated with <key> or undefined if not in cache.\n\t *\n\t * @param {String} key\n\t * @param {Boolean} returnEntry\n\t * @return {Entry|*}\n\t */\n\t\n\tp.get = function (key, returnEntry) {\n\t  var entry = this._keymap[key];\n\t  if (entry === undefined) return;\n\t  if (entry === this.tail) {\n\t    return returnEntry ? entry : entry.value;\n\t  }\n\t  // HEAD--------------TAIL\n\t  //   <.older   .newer>\n\t  //  <--- add direction --\n\t  //   A  B  C  <D>  E\n\t  if (entry.newer) {\n\t    if (entry === this.head) {\n\t      this.head = entry.newer;\n\t    }\n\t    entry.newer.older = entry.older; // C <-- E.\n\t  }\n\t  if (entry.older) {\n\t    entry.older.newer = entry.newer; // C. --> E\n\t  }\n\t  entry.newer = undefined; // D --x\n\t  entry.older = this.tail; // D. --> E\n\t  if (this.tail) {\n\t    this.tail.newer = entry; // E. <-- D\n\t  }\n\t  this.tail = entry;\n\t  return returnEntry ? entry : entry.value;\n\t};\n\t\n\tvar cache$1 = new Cache(1000);\n\tvar filterTokenRE = /[^\\s'\"]+|'[^']*'|\"[^\"]*\"/g;\n\tvar reservedArgRE = /^in$|^-?\\d+/;\n\t\n\t/**\n\t * Parser state\n\t */\n\t\n\tvar str;\n\tvar dir;\n\tvar c;\n\tvar prev;\n\tvar i;\n\tvar l;\n\tvar lastFilterIndex;\n\tvar inSingle;\n\tvar inDouble;\n\tvar curly;\n\tvar square;\n\tvar paren;\n\t/**\n\t * Push a filter to the current directive object\n\t */\n\t\n\tfunction pushFilter() {\n\t  var exp = str.slice(lastFilterIndex, i).trim();\n\t  var filter;\n\t  if (exp) {\n\t    filter = {};\n\t    var tokens = exp.match(filterTokenRE);\n\t    filter.name = tokens[0];\n\t    if (tokens.length > 1) {\n\t      filter.args = tokens.slice(1).map(processFilterArg);\n\t    }\n\t  }\n\t  if (filter) {\n\t    (dir.filters = dir.filters || []).push(filter);\n\t  }\n\t  lastFilterIndex = i + 1;\n\t}\n\t\n\t/**\n\t * Check if an argument is dynamic and strip quotes.\n\t *\n\t * @param {String} arg\n\t * @return {Object}\n\t */\n\t\n\tfunction processFilterArg(arg) {\n\t  if (reservedArgRE.test(arg)) {\n\t    return {\n\t      value: toNumber(arg),\n\t      dynamic: false\n\t    };\n\t  } else {\n\t    var stripped = stripQuotes(arg);\n\t    var dynamic = stripped === arg;\n\t    return {\n\t      value: dynamic ? arg : stripped,\n\t      dynamic: dynamic\n\t    };\n\t  }\n\t}\n\t\n\t/**\n\t * Parse a directive value and extract the expression\n\t * and its filters into a descriptor.\n\t *\n\t * Example:\n\t *\n\t * \"a + 1 | uppercase\" will yield:\n\t * {\n\t *   expression: 'a + 1',\n\t *   filters: [\n\t *     { name: 'uppercase', args: null }\n\t *   ]\n\t * }\n\t *\n\t * @param {String} s\n\t * @return {Object}\n\t */\n\t\n\tfunction parseDirective(s) {\n\t  var hit = cache$1.get(s);\n\t  if (hit) {\n\t    return hit;\n\t  }\n\t\n\t  // reset parser state\n\t  str = s;\n\t  inSingle = inDouble = false;\n\t  curly = square = paren = 0;\n\t  lastFilterIndex = 0;\n\t  dir = {};\n\t\n\t  for (i = 0, l = str.length; i < l; i++) {\n\t    prev = c;\n\t    c = str.charCodeAt(i);\n\t    if (inSingle) {\n\t      // check single quote\n\t      if (c === 0x27 && prev !== 0x5C) inSingle = !inSingle;\n\t    } else if (inDouble) {\n\t      // check double quote\n\t      if (c === 0x22 && prev !== 0x5C) inDouble = !inDouble;\n\t    } else if (c === 0x7C && // pipe\n\t    str.charCodeAt(i + 1) !== 0x7C && str.charCodeAt(i - 1) !== 0x7C) {\n\t      if (dir.expression == null) {\n\t        // first filter, end of expression\n\t        lastFilterIndex = i + 1;\n\t        dir.expression = str.slice(0, i).trim();\n\t      } else {\n\t        // already has filter\n\t        pushFilter();\n\t      }\n\t    } else {\n\t      switch (c) {\n\t        case 0x22:\n\t          inDouble = true;break; // \"\n\t        case 0x27:\n\t          inSingle = true;break; // '\n\t        case 0x28:\n\t          paren++;break; // (\n\t        case 0x29:\n\t          paren--;break; // )\n\t        case 0x5B:\n\t          square++;break; // [\n\t        case 0x5D:\n\t          square--;break; // ]\n\t        case 0x7B:\n\t          curly++;break; // {\n\t        case 0x7D:\n\t          curly--;break; // }\n\t      }\n\t    }\n\t  }\n\t\n\t  if (dir.expression == null) {\n\t    dir.expression = str.slice(0, i).trim();\n\t  } else if (lastFilterIndex !== 0) {\n\t    pushFilter();\n\t  }\n\t\n\t  cache$1.put(s, dir);\n\t  return dir;\n\t}\n\t\n\tvar directive = Object.freeze({\n\t  parseDirective: parseDirective\n\t});\n\t\n\tvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\tvar cache = undefined;\n\tvar tagRE = undefined;\n\tvar htmlRE = undefined;\n\t/**\n\t * Escape a string so it can be used in a RegExp\n\t * constructor.\n\t *\n\t * @param {String} str\n\t */\n\t\n\tfunction escapeRegex(str) {\n\t  return str.replace(regexEscapeRE, '\\\\$&');\n\t}\n\t\n\tfunction compileRegex() {\n\t  var open = escapeRegex(config.delimiters[0]);\n\t  var close = escapeRegex(config.delimiters[1]);\n\t  var unsafeOpen = escapeRegex(config.unsafeDelimiters[0]);\n\t  var unsafeClose = escapeRegex(config.unsafeDelimiters[1]);\n\t  tagRE = new RegExp(unsafeOpen + '((?:.|\\\\n)+?)' + unsafeClose + '|' + open + '((?:.|\\\\n)+?)' + close, 'g');\n\t  htmlRE = new RegExp('^' + unsafeOpen + '.*' + unsafeClose + '$');\n\t  // reset cache\n\t  cache = new Cache(1000);\n\t}\n\t\n\t/**\n\t * Parse a template text string into an array of tokens.\n\t *\n\t * @param {String} text\n\t * @return {Array<Object> | null}\n\t *               - {String} type\n\t *               - {String} value\n\t *               - {Boolean} [html]\n\t *               - {Boolean} [oneTime]\n\t */\n\t\n\tfunction parseText(text) {\n\t  if (!cache) {\n\t    compileRegex();\n\t  }\n\t  var hit = cache.get(text);\n\t  if (hit) {\n\t    return hit;\n\t  }\n\t  if (!tagRE.test(text)) {\n\t    return null;\n\t  }\n\t  var tokens = [];\n\t  var lastIndex = tagRE.lastIndex = 0;\n\t  var match, index, html, value, first, oneTime;\n\t  /* eslint-disable no-cond-assign */\n\t  while (match = tagRE.exec(text)) {\n\t    /* eslint-enable no-cond-assign */\n\t    index = match.index;\n\t    // push text token\n\t    if (index > lastIndex) {\n\t      tokens.push({\n\t        value: text.slice(lastIndex, index)\n\t      });\n\t    }\n\t    // tag token\n\t    html = htmlRE.test(match[0]);\n\t    value = html ? match[1] : match[2];\n\t    first = value.charCodeAt(0);\n\t    oneTime = first === 42; // *\n\t    value = oneTime ? value.slice(1) : value;\n\t    tokens.push({\n\t      tag: true,\n\t      value: value.trim(),\n\t      html: html,\n\t      oneTime: oneTime\n\t    });\n\t    lastIndex = index + match[0].length;\n\t  }\n\t  if (lastIndex < text.length) {\n\t    tokens.push({\n\t      value: text.slice(lastIndex)\n\t    });\n\t  }\n\t  cache.put(text, tokens);\n\t  return tokens;\n\t}\n\t\n\t/**\n\t * Format a list of tokens into an expression.\n\t * e.g. tokens parsed from 'a {{b}} c' can be serialized\n\t * into one single expression as '\"a \" + b + \" c\"'.\n\t *\n\t * @param {Array} tokens\n\t * @param {Vue} [vm]\n\t * @return {String}\n\t */\n\t\n\tfunction tokensToExp(tokens, vm) {\n\t  if (tokens.length > 1) {\n\t    return tokens.map(function (token) {\n\t      return formatToken(token, vm);\n\t    }).join('+');\n\t  } else {\n\t    return formatToken(tokens[0], vm, true);\n\t  }\n\t}\n\t\n\t/**\n\t * Format a single token.\n\t *\n\t * @param {Object} token\n\t * @param {Vue} [vm]\n\t * @param {Boolean} [single]\n\t * @return {String}\n\t */\n\t\n\tfunction formatToken(token, vm, single) {\n\t  return token.tag ? token.oneTime && vm ? '\"' + vm.$eval(token.value) + '\"' : inlineFilters(token.value, single) : '\"' + token.value + '\"';\n\t}\n\t\n\t/**\n\t * For an attribute with multiple interpolation tags,\n\t * e.g. attr=\"some-{{thing | filter}}\", in order to combine\n\t * the whole thing into a single watchable expression, we\n\t * have to inline those filters. This function does exactly\n\t * that. This is a bit hacky but it avoids heavy changes\n\t * to directive parser and watcher mechanism.\n\t *\n\t * @param {String} exp\n\t * @param {Boolean} single\n\t * @return {String}\n\t */\n\t\n\tvar filterRE = /[^|]\\|[^|]/;\n\tfunction inlineFilters(exp, single) {\n\t  if (!filterRE.test(exp)) {\n\t    return single ? exp : '(' + exp + ')';\n\t  } else {\n\t    var dir = parseDirective(exp);\n\t    if (!dir.filters) {\n\t      return '(' + exp + ')';\n\t    } else {\n\t      return 'this._applyFilters(' + dir.expression + // value\n\t      ',null,' + // oldValue (null for read)\n\t      JSON.stringify(dir.filters) + // filter descriptors\n\t      ',false)'; // write?\n\t    }\n\t  }\n\t}\n\t\n\tvar text = Object.freeze({\n\t  compileRegex: compileRegex,\n\t  parseText: parseText,\n\t  tokensToExp: tokensToExp\n\t});\n\t\n\tvar delimiters = ['{{', '}}'];\n\tvar unsafeDelimiters = ['{{{', '}}}'];\n\t\n\tvar config = Object.defineProperties({\n\t\n\t  /**\n\t   * Whether to print debug messages.\n\t   * Also enables stack trace for warnings.\n\t   *\n\t   * @type {Boolean}\n\t   */\n\t\n\t  debug: false,\n\t\n\t  /**\n\t   * Whether to suppress warnings.\n\t   *\n\t   * @type {Boolean}\n\t   */\n\t\n\t  silent: false,\n\t\n\t  /**\n\t   * Whether to use async rendering.\n\t   */\n\t\n\t  async: true,\n\t\n\t  /**\n\t   * Whether to warn against errors caught when evaluating\n\t   * expressions.\n\t   */\n\t\n\t  warnExpressionErrors: true,\n\t\n\t  /**\n\t   * Whether to allow devtools inspection.\n\t   * Disabled by default in production builds.\n\t   */\n\t\n\t  devtools: (\"production\") !== 'production',\n\t\n\t  /**\n\t   * Internal flag to indicate the delimiters have been\n\t   * changed.\n\t   *\n\t   * @type {Boolean}\n\t   */\n\t\n\t  _delimitersChanged: true,\n\t\n\t  /**\n\t   * List of asset types that a component can own.\n\t   *\n\t   * @type {Array}\n\t   */\n\t\n\t  _assetTypes: ['component', 'directive', 'elementDirective', 'filter', 'transition', 'partial'],\n\t\n\t  /**\n\t   * prop binding modes\n\t   */\n\t\n\t  _propBindingModes: {\n\t    ONE_WAY: 0,\n\t    TWO_WAY: 1,\n\t    ONE_TIME: 2\n\t  },\n\t\n\t  /**\n\t   * Max circular updates allowed in a batcher flush cycle.\n\t   */\n\t\n\t  _maxUpdateCount: 100\n\t\n\t}, {\n\t  delimiters: { /**\n\t                 * Interpolation delimiters. Changing these would trigger\n\t                 * the text parser to re-compile the regular expressions.\n\t                 *\n\t                 * @type {Array<String>}\n\t                 */\n\t\n\t    get: function get() {\n\t      return delimiters;\n\t    },\n\t    set: function set(val) {\n\t      delimiters = val;\n\t      compileRegex();\n\t    },\n\t    configurable: true,\n\t    enumerable: true\n\t  },\n\t  unsafeDelimiters: {\n\t    get: function get() {\n\t      return unsafeDelimiters;\n\t    },\n\t    set: function set(val) {\n\t      unsafeDelimiters = val;\n\t      compileRegex();\n\t    },\n\t    configurable: true,\n\t    enumerable: true\n\t  }\n\t});\n\t\n\tvar warn = undefined;\n\tvar formatComponentName = undefined;\n\t\n\tif (false) {\n\t  (function () {\n\t    var hasConsole = typeof console !== 'undefined';\n\t\n\t    warn = function (msg, vm) {\n\t      if (hasConsole && !config.silent) {\n\t        console.error('[Vue warn]: ' + msg + (vm ? formatComponentName(vm) : ''));\n\t      }\n\t    };\n\t\n\t    formatComponentName = function (vm) {\n\t      var name = vm._isVue ? vm.$options.name : vm.name;\n\t      return name ? ' (found in component: <' + hyphenate(name) + '>)' : '';\n\t    };\n\t  })();\n\t}\n\t\n\t/**\n\t * Append with transition.\n\t *\n\t * @param {Element} el\n\t * @param {Element} target\n\t * @param {Vue} vm\n\t * @param {Function} [cb]\n\t */\n\t\n\tfunction appendWithTransition(el, target, vm, cb) {\n\t  applyTransition(el, 1, function () {\n\t    target.appendChild(el);\n\t  }, vm, cb);\n\t}\n\t\n\t/**\n\t * InsertBefore with transition.\n\t *\n\t * @param {Element} el\n\t * @param {Element} target\n\t * @param {Vue} vm\n\t * @param {Function} [cb]\n\t */\n\t\n\tfunction beforeWithTransition(el, target, vm, cb) {\n\t  applyTransition(el, 1, function () {\n\t    before(el, target);\n\t  }, vm, cb);\n\t}\n\t\n\t/**\n\t * Remove with transition.\n\t *\n\t * @param {Element} el\n\t * @param {Vue} vm\n\t * @param {Function} [cb]\n\t */\n\t\n\tfunction removeWithTransition(el, vm, cb) {\n\t  applyTransition(el, -1, function () {\n\t    remove(el);\n\t  }, vm, cb);\n\t}\n\t\n\t/**\n\t * Apply transitions with an operation callback.\n\t *\n\t * @param {Element} el\n\t * @param {Number} direction\n\t *                  1: enter\n\t *                 -1: leave\n\t * @param {Function} op - the actual DOM operation\n\t * @param {Vue} vm\n\t * @param {Function} [cb]\n\t */\n\t\n\tfunction applyTransition(el, direction, op, vm, cb) {\n\t  var transition = el.__v_trans;\n\t  if (!transition ||\n\t  // skip if there are no js hooks and CSS transition is\n\t  // not supported\n\t  !transition.hooks && !transitionEndEvent ||\n\t  // skip transitions for initial compile\n\t  !vm._isCompiled ||\n\t  // if the vm is being manipulated by a parent directive\n\t  // during the parent's compilation phase, skip the\n\t  // animation.\n\t  vm.$parent && !vm.$parent._isCompiled) {\n\t    op();\n\t    if (cb) cb();\n\t    return;\n\t  }\n\t  var action = direction > 0 ? 'enter' : 'leave';\n\t  transition[action](op, cb);\n\t}\n\t\n\tvar transition = Object.freeze({\n\t  appendWithTransition: appendWithTransition,\n\t  beforeWithTransition: beforeWithTransition,\n\t  removeWithTransition: removeWithTransition,\n\t  applyTransition: applyTransition\n\t});\n\t\n\t/**\n\t * Query an element selector if it's not an element already.\n\t *\n\t * @param {String|Element} el\n\t * @return {Element}\n\t */\n\t\n\tfunction query(el) {\n\t  if (typeof el === 'string') {\n\t    var selector = el;\n\t    el = document.querySelector(el);\n\t    if (!el) {\n\t      (\"production\") !== 'production' && warn('Cannot find element: ' + selector);\n\t    }\n\t  }\n\t  return el;\n\t}\n\t\n\t/**\n\t * Check if a node is in the document.\n\t * Note: document.documentElement.contains should work here\n\t * but always returns false for comment nodes in phantomjs,\n\t * making unit tests difficult. This is fixed by doing the\n\t * contains() check on the node's parentNode instead of\n\t * the node itself.\n\t *\n\t * @param {Node} node\n\t * @return {Boolean}\n\t */\n\t\n\tfunction inDoc(node) {\n\t  var doc = document.documentElement;\n\t  var parent = node && node.parentNode;\n\t  return doc === node || doc === parent || !!(parent && parent.nodeType === 1 && doc.contains(parent));\n\t}\n\t\n\t/**\n\t * Get and remove an attribute from a node.\n\t *\n\t * @param {Node} node\n\t * @param {String} _attr\n\t */\n\t\n\tfunction getAttr(node, _attr) {\n\t  var val = node.getAttribute(_attr);\n\t  if (val !== null) {\n\t    node.removeAttribute(_attr);\n\t  }\n\t  return val;\n\t}\n\t\n\t/**\n\t * Get an attribute with colon or v-bind: prefix.\n\t *\n\t * @param {Node} node\n\t * @param {String} name\n\t * @return {String|null}\n\t */\n\t\n\tfunction getBindAttr(node, name) {\n\t  var val = getAttr(node, ':' + name);\n\t  if (val === null) {\n\t    val = getAttr(node, 'v-bind:' + name);\n\t  }\n\t  return val;\n\t}\n\t\n\t/**\n\t * Check the presence of a bind attribute.\n\t *\n\t * @param {Node} node\n\t * @param {String} name\n\t * @return {Boolean}\n\t */\n\t\n\tfunction hasBindAttr(node, name) {\n\t  return node.hasAttribute(name) || node.hasAttribute(':' + name) || node.hasAttribute('v-bind:' + name);\n\t}\n\t\n\t/**\n\t * Insert el before target\n\t *\n\t * @param {Element} el\n\t * @param {Element} target\n\t */\n\t\n\tfunction before(el, target) {\n\t  target.parentNode.insertBefore(el, target);\n\t}\n\t\n\t/**\n\t * Insert el after target\n\t *\n\t * @param {Element} el\n\t * @param {Element} target\n\t */\n\t\n\tfunction after(el, target) {\n\t  if (target.nextSibling) {\n\t    before(el, target.nextSibling);\n\t  } else {\n\t    target.parentNode.appendChild(el);\n\t  }\n\t}\n\t\n\t/**\n\t * Remove el from DOM\n\t *\n\t * @param {Element} el\n\t */\n\t\n\tfunction remove(el) {\n\t  el.parentNode.removeChild(el);\n\t}\n\t\n\t/**\n\t * Prepend el to target\n\t *\n\t * @param {Element} el\n\t * @param {Element} target\n\t */\n\t\n\tfunction prepend(el, target) {\n\t  if (target.firstChild) {\n\t    before(el, target.firstChild);\n\t  } else {\n\t    target.appendChild(el);\n\t  }\n\t}\n\t\n\t/**\n\t * Replace target with el\n\t *\n\t * @param {Element} target\n\t * @param {Element} el\n\t */\n\t\n\tfunction replace(target, el) {\n\t  var parent = target.parentNode;\n\t  if (parent) {\n\t    parent.replaceChild(el, target);\n\t  }\n\t}\n\t\n\t/**\n\t * Add event listener shorthand.\n\t *\n\t * @param {Element} el\n\t * @param {String} event\n\t * @param {Function} cb\n\t * @param {Boolean} [useCapture]\n\t */\n\t\n\tfunction on(el, event, cb, useCapture) {\n\t  el.addEventListener(event, cb, useCapture);\n\t}\n\t\n\t/**\n\t * Remove event listener shorthand.\n\t *\n\t * @param {Element} el\n\t * @param {String} event\n\t * @param {Function} cb\n\t */\n\t\n\tfunction off(el, event, cb) {\n\t  el.removeEventListener(event, cb);\n\t}\n\t\n\t/**\n\t * For IE9 compat: when both class and :class are present\n\t * getAttribute('class') returns wrong value...\n\t *\n\t * @param {Element} el\n\t * @return {String}\n\t */\n\t\n\tfunction getClass(el) {\n\t  var classname = el.className;\n\t  if (typeof classname === 'object') {\n\t    classname = classname.baseVal || '';\n\t  }\n\t  return classname;\n\t}\n\t\n\t/**\n\t * In IE9, setAttribute('class') will result in empty class\n\t * if the element also has the :class attribute; However in\n\t * PhantomJS, setting `className` does not work on SVG elements...\n\t * So we have to do a conditional check here.\n\t *\n\t * @param {Element} el\n\t * @param {String} cls\n\t */\n\t\n\tfunction setClass(el, cls) {\n\t  /* istanbul ignore if */\n\t  if (isIE9 && !/svg$/.test(el.namespaceURI)) {\n\t    el.className = cls;\n\t  } else {\n\t    el.setAttribute('class', cls);\n\t  }\n\t}\n\t\n\t/**\n\t * Add class with compatibility for IE & SVG\n\t *\n\t * @param {Element} el\n\t * @param {String} cls\n\t */\n\t\n\tfunction addClass(el, cls) {\n\t  if (el.classList) {\n\t    el.classList.add(cls);\n\t  } else {\n\t    var cur = ' ' + getClass(el) + ' ';\n\t    if (cur.indexOf(' ' + cls + ' ') < 0) {\n\t      setClass(el, (cur + cls).trim());\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Remove class with compatibility for IE & SVG\n\t *\n\t * @param {Element} el\n\t * @param {String} cls\n\t */\n\t\n\tfunction removeClass(el, cls) {\n\t  if (el.classList) {\n\t    el.classList.remove(cls);\n\t  } else {\n\t    var cur = ' ' + getClass(el) + ' ';\n\t    var tar = ' ' + cls + ' ';\n\t    while (cur.indexOf(tar) >= 0) {\n\t      cur = cur.replace(tar, ' ');\n\t    }\n\t    setClass(el, cur.trim());\n\t  }\n\t  if (!el.className) {\n\t    el.removeAttribute('class');\n\t  }\n\t}\n\t\n\t/**\n\t * Extract raw content inside an element into a temporary\n\t * container div\n\t *\n\t * @param {Element} el\n\t * @param {Boolean} asFragment\n\t * @return {Element|DocumentFragment}\n\t */\n\t\n\tfunction extractContent(el, asFragment) {\n\t  var child;\n\t  var rawContent;\n\t  /* istanbul ignore if */\n\t  if (isTemplate(el) && isFragment(el.content)) {\n\t    el = el.content;\n\t  }\n\t  if (el.hasChildNodes()) {\n\t    trimNode(el);\n\t    rawContent = asFragment ? document.createDocumentFragment() : document.createElement('div');\n\t    /* eslint-disable no-cond-assign */\n\t    while (child = el.firstChild) {\n\t      /* eslint-enable no-cond-assign */\n\t      rawContent.appendChild(child);\n\t    }\n\t  }\n\t  return rawContent;\n\t}\n\t\n\t/**\n\t * Trim possible empty head/tail text and comment\n\t * nodes inside a parent.\n\t *\n\t * @param {Node} node\n\t */\n\t\n\tfunction trimNode(node) {\n\t  var child;\n\t  /* eslint-disable no-sequences */\n\t  while ((child = node.firstChild, isTrimmable(child))) {\n\t    node.removeChild(child);\n\t  }\n\t  while ((child = node.lastChild, isTrimmable(child))) {\n\t    node.removeChild(child);\n\t  }\n\t  /* eslint-enable no-sequences */\n\t}\n\t\n\tfunction isTrimmable(node) {\n\t  return node && (node.nodeType === 3 && !node.data.trim() || node.nodeType === 8);\n\t}\n\t\n\t/**\n\t * Check if an element is a template tag.\n\t * Note if the template appears inside an SVG its tagName\n\t * will be in lowercase.\n\t *\n\t * @param {Element} el\n\t */\n\t\n\tfunction isTemplate(el) {\n\t  return el.tagName && el.tagName.toLowerCase() === 'template';\n\t}\n\t\n\t/**\n\t * Create an \"anchor\" for performing dom insertion/removals.\n\t * This is used in a number of scenarios:\n\t * - fragment instance\n\t * - v-html\n\t * - v-if\n\t * - v-for\n\t * - component\n\t *\n\t * @param {String} content\n\t * @param {Boolean} persist - IE trashes empty textNodes on\n\t *                            cloneNode(true), so in certain\n\t *                            cases the anchor needs to be\n\t *                            non-empty to be persisted in\n\t *                            templates.\n\t * @return {Comment|Text}\n\t */\n\t\n\tfunction createAnchor(content, persist) {\n\t  var anchor = config.debug ? document.createComment(content) : document.createTextNode(persist ? ' ' : '');\n\t  anchor.__v_anchor = true;\n\t  return anchor;\n\t}\n\t\n\t/**\n\t * Find a component ref attribute that starts with $.\n\t *\n\t * @param {Element} node\n\t * @return {String|undefined}\n\t */\n\t\n\tvar refRE = /^v-ref:/;\n\t\n\tfunction findRef(node) {\n\t  if (node.hasAttributes()) {\n\t    var attrs = node.attributes;\n\t    for (var i = 0, l = attrs.length; i < l; i++) {\n\t      var name = attrs[i].name;\n\t      if (refRE.test(name)) {\n\t        return camelize(name.replace(refRE, ''));\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Map a function to a range of nodes .\n\t *\n\t * @param {Node} node\n\t * @param {Node} end\n\t * @param {Function} op\n\t */\n\t\n\tfunction mapNodeRange(node, end, op) {\n\t  var next;\n\t  while (node !== end) {\n\t    next = node.nextSibling;\n\t    op(node);\n\t    node = next;\n\t  }\n\t  op(end);\n\t}\n\t\n\t/**\n\t * Remove a range of nodes with transition, store\n\t * the nodes in a fragment with correct ordering,\n\t * and call callback when done.\n\t *\n\t * @param {Node} start\n\t * @param {Node} end\n\t * @param {Vue} vm\n\t * @param {DocumentFragment} frag\n\t * @param {Function} cb\n\t */\n\t\n\tfunction removeNodeRange(start, end, vm, frag, cb) {\n\t  var done = false;\n\t  var removed = 0;\n\t  var nodes = [];\n\t  mapNodeRange(start, end, function (node) {\n\t    if (node === end) done = true;\n\t    nodes.push(node);\n\t    removeWithTransition(node, vm, onRemoved);\n\t  });\n\t  function onRemoved() {\n\t    removed++;\n\t    if (done && removed >= nodes.length) {\n\t      for (var i = 0; i < nodes.length; i++) {\n\t        frag.appendChild(nodes[i]);\n\t      }\n\t      cb && cb();\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Check if a node is a DocumentFragment.\n\t *\n\t * @param {Node} node\n\t * @return {Boolean}\n\t */\n\t\n\tfunction isFragment(node) {\n\t  return node && node.nodeType === 11;\n\t}\n\t\n\t/**\n\t * Get outerHTML of elements, taking care\n\t * of SVG elements in IE as well.\n\t *\n\t * @param {Element} el\n\t * @return {String}\n\t */\n\t\n\tfunction getOuterHTML(el) {\n\t  if (el.outerHTML) {\n\t    return el.outerHTML;\n\t  } else {\n\t    var container = document.createElement('div');\n\t    container.appendChild(el.cloneNode(true));\n\t    return container.innerHTML;\n\t  }\n\t}\n\t\n\tvar commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/i;\n\tvar reservedTagRE = /^(slot|partial|component)$/i;\n\t\n\tvar isUnknownElement = undefined;\n\tif (false) {\n\t  isUnknownElement = function (el, tag) {\n\t    if (tag.indexOf('-') > -1) {\n\t      // http://stackoverflow.com/a/28210364/1070244\n\t      return el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;\n\t    } else {\n\t      return (/HTMLUnknownElement/.test(el.toString()) &&\n\t        // Chrome returns unknown for several HTML5 elements.\n\t        // https://code.google.com/p/chromium/issues/detail?id=540526\n\t        !/^(data|time|rtc|rb)$/.test(tag)\n\t      );\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * Check if an element is a component, if yes return its\n\t * component id.\n\t *\n\t * @param {Element} el\n\t * @param {Object} options\n\t * @return {Object|undefined}\n\t */\n\t\n\tfunction checkComponentAttr(el, options) {\n\t  var tag = el.tagName.toLowerCase();\n\t  var hasAttrs = el.hasAttributes();\n\t  if (!commonTagRE.test(tag) && !reservedTagRE.test(tag)) {\n\t    if (resolveAsset(options, 'components', tag)) {\n\t      return { id: tag };\n\t    } else {\n\t      var is = hasAttrs && getIsBinding(el);\n\t      if (is) {\n\t        return is;\n\t      } else if (false) {\n\t        var expectedTag = options._componentNameMap && options._componentNameMap[tag];\n\t        if (expectedTag) {\n\t          warn('Unknown custom element: <' + tag + '> - ' + 'did you mean <' + expectedTag + '>? ' + 'HTML is case-insensitive, remember to use kebab-case in templates.');\n\t        } else if (isUnknownElement(el, tag)) {\n\t          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the \"name\" option.');\n\t        }\n\t      }\n\t    }\n\t  } else if (hasAttrs) {\n\t    return getIsBinding(el);\n\t  }\n\t}\n\t\n\t/**\n\t * Get \"is\" binding from an element.\n\t *\n\t * @param {Element} el\n\t * @return {Object|undefined}\n\t */\n\t\n\tfunction getIsBinding(el) {\n\t  // dynamic syntax\n\t  var exp = getAttr(el, 'is');\n\t  if (exp != null) {\n\t    return { id: exp };\n\t  } else {\n\t    exp = getBindAttr(el, 'is');\n\t    if (exp != null) {\n\t      return { id: exp, dynamic: true };\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Option overwriting strategies are functions that handle\n\t * how to merge a parent option value and a child option\n\t * value into the final value.\n\t *\n\t * All strategy functions follow the same signature:\n\t *\n\t * @param {*} parentVal\n\t * @param {*} childVal\n\t * @param {Vue} [vm]\n\t */\n\t\n\tvar strats = config.optionMergeStrategies = Object.create(null);\n\t\n\t/**\n\t * Helper that recursively merges two data objects together.\n\t */\n\t\n\tfunction mergeData(to, from) {\n\t  var key, toVal, fromVal;\n\t  for (key in from) {\n\t    toVal = to[key];\n\t    fromVal = from[key];\n\t    if (!hasOwn(to, key)) {\n\t      set(to, key, fromVal);\n\t    } else if (isObject(toVal) && isObject(fromVal)) {\n\t      mergeData(toVal, fromVal);\n\t    }\n\t  }\n\t  return to;\n\t}\n\t\n\t/**\n\t * Data\n\t */\n\t\n\tstrats.data = function (parentVal, childVal, vm) {\n\t  if (!vm) {\n\t    // in a Vue.extend merge, both should be functions\n\t    if (!childVal) {\n\t      return parentVal;\n\t    }\n\t    if (typeof childVal !== 'function') {\n\t      (\"production\") !== 'production' && warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n\t      return parentVal;\n\t    }\n\t    if (!parentVal) {\n\t      return childVal;\n\t    }\n\t    // when parentVal & childVal are both present,\n\t    // we need to return a function that returns the\n\t    // merged result of both functions... no need to\n\t    // check if parentVal is a function here because\n\t    // it has to be a function to pass previous merges.\n\t    return function mergedDataFn() {\n\t      return mergeData(childVal.call(this), parentVal.call(this));\n\t    };\n\t  } else if (parentVal || childVal) {\n\t    return function mergedInstanceDataFn() {\n\t      // instance merge\n\t      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;\n\t      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;\n\t      if (instanceData) {\n\t        return mergeData(instanceData, defaultData);\n\t      } else {\n\t        return defaultData;\n\t      }\n\t    };\n\t  }\n\t};\n\t\n\t/**\n\t * El\n\t */\n\t\n\tstrats.el = function (parentVal, childVal, vm) {\n\t  if (!vm && childVal && typeof childVal !== 'function') {\n\t    (\"production\") !== 'production' && warn('The \"el\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n\t    return;\n\t  }\n\t  var ret = childVal || parentVal;\n\t  // invoke the element factory if this is instance merge\n\t  return vm && typeof ret === 'function' ? ret.call(vm) : ret;\n\t};\n\t\n\t/**\n\t * Hooks and param attributes are merged as arrays.\n\t */\n\t\n\tstrats.init = strats.created = strats.ready = strats.attached = strats.detached = strats.beforeCompile = strats.compiled = strats.beforeDestroy = strats.destroyed = strats.activate = function (parentVal, childVal) {\n\t  return childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;\n\t};\n\t\n\t/**\n\t * Assets\n\t *\n\t * When a vm is present (instance creation), we need to do\n\t * a three-way merge between constructor options, instance\n\t * options and parent options.\n\t */\n\t\n\tfunction mergeAssets(parentVal, childVal) {\n\t  var res = Object.create(parentVal);\n\t  return childVal ? extend(res, guardArrayAssets(childVal)) : res;\n\t}\n\t\n\tconfig._assetTypes.forEach(function (type) {\n\t  strats[type + 's'] = mergeAssets;\n\t});\n\t\n\t/**\n\t * Events & Watchers.\n\t *\n\t * Events & watchers hashes should not overwrite one\n\t * another, so we merge them as arrays.\n\t */\n\t\n\tstrats.watch = strats.events = function (parentVal, childVal) {\n\t  if (!childVal) return parentVal;\n\t  if (!parentVal) return childVal;\n\t  var ret = {};\n\t  extend(ret, parentVal);\n\t  for (var key in childVal) {\n\t    var parent = ret[key];\n\t    var child = childVal[key];\n\t    if (parent && !isArray(parent)) {\n\t      parent = [parent];\n\t    }\n\t    ret[key] = parent ? parent.concat(child) : [child];\n\t  }\n\t  return ret;\n\t};\n\t\n\t/**\n\t * Other object hashes.\n\t */\n\t\n\tstrats.props = strats.methods = strats.computed = function (parentVal, childVal) {\n\t  if (!childVal) return parentVal;\n\t  if (!parentVal) return childVal;\n\t  var ret = Object.create(null);\n\t  extend(ret, parentVal);\n\t  extend(ret, childVal);\n\t  return ret;\n\t};\n\t\n\t/**\n\t * Default strategy.\n\t */\n\t\n\tvar defaultStrat = function defaultStrat(parentVal, childVal) {\n\t  return childVal === undefined ? parentVal : childVal;\n\t};\n\t\n\t/**\n\t * Make sure component options get converted to actual\n\t * constructors.\n\t *\n\t * @param {Object} options\n\t */\n\t\n\tfunction guardComponents(options) {\n\t  if (options.components) {\n\t    var components = options.components = guardArrayAssets(options.components);\n\t    var ids = Object.keys(components);\n\t    var def;\n\t    if (false) {\n\t      var map = options._componentNameMap = {};\n\t    }\n\t    for (var i = 0, l = ids.length; i < l; i++) {\n\t      var key = ids[i];\n\t      if (commonTagRE.test(key) || reservedTagRE.test(key)) {\n\t        (\"production\") !== 'production' && warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);\n\t        continue;\n\t      }\n\t      // record a all lowercase <-> kebab-case mapping for\n\t      // possible custom element case error warning\n\t      if (false) {\n\t        map[key.replace(/-/g, '').toLowerCase()] = hyphenate(key);\n\t      }\n\t      def = components[key];\n\t      if (isPlainObject(def)) {\n\t        components[key] = Vue.extend(def);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Ensure all props option syntax are normalized into the\n\t * Object-based format.\n\t *\n\t * @param {Object} options\n\t */\n\t\n\tfunction guardProps(options) {\n\t  var props = options.props;\n\t  var i, val;\n\t  if (isArray(props)) {\n\t    options.props = {};\n\t    i = props.length;\n\t    while (i--) {\n\t      val = props[i];\n\t      if (typeof val === 'string') {\n\t        options.props[val] = null;\n\t      } else if (val.name) {\n\t        options.props[val.name] = val;\n\t      }\n\t    }\n\t  } else if (isPlainObject(props)) {\n\t    var keys = Object.keys(props);\n\t    i = keys.length;\n\t    while (i--) {\n\t      val = props[keys[i]];\n\t      if (typeof val === 'function') {\n\t        props[keys[i]] = { type: val };\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Guard an Array-format assets option and converted it\n\t * into the key-value Object format.\n\t *\n\t * @param {Object|Array} assets\n\t * @return {Object}\n\t */\n\t\n\tfunction guardArrayAssets(assets) {\n\t  if (isArray(assets)) {\n\t    var res = {};\n\t    var i = assets.length;\n\t    var asset;\n\t    while (i--) {\n\t      asset = assets[i];\n\t      var id = typeof asset === 'function' ? asset.options && asset.options.name || asset.id : asset.name || asset.id;\n\t      if (!id) {\n\t        (\"production\") !== 'production' && warn('Array-syntax assets must provide a \"name\" or \"id\" field.');\n\t      } else {\n\t        res[id] = asset;\n\t      }\n\t    }\n\t    return res;\n\t  }\n\t  return assets;\n\t}\n\t\n\t/**\n\t * Merge two option objects into a new one.\n\t * Core utility used in both instantiation and inheritance.\n\t *\n\t * @param {Object} parent\n\t * @param {Object} child\n\t * @param {Vue} [vm] - if vm is present, indicates this is\n\t *                     an instantiation merge.\n\t */\n\t\n\tfunction mergeOptions(parent, child, vm) {\n\t  guardComponents(child);\n\t  guardProps(child);\n\t  var options = {};\n\t  var key;\n\t  if (child.mixins) {\n\t    for (var i = 0, l = child.mixins.length; i < l; i++) {\n\t      parent = mergeOptions(parent, child.mixins[i], vm);\n\t    }\n\t  }\n\t  for (key in parent) {\n\t    mergeField(key);\n\t  }\n\t  for (key in child) {\n\t    if (!hasOwn(parent, key)) {\n\t      mergeField(key);\n\t    }\n\t  }\n\t  function mergeField(key) {\n\t    var strat = strats[key] || defaultStrat;\n\t    options[key] = strat(parent[key], child[key], vm, key);\n\t  }\n\t  return options;\n\t}\n\t\n\t/**\n\t * Resolve an asset.\n\t * This function is used because child instances need access\n\t * to assets defined in its ancestor chain.\n\t *\n\t * @param {Object} options\n\t * @param {String} type\n\t * @param {String} id\n\t * @param {Boolean} warnMissing\n\t * @return {Object|Function}\n\t */\n\t\n\tfunction resolveAsset(options, type, id, warnMissing) {\n\t  /* istanbul ignore if */\n\t  if (typeof id !== 'string') {\n\t    return;\n\t  }\n\t  var assets = options[type];\n\t  var camelizedId;\n\t  var res = assets[id] ||\n\t  // camelCase ID\n\t  assets[camelizedId = camelize(id)] ||\n\t  // Pascal Case ID\n\t  assets[camelizedId.charAt(0).toUpperCase() + camelizedId.slice(1)];\n\t  if (false) {\n\t    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);\n\t  }\n\t  return res;\n\t}\n\t\n\tvar uid$1 = 0;\n\t\n\t/**\n\t * A dep is an observable that can have multiple\n\t * directives subscribing to it.\n\t *\n\t * @constructor\n\t */\n\tfunction Dep() {\n\t  this.id = uid$1++;\n\t  this.subs = [];\n\t}\n\t\n\t// the current target watcher being evaluated.\n\t// this is globally unique because there could be only one\n\t// watcher being evaluated at any time.\n\tDep.target = null;\n\t\n\t/**\n\t * Add a directive subscriber.\n\t *\n\t * @param {Directive} sub\n\t */\n\t\n\tDep.prototype.addSub = function (sub) {\n\t  this.subs.push(sub);\n\t};\n\t\n\t/**\n\t * Remove a directive subscriber.\n\t *\n\t * @param {Directive} sub\n\t */\n\t\n\tDep.prototype.removeSub = function (sub) {\n\t  this.subs.$remove(sub);\n\t};\n\t\n\t/**\n\t * Add self as a dependency to the target watcher.\n\t */\n\t\n\tDep.prototype.depend = function () {\n\t  Dep.target.addDep(this);\n\t};\n\t\n\t/**\n\t * Notify all subscribers of a new value.\n\t */\n\t\n\tDep.prototype.notify = function () {\n\t  // stablize the subscriber list first\n\t  var subs = toArray(this.subs);\n\t  for (var i = 0, l = subs.length; i < l; i++) {\n\t    subs[i].update();\n\t  }\n\t};\n\t\n\tvar arrayProto = Array.prototype;\n\tvar arrayMethods = Object.create(arrayProto)\n\t\n\t/**\n\t * Intercept mutating methods and emit events\n\t */\n\t\n\t;['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {\n\t  // cache original method\n\t  var original = arrayProto[method];\n\t  def(arrayMethods, method, function mutator() {\n\t    // avoid leaking arguments:\n\t    // http://jsperf.com/closure-with-arguments\n\t    var i = arguments.length;\n\t    var args = new Array(i);\n\t    while (i--) {\n\t      args[i] = arguments[i];\n\t    }\n\t    var result = original.apply(this, args);\n\t    var ob = this.__ob__;\n\t    var inserted;\n\t    switch (method) {\n\t      case 'push':\n\t        inserted = args;\n\t        break;\n\t      case 'unshift':\n\t        inserted = args;\n\t        break;\n\t      case 'splice':\n\t        inserted = args.slice(2);\n\t        break;\n\t    }\n\t    if (inserted) ob.observeArray(inserted);\n\t    // notify change\n\t    ob.dep.notify();\n\t    return result;\n\t  });\n\t});\n\t\n\t/**\n\t * Swap the element at the given index with a new value\n\t * and emits corresponding event.\n\t *\n\t * @param {Number} index\n\t * @param {*} val\n\t * @return {*} - replaced element\n\t */\n\t\n\tdef(arrayProto, '$set', function $set(index, val) {\n\t  if (index >= this.length) {\n\t    this.length = Number(index) + 1;\n\t  }\n\t  return this.splice(index, 1, val)[0];\n\t});\n\t\n\t/**\n\t * Convenience method to remove the element at given index or target element reference.\n\t *\n\t * @param {*} item\n\t */\n\t\n\tdef(arrayProto, '$remove', function $remove(item) {\n\t  /* istanbul ignore if */\n\t  if (!this.length) return;\n\t  var index = indexOf(this, item);\n\t  if (index > -1) {\n\t    return this.splice(index, 1);\n\t  }\n\t});\n\t\n\tvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\t\n\t/**\n\t * By default, when a reactive property is set, the new value is\n\t * also converted to become reactive. However in certain cases, e.g.\n\t * v-for scope alias and props, we don't want to force conversion\n\t * because the value may be a nested value under a frozen data structure.\n\t *\n\t * So whenever we want to set a reactive property without forcing\n\t * conversion on the new value, we wrap that call inside this function.\n\t */\n\t\n\tvar shouldConvert = true;\n\t\n\tfunction withoutConversion(fn) {\n\t  shouldConvert = false;\n\t  fn();\n\t  shouldConvert = true;\n\t}\n\t\n\t/**\n\t * Observer class that are attached to each observed\n\t * object. Once attached, the observer converts target\n\t * object's property keys into getter/setters that\n\t * collect dependencies and dispatches updates.\n\t *\n\t * @param {Array|Object} value\n\t * @constructor\n\t */\n\t\n\tfunction Observer(value) {\n\t  this.value = value;\n\t  this.dep = new Dep();\n\t  def(value, '__ob__', this);\n\t  if (isArray(value)) {\n\t    var augment = hasProto ? protoAugment : copyAugment;\n\t    augment(value, arrayMethods, arrayKeys);\n\t    this.observeArray(value);\n\t  } else {\n\t    this.walk(value);\n\t  }\n\t}\n\t\n\t// Instance methods\n\t\n\t/**\n\t * Walk through each property and convert them into\n\t * getter/setters. This method should only be called when\n\t * value type is Object.\n\t *\n\t * @param {Object} obj\n\t */\n\t\n\tObserver.prototype.walk = function (obj) {\n\t  var keys = Object.keys(obj);\n\t  for (var i = 0, l = keys.length; i < l; i++) {\n\t    this.convert(keys[i], obj[keys[i]]);\n\t  }\n\t};\n\t\n\t/**\n\t * Observe a list of Array items.\n\t *\n\t * @param {Array} items\n\t */\n\t\n\tObserver.prototype.observeArray = function (items) {\n\t  for (var i = 0, l = items.length; i < l; i++) {\n\t    observe(items[i]);\n\t  }\n\t};\n\t\n\t/**\n\t * Convert a property into getter/setter so we can emit\n\t * the events when the property is accessed/changed.\n\t *\n\t * @param {String} key\n\t * @param {*} val\n\t */\n\t\n\tObserver.prototype.convert = function (key, val) {\n\t  defineReactive(this.value, key, val);\n\t};\n\t\n\t/**\n\t * Add an owner vm, so that when $set/$delete mutations\n\t * happen we can notify owner vms to proxy the keys and\n\t * digest the watchers. This is only called when the object\n\t * is observed as an instance's root $data.\n\t *\n\t * @param {Vue} vm\n\t */\n\t\n\tObserver.prototype.addVm = function (vm) {\n\t  (this.vms || (this.vms = [])).push(vm);\n\t};\n\t\n\t/**\n\t * Remove an owner vm. This is called when the object is\n\t * swapped out as an instance's $data object.\n\t *\n\t * @param {Vue} vm\n\t */\n\t\n\tObserver.prototype.removeVm = function (vm) {\n\t  this.vms.$remove(vm);\n\t};\n\t\n\t// helpers\n\t\n\t/**\n\t * Augment an target Object or Array by intercepting\n\t * the prototype chain using __proto__\n\t *\n\t * @param {Object|Array} target\n\t * @param {Object} src\n\t */\n\t\n\tfunction protoAugment(target, src) {\n\t  /* eslint-disable no-proto */\n\t  target.__proto__ = src;\n\t  /* eslint-enable no-proto */\n\t}\n\t\n\t/**\n\t * Augment an target Object or Array by defining\n\t * hidden properties.\n\t *\n\t * @param {Object|Array} target\n\t * @param {Object} proto\n\t */\n\t\n\tfunction copyAugment(target, src, keys) {\n\t  for (var i = 0, l = keys.length; i < l; i++) {\n\t    var key = keys[i];\n\t    def(target, key, src[key]);\n\t  }\n\t}\n\t\n\t/**\n\t * Attempt to create an observer instance for a value,\n\t * returns the new observer if successfully observed,\n\t * or the existing observer if the value already has one.\n\t *\n\t * @param {*} value\n\t * @param {Vue} [vm]\n\t * @return {Observer|undefined}\n\t * @static\n\t */\n\t\n\tfunction observe(value, vm) {\n\t  if (!value || typeof value !== 'object') {\n\t    return;\n\t  }\n\t  var ob;\n\t  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n\t    ob = value.__ob__;\n\t  } else if (shouldConvert && (isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {\n\t    ob = new Observer(value);\n\t  }\n\t  if (ob && vm) {\n\t    ob.addVm(vm);\n\t  }\n\t  return ob;\n\t}\n\t\n\t/**\n\t * Define a reactive property on an Object.\n\t *\n\t * @param {Object} obj\n\t * @param {String} key\n\t * @param {*} val\n\t */\n\t\n\tfunction defineReactive(obj, key, val) {\n\t  var dep = new Dep();\n\t\n\t  var property = Object.getOwnPropertyDescriptor(obj, key);\n\t  if (property && property.configurable === false) {\n\t    return;\n\t  }\n\t\n\t  // cater for pre-defined getter/setters\n\t  var getter = property && property.get;\n\t  var setter = property && property.set;\n\t\n\t  var childOb = observe(val);\n\t  Object.defineProperty(obj, key, {\n\t    enumerable: true,\n\t    configurable: true,\n\t    get: function reactiveGetter() {\n\t      var value = getter ? getter.call(obj) : val;\n\t      if (Dep.target) {\n\t        dep.depend();\n\t        if (childOb) {\n\t          childOb.dep.depend();\n\t        }\n\t        if (isArray(value)) {\n\t          for (var e, i = 0, l = value.length; i < l; i++) {\n\t            e = value[i];\n\t            e && e.__ob__ && e.__ob__.dep.depend();\n\t          }\n\t        }\n\t      }\n\t      return value;\n\t    },\n\t    set: function reactiveSetter(newVal) {\n\t      var value = getter ? getter.call(obj) : val;\n\t      if (newVal === value) {\n\t        return;\n\t      }\n\t      if (setter) {\n\t        setter.call(obj, newVal);\n\t      } else {\n\t        val = newVal;\n\t      }\n\t      childOb = observe(newVal);\n\t      dep.notify();\n\t    }\n\t  });\n\t}\n\t\n\t\n\t\n\tvar util = Object.freeze({\n\t\tdefineReactive: defineReactive,\n\t\tset: set,\n\t\tdel: del,\n\t\thasOwn: hasOwn,\n\t\tisLiteral: isLiteral,\n\t\tisReserved: isReserved,\n\t\t_toString: _toString,\n\t\ttoNumber: toNumber,\n\t\ttoBoolean: toBoolean,\n\t\tstripQuotes: stripQuotes,\n\t\tcamelize: camelize,\n\t\thyphenate: hyphenate,\n\t\tclassify: classify,\n\t\tbind: bind,\n\t\ttoArray: toArray,\n\t\textend: extend,\n\t\tisObject: isObject,\n\t\tisPlainObject: isPlainObject,\n\t\tdef: def,\n\t\tdebounce: _debounce,\n\t\tindexOf: indexOf,\n\t\tcancellable: cancellable,\n\t\tlooseEqual: looseEqual,\n\t\tisArray: isArray,\n\t\thasProto: hasProto,\n\t\tinBrowser: inBrowser,\n\t\tdevtools: devtools,\n\t\tisIE9: isIE9,\n\t\tisAndroid: isAndroid,\n\t\tget transitionProp () { return transitionProp; },\n\t\tget transitionEndEvent () { return transitionEndEvent; },\n\t\tget animationProp () { return animationProp; },\n\t\tget animationEndEvent () { return animationEndEvent; },\n\t\tnextTick: nextTick,\n\t\tquery: query,\n\t\tinDoc: inDoc,\n\t\tgetAttr: getAttr,\n\t\tgetBindAttr: getBindAttr,\n\t\thasBindAttr: hasBindAttr,\n\t\tbefore: before,\n\t\tafter: after,\n\t\tremove: remove,\n\t\tprepend: prepend,\n\t\treplace: replace,\n\t\ton: on,\n\t\toff: off,\n\t\tsetClass: setClass,\n\t\taddClass: addClass,\n\t\tremoveClass: removeClass,\n\t\textractContent: extractContent,\n\t\ttrimNode: trimNode,\n\t\tisTemplate: isTemplate,\n\t\tcreateAnchor: createAnchor,\n\t\tfindRef: findRef,\n\t\tmapNodeRange: mapNodeRange,\n\t\tremoveNodeRange: removeNodeRange,\n\t\tisFragment: isFragment,\n\t\tgetOuterHTML: getOuterHTML,\n\t\tmergeOptions: mergeOptions,\n\t\tresolveAsset: resolveAsset,\n\t\tcheckComponentAttr: checkComponentAttr,\n\t\tcommonTagRE: commonTagRE,\n\t\treservedTagRE: reservedTagRE,\n\t\tget warn () { return warn; }\n\t});\n\t\n\tvar uid = 0;\n\t\n\tfunction initMixin (Vue) {\n\t  /**\n\t   * The main init sequence. This is called for every\n\t   * instance, including ones that are created from extended\n\t   * constructors.\n\t   *\n\t   * @param {Object} options - this options object should be\n\t   *                           the result of merging class\n\t   *                           options and the options passed\n\t   *                           in to the constructor.\n\t   */\n\t\n\t  Vue.prototype._init = function (options) {\n\t    options = options || {};\n\t\n\t    this.$el = null;\n\t    this.$parent = options.parent;\n\t    this.$root = this.$parent ? this.$parent.$root : this;\n\t    this.$children = [];\n\t    this.$refs = {}; // child vm references\n\t    this.$els = {}; // element references\n\t    this._watchers = []; // all watchers as an array\n\t    this._directives = []; // all directives\n\t\n\t    // a uid\n\t    this._uid = uid++;\n\t\n\t    // a flag to avoid this being observed\n\t    this._isVue = true;\n\t\n\t    // events bookkeeping\n\t    this._events = {}; // registered callbacks\n\t    this._eventsCount = {}; // for $broadcast optimization\n\t\n\t    // fragment instance properties\n\t    this._isFragment = false;\n\t    this._fragment = // @type {DocumentFragment}\n\t    this._fragmentStart = // @type {Text|Comment}\n\t    this._fragmentEnd = null; // @type {Text|Comment}\n\t\n\t    // lifecycle state\n\t    this._isCompiled = this._isDestroyed = this._isReady = this._isAttached = this._isBeingDestroyed = this._vForRemoving = false;\n\t    this._unlinkFn = null;\n\t\n\t    // context:\n\t    // if this is a transcluded component, context\n\t    // will be the common parent vm of this instance\n\t    // and its host.\n\t    this._context = options._context || this.$parent;\n\t\n\t    // scope:\n\t    // if this is inside an inline v-for, the scope\n\t    // will be the intermediate scope created for this\n\t    // repeat fragment. this is used for linking props\n\t    // and container directives.\n\t    this._scope = options._scope;\n\t\n\t    // fragment:\n\t    // if this instance is compiled inside a Fragment, it\n\t    // needs to reigster itself as a child of that fragment\n\t    // for attach/detach to work properly.\n\t    this._frag = options._frag;\n\t    if (this._frag) {\n\t      this._frag.children.push(this);\n\t    }\n\t\n\t    // push self into parent / transclusion host\n\t    if (this.$parent) {\n\t      this.$parent.$children.push(this);\n\t    }\n\t\n\t    // merge options.\n\t    options = this.$options = mergeOptions(this.constructor.options, options, this);\n\t\n\t    // set ref\n\t    this._updateRef();\n\t\n\t    // initialize data as empty object.\n\t    // it will be filled up in _initScope().\n\t    this._data = {};\n\t\n\t    // save raw constructor data before merge\n\t    // so that we know which properties are provided at\n\t    // instantiation.\n\t    this._runtimeData = options.data;\n\t\n\t    // call init hook\n\t    this._callHook('init');\n\t\n\t    // initialize data observation and scope inheritance.\n\t    this._initState();\n\t\n\t    // setup event system and option events.\n\t    this._initEvents();\n\t\n\t    // call created hook\n\t    this._callHook('created');\n\t\n\t    // if `el` option is passed, start compilation.\n\t    if (options.el) {\n\t      this.$mount(options.el);\n\t    }\n\t  };\n\t}\n\t\n\tvar pathCache = new Cache(1000);\n\t\n\t// actions\n\tvar APPEND = 0;\n\tvar PUSH = 1;\n\tvar INC_SUB_PATH_DEPTH = 2;\n\tvar PUSH_SUB_PATH = 3;\n\t\n\t// states\n\tvar BEFORE_PATH = 0;\n\tvar IN_PATH = 1;\n\tvar BEFORE_IDENT = 2;\n\tvar IN_IDENT = 3;\n\tvar IN_SUB_PATH = 4;\n\tvar IN_SINGLE_QUOTE = 5;\n\tvar IN_DOUBLE_QUOTE = 6;\n\tvar AFTER_PATH = 7;\n\tvar ERROR = 8;\n\t\n\tvar pathStateMachine = [];\n\t\n\tpathStateMachine[BEFORE_PATH] = {\n\t  'ws': [BEFORE_PATH],\n\t  'ident': [IN_IDENT, APPEND],\n\t  '[': [IN_SUB_PATH],\n\t  'eof': [AFTER_PATH]\n\t};\n\t\n\tpathStateMachine[IN_PATH] = {\n\t  'ws': [IN_PATH],\n\t  '.': [BEFORE_IDENT],\n\t  '[': [IN_SUB_PATH],\n\t  'eof': [AFTER_PATH]\n\t};\n\t\n\tpathStateMachine[BEFORE_IDENT] = {\n\t  'ws': [BEFORE_IDENT],\n\t  'ident': [IN_IDENT, APPEND]\n\t};\n\t\n\tpathStateMachine[IN_IDENT] = {\n\t  'ident': [IN_IDENT, APPEND],\n\t  '0': [IN_IDENT, APPEND],\n\t  'number': [IN_IDENT, APPEND],\n\t  'ws': [IN_PATH, PUSH],\n\t  '.': [BEFORE_IDENT, PUSH],\n\t  '[': [IN_SUB_PATH, PUSH],\n\t  'eof': [AFTER_PATH, PUSH]\n\t};\n\t\n\tpathStateMachine[IN_SUB_PATH] = {\n\t  \"'\": [IN_SINGLE_QUOTE, APPEND],\n\t  '\"': [IN_DOUBLE_QUOTE, APPEND],\n\t  '[': [IN_SUB_PATH, INC_SUB_PATH_DEPTH],\n\t  ']': [IN_PATH, PUSH_SUB_PATH],\n\t  'eof': ERROR,\n\t  'else': [IN_SUB_PATH, APPEND]\n\t};\n\t\n\tpathStateMachine[IN_SINGLE_QUOTE] = {\n\t  \"'\": [IN_SUB_PATH, APPEND],\n\t  'eof': ERROR,\n\t  'else': [IN_SINGLE_QUOTE, APPEND]\n\t};\n\t\n\tpathStateMachine[IN_DOUBLE_QUOTE] = {\n\t  '\"': [IN_SUB_PATH, APPEND],\n\t  'eof': ERROR,\n\t  'else': [IN_DOUBLE_QUOTE, APPEND]\n\t};\n\t\n\t/**\n\t * Determine the type of a character in a keypath.\n\t *\n\t * @param {Char} ch\n\t * @return {String} type\n\t */\n\t\n\tfunction getPathCharType(ch) {\n\t  if (ch === undefined) {\n\t    return 'eof';\n\t  }\n\t\n\t  var code = ch.charCodeAt(0);\n\t\n\t  switch (code) {\n\t    case 0x5B: // [\n\t    case 0x5D: // ]\n\t    case 0x2E: // .\n\t    case 0x22: // \"\n\t    case 0x27: // '\n\t    case 0x30:\n\t      // 0\n\t      return ch;\n\t\n\t    case 0x5F: // _\n\t    case 0x24:\n\t      // $\n\t      return 'ident';\n\t\n\t    case 0x20: // Space\n\t    case 0x09: // Tab\n\t    case 0x0A: // Newline\n\t    case 0x0D: // Return\n\t    case 0xA0: // No-break space\n\t    case 0xFEFF: // Byte Order Mark\n\t    case 0x2028: // Line Separator\n\t    case 0x2029:\n\t      // Paragraph Separator\n\t      return 'ws';\n\t  }\n\t\n\t  // a-z, A-Z\n\t  if (code >= 0x61 && code <= 0x7A || code >= 0x41 && code <= 0x5A) {\n\t    return 'ident';\n\t  }\n\t\n\t  // 1-9\n\t  if (code >= 0x31 && code <= 0x39) {\n\t    return 'number';\n\t  }\n\t\n\t  return 'else';\n\t}\n\t\n\t/**\n\t * Format a subPath, return its plain form if it is\n\t * a literal string or number. Otherwise prepend the\n\t * dynamic indicator (*).\n\t *\n\t * @param {String} path\n\t * @return {String}\n\t */\n\t\n\tfunction formatSubPath(path) {\n\t  var trimmed = path.trim();\n\t  // invalid leading 0\n\t  if (path.charAt(0) === '0' && isNaN(path)) {\n\t    return false;\n\t  }\n\t  return isLiteral(trimmed) ? stripQuotes(trimmed) : '*' + trimmed;\n\t}\n\t\n\t/**\n\t * Parse a string path into an array of segments\n\t *\n\t * @param {String} path\n\t * @return {Array|undefined}\n\t */\n\t\n\tfunction parse(path) {\n\t  var keys = [];\n\t  var index = -1;\n\t  var mode = BEFORE_PATH;\n\t  var subPathDepth = 0;\n\t  var c, newChar, key, type, transition, action, typeMap;\n\t\n\t  var actions = [];\n\t\n\t  actions[PUSH] = function () {\n\t    if (key !== undefined) {\n\t      keys.push(key);\n\t      key = undefined;\n\t    }\n\t  };\n\t\n\t  actions[APPEND] = function () {\n\t    if (key === undefined) {\n\t      key = newChar;\n\t    } else {\n\t      key += newChar;\n\t    }\n\t  };\n\t\n\t  actions[INC_SUB_PATH_DEPTH] = function () {\n\t    actions[APPEND]();\n\t    subPathDepth++;\n\t  };\n\t\n\t  actions[PUSH_SUB_PATH] = function () {\n\t    if (subPathDepth > 0) {\n\t      subPathDepth--;\n\t      mode = IN_SUB_PATH;\n\t      actions[APPEND]();\n\t    } else {\n\t      subPathDepth = 0;\n\t      key = formatSubPath(key);\n\t      if (key === false) {\n\t        return false;\n\t      } else {\n\t        actions[PUSH]();\n\t      }\n\t    }\n\t  };\n\t\n\t  function maybeUnescapeQuote() {\n\t    var nextChar = path[index + 1];\n\t    if (mode === IN_SINGLE_QUOTE && nextChar === \"'\" || mode === IN_DOUBLE_QUOTE && nextChar === '\"') {\n\t      index++;\n\t      newChar = '\\\\' + nextChar;\n\t      actions[APPEND]();\n\t      return true;\n\t    }\n\t  }\n\t\n\t  while (mode != null) {\n\t    index++;\n\t    c = path[index];\n\t\n\t    if (c === '\\\\' && maybeUnescapeQuote()) {\n\t      continue;\n\t    }\n\t\n\t    type = getPathCharType(c);\n\t    typeMap = pathStateMachine[mode];\n\t    transition = typeMap[type] || typeMap['else'] || ERROR;\n\t\n\t    if (transition === ERROR) {\n\t      return; // parse error\n\t    }\n\t\n\t    mode = transition[0];\n\t    action = actions[transition[1]];\n\t    if (action) {\n\t      newChar = transition[2];\n\t      newChar = newChar === undefined ? c : newChar;\n\t      if (action() === false) {\n\t        return;\n\t      }\n\t    }\n\t\n\t    if (mode === AFTER_PATH) {\n\t      keys.raw = path;\n\t      return keys;\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * External parse that check for a cache hit first\n\t *\n\t * @param {String} path\n\t * @return {Array|undefined}\n\t */\n\t\n\tfunction parsePath(path) {\n\t  var hit = pathCache.get(path);\n\t  if (!hit) {\n\t    hit = parse(path);\n\t    if (hit) {\n\t      pathCache.put(path, hit);\n\t    }\n\t  }\n\t  return hit;\n\t}\n\t\n\t/**\n\t * Get from an object from a path string\n\t *\n\t * @param {Object} obj\n\t * @param {String} path\n\t */\n\t\n\tfunction getPath(obj, path) {\n\t  return parseExpression(path).get(obj);\n\t}\n\t\n\t/**\n\t * Warn against setting non-existent root path on a vm.\n\t */\n\t\n\tvar warnNonExistent;\n\tif (false) {\n\t  warnNonExistent = function (path, vm) {\n\t    warn('You are setting a non-existent path \"' + path.raw + '\" ' + 'on a vm instance. Consider pre-initializing the property ' + 'with the \"data\" option for more reliable reactivity ' + 'and better performance.', vm);\n\t  };\n\t}\n\t\n\t/**\n\t * Set on an object from a path\n\t *\n\t * @param {Object} obj\n\t * @param {String | Array} path\n\t * @param {*} val\n\t */\n\t\n\tfunction setPath(obj, path, val) {\n\t  var original = obj;\n\t  if (typeof path === 'string') {\n\t    path = parse(path);\n\t  }\n\t  if (!path || !isObject(obj)) {\n\t    return false;\n\t  }\n\t  var last, key;\n\t  for (var i = 0, l = path.length; i < l; i++) {\n\t    last = obj;\n\t    key = path[i];\n\t    if (key.charAt(0) === '*') {\n\t      key = parseExpression(key.slice(1)).get.call(original, original);\n\t    }\n\t    if (i < l - 1) {\n\t      obj = obj[key];\n\t      if (!isObject(obj)) {\n\t        obj = {};\n\t        if (false) {\n\t          warnNonExistent(path, last);\n\t        }\n\t        set(last, key, obj);\n\t      }\n\t    } else {\n\t      if (isArray(obj)) {\n\t        obj.$set(key, val);\n\t      } else if (key in obj) {\n\t        obj[key] = val;\n\t      } else {\n\t        if (false) {\n\t          warnNonExistent(path, obj);\n\t        }\n\t        set(obj, key, val);\n\t      }\n\t    }\n\t  }\n\t  return true;\n\t}\n\t\n\tvar path = Object.freeze({\n\t  parsePath: parsePath,\n\t  getPath: getPath,\n\t  setPath: setPath\n\t});\n\t\n\tvar expressionCache = new Cache(1000);\n\t\n\tvar allowedKeywords = 'Math,Date,this,true,false,null,undefined,Infinity,NaN,' + 'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,' + 'encodeURIComponent,parseInt,parseFloat';\n\tvar allowedKeywordsRE = new RegExp('^(' + allowedKeywords.replace(/,/g, '\\\\b|') + '\\\\b)');\n\t\n\t// keywords that don't make sense inside expressions\n\tvar improperKeywords = 'break,case,class,catch,const,continue,debugger,default,' + 'delete,do,else,export,extends,finally,for,function,if,' + 'import,in,instanceof,let,return,super,switch,throw,try,' + 'var,while,with,yield,enum,await,implements,package,' + 'protected,static,interface,private,public';\n\tvar improperKeywordsRE = new RegExp('^(' + improperKeywords.replace(/,/g, '\\\\b|') + '\\\\b)');\n\t\n\tvar wsRE = /\\s/g;\n\tvar newlineRE = /\\n/g;\n\tvar saveRE = /[\\{,]\\s*[\\w\\$_]+\\s*:|('(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`)|new |typeof |void /g;\n\tvar restoreRE = /\"(\\d+)\"/g;\n\tvar pathTestRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?'\\]|\\[\".*?\"\\]|\\[\\d+\\]|\\[[A-Za-z_$][\\w$]*\\])*$/;\n\tvar identRE = /[^\\w$\\.](?:[A-Za-z_$][\\w$]*)/g;\n\tvar booleanLiteralRE = /^(?:true|false)$/;\n\t\n\t/**\n\t * Save / Rewrite / Restore\n\t *\n\t * When rewriting paths found in an expression, it is\n\t * possible for the same letter sequences to be found in\n\t * strings and Object literal property keys. Therefore we\n\t * remove and store these parts in a temporary array, and\n\t * restore them after the path rewrite.\n\t */\n\t\n\tvar saved = [];\n\t\n\t/**\n\t * Save replacer\n\t *\n\t * The save regex can match two possible cases:\n\t * 1. An opening object literal\n\t * 2. A string\n\t * If matched as a plain string, we need to escape its\n\t * newlines, since the string needs to be preserved when\n\t * generating the function body.\n\t *\n\t * @param {String} str\n\t * @param {String} isString - str if matched as a string\n\t * @return {String} - placeholder with index\n\t */\n\t\n\tfunction save(str, isString) {\n\t  var i = saved.length;\n\t  saved[i] = isString ? str.replace(newlineRE, '\\\\n') : str;\n\t  return '\"' + i + '\"';\n\t}\n\t\n\t/**\n\t * Path rewrite replacer\n\t *\n\t * @param {String} raw\n\t * @return {String}\n\t */\n\t\n\tfunction rewrite(raw) {\n\t  var c = raw.charAt(0);\n\t  var path = raw.slice(1);\n\t  if (allowedKeywordsRE.test(path)) {\n\t    return raw;\n\t  } else {\n\t    path = path.indexOf('\"') > -1 ? path.replace(restoreRE, restore) : path;\n\t    return c + 'scope.' + path;\n\t  }\n\t}\n\t\n\t/**\n\t * Restore replacer\n\t *\n\t * @param {String} str\n\t * @param {String} i - matched save index\n\t * @return {String}\n\t */\n\t\n\tfunction restore(str, i) {\n\t  return saved[i];\n\t}\n\t\n\t/**\n\t * Rewrite an expression, prefixing all path accessors with\n\t * `scope.` and generate getter/setter functions.\n\t *\n\t * @param {String} exp\n\t * @return {Function}\n\t */\n\t\n\tfunction compileGetter(exp) {\n\t  if (improperKeywordsRE.test(exp)) {\n\t    (\"production\") !== 'production' && warn('Avoid using reserved keywords in expression: ' + exp);\n\t  }\n\t  // reset state\n\t  saved.length = 0;\n\t  // save strings and object literal keys\n\t  var body = exp.replace(saveRE, save).replace(wsRE, '');\n\t  // rewrite all paths\n\t  // pad 1 space here becaue the regex matches 1 extra char\n\t  body = (' ' + body).replace(identRE, rewrite).replace(restoreRE, restore);\n\t  return makeGetterFn(body);\n\t}\n\t\n\t/**\n\t * Build a getter function. Requires eval.\n\t *\n\t * We isolate the try/catch so it doesn't affect the\n\t * optimization of the parse function when it is not called.\n\t *\n\t * @param {String} body\n\t * @return {Function|undefined}\n\t */\n\t\n\tfunction makeGetterFn(body) {\n\t  try {\n\t    /* eslint-disable no-new-func */\n\t    return new Function('scope', 'return ' + body + ';');\n\t    /* eslint-enable no-new-func */\n\t  } catch (e) {\n\t    (\"production\") !== 'production' && warn('Invalid expression. ' + 'Generated function body: ' + body);\n\t  }\n\t}\n\t\n\t/**\n\t * Compile a setter function for the expression.\n\t *\n\t * @param {String} exp\n\t * @return {Function|undefined}\n\t */\n\t\n\tfunction compileSetter(exp) {\n\t  var path = parsePath(exp);\n\t  if (path) {\n\t    return function (scope, val) {\n\t      setPath(scope, path, val);\n\t    };\n\t  } else {\n\t    (\"production\") !== 'production' && warn('Invalid setter expression: ' + exp);\n\t  }\n\t}\n\t\n\t/**\n\t * Parse an expression into re-written getter/setters.\n\t *\n\t * @param {String} exp\n\t * @param {Boolean} needSet\n\t * @return {Function}\n\t */\n\t\n\tfunction parseExpression(exp, needSet) {\n\t  exp = exp.trim();\n\t  // try cache\n\t  var hit = expressionCache.get(exp);\n\t  if (hit) {\n\t    if (needSet && !hit.set) {\n\t      hit.set = compileSetter(hit.exp);\n\t    }\n\t    return hit;\n\t  }\n\t  var res = { exp: exp };\n\t  res.get = isSimplePath(exp) && exp.indexOf('[') < 0\n\t  // optimized super simple getter\n\t  ? makeGetterFn('scope.' + exp)\n\t  // dynamic getter\n\t  : compileGetter(exp);\n\t  if (needSet) {\n\t    res.set = compileSetter(exp);\n\t  }\n\t  expressionCache.put(exp, res);\n\t  return res;\n\t}\n\t\n\t/**\n\t * Check if an expression is a simple path.\n\t *\n\t * @param {String} exp\n\t * @return {Boolean}\n\t */\n\t\n\tfunction isSimplePath(exp) {\n\t  return pathTestRE.test(exp) &&\n\t  // don't treat true/false as paths\n\t  !booleanLiteralRE.test(exp) &&\n\t  // Math constants e.g. Math.PI, Math.E etc.\n\t  exp.slice(0, 5) !== 'Math.';\n\t}\n\t\n\tvar expression = Object.freeze({\n\t  parseExpression: parseExpression,\n\t  isSimplePath: isSimplePath\n\t});\n\t\n\t// we have two separate queues: one for directive updates\n\t// and one for user watcher registered via $watch().\n\t// we want to guarantee directive updates to be called\n\t// before user watchers so that when user watchers are\n\t// triggered, the DOM would have already been in updated\n\t// state.\n\t\n\tvar queueIndex;\n\tvar queue = [];\n\tvar userQueue = [];\n\tvar has = {};\n\tvar circular = {};\n\tvar waiting = false;\n\tvar internalQueueDepleted = false;\n\t\n\t/**\n\t * Reset the batcher's state.\n\t */\n\t\n\tfunction resetBatcherState() {\n\t  queue = [];\n\t  userQueue = [];\n\t  has = {};\n\t  circular = {};\n\t  waiting = internalQueueDepleted = false;\n\t}\n\t\n\t/**\n\t * Flush both queues and run the watchers.\n\t */\n\t\n\tfunction flushBatcherQueue() {\n\t  runBatcherQueue(queue);\n\t  internalQueueDepleted = true;\n\t  runBatcherQueue(userQueue);\n\t  // dev tool hook\n\t  /* istanbul ignore if */\n\t  if (devtools && config.devtools) {\n\t    devtools.emit('flush');\n\t  }\n\t  resetBatcherState();\n\t}\n\t\n\t/**\n\t * Run the watchers in a single queue.\n\t *\n\t * @param {Array} queue\n\t */\n\t\n\tfunction runBatcherQueue(queue) {\n\t  // do not cache length because more watchers might be pushed\n\t  // as we run existing watchers\n\t  for (queueIndex = 0; queueIndex < queue.length; queueIndex++) {\n\t    var watcher = queue[queueIndex];\n\t    var id = watcher.id;\n\t    has[id] = null;\n\t    watcher.run();\n\t    // in dev build, check and stop circular updates.\n\t    if (false) {\n\t      circular[id] = (circular[id] || 0) + 1;\n\t      if (circular[id] > config._maxUpdateCount) {\n\t        warn('You may have an infinite update loop for watcher ' + 'with expression \"' + watcher.expression + '\"', watcher.vm);\n\t        break;\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Push a watcher into the watcher queue.\n\t * Jobs with duplicate IDs will be skipped unless it's\n\t * pushed when the queue is being flushed.\n\t *\n\t * @param {Watcher} watcher\n\t *   properties:\n\t *   - {Number} id\n\t *   - {Function} run\n\t */\n\t\n\tfunction pushWatcher(watcher) {\n\t  var id = watcher.id;\n\t  if (has[id] == null) {\n\t    if (internalQueueDepleted && !watcher.user) {\n\t      // an internal watcher triggered by a user watcher...\n\t      // let's run it immediately after current user watcher is done.\n\t      userQueue.splice(queueIndex + 1, 0, watcher);\n\t    } else {\n\t      // push watcher into appropriate queue\n\t      var q = watcher.user ? userQueue : queue;\n\t      has[id] = q.length;\n\t      q.push(watcher);\n\t      // queue the flush\n\t      if (!waiting) {\n\t        waiting = true;\n\t        nextTick(flushBatcherQueue);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tvar uid$2 = 0;\n\t\n\t/**\n\t * A watcher parses an expression, collects dependencies,\n\t * and fires callback when the expression value changes.\n\t * This is used for both the $watch() api and directives.\n\t *\n\t * @param {Vue} vm\n\t * @param {String|Function} expOrFn\n\t * @param {Function} cb\n\t * @param {Object} options\n\t *                 - {Array} filters\n\t *                 - {Boolean} twoWay\n\t *                 - {Boolean} deep\n\t *                 - {Boolean} user\n\t *                 - {Boolean} sync\n\t *                 - {Boolean} lazy\n\t *                 - {Function} [preProcess]\n\t *                 - {Function} [postProcess]\n\t * @constructor\n\t */\n\tfunction Watcher(vm, expOrFn, cb, options) {\n\t  // mix in options\n\t  if (options) {\n\t    extend(this, options);\n\t  }\n\t  var isFn = typeof expOrFn === 'function';\n\t  this.vm = vm;\n\t  vm._watchers.push(this);\n\t  this.expression = expOrFn;\n\t  this.cb = cb;\n\t  this.id = ++uid$2; // uid for batching\n\t  this.active = true;\n\t  this.dirty = this.lazy; // for lazy watchers\n\t  this.deps = [];\n\t  this.newDeps = [];\n\t  this.depIds = Object.create(null);\n\t  this.newDepIds = null;\n\t  this.prevError = null; // for async error stacks\n\t  // parse expression for getter/setter\n\t  if (isFn) {\n\t    this.getter = expOrFn;\n\t    this.setter = undefined;\n\t  } else {\n\t    var res = parseExpression(expOrFn, this.twoWay);\n\t    this.getter = res.get;\n\t    this.setter = res.set;\n\t  }\n\t  this.value = this.lazy ? undefined : this.get();\n\t  // state for avoiding false triggers for deep and Array\n\t  // watchers during vm._digest()\n\t  this.queued = this.shallow = false;\n\t}\n\t\n\t/**\n\t * Evaluate the getter, and re-collect dependencies.\n\t */\n\t\n\tWatcher.prototype.get = function () {\n\t  this.beforeGet();\n\t  var scope = this.scope || this.vm;\n\t  var value;\n\t  try {\n\t    value = this.getter.call(scope, scope);\n\t  } catch (e) {\n\t    if (false) {\n\t      warn('Error when evaluating expression ' + '\"' + this.expression + '\": ' + e.toString(), this.vm);\n\t    }\n\t  }\n\t  // \"touch\" every property so they are all tracked as\n\t  // dependencies for deep watching\n\t  if (this.deep) {\n\t    traverse(value);\n\t  }\n\t  if (this.preProcess) {\n\t    value = this.preProcess(value);\n\t  }\n\t  if (this.filters) {\n\t    value = scope._applyFilters(value, null, this.filters, false);\n\t  }\n\t  if (this.postProcess) {\n\t    value = this.postProcess(value);\n\t  }\n\t  this.afterGet();\n\t  return value;\n\t};\n\t\n\t/**\n\t * Set the corresponding value with the setter.\n\t *\n\t * @param {*} value\n\t */\n\t\n\tWatcher.prototype.set = function (value) {\n\t  var scope = this.scope || this.vm;\n\t  if (this.filters) {\n\t    value = scope._applyFilters(value, this.value, this.filters, true);\n\t  }\n\t  try {\n\t    this.setter.call(scope, scope, value);\n\t  } catch (e) {\n\t    if (false) {\n\t      warn('Error when evaluating setter ' + '\"' + this.expression + '\": ' + e.toString(), this.vm);\n\t    }\n\t  }\n\t  // two-way sync for v-for alias\n\t  var forContext = scope.$forContext;\n\t  if (forContext && forContext.alias === this.expression) {\n\t    if (forContext.filters) {\n\t      (\"production\") !== 'production' && warn('It seems you are using two-way binding on ' + 'a v-for alias (' + this.expression + '), and the ' + 'v-for has filters. This will not work properly. ' + 'Either remove the filters or use an array of ' + 'objects and bind to object properties instead.', this.vm);\n\t      return;\n\t    }\n\t    forContext._withLock(function () {\n\t      if (scope.$key) {\n\t        // original is an object\n\t        forContext.rawValue[scope.$key] = value;\n\t      } else {\n\t        forContext.rawValue.$set(scope.$index, value);\n\t      }\n\t    });\n\t  }\n\t};\n\t\n\t/**\n\t * Prepare for dependency collection.\n\t */\n\t\n\tWatcher.prototype.beforeGet = function () {\n\t  Dep.target = this;\n\t  this.newDepIds = Object.create(null);\n\t  this.newDeps.length = 0;\n\t};\n\t\n\t/**\n\t * Add a dependency to this directive.\n\t *\n\t * @param {Dep} dep\n\t */\n\t\n\tWatcher.prototype.addDep = function (dep) {\n\t  var id = dep.id;\n\t  if (!this.newDepIds[id]) {\n\t    this.newDepIds[id] = true;\n\t    this.newDeps.push(dep);\n\t    if (!this.depIds[id]) {\n\t      dep.addSub(this);\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Clean up for dependency collection.\n\t */\n\t\n\tWatcher.prototype.afterGet = function () {\n\t  Dep.target = null;\n\t  var i = this.deps.length;\n\t  while (i--) {\n\t    var dep = this.deps[i];\n\t    if (!this.newDepIds[dep.id]) {\n\t      dep.removeSub(this);\n\t    }\n\t  }\n\t  this.depIds = this.newDepIds;\n\t  var tmp = this.deps;\n\t  this.deps = this.newDeps;\n\t  this.newDeps = tmp;\n\t};\n\t\n\t/**\n\t * Subscriber interface.\n\t * Will be called when a dependency changes.\n\t *\n\t * @param {Boolean} shallow\n\t */\n\t\n\tWatcher.prototype.update = function (shallow) {\n\t  if (this.lazy) {\n\t    this.dirty = true;\n\t  } else if (this.sync || !config.async) {\n\t    this.run();\n\t  } else {\n\t    // if queued, only overwrite shallow with non-shallow,\n\t    // but not the other way around.\n\t    this.shallow = this.queued ? shallow ? this.shallow : false : !!shallow;\n\t    this.queued = true;\n\t    // record before-push error stack in debug mode\n\t    /* istanbul ignore if */\n\t    if (false) {\n\t      this.prevError = new Error('[vue] async stack trace');\n\t    }\n\t    pushWatcher(this);\n\t  }\n\t};\n\t\n\t/**\n\t * Batcher job interface.\n\t * Will be called by the batcher.\n\t */\n\t\n\tWatcher.prototype.run = function () {\n\t  if (this.active) {\n\t    var value = this.get();\n\t    if (value !== this.value ||\n\t    // Deep watchers and watchers on Object/Arrays should fire even\n\t    // when the value is the same, because the value may\n\t    // have mutated; but only do so if this is a\n\t    // non-shallow update (caused by a vm digest).\n\t    (isObject(value) || this.deep) && !this.shallow) {\n\t      // set new value\n\t      var oldValue = this.value;\n\t      this.value = value;\n\t      // in debug + async mode, when a watcher callbacks\n\t      // throws, we also throw the saved before-push error\n\t      // so the full cross-tick stack trace is available.\n\t      var prevError = this.prevError;\n\t      /* istanbul ignore if */\n\t      if (false) {\n\t        this.prevError = null;\n\t        try {\n\t          this.cb.call(this.vm, value, oldValue);\n\t        } catch (e) {\n\t          nextTick(function () {\n\t            throw prevError;\n\t          }, 0);\n\t          throw e;\n\t        }\n\t      } else {\n\t        this.cb.call(this.vm, value, oldValue);\n\t      }\n\t    }\n\t    this.queued = this.shallow = false;\n\t  }\n\t};\n\t\n\t/**\n\t * Evaluate the value of the watcher.\n\t * This only gets called for lazy watchers.\n\t */\n\t\n\tWatcher.prototype.evaluate = function () {\n\t  // avoid overwriting another watcher that is being\n\t  // collected.\n\t  var current = Dep.target;\n\t  this.value = this.get();\n\t  this.dirty = false;\n\t  Dep.target = current;\n\t};\n\t\n\t/**\n\t * Depend on all deps collected by this watcher.\n\t */\n\t\n\tWatcher.prototype.depend = function () {\n\t  var i = this.deps.length;\n\t  while (i--) {\n\t    this.deps[i].depend();\n\t  }\n\t};\n\t\n\t/**\n\t * Remove self from all dependencies' subcriber list.\n\t */\n\t\n\tWatcher.prototype.teardown = function () {\n\t  if (this.active) {\n\t    // remove self from vm's watcher list\n\t    // this is a somewhat expensive operation so we skip it\n\t    // if the vm is being destroyed or is performing a v-for\n\t    // re-render (the watcher list is then filtered by v-for).\n\t    if (!this.vm._isBeingDestroyed && !this.vm._vForRemoving) {\n\t      this.vm._watchers.$remove(this);\n\t    }\n\t    var i = this.deps.length;\n\t    while (i--) {\n\t      this.deps[i].removeSub(this);\n\t    }\n\t    this.active = false;\n\t    this.vm = this.cb = this.value = null;\n\t  }\n\t};\n\t\n\t/**\n\t * Recrusively traverse an object to evoke all converted\n\t * getters, so that every nested property inside the object\n\t * is collected as a \"deep\" dependency.\n\t *\n\t * @param {*} val\n\t */\n\t\n\tfunction traverse(val) {\n\t  var i, keys;\n\t  if (isArray(val)) {\n\t    i = val.length;\n\t    while (i--) traverse(val[i]);\n\t  } else if (isObject(val)) {\n\t    keys = Object.keys(val);\n\t    i = keys.length;\n\t    while (i--) traverse(val[keys[i]]);\n\t  }\n\t}\n\t\n\tvar text$1 = {\n\t\n\t  bind: function bind() {\n\t    this.attr = this.el.nodeType === 3 ? 'data' : 'textContent';\n\t  },\n\t\n\t  update: function update(value) {\n\t    this.el[this.attr] = _toString(value);\n\t  }\n\t};\n\t\n\tvar templateCache = new Cache(1000);\n\tvar idSelectorCache = new Cache(1000);\n\t\n\tvar map = {\n\t  efault: [0, '', ''],\n\t  legend: [1, '<fieldset>', '</fieldset>'],\n\t  tr: [2, '<table><tbody>', '</tbody></table>'],\n\t  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>']\n\t};\n\t\n\tmap.td = map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];\n\t\n\tmap.option = map.optgroup = [1, '<select multiple=\"multiple\">', '</select>'];\n\t\n\tmap.thead = map.tbody = map.colgroup = map.caption = map.tfoot = [1, '<table>', '</table>'];\n\t\n\tmap.g = map.defs = map.symbol = map.use = map.image = map.text = map.circle = map.ellipse = map.line = map.path = map.polygon = map.polyline = map.rect = [1, '<svg ' + 'xmlns=\"http://www.w3.org/2000/svg\" ' + 'xmlns:xlink=\"http://www.w3.org/1999/xlink\" ' + 'xmlns:ev=\"http://www.w3.org/2001/xml-events\"' + 'version=\"1.1\">', '</svg>'];\n\t\n\t/**\n\t * Check if a node is a supported template node with a\n\t * DocumentFragment content.\n\t *\n\t * @param {Node} node\n\t * @return {Boolean}\n\t */\n\t\n\tfunction isRealTemplate(node) {\n\t  return isTemplate(node) && isFragment(node.content);\n\t}\n\t\n\tvar tagRE$1 = /<([\\w:-]+)/;\n\tvar entityRE = /&#?\\w+?;/;\n\t\n\t/**\n\t * Convert a string template to a DocumentFragment.\n\t * Determines correct wrapping by tag types. Wrapping\n\t * strategy found in jQuery & component/domify.\n\t *\n\t * @param {String} templateString\n\t * @param {Boolean} raw\n\t * @return {DocumentFragment}\n\t */\n\t\n\tfunction stringToFragment(templateString, raw) {\n\t  // try a cache hit first\n\t  var cacheKey = raw ? templateString : templateString.trim();\n\t  var hit = templateCache.get(cacheKey);\n\t  if (hit) {\n\t    return hit;\n\t  }\n\t\n\t  var frag = document.createDocumentFragment();\n\t  var tagMatch = templateString.match(tagRE$1);\n\t  var entityMatch = entityRE.test(templateString);\n\t\n\t  if (!tagMatch && !entityMatch) {\n\t    // text only, return a single text node.\n\t    frag.appendChild(document.createTextNode(templateString));\n\t  } else {\n\t    var tag = tagMatch && tagMatch[1];\n\t    var wrap = map[tag] || map.efault;\n\t    var depth = wrap[0];\n\t    var prefix = wrap[1];\n\t    var suffix = wrap[2];\n\t    var node = document.createElement('div');\n\t\n\t    node.innerHTML = prefix + templateString + suffix;\n\t    while (depth--) {\n\t      node = node.lastChild;\n\t    }\n\t\n\t    var child;\n\t    /* eslint-disable no-cond-assign */\n\t    while (child = node.firstChild) {\n\t      /* eslint-enable no-cond-assign */\n\t      frag.appendChild(child);\n\t    }\n\t  }\n\t  if (!raw) {\n\t    trimNode(frag);\n\t  }\n\t  templateCache.put(cacheKey, frag);\n\t  return frag;\n\t}\n\t\n\t/**\n\t * Convert a template node to a DocumentFragment.\n\t *\n\t * @param {Node} node\n\t * @return {DocumentFragment}\n\t */\n\t\n\tfunction nodeToFragment(node) {\n\t  // if its a template tag and the browser supports it,\n\t  // its content is already a document fragment.\n\t  if (isRealTemplate(node)) {\n\t    trimNode(node.content);\n\t    return node.content;\n\t  }\n\t  // script template\n\t  if (node.tagName === 'SCRIPT') {\n\t    return stringToFragment(node.textContent);\n\t  }\n\t  // normal node, clone it to avoid mutating the original\n\t  var clonedNode = cloneNode(node);\n\t  var frag = document.createDocumentFragment();\n\t  var child;\n\t  /* eslint-disable no-cond-assign */\n\t  while (child = clonedNode.firstChild) {\n\t    /* eslint-enable no-cond-assign */\n\t    frag.appendChild(child);\n\t  }\n\t  trimNode(frag);\n\t  return frag;\n\t}\n\t\n\t// Test for the presence of the Safari template cloning bug\n\t// https://bugs.webkit.org/showug.cgi?id=137755\n\tvar hasBrokenTemplate = (function () {\n\t  /* istanbul ignore else */\n\t  if (inBrowser) {\n\t    var a = document.createElement('div');\n\t    a.innerHTML = '<template>1</template>';\n\t    return !a.cloneNode(true).firstChild.innerHTML;\n\t  } else {\n\t    return false;\n\t  }\n\t})();\n\t\n\t// Test for IE10/11 textarea placeholder clone bug\n\tvar hasTextareaCloneBug = (function () {\n\t  /* istanbul ignore else */\n\t  if (inBrowser) {\n\t    var t = document.createElement('textarea');\n\t    t.placeholder = 't';\n\t    return t.cloneNode(true).value === 't';\n\t  } else {\n\t    return false;\n\t  }\n\t})();\n\t\n\t/**\n\t * 1. Deal with Safari cloning nested <template> bug by\n\t *    manually cloning all template instances.\n\t * 2. Deal with IE10/11 textarea placeholder bug by setting\n\t *    the correct value after cloning.\n\t *\n\t * @param {Element|DocumentFragment} node\n\t * @return {Element|DocumentFragment}\n\t */\n\t\n\tfunction cloneNode(node) {\n\t  /* istanbul ignore if */\n\t  if (!node.querySelectorAll) {\n\t    return node.cloneNode();\n\t  }\n\t  var res = node.cloneNode(true);\n\t  var i, original, cloned;\n\t  /* istanbul ignore if */\n\t  if (hasBrokenTemplate) {\n\t    var tempClone = res;\n\t    if (isRealTemplate(node)) {\n\t      node = node.content;\n\t      tempClone = res.content;\n\t    }\n\t    original = node.querySelectorAll('template');\n\t    if (original.length) {\n\t      cloned = tempClone.querySelectorAll('template');\n\t      i = cloned.length;\n\t      while (i--) {\n\t        cloned[i].parentNode.replaceChild(cloneNode(original[i]), cloned[i]);\n\t      }\n\t    }\n\t  }\n\t  /* istanbul ignore if */\n\t  if (hasTextareaCloneBug) {\n\t    if (node.tagName === 'TEXTAREA') {\n\t      res.value = node.value;\n\t    } else {\n\t      original = node.querySelectorAll('textarea');\n\t      if (original.length) {\n\t        cloned = res.querySelectorAll('textarea');\n\t        i = cloned.length;\n\t        while (i--) {\n\t          cloned[i].value = original[i].value;\n\t        }\n\t      }\n\t    }\n\t  }\n\t  return res;\n\t}\n\t\n\t/**\n\t * Process the template option and normalizes it into a\n\t * a DocumentFragment that can be used as a partial or a\n\t * instance template.\n\t *\n\t * @param {*} template\n\t *        Possible values include:\n\t *        - DocumentFragment object\n\t *        - Node object of type Template\n\t *        - id selector: '#some-template-id'\n\t *        - template string: '<div><span>{{msg}}</span></div>'\n\t * @param {Boolean} shouldClone\n\t * @param {Boolean} raw\n\t *        inline HTML interpolation. Do not check for id\n\t *        selector and keep whitespace in the string.\n\t * @return {DocumentFragment|undefined}\n\t */\n\t\n\tfunction parseTemplate(template, shouldClone, raw) {\n\t  var node, frag;\n\t\n\t  // if the template is already a document fragment,\n\t  // do nothing\n\t  if (isFragment(template)) {\n\t    trimNode(template);\n\t    return shouldClone ? cloneNode(template) : template;\n\t  }\n\t\n\t  if (typeof template === 'string') {\n\t    // id selector\n\t    if (!raw && template.charAt(0) === '#') {\n\t      // id selector can be cached too\n\t      frag = idSelectorCache.get(template);\n\t      if (!frag) {\n\t        node = document.getElementById(template.slice(1));\n\t        if (node) {\n\t          frag = nodeToFragment(node);\n\t          // save selector to cache\n\t          idSelectorCache.put(template, frag);\n\t        }\n\t      }\n\t    } else {\n\t      // normal string template\n\t      frag = stringToFragment(template, raw);\n\t    }\n\t  } else if (template.nodeType) {\n\t    // a direct node\n\t    frag = nodeToFragment(template);\n\t  }\n\t\n\t  return frag && shouldClone ? cloneNode(frag) : frag;\n\t}\n\t\n\tvar template = Object.freeze({\n\t  cloneNode: cloneNode,\n\t  parseTemplate: parseTemplate\n\t});\n\t\n\tvar html = {\n\t\n\t  bind: function bind() {\n\t    // a comment node means this is a binding for\n\t    // {{{ inline unescaped html }}}\n\t    if (this.el.nodeType === 8) {\n\t      // hold nodes\n\t      this.nodes = [];\n\t      // replace the placeholder with proper anchor\n\t      this.anchor = createAnchor('v-html');\n\t      replace(this.el, this.anchor);\n\t    }\n\t  },\n\t\n\t  update: function update(value) {\n\t    value = _toString(value);\n\t    if (this.nodes) {\n\t      this.swap(value);\n\t    } else {\n\t      this.el.innerHTML = value;\n\t    }\n\t  },\n\t\n\t  swap: function swap(value) {\n\t    // remove old nodes\n\t    var i = this.nodes.length;\n\t    while (i--) {\n\t      remove(this.nodes[i]);\n\t    }\n\t    // convert new value to a fragment\n\t    // do not attempt to retrieve from id selector\n\t    var frag = parseTemplate(value, true, true);\n\t    // save a reference to these nodes so we can remove later\n\t    this.nodes = toArray(frag.childNodes);\n\t    before(frag, this.anchor);\n\t  }\n\t};\n\t\n\t/**\n\t * Abstraction for a partially-compiled fragment.\n\t * Can optionally compile content with a child scope.\n\t *\n\t * @param {Function} linker\n\t * @param {Vue} vm\n\t * @param {DocumentFragment} frag\n\t * @param {Vue} [host]\n\t * @param {Object} [scope]\n\t * @param {Fragment} [parentFrag]\n\t */\n\tfunction Fragment(linker, vm, frag, host, scope, parentFrag) {\n\t  this.children = [];\n\t  this.childFrags = [];\n\t  this.vm = vm;\n\t  this.scope = scope;\n\t  this.inserted = false;\n\t  this.parentFrag = parentFrag;\n\t  if (parentFrag) {\n\t    parentFrag.childFrags.push(this);\n\t  }\n\t  this.unlink = linker(vm, frag, host, scope, this);\n\t  var single = this.single = frag.childNodes.length === 1 &&\n\t  // do not go single mode if the only node is an anchor\n\t  !frag.childNodes[0].__v_anchor;\n\t  if (single) {\n\t    this.node = frag.childNodes[0];\n\t    this.before = singleBefore;\n\t    this.remove = singleRemove;\n\t  } else {\n\t    this.node = createAnchor('fragment-start');\n\t    this.end = createAnchor('fragment-end');\n\t    this.frag = frag;\n\t    prepend(this.node, frag);\n\t    frag.appendChild(this.end);\n\t    this.before = multiBefore;\n\t    this.remove = multiRemove;\n\t  }\n\t  this.node.__v_frag = this;\n\t}\n\t\n\t/**\n\t * Call attach/detach for all components contained within\n\t * this fragment. Also do so recursively for all child\n\t * fragments.\n\t *\n\t * @param {Function} hook\n\t */\n\t\n\tFragment.prototype.callHook = function (hook) {\n\t  var i, l;\n\t  for (i = 0, l = this.childFrags.length; i < l; i++) {\n\t    this.childFrags[i].callHook(hook);\n\t  }\n\t  for (i = 0, l = this.children.length; i < l; i++) {\n\t    hook(this.children[i]);\n\t  }\n\t};\n\t\n\t/**\n\t * Insert fragment before target, single node version\n\t *\n\t * @param {Node} target\n\t * @param {Boolean} withTransition\n\t */\n\t\n\tfunction singleBefore(target, withTransition) {\n\t  this.inserted = true;\n\t  var method = withTransition !== false ? beforeWithTransition : before;\n\t  method(this.node, target, this.vm);\n\t  if (inDoc(this.node)) {\n\t    this.callHook(attach);\n\t  }\n\t}\n\t\n\t/**\n\t * Remove fragment, single node version\n\t */\n\t\n\tfunction singleRemove() {\n\t  this.inserted = false;\n\t  var shouldCallRemove = inDoc(this.node);\n\t  var self = this;\n\t  this.beforeRemove();\n\t  removeWithTransition(this.node, this.vm, function () {\n\t    if (shouldCallRemove) {\n\t      self.callHook(detach);\n\t    }\n\t    self.destroy();\n\t  });\n\t}\n\t\n\t/**\n\t * Insert fragment before target, multi-nodes version\n\t *\n\t * @param {Node} target\n\t * @param {Boolean} withTransition\n\t */\n\t\n\tfunction multiBefore(target, withTransition) {\n\t  this.inserted = true;\n\t  var vm = this.vm;\n\t  var method = withTransition !== false ? beforeWithTransition : before;\n\t  mapNodeRange(this.node, this.end, function (node) {\n\t    method(node, target, vm);\n\t  });\n\t  if (inDoc(this.node)) {\n\t    this.callHook(attach);\n\t  }\n\t}\n\t\n\t/**\n\t * Remove fragment, multi-nodes version\n\t */\n\t\n\tfunction multiRemove() {\n\t  this.inserted = false;\n\t  var self = this;\n\t  var shouldCallRemove = inDoc(this.node);\n\t  this.beforeRemove();\n\t  removeNodeRange(this.node, this.end, this.vm, this.frag, function () {\n\t    if (shouldCallRemove) {\n\t      self.callHook(detach);\n\t    }\n\t    self.destroy();\n\t  });\n\t}\n\t\n\t/**\n\t * Prepare the fragment for removal.\n\t */\n\t\n\tFragment.prototype.beforeRemove = function () {\n\t  var i, l;\n\t  for (i = 0, l = this.childFrags.length; i < l; i++) {\n\t    // call the same method recursively on child\n\t    // fragments, depth-first\n\t    this.childFrags[i].beforeRemove(false);\n\t  }\n\t  for (i = 0, l = this.children.length; i < l; i++) {\n\t    // Call destroy for all contained instances,\n\t    // with remove:false and defer:true.\n\t    // Defer is necessary because we need to\n\t    // keep the children to call detach hooks\n\t    // on them.\n\t    this.children[i].$destroy(false, true);\n\t  }\n\t  var dirs = this.unlink.dirs;\n\t  for (i = 0, l = dirs.length; i < l; i++) {\n\t    // disable the watchers on all the directives\n\t    // so that the rendered content stays the same\n\t    // during removal.\n\t    dirs[i]._watcher && dirs[i]._watcher.teardown();\n\t  }\n\t};\n\t\n\t/**\n\t * Destroy the fragment.\n\t */\n\t\n\tFragment.prototype.destroy = function () {\n\t  if (this.parentFrag) {\n\t    this.parentFrag.childFrags.$remove(this);\n\t  }\n\t  this.node.__v_frag = null;\n\t  this.unlink();\n\t};\n\t\n\t/**\n\t * Call attach hook for a Vue instance.\n\t *\n\t * @param {Vue} child\n\t */\n\t\n\tfunction attach(child) {\n\t  if (!child._isAttached && inDoc(child.$el)) {\n\t    child._callHook('attached');\n\t  }\n\t}\n\t\n\t/**\n\t * Call detach hook for a Vue instance.\n\t *\n\t * @param {Vue} child\n\t */\n\t\n\tfunction detach(child) {\n\t  if (child._isAttached && !inDoc(child.$el)) {\n\t    child._callHook('detached');\n\t  }\n\t}\n\t\n\tvar linkerCache = new Cache(5000);\n\t\n\t/**\n\t * A factory that can be used to create instances of a\n\t * fragment. Caches the compiled linker if possible.\n\t *\n\t * @param {Vue} vm\n\t * @param {Element|String} el\n\t */\n\tfunction FragmentFactory(vm, el) {\n\t  this.vm = vm;\n\t  var template;\n\t  var isString = typeof el === 'string';\n\t  if (isString || isTemplate(el)) {\n\t    template = parseTemplate(el, true);\n\t  } else {\n\t    template = document.createDocumentFragment();\n\t    template.appendChild(el);\n\t  }\n\t  this.template = template;\n\t  // linker can be cached, but only for components\n\t  var linker;\n\t  var cid = vm.constructor.cid;\n\t  if (cid > 0) {\n\t    var cacheId = cid + (isString ? el : getOuterHTML(el));\n\t    linker = linkerCache.get(cacheId);\n\t    if (!linker) {\n\t      linker = compile(template, vm.$options, true);\n\t      linkerCache.put(cacheId, linker);\n\t    }\n\t  } else {\n\t    linker = compile(template, vm.$options, true);\n\t  }\n\t  this.linker = linker;\n\t}\n\t\n\t/**\n\t * Create a fragment instance with given host and scope.\n\t *\n\t * @param {Vue} host\n\t * @param {Object} scope\n\t * @param {Fragment} parentFrag\n\t */\n\t\n\tFragmentFactory.prototype.create = function (host, scope, parentFrag) {\n\t  var frag = cloneNode(this.template);\n\t  return new Fragment(this.linker, this.vm, frag, host, scope, parentFrag);\n\t};\n\t\n\tvar ON = 700;\n\tvar MODEL = 800;\n\tvar BIND = 850;\n\tvar TRANSITION = 1100;\n\tvar EL = 1500;\n\tvar COMPONENT = 1500;\n\tvar PARTIAL = 1750;\n\tvar IF = 2100;\n\tvar FOR = 2200;\n\tvar SLOT = 2300;\n\t\n\tvar uid$3 = 0;\n\t\n\tvar vFor = {\n\t\n\t  priority: FOR,\n\t  terminal: true,\n\t\n\t  params: ['track-by', 'stagger', 'enter-stagger', 'leave-stagger'],\n\t\n\t  bind: function bind() {\n\t    // support \"item in/of items\" syntax\n\t    var inMatch = this.expression.match(/(.*) (?:in|of) (.*)/);\n\t    if (inMatch) {\n\t      var itMatch = inMatch[1].match(/\\((.*),(.*)\\)/);\n\t      if (itMatch) {\n\t        this.iterator = itMatch[1].trim();\n\t        this.alias = itMatch[2].trim();\n\t      } else {\n\t        this.alias = inMatch[1].trim();\n\t      }\n\t      this.expression = inMatch[2];\n\t    }\n\t\n\t    if (!this.alias) {\n\t      (\"production\") !== 'production' && warn('Invalid v-for expression \"' + this.descriptor.raw + '\": ' + 'alias is required.', this.vm);\n\t      return;\n\t    }\n\t\n\t    // uid as a cache identifier\n\t    this.id = '__v-for__' + ++uid$3;\n\t\n\t    // check if this is an option list,\n\t    // so that we know if we need to update the <select>'s\n\t    // v-model when the option list has changed.\n\t    // because v-model has a lower priority than v-for,\n\t    // the v-model is not bound here yet, so we have to\n\t    // retrive it in the actual updateModel() function.\n\t    var tag = this.el.tagName;\n\t    this.isOption = (tag === 'OPTION' || tag === 'OPTGROUP') && this.el.parentNode.tagName === 'SELECT';\n\t\n\t    // setup anchor nodes\n\t    this.start = createAnchor('v-for-start');\n\t    this.end = createAnchor('v-for-end');\n\t    replace(this.el, this.end);\n\t    before(this.start, this.end);\n\t\n\t    // cache\n\t    this.cache = Object.create(null);\n\t\n\t    // fragment factory\n\t    this.factory = new FragmentFactory(this.vm, this.el);\n\t  },\n\t\n\t  update: function update(data) {\n\t    this.diff(data);\n\t    this.updateRef();\n\t    this.updateModel();\n\t  },\n\t\n\t  /**\n\t   * Diff, based on new data and old data, determine the\n\t   * minimum amount of DOM manipulations needed to make the\n\t   * DOM reflect the new data Array.\n\t   *\n\t   * The algorithm diffs the new data Array by storing a\n\t   * hidden reference to an owner vm instance on previously\n\t   * seen data. This allows us to achieve O(n) which is\n\t   * better than a levenshtein distance based algorithm,\n\t   * which is O(m * n).\n\t   *\n\t   * @param {Array} data\n\t   */\n\t\n\t  diff: function diff(data) {\n\t    // check if the Array was converted from an Object\n\t    var item = data[0];\n\t    var convertedFromObject = this.fromObject = isObject(item) && hasOwn(item, '$key') && hasOwn(item, '$value');\n\t\n\t    var trackByKey = this.params.trackBy;\n\t    var oldFrags = this.frags;\n\t    var frags = this.frags = new Array(data.length);\n\t    var alias = this.alias;\n\t    var iterator = this.iterator;\n\t    var start = this.start;\n\t    var end = this.end;\n\t    var inDocument = inDoc(start);\n\t    var init = !oldFrags;\n\t    var i, l, frag, key, value, primitive;\n\t\n\t    // First pass, go through the new Array and fill up\n\t    // the new frags array. If a piece of data has a cached\n\t    // instance for it, we reuse it. Otherwise build a new\n\t    // instance.\n\t    for (i = 0, l = data.length; i < l; i++) {\n\t      item = data[i];\n\t      key = convertedFromObject ? item.$key : null;\n\t      value = convertedFromObject ? item.$value : item;\n\t      primitive = !isObject(value);\n\t      frag = !init && this.getCachedFrag(value, i, key);\n\t      if (frag) {\n\t        // reusable fragment\n\t        frag.reused = true;\n\t        // update $index\n\t        frag.scope.$index = i;\n\t        // update $key\n\t        if (key) {\n\t          frag.scope.$key = key;\n\t        }\n\t        // update iterator\n\t        if (iterator) {\n\t          frag.scope[iterator] = key !== null ? key : i;\n\t        }\n\t        // update data for track-by, object repeat &\n\t        // primitive values.\n\t        if (trackByKey || convertedFromObject || primitive) {\n\t          withoutConversion(function () {\n\t            frag.scope[alias] = value;\n\t          });\n\t        }\n\t      } else {\n\t        // new isntance\n\t        frag = this.create(value, alias, i, key);\n\t        frag.fresh = !init;\n\t      }\n\t      frags[i] = frag;\n\t      if (init) {\n\t        frag.before(end);\n\t      }\n\t    }\n\t\n\t    // we're done for the initial render.\n\t    if (init) {\n\t      return;\n\t    }\n\t\n\t    // Second pass, go through the old fragments and\n\t    // destroy those who are not reused (and remove them\n\t    // from cache)\n\t    var removalIndex = 0;\n\t    var totalRemoved = oldFrags.length - frags.length;\n\t    // when removing a large number of fragments, watcher removal\n\t    // turns out to be a perf bottleneck, so we batch the watcher\n\t    // removals into a single filter call!\n\t    this.vm._vForRemoving = true;\n\t    for (i = 0, l = oldFrags.length; i < l; i++) {\n\t      frag = oldFrags[i];\n\t      if (!frag.reused) {\n\t        this.deleteCachedFrag(frag);\n\t        this.remove(frag, removalIndex++, totalRemoved, inDocument);\n\t      }\n\t    }\n\t    this.vm._vForRemoving = false;\n\t    if (removalIndex) {\n\t      this.vm._watchers = this.vm._watchers.filter(function (w) {\n\t        return w.active;\n\t      });\n\t    }\n\t\n\t    // Final pass, move/insert new fragments into the\n\t    // right place.\n\t    var targetPrev, prevEl, currentPrev;\n\t    var insertionIndex = 0;\n\t    for (i = 0, l = frags.length; i < l; i++) {\n\t      frag = frags[i];\n\t      // this is the frag that we should be after\n\t      targetPrev = frags[i - 1];\n\t      prevEl = targetPrev ? targetPrev.staggerCb ? targetPrev.staggerAnchor : targetPrev.end || targetPrev.node : start;\n\t      if (frag.reused && !frag.staggerCb) {\n\t        currentPrev = findPrevFrag(frag, start, this.id);\n\t        if (currentPrev !== targetPrev && (!currentPrev ||\n\t        // optimization for moving a single item.\n\t        // thanks to suggestions by @livoras in #1807\n\t        findPrevFrag(currentPrev, start, this.id) !== targetPrev)) {\n\t          this.move(frag, prevEl);\n\t        }\n\t      } else {\n\t        // new instance, or still in stagger.\n\t        // insert with updated stagger index.\n\t        this.insert(frag, insertionIndex++, prevEl, inDocument);\n\t      }\n\t      frag.reused = frag.fresh = false;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Create a new fragment instance.\n\t   *\n\t   * @param {*} value\n\t   * @param {String} alias\n\t   * @param {Number} index\n\t   * @param {String} [key]\n\t   * @return {Fragment}\n\t   */\n\t\n\t  create: function create(value, alias, index, key) {\n\t    var host = this._host;\n\t    // create iteration scope\n\t    var parentScope = this._scope || this.vm;\n\t    var scope = Object.create(parentScope);\n\t    // ref holder for the scope\n\t    scope.$refs = Object.create(parentScope.$refs);\n\t    scope.$els = Object.create(parentScope.$els);\n\t    // make sure point $parent to parent scope\n\t    scope.$parent = parentScope;\n\t    // for two-way binding on alias\n\t    scope.$forContext = this;\n\t    // define scope properties\n\t    // important: define the scope alias without forced conversion\n\t    // so that frozen data structures remain non-reactive.\n\t    withoutConversion(function () {\n\t      defineReactive(scope, alias, value);\n\t    });\n\t    defineReactive(scope, '$index', index);\n\t    if (key) {\n\t      defineReactive(scope, '$key', key);\n\t    } else if (scope.$key) {\n\t      // avoid accidental fallback\n\t      def(scope, '$key', null);\n\t    }\n\t    if (this.iterator) {\n\t      defineReactive(scope, this.iterator, key !== null ? key : index);\n\t    }\n\t    var frag = this.factory.create(host, scope, this._frag);\n\t    frag.forId = this.id;\n\t    this.cacheFrag(value, frag, index, key);\n\t    return frag;\n\t  },\n\t\n\t  /**\n\t   * Update the v-ref on owner vm.\n\t   */\n\t\n\t  updateRef: function updateRef() {\n\t    var ref = this.descriptor.ref;\n\t    if (!ref) return;\n\t    var hash = (this._scope || this.vm).$refs;\n\t    var refs;\n\t    if (!this.fromObject) {\n\t      refs = this.frags.map(findVmFromFrag);\n\t    } else {\n\t      refs = {};\n\t      this.frags.forEach(function (frag) {\n\t        refs[frag.scope.$key] = findVmFromFrag(frag);\n\t      });\n\t    }\n\t    hash[ref] = refs;\n\t  },\n\t\n\t  /**\n\t   * For option lists, update the containing v-model on\n\t   * parent <select>.\n\t   */\n\t\n\t  updateModel: function updateModel() {\n\t    if (this.isOption) {\n\t      var parent = this.start.parentNode;\n\t      var model = parent && parent.__v_model;\n\t      if (model) {\n\t        model.forceUpdate();\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Insert a fragment. Handles staggering.\n\t   *\n\t   * @param {Fragment} frag\n\t   * @param {Number} index\n\t   * @param {Node} prevEl\n\t   * @param {Boolean} inDocument\n\t   */\n\t\n\t  insert: function insert(frag, index, prevEl, inDocument) {\n\t    if (frag.staggerCb) {\n\t      frag.staggerCb.cancel();\n\t      frag.staggerCb = null;\n\t    }\n\t    var staggerAmount = this.getStagger(frag, index, null, 'enter');\n\t    if (inDocument && staggerAmount) {\n\t      // create an anchor and insert it synchronously,\n\t      // so that we can resolve the correct order without\n\t      // worrying about some elements not inserted yet\n\t      var anchor = frag.staggerAnchor;\n\t      if (!anchor) {\n\t        anchor = frag.staggerAnchor = createAnchor('stagger-anchor');\n\t        anchor.__v_frag = frag;\n\t      }\n\t      after(anchor, prevEl);\n\t      var op = frag.staggerCb = cancellable(function () {\n\t        frag.staggerCb = null;\n\t        frag.before(anchor);\n\t        remove(anchor);\n\t      });\n\t      setTimeout(op, staggerAmount);\n\t    } else {\n\t      frag.before(prevEl.nextSibling);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Remove a fragment. Handles staggering.\n\t   *\n\t   * @param {Fragment} frag\n\t   * @param {Number} index\n\t   * @param {Number} total\n\t   * @param {Boolean} inDocument\n\t   */\n\t\n\t  remove: function remove(frag, index, total, inDocument) {\n\t    if (frag.staggerCb) {\n\t      frag.staggerCb.cancel();\n\t      frag.staggerCb = null;\n\t      // it's not possible for the same frag to be removed\n\t      // twice, so if we have a pending stagger callback,\n\t      // it means this frag is queued for enter but removed\n\t      // before its transition started. Since it is already\n\t      // destroyed, we can just leave it in detached state.\n\t      return;\n\t    }\n\t    var staggerAmount = this.getStagger(frag, index, total, 'leave');\n\t    if (inDocument && staggerAmount) {\n\t      var op = frag.staggerCb = cancellable(function () {\n\t        frag.staggerCb = null;\n\t        frag.remove();\n\t      });\n\t      setTimeout(op, staggerAmount);\n\t    } else {\n\t      frag.remove();\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Move a fragment to a new position.\n\t   * Force no transition.\n\t   *\n\t   * @param {Fragment} frag\n\t   * @param {Node} prevEl\n\t   */\n\t\n\t  move: function move(frag, prevEl) {\n\t    // fix a common issue with Sortable:\n\t    // if prevEl doesn't have nextSibling, this means it's\n\t    // been dragged after the end anchor. Just re-position\n\t    // the end anchor to the end of the container.\n\t    /* istanbul ignore if */\n\t    if (!prevEl.nextSibling) {\n\t      this.end.parentNode.appendChild(this.end);\n\t    }\n\t    frag.before(prevEl.nextSibling, false);\n\t  },\n\t\n\t  /**\n\t   * Cache a fragment using track-by or the object key.\n\t   *\n\t   * @param {*} value\n\t   * @param {Fragment} frag\n\t   * @param {Number} index\n\t   * @param {String} [key]\n\t   */\n\t\n\t  cacheFrag: function cacheFrag(value, frag, index, key) {\n\t    var trackByKey = this.params.trackBy;\n\t    var cache = this.cache;\n\t    var primitive = !isObject(value);\n\t    var id;\n\t    if (key || trackByKey || primitive) {\n\t      id = trackByKey ? trackByKey === '$index' ? index : getPath(value, trackByKey) : key || value;\n\t      if (!cache[id]) {\n\t        cache[id] = frag;\n\t      } else if (trackByKey !== '$index') {\n\t        (\"production\") !== 'production' && this.warnDuplicate(value);\n\t      }\n\t    } else {\n\t      id = this.id;\n\t      if (hasOwn(value, id)) {\n\t        if (value[id] === null) {\n\t          value[id] = frag;\n\t        } else {\n\t          (\"production\") !== 'production' && this.warnDuplicate(value);\n\t        }\n\t      } else {\n\t        def(value, id, frag);\n\t      }\n\t    }\n\t    frag.raw = value;\n\t  },\n\t\n\t  /**\n\t   * Get a cached fragment from the value/index/key\n\t   *\n\t   * @param {*} value\n\t   * @param {Number} index\n\t   * @param {String} key\n\t   * @return {Fragment}\n\t   */\n\t\n\t  getCachedFrag: function getCachedFrag(value, index, key) {\n\t    var trackByKey = this.params.trackBy;\n\t    var primitive = !isObject(value);\n\t    var frag;\n\t    if (key || trackByKey || primitive) {\n\t      var id = trackByKey ? trackByKey === '$index' ? index : getPath(value, trackByKey) : key || value;\n\t      frag = this.cache[id];\n\t    } else {\n\t      frag = value[this.id];\n\t    }\n\t    if (frag && (frag.reused || frag.fresh)) {\n\t      (\"production\") !== 'production' && this.warnDuplicate(value);\n\t    }\n\t    return frag;\n\t  },\n\t\n\t  /**\n\t   * Delete a fragment from cache.\n\t   *\n\t   * @param {Fragment} frag\n\t   */\n\t\n\t  deleteCachedFrag: function deleteCachedFrag(frag) {\n\t    var value = frag.raw;\n\t    var trackByKey = this.params.trackBy;\n\t    var scope = frag.scope;\n\t    var index = scope.$index;\n\t    // fix #948: avoid accidentally fall through to\n\t    // a parent repeater which happens to have $key.\n\t    var key = hasOwn(scope, '$key') && scope.$key;\n\t    var primitive = !isObject(value);\n\t    if (trackByKey || key || primitive) {\n\t      var id = trackByKey ? trackByKey === '$index' ? index : getPath(value, trackByKey) : key || value;\n\t      this.cache[id] = null;\n\t    } else {\n\t      value[this.id] = null;\n\t      frag.raw = null;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Get the stagger amount for an insertion/removal.\n\t   *\n\t   * @param {Fragment} frag\n\t   * @param {Number} index\n\t   * @param {Number} total\n\t   * @param {String} type\n\t   */\n\t\n\t  getStagger: function getStagger(frag, index, total, type) {\n\t    type = type + 'Stagger';\n\t    var trans = frag.node.__v_trans;\n\t    var hooks = trans && trans.hooks;\n\t    var hook = hooks && (hooks[type] || hooks.stagger);\n\t    return hook ? hook.call(frag, index, total) : index * parseInt(this.params[type] || this.params.stagger, 10);\n\t  },\n\t\n\t  /**\n\t   * Pre-process the value before piping it through the\n\t   * filters. This is passed to and called by the watcher.\n\t   */\n\t\n\t  _preProcess: function _preProcess(value) {\n\t    // regardless of type, store the un-filtered raw value.\n\t    this.rawValue = value;\n\t    return value;\n\t  },\n\t\n\t  /**\n\t   * Post-process the value after it has been piped through\n\t   * the filters. This is passed to and called by the watcher.\n\t   *\n\t   * It is necessary for this to be called during the\n\t   * wathcer's dependency collection phase because we want\n\t   * the v-for to update when the source Object is mutated.\n\t   */\n\t\n\t  _postProcess: function _postProcess(value) {\n\t    if (isArray(value)) {\n\t      return value;\n\t    } else if (isPlainObject(value)) {\n\t      // convert plain object to array.\n\t      var keys = Object.keys(value);\n\t      var i = keys.length;\n\t      var res = new Array(i);\n\t      var key;\n\t      while (i--) {\n\t        key = keys[i];\n\t        res[i] = {\n\t          $key: key,\n\t          $value: value[key]\n\t        };\n\t      }\n\t      return res;\n\t    } else {\n\t      if (typeof value === 'number' && !isNaN(value)) {\n\t        value = range(value);\n\t      }\n\t      return value || [];\n\t    }\n\t  },\n\t\n\t  unbind: function unbind() {\n\t    if (this.descriptor.ref) {\n\t      (this._scope || this.vm).$refs[this.descriptor.ref] = null;\n\t    }\n\t    if (this.frags) {\n\t      var i = this.frags.length;\n\t      var frag;\n\t      while (i--) {\n\t        frag = this.frags[i];\n\t        this.deleteCachedFrag(frag);\n\t        frag.destroy();\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Helper to find the previous element that is a fragment\n\t * anchor. This is necessary because a destroyed frag's\n\t * element could still be lingering in the DOM before its\n\t * leaving transition finishes, but its inserted flag\n\t * should have been set to false so we can skip them.\n\t *\n\t * If this is a block repeat, we want to make sure we only\n\t * return frag that is bound to this v-for. (see #929)\n\t *\n\t * @param {Fragment} frag\n\t * @param {Comment|Text} anchor\n\t * @param {String} id\n\t * @return {Fragment}\n\t */\n\t\n\tfunction findPrevFrag(frag, anchor, id) {\n\t  var el = frag.node.previousSibling;\n\t  /* istanbul ignore if */\n\t  if (!el) return;\n\t  frag = el.__v_frag;\n\t  while ((!frag || frag.forId !== id || !frag.inserted) && el !== anchor) {\n\t    el = el.previousSibling;\n\t    /* istanbul ignore if */\n\t    if (!el) return;\n\t    frag = el.__v_frag;\n\t  }\n\t  return frag;\n\t}\n\t\n\t/**\n\t * Find a vm from a fragment.\n\t *\n\t * @param {Fragment} frag\n\t * @return {Vue|undefined}\n\t */\n\t\n\tfunction findVmFromFrag(frag) {\n\t  var node = frag.node;\n\t  // handle multi-node frag\n\t  if (frag.end) {\n\t    while (!node.__vue__ && node !== frag.end && node.nextSibling) {\n\t      node = node.nextSibling;\n\t    }\n\t  }\n\t  return node.__vue__;\n\t}\n\t\n\t/**\n\t * Create a range array from given number.\n\t *\n\t * @param {Number} n\n\t * @return {Array}\n\t */\n\t\n\tfunction range(n) {\n\t  var i = -1;\n\t  var ret = new Array(Math.floor(n));\n\t  while (++i < n) {\n\t    ret[i] = i;\n\t  }\n\t  return ret;\n\t}\n\t\n\tif (false) {\n\t  vFor.warnDuplicate = function (value) {\n\t    warn('Duplicate value found in v-for=\"' + this.descriptor.raw + '\": ' + JSON.stringify(value) + '. Use track-by=\"$index\" if ' + 'you are expecting duplicate values.', this.vm);\n\t  };\n\t}\n\t\n\tvar vIf = {\n\t\n\t  priority: IF,\n\t  terminal: true,\n\t\n\t  bind: function bind() {\n\t    var el = this.el;\n\t    if (!el.__vue__) {\n\t      // check else block\n\t      var next = el.nextElementSibling;\n\t      if (next && getAttr(next, 'v-else') !== null) {\n\t        remove(next);\n\t        this.elseEl = next;\n\t      }\n\t      // check main block\n\t      this.anchor = createAnchor('v-if');\n\t      replace(el, this.anchor);\n\t    } else {\n\t      (\"production\") !== 'production' && warn('v-if=\"' + this.expression + '\" cannot be ' + 'used on an instance root element.', this.vm);\n\t      this.invalid = true;\n\t    }\n\t  },\n\t\n\t  update: function update(value) {\n\t    if (this.invalid) return;\n\t    if (value) {\n\t      if (!this.frag) {\n\t        this.insert();\n\t      }\n\t    } else {\n\t      this.remove();\n\t    }\n\t  },\n\t\n\t  insert: function insert() {\n\t    if (this.elseFrag) {\n\t      this.elseFrag.remove();\n\t      this.elseFrag = null;\n\t    }\n\t    // lazy init factory\n\t    if (!this.factory) {\n\t      this.factory = new FragmentFactory(this.vm, this.el);\n\t    }\n\t    this.frag = this.factory.create(this._host, this._scope, this._frag);\n\t    this.frag.before(this.anchor);\n\t  },\n\t\n\t  remove: function remove() {\n\t    if (this.frag) {\n\t      this.frag.remove();\n\t      this.frag = null;\n\t    }\n\t    if (this.elseEl && !this.elseFrag) {\n\t      if (!this.elseFactory) {\n\t        this.elseFactory = new FragmentFactory(this.elseEl._context || this.vm, this.elseEl);\n\t      }\n\t      this.elseFrag = this.elseFactory.create(this._host, this._scope, this._frag);\n\t      this.elseFrag.before(this.anchor);\n\t    }\n\t  },\n\t\n\t  unbind: function unbind() {\n\t    if (this.frag) {\n\t      this.frag.destroy();\n\t    }\n\t    if (this.elseFrag) {\n\t      this.elseFrag.destroy();\n\t    }\n\t  }\n\t};\n\t\n\tvar show = {\n\t\n\t  bind: function bind() {\n\t    // check else block\n\t    var next = this.el.nextElementSibling;\n\t    if (next && getAttr(next, 'v-else') !== null) {\n\t      this.elseEl = next;\n\t    }\n\t  },\n\t\n\t  update: function update(value) {\n\t    this.apply(this.el, value);\n\t    if (this.elseEl) {\n\t      this.apply(this.elseEl, !value);\n\t    }\n\t  },\n\t\n\t  apply: function apply(el, value) {\n\t    if (inDoc(el)) {\n\t      applyTransition(el, value ? 1 : -1, toggle, this.vm);\n\t    } else {\n\t      toggle();\n\t    }\n\t    function toggle() {\n\t      el.style.display = value ? '' : 'none';\n\t    }\n\t  }\n\t};\n\t\n\tvar text$2 = {\n\t\n\t  bind: function bind() {\n\t    var self = this;\n\t    var el = this.el;\n\t    var isRange = el.type === 'range';\n\t    var lazy = this.params.lazy;\n\t    var number = this.params.number;\n\t    var debounce = this.params.debounce;\n\t\n\t    // handle composition events.\n\t    //   http://blog.evanyou.me/2014/01/03/composition-event/\n\t    // skip this for Android because it handles composition\n\t    // events quite differently. Android doesn't trigger\n\t    // composition events for language input methods e.g.\n\t    // Chinese, but instead triggers them for spelling\n\t    // suggestions... (see Discussion/#162)\n\t    var composing = false;\n\t    if (!isAndroid && !isRange) {\n\t      this.on('compositionstart', function () {\n\t        composing = true;\n\t      });\n\t      this.on('compositionend', function () {\n\t        composing = false;\n\t        // in IE11 the \"compositionend\" event fires AFTER\n\t        // the \"input\" event, so the input handler is blocked\n\t        // at the end... have to call it here.\n\t        //\n\t        // #1327: in lazy mode this is unecessary.\n\t        if (!lazy) {\n\t          self.listener();\n\t        }\n\t      });\n\t    }\n\t\n\t    // prevent messing with the input when user is typing,\n\t    // and force update on blur.\n\t    this.focused = false;\n\t    if (!isRange && !lazy) {\n\t      this.on('focus', function () {\n\t        self.focused = true;\n\t      });\n\t      this.on('blur', function () {\n\t        self.focused = false;\n\t        // do not sync value after fragment removal (#2017)\n\t        if (!self._frag || self._frag.inserted) {\n\t          self.rawListener();\n\t        }\n\t      });\n\t    }\n\t\n\t    // Now attach the main listener\n\t    this.listener = this.rawListener = function () {\n\t      if (composing || !self._bound) {\n\t        return;\n\t      }\n\t      var val = number || isRange ? toNumber(el.value) : el.value;\n\t      self.set(val);\n\t      // force update on next tick to avoid lock & same value\n\t      // also only update when user is not typing\n\t      nextTick(function () {\n\t        if (self._bound && !self.focused) {\n\t          self.update(self._watcher.value);\n\t        }\n\t      });\n\t    };\n\t\n\t    // apply debounce\n\t    if (debounce) {\n\t      this.listener = _debounce(this.listener, debounce);\n\t    }\n\t\n\t    // Support jQuery events, since jQuery.trigger() doesn't\n\t    // trigger native events in some cases and some plugins\n\t    // rely on $.trigger()\n\t    //\n\t    // We want to make sure if a listener is attached using\n\t    // jQuery, it is also removed with jQuery, that's why\n\t    // we do the check for each directive instance and\n\t    // store that check result on itself. This also allows\n\t    // easier test coverage control by unsetting the global\n\t    // jQuery variable in tests.\n\t    this.hasjQuery = typeof jQuery === 'function';\n\t    if (this.hasjQuery) {\n\t      var method = jQuery.fn.on ? 'on' : 'bind';\n\t      jQuery(el)[method]('change', this.rawListener);\n\t      if (!lazy) {\n\t        jQuery(el)[method]('input', this.listener);\n\t      }\n\t    } else {\n\t      this.on('change', this.rawListener);\n\t      if (!lazy) {\n\t        this.on('input', this.listener);\n\t      }\n\t    }\n\t\n\t    // IE9 doesn't fire input event on backspace/del/cut\n\t    if (!lazy && isIE9) {\n\t      this.on('cut', function () {\n\t        nextTick(self.listener);\n\t      });\n\t      this.on('keyup', function (e) {\n\t        if (e.keyCode === 46 || e.keyCode === 8) {\n\t          self.listener();\n\t        }\n\t      });\n\t    }\n\t\n\t    // set initial value if present\n\t    if (el.hasAttribute('value') || el.tagName === 'TEXTAREA' && el.value.trim()) {\n\t      this.afterBind = this.listener;\n\t    }\n\t  },\n\t\n\t  update: function update(value) {\n\t    this.el.value = _toString(value);\n\t  },\n\t\n\t  unbind: function unbind() {\n\t    var el = this.el;\n\t    if (this.hasjQuery) {\n\t      var method = jQuery.fn.off ? 'off' : 'unbind';\n\t      jQuery(el)[method]('change', this.listener);\n\t      jQuery(el)[method]('input', this.listener);\n\t    }\n\t  }\n\t};\n\t\n\tvar radio = {\n\t\n\t  bind: function bind() {\n\t    var self = this;\n\t    var el = this.el;\n\t\n\t    this.getValue = function () {\n\t      // value overwrite via v-bind:value\n\t      if (el.hasOwnProperty('_value')) {\n\t        return el._value;\n\t      }\n\t      var val = el.value;\n\t      if (self.params.number) {\n\t        val = toNumber(val);\n\t      }\n\t      return val;\n\t    };\n\t\n\t    this.listener = function () {\n\t      self.set(self.getValue());\n\t    };\n\t    this.on('change', this.listener);\n\t\n\t    if (el.hasAttribute('checked')) {\n\t      this.afterBind = this.listener;\n\t    }\n\t  },\n\t\n\t  update: function update(value) {\n\t    this.el.checked = looseEqual(value, this.getValue());\n\t  }\n\t};\n\t\n\tvar select = {\n\t\n\t  bind: function bind() {\n\t    var self = this;\n\t    var el = this.el;\n\t\n\t    // method to force update DOM using latest value.\n\t    this.forceUpdate = function () {\n\t      if (self._watcher) {\n\t        self.update(self._watcher.get());\n\t      }\n\t    };\n\t\n\t    // check if this is a multiple select\n\t    var multiple = this.multiple = el.hasAttribute('multiple');\n\t\n\t    // attach listener\n\t    this.listener = function () {\n\t      var value = getValue(el, multiple);\n\t      value = self.params.number ? isArray(value) ? value.map(toNumber) : toNumber(value) : value;\n\t      self.set(value);\n\t    };\n\t    this.on('change', this.listener);\n\t\n\t    // if has initial value, set afterBind\n\t    var initValue = getValue(el, multiple, true);\n\t    if (multiple && initValue.length || !multiple && initValue !== null) {\n\t      this.afterBind = this.listener;\n\t    }\n\t\n\t    // All major browsers except Firefox resets\n\t    // selectedIndex with value -1 to 0 when the element\n\t    // is appended to a new parent, therefore we have to\n\t    // force a DOM update whenever that happens...\n\t    this.vm.$on('hook:attached', this.forceUpdate);\n\t  },\n\t\n\t  update: function update(value) {\n\t    var el = this.el;\n\t    el.selectedIndex = -1;\n\t    var multi = this.multiple && isArray(value);\n\t    var options = el.options;\n\t    var i = options.length;\n\t    var op, val;\n\t    while (i--) {\n\t      op = options[i];\n\t      val = op.hasOwnProperty('_value') ? op._value : op.value;\n\t      /* eslint-disable eqeqeq */\n\t      op.selected = multi ? indexOf$1(value, val) > -1 : looseEqual(value, val);\n\t      /* eslint-enable eqeqeq */\n\t    }\n\t  },\n\t\n\t  unbind: function unbind() {\n\t    /* istanbul ignore next */\n\t    this.vm.$off('hook:attached', this.forceUpdate);\n\t  }\n\t};\n\t\n\t/**\n\t * Get select value\n\t *\n\t * @param {SelectElement} el\n\t * @param {Boolean} multi\n\t * @param {Boolean} init\n\t * @return {Array|*}\n\t */\n\t\n\tfunction getValue(el, multi, init) {\n\t  var res = multi ? [] : null;\n\t  var op, val, selected;\n\t  for (var i = 0, l = el.options.length; i < l; i++) {\n\t    op = el.options[i];\n\t    selected = init ? op.hasAttribute('selected') : op.selected;\n\t    if (selected) {\n\t      val = op.hasOwnProperty('_value') ? op._value : op.value;\n\t      if (multi) {\n\t        res.push(val);\n\t      } else {\n\t        return val;\n\t      }\n\t    }\n\t  }\n\t  return res;\n\t}\n\t\n\t/**\n\t * Native Array.indexOf uses strict equal, but in this\n\t * case we need to match string/numbers with custom equal.\n\t *\n\t * @param {Array} arr\n\t * @param {*} val\n\t */\n\t\n\tfunction indexOf$1(arr, val) {\n\t  var i = arr.length;\n\t  while (i--) {\n\t    if (looseEqual(arr[i], val)) {\n\t      return i;\n\t    }\n\t  }\n\t  return -1;\n\t}\n\t\n\tvar checkbox = {\n\t\n\t  bind: function bind() {\n\t    var self = this;\n\t    var el = this.el;\n\t\n\t    this.getValue = function () {\n\t      return el.hasOwnProperty('_value') ? el._value : self.params.number ? toNumber(el.value) : el.value;\n\t    };\n\t\n\t    function getBooleanValue() {\n\t      var val = el.checked;\n\t      if (val && el.hasOwnProperty('_trueValue')) {\n\t        return el._trueValue;\n\t      }\n\t      if (!val && el.hasOwnProperty('_falseValue')) {\n\t        return el._falseValue;\n\t      }\n\t      return val;\n\t    }\n\t\n\t    this.listener = function () {\n\t      var model = self._watcher.value;\n\t      if (isArray(model)) {\n\t        var val = self.getValue();\n\t        if (el.checked) {\n\t          if (indexOf(model, val) < 0) {\n\t            model.push(val);\n\t          }\n\t        } else {\n\t          model.$remove(val);\n\t        }\n\t      } else {\n\t        self.set(getBooleanValue());\n\t      }\n\t    };\n\t\n\t    this.on('change', this.listener);\n\t    if (el.hasAttribute('checked')) {\n\t      this.afterBind = this.listener;\n\t    }\n\t  },\n\t\n\t  update: function update(value) {\n\t    var el = this.el;\n\t    if (isArray(value)) {\n\t      el.checked = indexOf(value, this.getValue()) > -1;\n\t    } else {\n\t      if (el.hasOwnProperty('_trueValue')) {\n\t        el.checked = looseEqual(value, el._trueValue);\n\t      } else {\n\t        el.checked = !!value;\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\tvar handlers = {\n\t  text: text$2,\n\t  radio: radio,\n\t  select: select,\n\t  checkbox: checkbox\n\t};\n\t\n\tvar model = {\n\t\n\t  priority: MODEL,\n\t  twoWay: true,\n\t  handlers: handlers,\n\t  params: ['lazy', 'number', 'debounce'],\n\t\n\t  /**\n\t   * Possible elements:\n\t   *   <select>\n\t   *   <textarea>\n\t   *   <input type=\"*\">\n\t   *     - text\n\t   *     - checkbox\n\t   *     - radio\n\t   *     - number\n\t   */\n\t\n\t  bind: function bind() {\n\t    // friendly warning...\n\t    this.checkFilters();\n\t    if (this.hasRead && !this.hasWrite) {\n\t      (\"production\") !== 'production' && warn('It seems you are using a read-only filter with ' + 'v-model=\"' + this.descriptor.raw + '\". ' + 'You might want to use a two-way filter to ensure correct behavior.', this.vm);\n\t    }\n\t    var el = this.el;\n\t    var tag = el.tagName;\n\t    var handler;\n\t    if (tag === 'INPUT') {\n\t      handler = handlers[el.type] || handlers.text;\n\t    } else if (tag === 'SELECT') {\n\t      handler = handlers.select;\n\t    } else if (tag === 'TEXTAREA') {\n\t      handler = handlers.text;\n\t    } else {\n\t      (\"production\") !== 'production' && warn('v-model does not support element type: ' + tag, this.vm);\n\t      return;\n\t    }\n\t    el.__v_model = this;\n\t    handler.bind.call(this);\n\t    this.update = handler.update;\n\t    this._unbind = handler.unbind;\n\t  },\n\t\n\t  /**\n\t   * Check read/write filter stats.\n\t   */\n\t\n\t  checkFilters: function checkFilters() {\n\t    var filters = this.filters;\n\t    if (!filters) return;\n\t    var i = filters.length;\n\t    while (i--) {\n\t      var filter = resolveAsset(this.vm.$options, 'filters', filters[i].name);\n\t      if (typeof filter === 'function' || filter.read) {\n\t        this.hasRead = true;\n\t      }\n\t      if (filter.write) {\n\t        this.hasWrite = true;\n\t      }\n\t    }\n\t  },\n\t\n\t  unbind: function unbind() {\n\t    this.el.__v_model = null;\n\t    this._unbind && this._unbind();\n\t  }\n\t};\n\t\n\t// keyCode aliases\n\tvar keyCodes = {\n\t  esc: 27,\n\t  tab: 9,\n\t  enter: 13,\n\t  space: 32,\n\t  'delete': [8, 46],\n\t  up: 38,\n\t  left: 37,\n\t  right: 39,\n\t  down: 40\n\t};\n\t\n\tfunction keyFilter(handler, keys) {\n\t  var codes = keys.map(function (key) {\n\t    var charCode = key.charCodeAt(0);\n\t    if (charCode > 47 && charCode < 58) {\n\t      return parseInt(key, 10);\n\t    }\n\t    if (key.length === 1) {\n\t      charCode = key.toUpperCase().charCodeAt(0);\n\t      if (charCode > 64 && charCode < 91) {\n\t        return charCode;\n\t      }\n\t    }\n\t    return keyCodes[key];\n\t  });\n\t  codes = [].concat.apply([], codes);\n\t  return function keyHandler(e) {\n\t    if (codes.indexOf(e.keyCode) > -1) {\n\t      return handler.call(this, e);\n\t    }\n\t  };\n\t}\n\t\n\tfunction stopFilter(handler) {\n\t  return function stopHandler(e) {\n\t    e.stopPropagation();\n\t    return handler.call(this, e);\n\t  };\n\t}\n\t\n\tfunction preventFilter(handler) {\n\t  return function preventHandler(e) {\n\t    e.preventDefault();\n\t    return handler.call(this, e);\n\t  };\n\t}\n\t\n\tfunction selfFilter(handler) {\n\t  return function selfHandler(e) {\n\t    if (e.target === e.currentTarget) {\n\t      return handler.call(this, e);\n\t    }\n\t  };\n\t}\n\t\n\tvar on$1 = {\n\t\n\t  priority: ON,\n\t  acceptStatement: true,\n\t  keyCodes: keyCodes,\n\t\n\t  bind: function bind() {\n\t    // deal with iframes\n\t    if (this.el.tagName === 'IFRAME' && this.arg !== 'load') {\n\t      var self = this;\n\t      this.iframeBind = function () {\n\t        on(self.el.contentWindow, self.arg, self.handler, self.modifiers.capture);\n\t      };\n\t      this.on('load', this.iframeBind);\n\t    }\n\t  },\n\t\n\t  update: function update(handler) {\n\t    // stub a noop for v-on with no value,\n\t    // e.g. @mousedown.prevent\n\t    if (!this.descriptor.raw) {\n\t      handler = function () {};\n\t    }\n\t\n\t    if (typeof handler !== 'function') {\n\t      (\"production\") !== 'production' && warn('v-on:' + this.arg + '=\"' + this.expression + '\" expects a function value, ' + 'got ' + handler, this.vm);\n\t      return;\n\t    }\n\t\n\t    // apply modifiers\n\t    if (this.modifiers.stop) {\n\t      handler = stopFilter(handler);\n\t    }\n\t    if (this.modifiers.prevent) {\n\t      handler = preventFilter(handler);\n\t    }\n\t    if (this.modifiers.self) {\n\t      handler = selfFilter(handler);\n\t    }\n\t    // key filter\n\t    var keys = Object.keys(this.modifiers).filter(function (key) {\n\t      return key !== 'stop' && key !== 'prevent' && key !== 'self';\n\t    });\n\t    if (keys.length) {\n\t      handler = keyFilter(handler, keys);\n\t    }\n\t\n\t    this.reset();\n\t    this.handler = handler;\n\t\n\t    if (this.iframeBind) {\n\t      this.iframeBind();\n\t    } else {\n\t      on(this.el, this.arg, this.handler, this.modifiers.capture);\n\t    }\n\t  },\n\t\n\t  reset: function reset() {\n\t    var el = this.iframeBind ? this.el.contentWindow : this.el;\n\t    if (this.handler) {\n\t      off(el, this.arg, this.handler);\n\t    }\n\t  },\n\t\n\t  unbind: function unbind() {\n\t    this.reset();\n\t  }\n\t};\n\t\n\tvar prefixes = ['-webkit-', '-moz-', '-ms-'];\n\tvar camelPrefixes = ['Webkit', 'Moz', 'ms'];\n\tvar importantRE = /!important;?$/;\n\tvar propCache = Object.create(null);\n\t\n\tvar testEl = null;\n\t\n\tvar style = {\n\t\n\t  deep: true,\n\t\n\t  update: function update(value) {\n\t    if (typeof value === 'string') {\n\t      this.el.style.cssText = value;\n\t    } else if (isArray(value)) {\n\t      this.handleObject(value.reduce(extend, {}));\n\t    } else {\n\t      this.handleObject(value || {});\n\t    }\n\t  },\n\t\n\t  handleObject: function handleObject(value) {\n\t    // cache object styles so that only changed props\n\t    // are actually updated.\n\t    var cache = this.cache || (this.cache = {});\n\t    var name, val;\n\t    for (name in cache) {\n\t      if (!(name in value)) {\n\t        this.handleSingle(name, null);\n\t        delete cache[name];\n\t      }\n\t    }\n\t    for (name in value) {\n\t      val = value[name];\n\t      if (val !== cache[name]) {\n\t        cache[name] = val;\n\t        this.handleSingle(name, val);\n\t      }\n\t    }\n\t  },\n\t\n\t  handleSingle: function handleSingle(prop, value) {\n\t    prop = normalize(prop);\n\t    if (!prop) return; // unsupported prop\n\t    // cast possible numbers/booleans into strings\n\t    if (value != null) value += '';\n\t    if (value) {\n\t      var isImportant = importantRE.test(value) ? 'important' : '';\n\t      if (isImportant) {\n\t        /* istanbul ignore if */\n\t        if (false) {\n\t          warn('It\\'s probably a bad idea to use !important with inline rules. ' + 'This feature will be deprecated in a future version of Vue.');\n\t        }\n\t        value = value.replace(importantRE, '').trim();\n\t        this.el.style.setProperty(prop.kebab, value, isImportant);\n\t      } else {\n\t        this.el.style[prop.camel] = value;\n\t      }\n\t    } else {\n\t      this.el.style[prop.camel] = '';\n\t    }\n\t  }\n\t\n\t};\n\t\n\t/**\n\t * Normalize a CSS property name.\n\t * - cache result\n\t * - auto prefix\n\t * - camelCase -> dash-case\n\t *\n\t * @param {String} prop\n\t * @return {String}\n\t */\n\t\n\tfunction normalize(prop) {\n\t  if (propCache[prop]) {\n\t    return propCache[prop];\n\t  }\n\t  var res = prefix(prop);\n\t  propCache[prop] = propCache[res] = res;\n\t  return res;\n\t}\n\t\n\t/**\n\t * Auto detect the appropriate prefix for a CSS property.\n\t * https://gist.github.com/paulirish/523692\n\t *\n\t * @param {String} prop\n\t * @return {String}\n\t */\n\t\n\tfunction prefix(prop) {\n\t  prop = hyphenate(prop);\n\t  var camel = camelize(prop);\n\t  var upper = camel.charAt(0).toUpperCase() + camel.slice(1);\n\t  if (!testEl) {\n\t    testEl = document.createElement('div');\n\t  }\n\t  var i = prefixes.length;\n\t  var prefixed;\n\t  while (i--) {\n\t    prefixed = camelPrefixes[i] + upper;\n\t    if (prefixed in testEl.style) {\n\t      return {\n\t        kebab: prefixes[i] + prop,\n\t        camel: prefixed\n\t      };\n\t    }\n\t  }\n\t  if (camel in testEl.style) {\n\t    return {\n\t      kebab: prop,\n\t      camel: camel\n\t    };\n\t  }\n\t}\n\t\n\t// xlink\n\tvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\tvar xlinkRE = /^xlink:/;\n\t\n\t// check for attributes that prohibit interpolations\n\tvar disallowedInterpAttrRE = /^v-|^:|^@|^(?:is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/;\n\t// these attributes should also set their corresponding properties\n\t// because they only affect the initial state of the element\n\tvar attrWithPropsRE = /^(?:value|checked|selected|muted)$/;\n\t// these attributes expect enumrated values of \"true\" or \"false\"\n\t// but are not boolean attributes\n\tvar enumeratedAttrRE = /^(?:draggable|contenteditable|spellcheck)$/;\n\t\n\t// these attributes should set a hidden property for\n\t// binding v-model to object values\n\tvar modelProps = {\n\t  value: '_value',\n\t  'true-value': '_trueValue',\n\t  'false-value': '_falseValue'\n\t};\n\t\n\tvar bind$1 = {\n\t\n\t  priority: BIND,\n\t\n\t  bind: function bind() {\n\t    var attr = this.arg;\n\t    var tag = this.el.tagName;\n\t    // should be deep watch on object mode\n\t    if (!attr) {\n\t      this.deep = true;\n\t    }\n\t    // handle interpolation bindings\n\t    var descriptor = this.descriptor;\n\t    var tokens = descriptor.interp;\n\t    if (tokens) {\n\t      // handle interpolations with one-time tokens\n\t      if (descriptor.hasOneTime) {\n\t        this.expression = tokensToExp(tokens, this._scope || this.vm);\n\t      }\n\t\n\t      // only allow binding on native attributes\n\t      if (disallowedInterpAttrRE.test(attr) || attr === 'name' && (tag === 'PARTIAL' || tag === 'SLOT')) {\n\t        (\"production\") !== 'production' && warn(attr + '=\"' + descriptor.raw + '\": ' + 'attribute interpolation is not allowed in Vue.js ' + 'directives and special attributes.', this.vm);\n\t        this.el.removeAttribute(attr);\n\t        this.invalid = true;\n\t      }\n\t\n\t      /* istanbul ignore if */\n\t      if (false) {\n\t        var raw = attr + '=\"' + descriptor.raw + '\": ';\n\t        // warn src\n\t        if (attr === 'src') {\n\t          warn(raw + 'interpolation in \"src\" attribute will cause ' + 'a 404 request. Use v-bind:src instead.', this.vm);\n\t        }\n\t\n\t        // warn style\n\t        if (attr === 'style') {\n\t          warn(raw + 'interpolation in \"style\" attribute will cause ' + 'the attribute to be discarded in Internet Explorer. ' + 'Use v-bind:style instead.', this.vm);\n\t        }\n\t      }\n\t    }\n\t  },\n\t\n\t  update: function update(value) {\n\t    if (this.invalid) {\n\t      return;\n\t    }\n\t    var attr = this.arg;\n\t    if (this.arg) {\n\t      this.handleSingle(attr, value);\n\t    } else {\n\t      this.handleObject(value || {});\n\t    }\n\t  },\n\t\n\t  // share object handler with v-bind:class\n\t  handleObject: style.handleObject,\n\t\n\t  handleSingle: function handleSingle(attr, value) {\n\t    var el = this.el;\n\t    var interp = this.descriptor.interp;\n\t    if (this.modifiers.camel) {\n\t      attr = camelize(attr);\n\t    }\n\t    if (!interp && attrWithPropsRE.test(attr) && attr in el) {\n\t      el[attr] = attr === 'value' ? value == null // IE9 will set input.value to \"null\" for null...\n\t      ? '' : value : value;\n\t    }\n\t    // set model props\n\t    var modelProp = modelProps[attr];\n\t    if (!interp && modelProp) {\n\t      el[modelProp] = value;\n\t      // update v-model if present\n\t      var model = el.__v_model;\n\t      if (model) {\n\t        model.listener();\n\t      }\n\t    }\n\t    // do not set value attribute for textarea\n\t    if (attr === 'value' && el.tagName === 'TEXTAREA') {\n\t      el.removeAttribute(attr);\n\t      return;\n\t    }\n\t    // update attribute\n\t    if (enumeratedAttrRE.test(attr)) {\n\t      el.setAttribute(attr, value ? 'true' : 'false');\n\t    } else if (value != null && value !== false) {\n\t      if (attr === 'class') {\n\t        // handle edge case #1960:\n\t        // class interpolation should not overwrite Vue transition class\n\t        if (el.__v_trans) {\n\t          value += ' ' + el.__v_trans.id + '-transition';\n\t        }\n\t        setClass(el, value);\n\t      } else if (xlinkRE.test(attr)) {\n\t        el.setAttributeNS(xlinkNS, attr, value === true ? '' : value);\n\t      } else {\n\t        el.setAttribute(attr, value === true ? '' : value);\n\t      }\n\t    } else {\n\t      el.removeAttribute(attr);\n\t    }\n\t  }\n\t};\n\t\n\tvar el = {\n\t\n\t  priority: EL,\n\t\n\t  bind: function bind() {\n\t    /* istanbul ignore if */\n\t    if (!this.arg) {\n\t      return;\n\t    }\n\t    var id = this.id = camelize(this.arg);\n\t    var refs = (this._scope || this.vm).$els;\n\t    if (hasOwn(refs, id)) {\n\t      refs[id] = this.el;\n\t    } else {\n\t      defineReactive(refs, id, this.el);\n\t    }\n\t  },\n\t\n\t  unbind: function unbind() {\n\t    var refs = (this._scope || this.vm).$els;\n\t    if (refs[this.id] === this.el) {\n\t      refs[this.id] = null;\n\t    }\n\t  }\n\t};\n\t\n\tvar ref = {\n\t  bind: function bind() {\n\t    (\"production\") !== 'production' && warn('v-ref:' + this.arg + ' must be used on a child ' + 'component. Found on <' + this.el.tagName.toLowerCase() + '>.', this.vm);\n\t  }\n\t};\n\t\n\tvar cloak = {\n\t  bind: function bind() {\n\t    var el = this.el;\n\t    this.vm.$once('pre-hook:compiled', function () {\n\t      el.removeAttribute('v-cloak');\n\t    });\n\t  }\n\t};\n\t\n\t// must export plain object\n\tvar directives = {\n\t  text: text$1,\n\t  html: html,\n\t  'for': vFor,\n\t  'if': vIf,\n\t  show: show,\n\t  model: model,\n\t  on: on$1,\n\t  bind: bind$1,\n\t  el: el,\n\t  ref: ref,\n\t  cloak: cloak\n\t};\n\t\n\tvar vClass = {\n\t\n\t  deep: true,\n\t\n\t  update: function update(value) {\n\t    if (value && typeof value === 'string') {\n\t      this.handleObject(stringToObject(value));\n\t    } else if (isPlainObject(value)) {\n\t      this.handleObject(value);\n\t    } else if (isArray(value)) {\n\t      this.handleArray(value);\n\t    } else {\n\t      this.cleanup();\n\t    }\n\t  },\n\t\n\t  handleObject: function handleObject(value) {\n\t    this.cleanup(value);\n\t    this.prevKeys = Object.keys(value);\n\t    setObjectClasses(this.el, value);\n\t  },\n\t\n\t  handleArray: function handleArray(value) {\n\t    this.cleanup(value);\n\t    for (var i = 0, l = value.length; i < l; i++) {\n\t      var val = value[i];\n\t      if (val && isPlainObject(val)) {\n\t        setObjectClasses(this.el, val);\n\t      } else if (val && typeof val === 'string') {\n\t        addClass(this.el, val);\n\t      }\n\t    }\n\t    this.prevKeys = value.slice();\n\t  },\n\t\n\t  cleanup: function cleanup(value) {\n\t    if (!this.prevKeys) return;\n\t\n\t    var i = this.prevKeys.length;\n\t    while (i--) {\n\t      var key = this.prevKeys[i];\n\t      if (!key) continue;\n\t\n\t      var keys = isPlainObject(key) ? Object.keys(key) : [key];\n\t      for (var j = 0, l = keys.length; j < l; j++) {\n\t        toggleClasses(this.el, keys[j], removeClass);\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\tfunction setObjectClasses(el, obj) {\n\t  var keys = Object.keys(obj);\n\t  for (var i = 0, l = keys.length; i < l; i++) {\n\t    var key = keys[i];\n\t    if (!obj[key]) continue;\n\t    toggleClasses(el, key, addClass);\n\t  }\n\t}\n\t\n\tfunction stringToObject(value) {\n\t  var res = {};\n\t  var keys = value.trim().split(/\\s+/);\n\t  for (var i = 0, l = keys.length; i < l; i++) {\n\t    res[keys[i]] = true;\n\t  }\n\t  return res;\n\t}\n\t\n\t/**\n\t * Add or remove a class/classes on an element\n\t *\n\t * @param {Element} el\n\t * @param {String} key The class name. This may or may not\n\t *                     contain a space character, in such a\n\t *                     case we'll deal with multiple class\n\t *                     names at once.\n\t * @param {Function} fn\n\t */\n\t\n\tfunction toggleClasses(el, key, fn) {\n\t  key = key.trim();\n\t\n\t  if (key.indexOf(' ') === -1) {\n\t    fn(el, key);\n\t    return;\n\t  }\n\t\n\t  // The key contains one or more space characters.\n\t  // Since a class name doesn't accept such characters, we\n\t  // treat it as multiple classes.\n\t  var keys = key.split(/\\s+/);\n\t  for (var i = 0, l = keys.length; i < l; i++) {\n\t    fn(el, keys[i]);\n\t  }\n\t}\n\t\n\tvar component = {\n\t\n\t  priority: COMPONENT,\n\t\n\t  params: ['keep-alive', 'transition-mode', 'inline-template'],\n\t\n\t  /**\n\t   * Setup. Two possible usages:\n\t   *\n\t   * - static:\n\t   *   <comp> or <div v-component=\"comp\">\n\t   *\n\t   * - dynamic:\n\t   *   <component :is=\"view\">\n\t   */\n\t\n\t  bind: function bind() {\n\t    if (!this.el.__vue__) {\n\t      // keep-alive cache\n\t      this.keepAlive = this.params.keepAlive;\n\t      if (this.keepAlive) {\n\t        this.cache = {};\n\t      }\n\t      // check inline-template\n\t      if (this.params.inlineTemplate) {\n\t        // extract inline template as a DocumentFragment\n\t        this.inlineTemplate = extractContent(this.el, true);\n\t      }\n\t      // component resolution related state\n\t      this.pendingComponentCb = this.Component = null;\n\t      // transition related state\n\t      this.pendingRemovals = 0;\n\t      this.pendingRemovalCb = null;\n\t      // create a ref anchor\n\t      this.anchor = createAnchor('v-component');\n\t      replace(this.el, this.anchor);\n\t      // remove is attribute.\n\t      // this is removed during compilation, but because compilation is\n\t      // cached, when the component is used elsewhere this attribute\n\t      // will remain at link time.\n\t      this.el.removeAttribute('is');\n\t      // remove ref, same as above\n\t      if (this.descriptor.ref) {\n\t        this.el.removeAttribute('v-ref:' + hyphenate(this.descriptor.ref));\n\t      }\n\t      // if static, build right now.\n\t      if (this.literal) {\n\t        this.setComponent(this.expression);\n\t      }\n\t    } else {\n\t      (\"production\") !== 'production' && warn('cannot mount component \"' + this.expression + '\" ' + 'on already mounted element: ' + this.el);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Public update, called by the watcher in the dynamic\n\t   * literal scenario, e.g. <component :is=\"view\">\n\t   */\n\t\n\t  update: function update(value) {\n\t    if (!this.literal) {\n\t      this.setComponent(value);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Switch dynamic components. May resolve the component\n\t   * asynchronously, and perform transition based on\n\t   * specified transition mode. Accepts a few additional\n\t   * arguments specifically for vue-router.\n\t   *\n\t   * The callback is called when the full transition is\n\t   * finished.\n\t   *\n\t   * @param {String} value\n\t   * @param {Function} [cb]\n\t   */\n\t\n\t  setComponent: function setComponent(value, cb) {\n\t    this.invalidatePending();\n\t    if (!value) {\n\t      // just remove current\n\t      this.unbuild(true);\n\t      this.remove(this.childVM, cb);\n\t      this.childVM = null;\n\t    } else {\n\t      var self = this;\n\t      this.resolveComponent(value, function () {\n\t        self.mountComponent(cb);\n\t      });\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Resolve the component constructor to use when creating\n\t   * the child vm.\n\t   *\n\t   * @param {String|Function} value\n\t   * @param {Function} cb\n\t   */\n\t\n\t  resolveComponent: function resolveComponent(value, cb) {\n\t    var self = this;\n\t    this.pendingComponentCb = cancellable(function (Component) {\n\t      self.ComponentName = Component.options.name || (typeof value === 'string' ? value : null);\n\t      self.Component = Component;\n\t      cb();\n\t    });\n\t    this.vm._resolveComponent(value, this.pendingComponentCb);\n\t  },\n\t\n\t  /**\n\t   * Create a new instance using the current constructor and\n\t   * replace the existing instance. This method doesn't care\n\t   * whether the new component and the old one are actually\n\t   * the same.\n\t   *\n\t   * @param {Function} [cb]\n\t   */\n\t\n\t  mountComponent: function mountComponent(cb) {\n\t    // actual mount\n\t    this.unbuild(true);\n\t    var self = this;\n\t    var activateHooks = this.Component.options.activate;\n\t    var cached = this.getCached();\n\t    var newComponent = this.build();\n\t    if (activateHooks && !cached) {\n\t      this.waitingFor = newComponent;\n\t      callActivateHooks(activateHooks, newComponent, function () {\n\t        if (self.waitingFor !== newComponent) {\n\t          return;\n\t        }\n\t        self.waitingFor = null;\n\t        self.transition(newComponent, cb);\n\t      });\n\t    } else {\n\t      // update ref for kept-alive component\n\t      if (cached) {\n\t        newComponent._updateRef();\n\t      }\n\t      this.transition(newComponent, cb);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * When the component changes or unbinds before an async\n\t   * constructor is resolved, we need to invalidate its\n\t   * pending callback.\n\t   */\n\t\n\t  invalidatePending: function invalidatePending() {\n\t    if (this.pendingComponentCb) {\n\t      this.pendingComponentCb.cancel();\n\t      this.pendingComponentCb = null;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Instantiate/insert a new child vm.\n\t   * If keep alive and has cached instance, insert that\n\t   * instance; otherwise build a new one and cache it.\n\t   *\n\t   * @param {Object} [extraOptions]\n\t   * @return {Vue} - the created instance\n\t   */\n\t\n\t  build: function build(extraOptions) {\n\t    var cached = this.getCached();\n\t    if (cached) {\n\t      return cached;\n\t    }\n\t    if (this.Component) {\n\t      // default options\n\t      var options = {\n\t        name: this.ComponentName,\n\t        el: cloneNode(this.el),\n\t        template: this.inlineTemplate,\n\t        // make sure to add the child with correct parent\n\t        // if this is a transcluded component, its parent\n\t        // should be the transclusion host.\n\t        parent: this._host || this.vm,\n\t        // if no inline-template, then the compiled\n\t        // linker can be cached for better performance.\n\t        _linkerCachable: !this.inlineTemplate,\n\t        _ref: this.descriptor.ref,\n\t        _asComponent: true,\n\t        _isRouterView: this._isRouterView,\n\t        // if this is a transcluded component, context\n\t        // will be the common parent vm of this instance\n\t        // and its host.\n\t        _context: this.vm,\n\t        // if this is inside an inline v-for, the scope\n\t        // will be the intermediate scope created for this\n\t        // repeat fragment. this is used for linking props\n\t        // and container directives.\n\t        _scope: this._scope,\n\t        // pass in the owner fragment of this component.\n\t        // this is necessary so that the fragment can keep\n\t        // track of its contained components in order to\n\t        // call attach/detach hooks for them.\n\t        _frag: this._frag\n\t      };\n\t      // extra options\n\t      // in 1.0.0 this is used by vue-router only\n\t      /* istanbul ignore if */\n\t      if (extraOptions) {\n\t        extend(options, extraOptions);\n\t      }\n\t      var child = new this.Component(options);\n\t      if (this.keepAlive) {\n\t        this.cache[this.Component.cid] = child;\n\t      }\n\t      /* istanbul ignore if */\n\t      if (false) {\n\t        warn('Transitions will not work on a fragment instance. ' + 'Template: ' + child.$options.template, child);\n\t      }\n\t      return child;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Try to get a cached instance of the current component.\n\t   *\n\t   * @return {Vue|undefined}\n\t   */\n\t\n\t  getCached: function getCached() {\n\t    return this.keepAlive && this.cache[this.Component.cid];\n\t  },\n\t\n\t  /**\n\t   * Teardown the current child, but defers cleanup so\n\t   * that we can separate the destroy and removal steps.\n\t   *\n\t   * @param {Boolean} defer\n\t   */\n\t\n\t  unbuild: function unbuild(defer) {\n\t    if (this.waitingFor) {\n\t      if (!this.keepAlive) {\n\t        this.waitingFor.$destroy();\n\t      }\n\t      this.waitingFor = null;\n\t    }\n\t    var child = this.childVM;\n\t    if (!child || this.keepAlive) {\n\t      if (child) {\n\t        // remove ref\n\t        child._inactive = true;\n\t        child._updateRef(true);\n\t      }\n\t      return;\n\t    }\n\t    // the sole purpose of `deferCleanup` is so that we can\n\t    // \"deactivate\" the vm right now and perform DOM removal\n\t    // later.\n\t    child.$destroy(false, defer);\n\t  },\n\t\n\t  /**\n\t   * Remove current destroyed child and manually do\n\t   * the cleanup after removal.\n\t   *\n\t   * @param {Function} cb\n\t   */\n\t\n\t  remove: function remove(child, cb) {\n\t    var keepAlive = this.keepAlive;\n\t    if (child) {\n\t      // we may have a component switch when a previous\n\t      // component is still being transitioned out.\n\t      // we want to trigger only one lastest insertion cb\n\t      // when the existing transition finishes. (#1119)\n\t      this.pendingRemovals++;\n\t      this.pendingRemovalCb = cb;\n\t      var self = this;\n\t      child.$remove(function () {\n\t        self.pendingRemovals--;\n\t        if (!keepAlive) child._cleanup();\n\t        if (!self.pendingRemovals && self.pendingRemovalCb) {\n\t          self.pendingRemovalCb();\n\t          self.pendingRemovalCb = null;\n\t        }\n\t      });\n\t    } else if (cb) {\n\t      cb();\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Actually swap the components, depending on the\n\t   * transition mode. Defaults to simultaneous.\n\t   *\n\t   * @param {Vue} target\n\t   * @param {Function} [cb]\n\t   */\n\t\n\t  transition: function transition(target, cb) {\n\t    var self = this;\n\t    var current = this.childVM;\n\t    // for devtool inspection\n\t    if (current) current._inactive = true;\n\t    target._inactive = false;\n\t    this.childVM = target;\n\t    switch (self.params.transitionMode) {\n\t      case 'in-out':\n\t        target.$before(self.anchor, function () {\n\t          self.remove(current, cb);\n\t        });\n\t        break;\n\t      case 'out-in':\n\t        self.remove(current, function () {\n\t          target.$before(self.anchor, cb);\n\t        });\n\t        break;\n\t      default:\n\t        self.remove(current);\n\t        target.$before(self.anchor, cb);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Unbind.\n\t   */\n\t\n\t  unbind: function unbind() {\n\t    this.invalidatePending();\n\t    // Do not defer cleanup when unbinding\n\t    this.unbuild();\n\t    // destroy all keep-alive cached instances\n\t    if (this.cache) {\n\t      for (var key in this.cache) {\n\t        this.cache[key].$destroy();\n\t      }\n\t      this.cache = null;\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Call activate hooks in order (asynchronous)\n\t *\n\t * @param {Array} hooks\n\t * @param {Vue} vm\n\t * @param {Function} cb\n\t */\n\t\n\tfunction callActivateHooks(hooks, vm, cb) {\n\t  var total = hooks.length;\n\t  var called = 0;\n\t  hooks[0].call(vm, next);\n\t  function next() {\n\t    if (++called >= total) {\n\t      cb();\n\t    } else {\n\t      hooks[called].call(vm, next);\n\t    }\n\t  }\n\t}\n\t\n\tvar propBindingModes = config._propBindingModes;\n\tvar empty = {};\n\t\n\t// regexes\n\tvar identRE$1 = /^[$_a-zA-Z]+[\\w$]*$/;\n\tvar settablePathRE = /^[A-Za-z_$][\\w$]*(\\.[A-Za-z_$][\\w$]*|\\[[^\\[\\]]+\\])*$/;\n\t\n\t/**\n\t * Compile props on a root element and return\n\t * a props link function.\n\t *\n\t * @param {Element|DocumentFragment} el\n\t * @param {Array} propOptions\n\t * @param {Vue} vm\n\t * @return {Function} propsLinkFn\n\t */\n\t\n\tfunction compileProps(el, propOptions, vm) {\n\t  var props = [];\n\t  var names = Object.keys(propOptions);\n\t  var i = names.length;\n\t  var options, name, attr, value, path, parsed, prop;\n\t  while (i--) {\n\t    name = names[i];\n\t    options = propOptions[name] || empty;\n\t\n\t    if (false) {\n\t      warn('Do not use $data as prop.', vm);\n\t      continue;\n\t    }\n\t\n\t    // props could contain dashes, which will be\n\t    // interpreted as minus calculations by the parser\n\t    // so we need to camelize the path here\n\t    path = camelize(name);\n\t    if (!identRE$1.test(path)) {\n\t      (\"production\") !== 'production' && warn('Invalid prop key: \"' + name + '\". Prop keys ' + 'must be valid identifiers.', vm);\n\t      continue;\n\t    }\n\t\n\t    prop = {\n\t      name: name,\n\t      path: path,\n\t      options: options,\n\t      mode: propBindingModes.ONE_WAY,\n\t      raw: null\n\t    };\n\t\n\t    attr = hyphenate(name);\n\t    // first check dynamic version\n\t    if ((value = getBindAttr(el, attr)) === null) {\n\t      if ((value = getBindAttr(el, attr + '.sync')) !== null) {\n\t        prop.mode = propBindingModes.TWO_WAY;\n\t      } else if ((value = getBindAttr(el, attr + '.once')) !== null) {\n\t        prop.mode = propBindingModes.ONE_TIME;\n\t      }\n\t    }\n\t    if (value !== null) {\n\t      // has dynamic binding!\n\t      prop.raw = value;\n\t      parsed = parseDirective(value);\n\t      value = parsed.expression;\n\t      prop.filters = parsed.filters;\n\t      // check binding type\n\t      if (isLiteral(value) && !parsed.filters) {\n\t        // for expressions containing literal numbers and\n\t        // booleans, there's no need to setup a prop binding,\n\t        // so we can optimize them as a one-time set.\n\t        prop.optimizedLiteral = true;\n\t      } else {\n\t        prop.dynamic = true;\n\t        // check non-settable path for two-way bindings\n\t        if (false) {\n\t          prop.mode = propBindingModes.ONE_WAY;\n\t          warn('Cannot bind two-way prop with non-settable ' + 'parent path: ' + value, vm);\n\t        }\n\t      }\n\t      prop.parentPath = value;\n\t\n\t      // warn required two-way\n\t      if (false) {\n\t        warn('Prop \"' + name + '\" expects a two-way binding type.', vm);\n\t      }\n\t    } else if ((value = getAttr(el, attr)) !== null) {\n\t      // has literal binding!\n\t      prop.raw = value;\n\t    } else if (false) {\n\t      // check possible camelCase prop usage\n\t      var lowerCaseName = path.toLowerCase();\n\t      value = /[A-Z\\-]/.test(name) && (el.getAttribute(lowerCaseName) || el.getAttribute(':' + lowerCaseName) || el.getAttribute('v-bind:' + lowerCaseName) || el.getAttribute(':' + lowerCaseName + '.once') || el.getAttribute('v-bind:' + lowerCaseName + '.once') || el.getAttribute(':' + lowerCaseName + '.sync') || el.getAttribute('v-bind:' + lowerCaseName + '.sync'));\n\t      if (value) {\n\t        warn('Possible usage error for prop `' + lowerCaseName + '` - ' + 'did you mean `' + attr + '`? HTML is case-insensitive, remember to use ' + 'kebab-case for props in templates.', vm);\n\t      } else if (options.required) {\n\t        // warn missing required\n\t        warn('Missing required prop: ' + name, vm);\n\t      }\n\t    }\n\t    // push prop\n\t    props.push(prop);\n\t  }\n\t  return makePropsLinkFn(props);\n\t}\n\t\n\t/**\n\t * Build a function that applies props to a vm.\n\t *\n\t * @param {Array} props\n\t * @return {Function} propsLinkFn\n\t */\n\t\n\tfunction makePropsLinkFn(props) {\n\t  return function propsLinkFn(vm, scope) {\n\t    // store resolved props info\n\t    vm._props = {};\n\t    var i = props.length;\n\t    var prop, path, options, value, raw;\n\t    while (i--) {\n\t      prop = props[i];\n\t      raw = prop.raw;\n\t      path = prop.path;\n\t      options = prop.options;\n\t      vm._props[path] = prop;\n\t      if (raw === null) {\n\t        // initialize absent prop\n\t        initProp(vm, prop, undefined);\n\t      } else if (prop.dynamic) {\n\t        // dynamic prop\n\t        if (prop.mode === propBindingModes.ONE_TIME) {\n\t          // one time binding\n\t          value = (scope || vm._context || vm).$get(prop.parentPath);\n\t          initProp(vm, prop, value);\n\t        } else {\n\t          if (vm._context) {\n\t            // dynamic binding\n\t            vm._bindDir({\n\t              name: 'prop',\n\t              def: propDef,\n\t              prop: prop\n\t            }, null, null, scope); // el, host, scope\n\t          } else {\n\t              // root instance\n\t              initProp(vm, prop, vm.$get(prop.parentPath));\n\t            }\n\t        }\n\t      } else if (prop.optimizedLiteral) {\n\t        // optimized literal, cast it and just set once\n\t        var stripped = stripQuotes(raw);\n\t        value = stripped === raw ? toBoolean(toNumber(raw)) : stripped;\n\t        initProp(vm, prop, value);\n\t      } else {\n\t        // string literal, but we need to cater for\n\t        // Boolean props with no value, or with same\n\t        // literal value (e.g. disabled=\"disabled\")\n\t        // see https://github.com/vuejs/vue-loader/issues/182\n\t        value = options.type === Boolean && (raw === '' || raw === hyphenate(prop.name)) ? true : raw;\n\t        initProp(vm, prop, value);\n\t      }\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * Process a prop with a rawValue, applying necessary coersions,\n\t * default values & assertions and call the given callback with\n\t * processed value.\n\t *\n\t * @param {Vue} vm\n\t * @param {Object} prop\n\t * @param {*} rawValue\n\t * @param {Function} fn\n\t */\n\t\n\tfunction processPropValue(vm, prop, rawValue, fn) {\n\t  var isSimple = prop.dynamic && isSimplePath(prop.parentPath);\n\t  var value = rawValue;\n\t  if (value === undefined) {\n\t    value = getPropDefaultValue(vm, prop);\n\t  }\n\t  value = coerceProp(prop, value);\n\t  var coerced = value !== rawValue;\n\t  if (!assertProp(prop, value, vm)) {\n\t    value = undefined;\n\t  }\n\t  if (isSimple && !coerced) {\n\t    withoutConversion(function () {\n\t      fn(value);\n\t    });\n\t  } else {\n\t    fn(value);\n\t  }\n\t}\n\t\n\t/**\n\t * Set a prop's initial value on a vm and its data object.\n\t *\n\t * @param {Vue} vm\n\t * @param {Object} prop\n\t * @param {*} value\n\t */\n\t\n\tfunction initProp(vm, prop, value) {\n\t  processPropValue(vm, prop, value, function (value) {\n\t    defineReactive(vm, prop.path, value);\n\t  });\n\t}\n\t\n\t/**\n\t * Update a prop's value on a vm.\n\t *\n\t * @param {Vue} vm\n\t * @param {Object} prop\n\t * @param {*} value\n\t */\n\t\n\tfunction updateProp(vm, prop, value) {\n\t  processPropValue(vm, prop, value, function (value) {\n\t    vm[prop.path] = value;\n\t  });\n\t}\n\t\n\t/**\n\t * Get the default value of a prop.\n\t *\n\t * @param {Vue} vm\n\t * @param {Object} prop\n\t * @return {*}\n\t */\n\t\n\tfunction getPropDefaultValue(vm, prop) {\n\t  // no default, return undefined\n\t  var options = prop.options;\n\t  if (!hasOwn(options, 'default')) {\n\t    // absent boolean value defaults to false\n\t    return options.type === Boolean ? false : undefined;\n\t  }\n\t  var def = options['default'];\n\t  // warn against non-factory defaults for Object & Array\n\t  if (isObject(def)) {\n\t    (\"production\") !== 'production' && warn('Invalid default value for prop \"' + prop.name + '\": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);\n\t  }\n\t  // call factory function for non-Function types\n\t  return typeof def === 'function' && options.type !== Function ? def.call(vm) : def;\n\t}\n\t\n\t/**\n\t * Assert whether a prop is valid.\n\t *\n\t * @param {Object} prop\n\t * @param {*} value\n\t * @param {Vue} vm\n\t */\n\t\n\tfunction assertProp(prop, value, vm) {\n\t  if (!prop.options.required && ( // non-required\n\t  prop.raw === null || // abscent\n\t  value == null) // null or undefined\n\t  ) {\n\t      return true;\n\t    }\n\t  var options = prop.options;\n\t  var type = options.type;\n\t  var valid = !type;\n\t  var expectedTypes = [];\n\t  if (type) {\n\t    if (!isArray(type)) {\n\t      type = [type];\n\t    }\n\t    for (var i = 0; i < type.length && !valid; i++) {\n\t      var assertedType = assertType(value, type[i]);\n\t      expectedTypes.push(assertedType.expectedType);\n\t      valid = assertedType.valid;\n\t    }\n\t  }\n\t  if (!valid) {\n\t    if (false) {\n\t      warn('Invalid prop: type check failed for prop \"' + prop.name + '\".' + ' Expected ' + expectedTypes.map(formatType).join(', ') + ', got ' + formatValue(value) + '.', vm);\n\t    }\n\t    return false;\n\t  }\n\t  var validator = options.validator;\n\t  if (validator) {\n\t    if (!validator(value)) {\n\t      (\"production\") !== 'production' && warn('Invalid prop: custom validator check failed for prop \"' + prop.name + '\".', vm);\n\t      return false;\n\t    }\n\t  }\n\t  return true;\n\t}\n\t\n\t/**\n\t * Force parsing value with coerce option.\n\t *\n\t * @param {*} value\n\t * @param {Object} options\n\t * @return {*}\n\t */\n\t\n\tfunction coerceProp(prop, value) {\n\t  var coerce = prop.options.coerce;\n\t  if (!coerce) {\n\t    return value;\n\t  }\n\t  // coerce is a function\n\t  return coerce(value);\n\t}\n\t\n\t/**\n\t * Assert the type of a value\n\t *\n\t * @param {*} value\n\t * @param {Function} type\n\t * @return {Object}\n\t */\n\t\n\tfunction assertType(value, type) {\n\t  var valid;\n\t  var expectedType;\n\t  if (type === String) {\n\t    expectedType = 'string';\n\t    valid = typeof value === expectedType;\n\t  } else if (type === Number) {\n\t    expectedType = 'number';\n\t    valid = typeof value === expectedType;\n\t  } else if (type === Boolean) {\n\t    expectedType = 'boolean';\n\t    valid = typeof value === expectedType;\n\t  } else if (type === Function) {\n\t    expectedType = 'function';\n\t    valid = typeof value === expectedType;\n\t  } else if (type === Object) {\n\t    expectedType = 'object';\n\t    valid = isPlainObject(value);\n\t  } else if (type === Array) {\n\t    expectedType = 'array';\n\t    valid = isArray(value);\n\t  } else {\n\t    valid = value instanceof type;\n\t  }\n\t  return {\n\t    valid: valid,\n\t    expectedType: expectedType\n\t  };\n\t}\n\t\n\t/**\n\t * Format type for output\n\t *\n\t * @param {String} type\n\t * @return {String}\n\t */\n\t\n\tfunction formatType(type) {\n\t  return type ? type.charAt(0).toUpperCase() + type.slice(1) : 'custom type';\n\t}\n\t\n\t/**\n\t * Format value\n\t *\n\t * @param {*} value\n\t * @return {String}\n\t */\n\t\n\tfunction formatValue(val) {\n\t  return Object.prototype.toString.call(val).slice(8, -1);\n\t}\n\t\n\tvar bindingModes = config._propBindingModes;\n\t\n\tvar propDef = {\n\t\n\t  bind: function bind() {\n\t    var child = this.vm;\n\t    var parent = child._context;\n\t    // passed in from compiler directly\n\t    var prop = this.descriptor.prop;\n\t    var childKey = prop.path;\n\t    var parentKey = prop.parentPath;\n\t    var twoWay = prop.mode === bindingModes.TWO_WAY;\n\t\n\t    var parentWatcher = this.parentWatcher = new Watcher(parent, parentKey, function (val) {\n\t      updateProp(child, prop, val);\n\t    }, {\n\t      twoWay: twoWay,\n\t      filters: prop.filters,\n\t      // important: props need to be observed on the\n\t      // v-for scope if present\n\t      scope: this._scope\n\t    });\n\t\n\t    // set the child initial value.\n\t    initProp(child, prop, parentWatcher.value);\n\t\n\t    // setup two-way binding\n\t    if (twoWay) {\n\t      // important: defer the child watcher creation until\n\t      // the created hook (after data observation)\n\t      var self = this;\n\t      child.$once('pre-hook:created', function () {\n\t        self.childWatcher = new Watcher(child, childKey, function (val) {\n\t          parentWatcher.set(val);\n\t        }, {\n\t          // ensure sync upward before parent sync down.\n\t          // this is necessary in cases e.g. the child\n\t          // mutates a prop array, then replaces it. (#1683)\n\t          sync: true\n\t        });\n\t      });\n\t    }\n\t  },\n\t\n\t  unbind: function unbind() {\n\t    this.parentWatcher.teardown();\n\t    if (this.childWatcher) {\n\t      this.childWatcher.teardown();\n\t    }\n\t  }\n\t};\n\t\n\tvar queue$1 = [];\n\tvar queued = false;\n\t\n\t/**\n\t * Push a job into the queue.\n\t *\n\t * @param {Function} job\n\t */\n\t\n\tfunction pushJob(job) {\n\t  queue$1.push(job);\n\t  if (!queued) {\n\t    queued = true;\n\t    nextTick(flush);\n\t  }\n\t}\n\t\n\t/**\n\t * Flush the queue, and do one forced reflow before\n\t * triggering transitions.\n\t */\n\t\n\tfunction flush() {\n\t  // Force layout\n\t  var f = document.documentElement.offsetHeight;\n\t  for (var i = 0; i < queue$1.length; i++) {\n\t    queue$1[i]();\n\t  }\n\t  queue$1 = [];\n\t  queued = false;\n\t  // dummy return, so js linters don't complain about\n\t  // unused variable f\n\t  return f;\n\t}\n\t\n\tvar TYPE_TRANSITION = 'transition';\n\tvar TYPE_ANIMATION = 'animation';\n\tvar transDurationProp = transitionProp + 'Duration';\n\tvar animDurationProp = animationProp + 'Duration';\n\t\n\t/**\n\t * If a just-entered element is applied the\n\t * leave class while its enter transition hasn't started yet,\n\t * and the transitioned property has the same value for both\n\t * enter/leave, then the leave transition will be skipped and\n\t * the transitionend event never fires. This function ensures\n\t * its callback to be called after a transition has started\n\t * by waiting for double raf.\n\t *\n\t * It falls back to setTimeout on devices that support CSS\n\t * transitions but not raf (e.g. Android 4.2 browser) - since\n\t * these environments are usually slow, we are giving it a\n\t * relatively large timeout.\n\t */\n\t\n\tvar raf = inBrowser && window.requestAnimationFrame;\n\tvar waitForTransitionStart = raf\n\t/* istanbul ignore next */\n\t? function (fn) {\n\t  raf(function () {\n\t    raf(fn);\n\t  });\n\t} : function (fn) {\n\t  setTimeout(fn, 50);\n\t};\n\t\n\t/**\n\t * A Transition object that encapsulates the state and logic\n\t * of the transition.\n\t *\n\t * @param {Element} el\n\t * @param {String} id\n\t * @param {Object} hooks\n\t * @param {Vue} vm\n\t */\n\tfunction Transition(el, id, hooks, vm) {\n\t  this.id = id;\n\t  this.el = el;\n\t  this.enterClass = hooks && hooks.enterClass || id + '-enter';\n\t  this.leaveClass = hooks && hooks.leaveClass || id + '-leave';\n\t  this.hooks = hooks;\n\t  this.vm = vm;\n\t  // async state\n\t  this.pendingCssEvent = this.pendingCssCb = this.cancel = this.pendingJsCb = this.op = this.cb = null;\n\t  this.justEntered = false;\n\t  this.entered = this.left = false;\n\t  this.typeCache = {};\n\t  // check css transition type\n\t  this.type = hooks && hooks.type;\n\t  /* istanbul ignore if */\n\t  if (false) {\n\t    if (this.type && this.type !== TYPE_TRANSITION && this.type !== TYPE_ANIMATION) {\n\t      warn('invalid CSS transition type for transition=\"' + this.id + '\": ' + this.type, vm);\n\t    }\n\t  }\n\t  // bind\n\t  var self = this;['enterNextTick', 'enterDone', 'leaveNextTick', 'leaveDone'].forEach(function (m) {\n\t    self[m] = bind(self[m], self);\n\t  });\n\t}\n\t\n\tvar p$1 = Transition.prototype;\n\t\n\t/**\n\t * Start an entering transition.\n\t *\n\t * 1. enter transition triggered\n\t * 2. call beforeEnter hook\n\t * 3. add enter class\n\t * 4. insert/show element\n\t * 5. call enter hook (with possible explicit js callback)\n\t * 6. reflow\n\t * 7. based on transition type:\n\t *    - transition:\n\t *        remove class now, wait for transitionend,\n\t *        then done if there's no explicit js callback.\n\t *    - animation:\n\t *        wait for animationend, remove class,\n\t *        then done if there's no explicit js callback.\n\t *    - no css transition:\n\t *        done now if there's no explicit js callback.\n\t * 8. wait for either done or js callback, then call\n\t *    afterEnter hook.\n\t *\n\t * @param {Function} op - insert/show the element\n\t * @param {Function} [cb]\n\t */\n\t\n\tp$1.enter = function (op, cb) {\n\t  this.cancelPending();\n\t  this.callHook('beforeEnter');\n\t  this.cb = cb;\n\t  addClass(this.el, this.enterClass);\n\t  op();\n\t  this.entered = false;\n\t  this.callHookWithCb('enter');\n\t  if (this.entered) {\n\t    return; // user called done synchronously.\n\t  }\n\t  this.cancel = this.hooks && this.hooks.enterCancelled;\n\t  pushJob(this.enterNextTick);\n\t};\n\t\n\t/**\n\t * The \"nextTick\" phase of an entering transition, which is\n\t * to be pushed into a queue and executed after a reflow so\n\t * that removing the class can trigger a CSS transition.\n\t */\n\t\n\tp$1.enterNextTick = function () {\n\t  var _this = this;\n\t\n\t  // prevent transition skipping\n\t  this.justEntered = true;\n\t  waitForTransitionStart(function () {\n\t    _this.justEntered = false;\n\t  });\n\t  var enterDone = this.enterDone;\n\t  var type = this.getCssTransitionType(this.enterClass);\n\t  if (!this.pendingJsCb) {\n\t    if (type === TYPE_TRANSITION) {\n\t      // trigger transition by removing enter class now\n\t      removeClass(this.el, this.enterClass);\n\t      this.setupCssCb(transitionEndEvent, enterDone);\n\t    } else if (type === TYPE_ANIMATION) {\n\t      this.setupCssCb(animationEndEvent, enterDone);\n\t    } else {\n\t      enterDone();\n\t    }\n\t  } else if (type === TYPE_TRANSITION) {\n\t    removeClass(this.el, this.enterClass);\n\t  }\n\t};\n\t\n\t/**\n\t * The \"cleanup\" phase of an entering transition.\n\t */\n\t\n\tp$1.enterDone = function () {\n\t  this.entered = true;\n\t  this.cancel = this.pendingJsCb = null;\n\t  removeClass(this.el, this.enterClass);\n\t  this.callHook('afterEnter');\n\t  if (this.cb) this.cb();\n\t};\n\t\n\t/**\n\t * Start a leaving transition.\n\t *\n\t * 1. leave transition triggered.\n\t * 2. call beforeLeave hook\n\t * 3. add leave class (trigger css transition)\n\t * 4. call leave hook (with possible explicit js callback)\n\t * 5. reflow if no explicit js callback is provided\n\t * 6. based on transition type:\n\t *    - transition or animation:\n\t *        wait for end event, remove class, then done if\n\t *        there's no explicit js callback.\n\t *    - no css transition:\n\t *        done if there's no explicit js callback.\n\t * 7. wait for either done or js callback, then call\n\t *    afterLeave hook.\n\t *\n\t * @param {Function} op - remove/hide the element\n\t * @param {Function} [cb]\n\t */\n\t\n\tp$1.leave = function (op, cb) {\n\t  this.cancelPending();\n\t  this.callHook('beforeLeave');\n\t  this.op = op;\n\t  this.cb = cb;\n\t  addClass(this.el, this.leaveClass);\n\t  this.left = false;\n\t  this.callHookWithCb('leave');\n\t  if (this.left) {\n\t    return; // user called done synchronously.\n\t  }\n\t  this.cancel = this.hooks && this.hooks.leaveCancelled;\n\t  // only need to handle leaveDone if\n\t  // 1. the transition is already done (synchronously called\n\t  //    by the user, which causes this.op set to null)\n\t  // 2. there's no explicit js callback\n\t  if (this.op && !this.pendingJsCb) {\n\t    // if a CSS transition leaves immediately after enter,\n\t    // the transitionend event never fires. therefore we\n\t    // detect such cases and end the leave immediately.\n\t    if (this.justEntered) {\n\t      this.leaveDone();\n\t    } else {\n\t      pushJob(this.leaveNextTick);\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * The \"nextTick\" phase of a leaving transition.\n\t */\n\t\n\tp$1.leaveNextTick = function () {\n\t  var type = this.getCssTransitionType(this.leaveClass);\n\t  if (type) {\n\t    var event = type === TYPE_TRANSITION ? transitionEndEvent : animationEndEvent;\n\t    this.setupCssCb(event, this.leaveDone);\n\t  } else {\n\t    this.leaveDone();\n\t  }\n\t};\n\t\n\t/**\n\t * The \"cleanup\" phase of a leaving transition.\n\t */\n\t\n\tp$1.leaveDone = function () {\n\t  this.left = true;\n\t  this.cancel = this.pendingJsCb = null;\n\t  this.op();\n\t  removeClass(this.el, this.leaveClass);\n\t  this.callHook('afterLeave');\n\t  if (this.cb) this.cb();\n\t  this.op = null;\n\t};\n\t\n\t/**\n\t * Cancel any pending callbacks from a previously running\n\t * but not finished transition.\n\t */\n\t\n\tp$1.cancelPending = function () {\n\t  this.op = this.cb = null;\n\t  var hasPending = false;\n\t  if (this.pendingCssCb) {\n\t    hasPending = true;\n\t    off(this.el, this.pendingCssEvent, this.pendingCssCb);\n\t    this.pendingCssEvent = this.pendingCssCb = null;\n\t  }\n\t  if (this.pendingJsCb) {\n\t    hasPending = true;\n\t    this.pendingJsCb.cancel();\n\t    this.pendingJsCb = null;\n\t  }\n\t  if (hasPending) {\n\t    removeClass(this.el, this.enterClass);\n\t    removeClass(this.el, this.leaveClass);\n\t  }\n\t  if (this.cancel) {\n\t    this.cancel.call(this.vm, this.el);\n\t    this.cancel = null;\n\t  }\n\t};\n\t\n\t/**\n\t * Call a user-provided synchronous hook function.\n\t *\n\t * @param {String} type\n\t */\n\t\n\tp$1.callHook = function (type) {\n\t  if (this.hooks && this.hooks[type]) {\n\t    this.hooks[type].call(this.vm, this.el);\n\t  }\n\t};\n\t\n\t/**\n\t * Call a user-provided, potentially-async hook function.\n\t * We check for the length of arguments to see if the hook\n\t * expects a `done` callback. If true, the transition's end\n\t * will be determined by when the user calls that callback;\n\t * otherwise, the end is determined by the CSS transition or\n\t * animation.\n\t *\n\t * @param {String} type\n\t */\n\t\n\tp$1.callHookWithCb = function (type) {\n\t  var hook = this.hooks && this.hooks[type];\n\t  if (hook) {\n\t    if (hook.length > 1) {\n\t      this.pendingJsCb = cancellable(this[type + 'Done']);\n\t    }\n\t    hook.call(this.vm, this.el, this.pendingJsCb);\n\t  }\n\t};\n\t\n\t/**\n\t * Get an element's transition type based on the\n\t * calculated styles.\n\t *\n\t * @param {String} className\n\t * @return {Number}\n\t */\n\t\n\tp$1.getCssTransitionType = function (className) {\n\t  /* istanbul ignore if */\n\t  if (!transitionEndEvent ||\n\t  // skip CSS transitions if page is not visible -\n\t  // this solves the issue of transitionend events not\n\t  // firing until the page is visible again.\n\t  // pageVisibility API is supported in IE10+, same as\n\t  // CSS transitions.\n\t  document.hidden ||\n\t  // explicit js-only transition\n\t  this.hooks && this.hooks.css === false ||\n\t  // element is hidden\n\t  isHidden(this.el)) {\n\t    return;\n\t  }\n\t  var type = this.type || this.typeCache[className];\n\t  if (type) return type;\n\t  var inlineStyles = this.el.style;\n\t  var computedStyles = window.getComputedStyle(this.el);\n\t  var transDuration = inlineStyles[transDurationProp] || computedStyles[transDurationProp];\n\t  if (transDuration && transDuration !== '0s') {\n\t    type = TYPE_TRANSITION;\n\t  } else {\n\t    var animDuration = inlineStyles[animDurationProp] || computedStyles[animDurationProp];\n\t    if (animDuration && animDuration !== '0s') {\n\t      type = TYPE_ANIMATION;\n\t    }\n\t  }\n\t  if (type) {\n\t    this.typeCache[className] = type;\n\t  }\n\t  return type;\n\t};\n\t\n\t/**\n\t * Setup a CSS transitionend/animationend callback.\n\t *\n\t * @param {String} event\n\t * @param {Function} cb\n\t */\n\t\n\tp$1.setupCssCb = function (event, cb) {\n\t  this.pendingCssEvent = event;\n\t  var self = this;\n\t  var el = this.el;\n\t  var onEnd = this.pendingCssCb = function (e) {\n\t    if (e.target === el) {\n\t      off(el, event, onEnd);\n\t      self.pendingCssEvent = self.pendingCssCb = null;\n\t      if (!self.pendingJsCb && cb) {\n\t        cb();\n\t      }\n\t    }\n\t  };\n\t  on(el, event, onEnd);\n\t};\n\t\n\t/**\n\t * Check if an element is hidden - in that case we can just\n\t * skip the transition alltogether.\n\t *\n\t * @param {Element} el\n\t * @return {Boolean}\n\t */\n\t\n\tfunction isHidden(el) {\n\t  if (/svg$/.test(el.namespaceURI)) {\n\t    // SVG elements do not have offset(Width|Height)\n\t    // so we need to check the client rect\n\t    var rect = el.getBoundingClientRect();\n\t    return !(rect.width || rect.height);\n\t  } else {\n\t    return !(el.offsetWidth || el.offsetHeight || el.getClientRects().length);\n\t  }\n\t}\n\t\n\tvar transition$1 = {\n\t\n\t  priority: TRANSITION,\n\t\n\t  update: function update(id, oldId) {\n\t    var el = this.el;\n\t    // resolve on owner vm\n\t    var hooks = resolveAsset(this.vm.$options, 'transitions', id);\n\t    id = id || 'v';\n\t    el.__v_trans = new Transition(el, id, hooks, this.vm);\n\t    if (oldId) {\n\t      removeClass(el, oldId + '-transition');\n\t    }\n\t    addClass(el, id + '-transition');\n\t  }\n\t};\n\t\n\tvar internalDirectives = {\n\t  style: style,\n\t  'class': vClass,\n\t  component: component,\n\t  prop: propDef,\n\t  transition: transition$1\n\t};\n\t\n\t// special binding prefixes\n\tvar bindRE = /^v-bind:|^:/;\n\tvar onRE = /^v-on:|^@/;\n\tvar dirAttrRE = /^v-([^:]+)(?:$|:(.*)$)/;\n\tvar modifierRE = /\\.[^\\.]+/g;\n\tvar transitionRE = /^(v-bind:|:)?transition$/;\n\t\n\t// default directive priority\n\tvar DEFAULT_PRIORITY = 1000;\n\tvar DEFAULT_TERMINAL_PRIORITY = 2000;\n\t\n\t/**\n\t * Compile a template and return a reusable composite link\n\t * function, which recursively contains more link functions\n\t * inside. This top level compile function would normally\n\t * be called on instance root nodes, but can also be used\n\t * for partial compilation if the partial argument is true.\n\t *\n\t * The returned composite link function, when called, will\n\t * return an unlink function that tearsdown all directives\n\t * created during the linking phase.\n\t *\n\t * @param {Element|DocumentFragment} el\n\t * @param {Object} options\n\t * @param {Boolean} partial\n\t * @return {Function}\n\t */\n\t\n\tfunction compile(el, options, partial) {\n\t  // link function for the node itself.\n\t  var nodeLinkFn = partial || !options._asComponent ? compileNode(el, options) : null;\n\t  // link function for the childNodes\n\t  var childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && el.tagName !== 'SCRIPT' && el.hasChildNodes() ? compileNodeList(el.childNodes, options) : null;\n\t\n\t  /**\n\t   * A composite linker function to be called on a already\n\t   * compiled piece of DOM, which instantiates all directive\n\t   * instances.\n\t   *\n\t   * @param {Vue} vm\n\t   * @param {Element|DocumentFragment} el\n\t   * @param {Vue} [host] - host vm of transcluded content\n\t   * @param {Object} [scope] - v-for scope\n\t   * @param {Fragment} [frag] - link context fragment\n\t   * @return {Function|undefined}\n\t   */\n\t\n\t  return function compositeLinkFn(vm, el, host, scope, frag) {\n\t    // cache childNodes before linking parent, fix #657\n\t    var childNodes = toArray(el.childNodes);\n\t    // link\n\t    var dirs = linkAndCapture(function compositeLinkCapturer() {\n\t      if (nodeLinkFn) nodeLinkFn(vm, el, host, scope, frag);\n\t      if (childLinkFn) childLinkFn(vm, childNodes, host, scope, frag);\n\t    }, vm);\n\t    return makeUnlinkFn(vm, dirs);\n\t  };\n\t}\n\t\n\t/**\n\t * Apply a linker to a vm/element pair and capture the\n\t * directives created during the process.\n\t *\n\t * @param {Function} linker\n\t * @param {Vue} vm\n\t */\n\t\n\tfunction linkAndCapture(linker, vm) {\n\t  /* istanbul ignore if */\n\t  if (true) {\n\t    // reset directives before every capture in production\n\t    // mode, so that when unlinking we don't need to splice\n\t    // them out (which turns out to be a perf hit).\n\t    // they are kept in development mode because they are\n\t    // useful for Vue's own tests.\n\t    vm._directives = [];\n\t  }\n\t  var originalDirCount = vm._directives.length;\n\t  linker();\n\t  var dirs = vm._directives.slice(originalDirCount);\n\t  dirs.sort(directiveComparator);\n\t  for (var i = 0, l = dirs.length; i < l; i++) {\n\t    dirs[i]._bind();\n\t  }\n\t  return dirs;\n\t}\n\t\n\t/**\n\t * Directive priority sort comparator\n\t *\n\t * @param {Object} a\n\t * @param {Object} b\n\t */\n\t\n\tfunction directiveComparator(a, b) {\n\t  a = a.descriptor.def.priority || DEFAULT_PRIORITY;\n\t  b = b.descriptor.def.priority || DEFAULT_PRIORITY;\n\t  return a > b ? -1 : a === b ? 0 : 1;\n\t}\n\t\n\t/**\n\t * Linker functions return an unlink function that\n\t * tearsdown all directives instances generated during\n\t * the process.\n\t *\n\t * We create unlink functions with only the necessary\n\t * information to avoid retaining additional closures.\n\t *\n\t * @param {Vue} vm\n\t * @param {Array} dirs\n\t * @param {Vue} [context]\n\t * @param {Array} [contextDirs]\n\t * @return {Function}\n\t */\n\t\n\tfunction makeUnlinkFn(vm, dirs, context, contextDirs) {\n\t  function unlink(destroying) {\n\t    teardownDirs(vm, dirs, destroying);\n\t    if (context && contextDirs) {\n\t      teardownDirs(context, contextDirs);\n\t    }\n\t  }\n\t  // expose linked directives\n\t  unlink.dirs = dirs;\n\t  return unlink;\n\t}\n\t\n\t/**\n\t * Teardown partial linked directives.\n\t *\n\t * @param {Vue} vm\n\t * @param {Array} dirs\n\t * @param {Boolean} destroying\n\t */\n\t\n\tfunction teardownDirs(vm, dirs, destroying) {\n\t  var i = dirs.length;\n\t  while (i--) {\n\t    dirs[i]._teardown();\n\t    if (false) {\n\t      vm._directives.$remove(dirs[i]);\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Compile link props on an instance.\n\t *\n\t * @param {Vue} vm\n\t * @param {Element} el\n\t * @param {Object} props\n\t * @param {Object} [scope]\n\t * @return {Function}\n\t */\n\t\n\tfunction compileAndLinkProps(vm, el, props, scope) {\n\t  var propsLinkFn = compileProps(el, props, vm);\n\t  var propDirs = linkAndCapture(function () {\n\t    propsLinkFn(vm, scope);\n\t  }, vm);\n\t  return makeUnlinkFn(vm, propDirs);\n\t}\n\t\n\t/**\n\t * Compile the root element of an instance.\n\t *\n\t * 1. attrs on context container (context scope)\n\t * 2. attrs on the component template root node, if\n\t *    replace:true (child scope)\n\t *\n\t * If this is a fragment instance, we only need to compile 1.\n\t *\n\t * @param {Element} el\n\t * @param {Object} options\n\t * @param {Object} contextOptions\n\t * @return {Function}\n\t */\n\t\n\tfunction compileRoot(el, options, contextOptions) {\n\t  var containerAttrs = options._containerAttrs;\n\t  var replacerAttrs = options._replacerAttrs;\n\t  var contextLinkFn, replacerLinkFn;\n\t\n\t  // only need to compile other attributes for\n\t  // non-fragment instances\n\t  if (el.nodeType !== 11) {\n\t    // for components, container and replacer need to be\n\t    // compiled separately and linked in different scopes.\n\t    if (options._asComponent) {\n\t      // 2. container attributes\n\t      if (containerAttrs && contextOptions) {\n\t        contextLinkFn = compileDirectives(containerAttrs, contextOptions);\n\t      }\n\t      if (replacerAttrs) {\n\t        // 3. replacer attributes\n\t        replacerLinkFn = compileDirectives(replacerAttrs, options);\n\t      }\n\t    } else {\n\t      // non-component, just compile as a normal element.\n\t      replacerLinkFn = compileDirectives(el.attributes, options);\n\t    }\n\t  } else if (false) {\n\t    // warn container directives for fragment instances\n\t    var names = containerAttrs.filter(function (attr) {\n\t      // allow vue-loader/vueify scoped css attributes\n\t      return attr.name.indexOf('_v-') < 0 &&\n\t      // allow event listeners\n\t      !onRE.test(attr.name) &&\n\t      // allow slots\n\t      attr.name !== 'slot';\n\t    }).map(function (attr) {\n\t      return '\"' + attr.name + '\"';\n\t    });\n\t    if (names.length) {\n\t      var plural = names.length > 1;\n\t      warn('Attribute' + (plural ? 's ' : ' ') + names.join(', ') + (plural ? ' are' : ' is') + ' ignored on component ' + '<' + options.el.tagName.toLowerCase() + '> because ' + 'the component is a fragment instance: ' + 'http://vuejs.org/guide/components.html#Fragment_Instance');\n\t    }\n\t  }\n\t\n\t  options._containerAttrs = options._replacerAttrs = null;\n\t  return function rootLinkFn(vm, el, scope) {\n\t    // link context scope dirs\n\t    var context = vm._context;\n\t    var contextDirs;\n\t    if (context && contextLinkFn) {\n\t      contextDirs = linkAndCapture(function () {\n\t        contextLinkFn(context, el, null, scope);\n\t      }, context);\n\t    }\n\t\n\t    // link self\n\t    var selfDirs = linkAndCapture(function () {\n\t      if (replacerLinkFn) replacerLinkFn(vm, el);\n\t    }, vm);\n\t\n\t    // return the unlink function that tearsdown context\n\t    // container directives.\n\t    return makeUnlinkFn(vm, selfDirs, context, contextDirs);\n\t  };\n\t}\n\t\n\t/**\n\t * Compile a node and return a nodeLinkFn based on the\n\t * node type.\n\t *\n\t * @param {Node} node\n\t * @param {Object} options\n\t * @return {Function|null}\n\t */\n\t\n\tfunction compileNode(node, options) {\n\t  var type = node.nodeType;\n\t  if (type === 1 && node.tagName !== 'SCRIPT') {\n\t    return compileElement(node, options);\n\t  } else if (type === 3 && node.data.trim()) {\n\t    return compileTextNode(node, options);\n\t  } else {\n\t    return null;\n\t  }\n\t}\n\t\n\t/**\n\t * Compile an element and return a nodeLinkFn.\n\t *\n\t * @param {Element} el\n\t * @param {Object} options\n\t * @return {Function|null}\n\t */\n\t\n\tfunction compileElement(el, options) {\n\t  // preprocess textareas.\n\t  // textarea treats its text content as the initial value.\n\t  // just bind it as an attr directive for value.\n\t  if (el.tagName === 'TEXTAREA') {\n\t    var tokens = parseText(el.value);\n\t    if (tokens) {\n\t      el.setAttribute(':value', tokensToExp(tokens));\n\t      el.value = '';\n\t    }\n\t  }\n\t  var linkFn;\n\t  var hasAttrs = el.hasAttributes();\n\t  var attrs = hasAttrs && toArray(el.attributes);\n\t  // check terminal directives (for & if)\n\t  if (hasAttrs) {\n\t    linkFn = checkTerminalDirectives(el, attrs, options);\n\t  }\n\t  // check element directives\n\t  if (!linkFn) {\n\t    linkFn = checkElementDirectives(el, options);\n\t  }\n\t  // check component\n\t  if (!linkFn) {\n\t    linkFn = checkComponent(el, options);\n\t  }\n\t  // normal directives\n\t  if (!linkFn && hasAttrs) {\n\t    linkFn = compileDirectives(attrs, options);\n\t  }\n\t  return linkFn;\n\t}\n\t\n\t/**\n\t * Compile a textNode and return a nodeLinkFn.\n\t *\n\t * @param {TextNode} node\n\t * @param {Object} options\n\t * @return {Function|null} textNodeLinkFn\n\t */\n\t\n\tfunction compileTextNode(node, options) {\n\t  // skip marked text nodes\n\t  if (node._skip) {\n\t    return removeText;\n\t  }\n\t\n\t  var tokens = parseText(node.wholeText);\n\t  if (!tokens) {\n\t    return null;\n\t  }\n\t\n\t  // mark adjacent text nodes as skipped,\n\t  // because we are using node.wholeText to compile\n\t  // all adjacent text nodes together. This fixes\n\t  // issues in IE where sometimes it splits up a single\n\t  // text node into multiple ones.\n\t  var next = node.nextSibling;\n\t  while (next && next.nodeType === 3) {\n\t    next._skip = true;\n\t    next = next.nextSibling;\n\t  }\n\t\n\t  var frag = document.createDocumentFragment();\n\t  var el, token;\n\t  for (var i = 0, l = tokens.length; i < l; i++) {\n\t    token = tokens[i];\n\t    el = token.tag ? processTextToken(token, options) : document.createTextNode(token.value);\n\t    frag.appendChild(el);\n\t  }\n\t  return makeTextNodeLinkFn(tokens, frag, options);\n\t}\n\t\n\t/**\n\t * Linker for an skipped text node.\n\t *\n\t * @param {Vue} vm\n\t * @param {Text} node\n\t */\n\t\n\tfunction removeText(vm, node) {\n\t  remove(node);\n\t}\n\t\n\t/**\n\t * Process a single text token.\n\t *\n\t * @param {Object} token\n\t * @param {Object} options\n\t * @return {Node}\n\t */\n\t\n\tfunction processTextToken(token, options) {\n\t  var el;\n\t  if (token.oneTime) {\n\t    el = document.createTextNode(token.value);\n\t  } else {\n\t    if (token.html) {\n\t      el = document.createComment('v-html');\n\t      setTokenType('html');\n\t    } else {\n\t      // IE will clean up empty textNodes during\n\t      // frag.cloneNode(true), so we have to give it\n\t      // something here...\n\t      el = document.createTextNode(' ');\n\t      setTokenType('text');\n\t    }\n\t  }\n\t  function setTokenType(type) {\n\t    if (token.descriptor) return;\n\t    var parsed = parseDirective(token.value);\n\t    token.descriptor = {\n\t      name: type,\n\t      def: directives[type],\n\t      expression: parsed.expression,\n\t      filters: parsed.filters\n\t    };\n\t  }\n\t  return el;\n\t}\n\t\n\t/**\n\t * Build a function that processes a textNode.\n\t *\n\t * @param {Array<Object>} tokens\n\t * @param {DocumentFragment} frag\n\t */\n\t\n\tfunction makeTextNodeLinkFn(tokens, frag) {\n\t  return function textNodeLinkFn(vm, el, host, scope) {\n\t    var fragClone = frag.cloneNode(true);\n\t    var childNodes = toArray(fragClone.childNodes);\n\t    var token, value, node;\n\t    for (var i = 0, l = tokens.length; i < l; i++) {\n\t      token = tokens[i];\n\t      value = token.value;\n\t      if (token.tag) {\n\t        node = childNodes[i];\n\t        if (token.oneTime) {\n\t          value = (scope || vm).$eval(value);\n\t          if (token.html) {\n\t            replace(node, parseTemplate(value, true));\n\t          } else {\n\t            node.data = value;\n\t          }\n\t        } else {\n\t          vm._bindDir(token.descriptor, node, host, scope);\n\t        }\n\t      }\n\t    }\n\t    replace(el, fragClone);\n\t  };\n\t}\n\t\n\t/**\n\t * Compile a node list and return a childLinkFn.\n\t *\n\t * @param {NodeList} nodeList\n\t * @param {Object} options\n\t * @return {Function|undefined}\n\t */\n\t\n\tfunction compileNodeList(nodeList, options) {\n\t  var linkFns = [];\n\t  var nodeLinkFn, childLinkFn, node;\n\t  for (var i = 0, l = nodeList.length; i < l; i++) {\n\t    node = nodeList[i];\n\t    nodeLinkFn = compileNode(node, options);\n\t    childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && node.tagName !== 'SCRIPT' && node.hasChildNodes() ? compileNodeList(node.childNodes, options) : null;\n\t    linkFns.push(nodeLinkFn, childLinkFn);\n\t  }\n\t  return linkFns.length ? makeChildLinkFn(linkFns) : null;\n\t}\n\t\n\t/**\n\t * Make a child link function for a node's childNodes.\n\t *\n\t * @param {Array<Function>} linkFns\n\t * @return {Function} childLinkFn\n\t */\n\t\n\tfunction makeChildLinkFn(linkFns) {\n\t  return function childLinkFn(vm, nodes, host, scope, frag) {\n\t    var node, nodeLinkFn, childrenLinkFn;\n\t    for (var i = 0, n = 0, l = linkFns.length; i < l; n++) {\n\t      node = nodes[n];\n\t      nodeLinkFn = linkFns[i++];\n\t      childrenLinkFn = linkFns[i++];\n\t      // cache childNodes before linking parent, fix #657\n\t      var childNodes = toArray(node.childNodes);\n\t      if (nodeLinkFn) {\n\t        nodeLinkFn(vm, node, host, scope, frag);\n\t      }\n\t      if (childrenLinkFn) {\n\t        childrenLinkFn(vm, childNodes, host, scope, frag);\n\t      }\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * Check for element directives (custom elements that should\n\t * be resovled as terminal directives).\n\t *\n\t * @param {Element} el\n\t * @param {Object} options\n\t */\n\t\n\tfunction checkElementDirectives(el, options) {\n\t  var tag = el.tagName.toLowerCase();\n\t  if (commonTagRE.test(tag)) {\n\t    return;\n\t  }\n\t  var def = resolveAsset(options, 'elementDirectives', tag);\n\t  if (def) {\n\t    return makeTerminalNodeLinkFn(el, tag, '', options, def);\n\t  }\n\t}\n\t\n\t/**\n\t * Check if an element is a component. If yes, return\n\t * a component link function.\n\t *\n\t * @param {Element} el\n\t * @param {Object} options\n\t * @return {Function|undefined}\n\t */\n\t\n\tfunction checkComponent(el, options) {\n\t  var component = checkComponentAttr(el, options);\n\t  if (component) {\n\t    var ref = findRef(el);\n\t    var descriptor = {\n\t      name: 'component',\n\t      ref: ref,\n\t      expression: component.id,\n\t      def: internalDirectives.component,\n\t      modifiers: {\n\t        literal: !component.dynamic\n\t      }\n\t    };\n\t    var componentLinkFn = function componentLinkFn(vm, el, host, scope, frag) {\n\t      if (ref) {\n\t        defineReactive((scope || vm).$refs, ref, null);\n\t      }\n\t      vm._bindDir(descriptor, el, host, scope, frag);\n\t    };\n\t    componentLinkFn.terminal = true;\n\t    return componentLinkFn;\n\t  }\n\t}\n\t\n\t/**\n\t * Check an element for terminal directives in fixed order.\n\t * If it finds one, return a terminal link function.\n\t *\n\t * @param {Element} el\n\t * @param {Array} attrs\n\t * @param {Object} options\n\t * @return {Function} terminalLinkFn\n\t */\n\t\n\tfunction checkTerminalDirectives(el, attrs, options) {\n\t  // skip v-pre\n\t  if (getAttr(el, 'v-pre') !== null) {\n\t    return skip;\n\t  }\n\t  // skip v-else block, but only if following v-if\n\t  if (el.hasAttribute('v-else')) {\n\t    var prev = el.previousElementSibling;\n\t    if (prev && prev.hasAttribute('v-if')) {\n\t      return skip;\n\t    }\n\t  }\n\t\n\t  var attr, name, value, modifiers, matched, dirName, rawName, arg, def, termDef;\n\t  for (var i = 0, j = attrs.length; i < j; i++) {\n\t    attr = attrs[i];\n\t    modifiers = parseModifiers(attr.name);\n\t    name = attr.name.replace(modifierRE, '');\n\t    if (matched = name.match(dirAttrRE)) {\n\t      def = resolveAsset(options, 'directives', matched[1]);\n\t      if (def && def.terminal) {\n\t        if (!termDef || (def.priority || DEFAULT_TERMINAL_PRIORITY) > termDef.priority) {\n\t          termDef = def;\n\t          rawName = attr.name;\n\t          value = attr.value;\n\t          dirName = matched[1];\n\t          arg = matched[2];\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  if (termDef) {\n\t    return makeTerminalNodeLinkFn(el, dirName, value, options, termDef, rawName, arg, modifiers);\n\t  }\n\t}\n\t\n\tfunction skip() {}\n\tskip.terminal = true;\n\t\n\t/**\n\t * Build a node link function for a terminal directive.\n\t * A terminal link function terminates the current\n\t * compilation recursion and handles compilation of the\n\t * subtree in the directive.\n\t *\n\t * @param {Element} el\n\t * @param {String} dirName\n\t * @param {String} value\n\t * @param {Object} options\n\t * @param {Object} def\n\t * @param {String} [rawName]\n\t * @param {String} [arg]\n\t * @param {Object} [modifiers]\n\t * @return {Function} terminalLinkFn\n\t */\n\t\n\tfunction makeTerminalNodeLinkFn(el, dirName, value, options, def, rawName, arg, modifiers) {\n\t  var parsed = parseDirective(value);\n\t  var descriptor = {\n\t    name: dirName,\n\t    arg: arg,\n\t    expression: parsed.expression,\n\t    filters: parsed.filters,\n\t    raw: value,\n\t    attr: rawName,\n\t    modifiers: modifiers,\n\t    def: def\n\t  };\n\t  // check ref for v-for and router-view\n\t  if (dirName === 'for' || dirName === 'router-view') {\n\t    descriptor.ref = findRef(el);\n\t  }\n\t  var fn = function terminalNodeLinkFn(vm, el, host, scope, frag) {\n\t    if (descriptor.ref) {\n\t      defineReactive((scope || vm).$refs, descriptor.ref, null);\n\t    }\n\t    vm._bindDir(descriptor, el, host, scope, frag);\n\t  };\n\t  fn.terminal = true;\n\t  return fn;\n\t}\n\t\n\t/**\n\t * Compile the directives on an element and return a linker.\n\t *\n\t * @param {Array|NamedNodeMap} attrs\n\t * @param {Object} options\n\t * @return {Function}\n\t */\n\t\n\tfunction compileDirectives(attrs, options) {\n\t  var i = attrs.length;\n\t  var dirs = [];\n\t  var attr, name, value, rawName, rawValue, dirName, arg, modifiers, dirDef, tokens, matched;\n\t  while (i--) {\n\t    attr = attrs[i];\n\t    name = rawName = attr.name;\n\t    value = rawValue = attr.value;\n\t    tokens = parseText(value);\n\t    // reset arg\n\t    arg = null;\n\t    // check modifiers\n\t    modifiers = parseModifiers(name);\n\t    name = name.replace(modifierRE, '');\n\t\n\t    // attribute interpolations\n\t    if (tokens) {\n\t      value = tokensToExp(tokens);\n\t      arg = name;\n\t      pushDir('bind', directives.bind, tokens);\n\t      // warn against mixing mustaches with v-bind\n\t      if (false) {\n\t        if (name === 'class' && Array.prototype.some.call(attrs, function (attr) {\n\t          return attr.name === ':class' || attr.name === 'v-bind:class';\n\t        })) {\n\t          warn('class=\"' + rawValue + '\": Do not mix mustache interpolation ' + 'and v-bind for \"class\" on the same element. Use one or the other.', options);\n\t        }\n\t      }\n\t    } else\n\t\n\t      // special attribute: transition\n\t      if (transitionRE.test(name)) {\n\t        modifiers.literal = !bindRE.test(name);\n\t        pushDir('transition', internalDirectives.transition);\n\t      } else\n\t\n\t        // event handlers\n\t        if (onRE.test(name)) {\n\t          arg = name.replace(onRE, '');\n\t          pushDir('on', directives.on);\n\t        } else\n\t\n\t          // attribute bindings\n\t          if (bindRE.test(name)) {\n\t            dirName = name.replace(bindRE, '');\n\t            if (dirName === 'style' || dirName === 'class') {\n\t              pushDir(dirName, internalDirectives[dirName]);\n\t            } else {\n\t              arg = dirName;\n\t              pushDir('bind', directives.bind);\n\t            }\n\t          } else\n\t\n\t            // normal directives\n\t            if (matched = name.match(dirAttrRE)) {\n\t              dirName = matched[1];\n\t              arg = matched[2];\n\t\n\t              // skip v-else (when used with v-show)\n\t              if (dirName === 'else') {\n\t                continue;\n\t              }\n\t\n\t              dirDef = resolveAsset(options, 'directives', dirName, true);\n\t              if (dirDef) {\n\t                pushDir(dirName, dirDef);\n\t              }\n\t            }\n\t  }\n\t\n\t  /**\n\t   * Push a directive.\n\t   *\n\t   * @param {String} dirName\n\t   * @param {Object|Function} def\n\t   * @param {Array} [interpTokens]\n\t   */\n\t\n\t  function pushDir(dirName, def, interpTokens) {\n\t    var hasOneTimeToken = interpTokens && hasOneTime(interpTokens);\n\t    var parsed = !hasOneTimeToken && parseDirective(value);\n\t    dirs.push({\n\t      name: dirName,\n\t      attr: rawName,\n\t      raw: rawValue,\n\t      def: def,\n\t      arg: arg,\n\t      modifiers: modifiers,\n\t      // conversion from interpolation strings with one-time token\n\t      // to expression is differed until directive bind time so that we\n\t      // have access to the actual vm context for one-time bindings.\n\t      expression: parsed && parsed.expression,\n\t      filters: parsed && parsed.filters,\n\t      interp: interpTokens,\n\t      hasOneTime: hasOneTimeToken\n\t    });\n\t  }\n\t\n\t  if (dirs.length) {\n\t    return makeNodeLinkFn(dirs);\n\t  }\n\t}\n\t\n\t/**\n\t * Parse modifiers from directive attribute name.\n\t *\n\t * @param {String} name\n\t * @return {Object}\n\t */\n\t\n\tfunction parseModifiers(name) {\n\t  var res = Object.create(null);\n\t  var match = name.match(modifierRE);\n\t  if (match) {\n\t    var i = match.length;\n\t    while (i--) {\n\t      res[match[i].slice(1)] = true;\n\t    }\n\t  }\n\t  return res;\n\t}\n\t\n\t/**\n\t * Build a link function for all directives on a single node.\n\t *\n\t * @param {Array} directives\n\t * @return {Function} directivesLinkFn\n\t */\n\t\n\tfunction makeNodeLinkFn(directives) {\n\t  return function nodeLinkFn(vm, el, host, scope, frag) {\n\t    // reverse apply because it's sorted low to high\n\t    var i = directives.length;\n\t    while (i--) {\n\t      vm._bindDir(directives[i], el, host, scope, frag);\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * Check if an interpolation string contains one-time tokens.\n\t *\n\t * @param {Array} tokens\n\t * @return {Boolean}\n\t */\n\t\n\tfunction hasOneTime(tokens) {\n\t  var i = tokens.length;\n\t  while (i--) {\n\t    if (tokens[i].oneTime) return true;\n\t  }\n\t}\n\t\n\tvar specialCharRE = /[^\\w\\-:\\.]/;\n\t\n\t/**\n\t * Process an element or a DocumentFragment based on a\n\t * instance option object. This allows us to transclude\n\t * a template node/fragment before the instance is created,\n\t * so the processed fragment can then be cloned and reused\n\t * in v-for.\n\t *\n\t * @param {Element} el\n\t * @param {Object} options\n\t * @return {Element|DocumentFragment}\n\t */\n\t\n\tfunction transclude(el, options) {\n\t  // extract container attributes to pass them down\n\t  // to compiler, because they need to be compiled in\n\t  // parent scope. we are mutating the options object here\n\t  // assuming the same object will be used for compile\n\t  // right after this.\n\t  if (options) {\n\t    options._containerAttrs = extractAttrs(el);\n\t  }\n\t  // for template tags, what we want is its content as\n\t  // a documentFragment (for fragment instances)\n\t  if (isTemplate(el)) {\n\t    el = parseTemplate(el);\n\t  }\n\t  if (options) {\n\t    if (options._asComponent && !options.template) {\n\t      options.template = '<slot></slot>';\n\t    }\n\t    if (options.template) {\n\t      options._content = extractContent(el);\n\t      el = transcludeTemplate(el, options);\n\t    }\n\t  }\n\t  if (isFragment(el)) {\n\t    // anchors for fragment instance\n\t    // passing in `persist: true` to avoid them being\n\t    // discarded by IE during template cloning\n\t    prepend(createAnchor('v-start', true), el);\n\t    el.appendChild(createAnchor('v-end', true));\n\t  }\n\t  return el;\n\t}\n\t\n\t/**\n\t * Process the template option.\n\t * If the replace option is true this will swap the $el.\n\t *\n\t * @param {Element} el\n\t * @param {Object} options\n\t * @return {Element|DocumentFragment}\n\t */\n\t\n\tfunction transcludeTemplate(el, options) {\n\t  var template = options.template;\n\t  var frag = parseTemplate(template, true);\n\t  if (frag) {\n\t    var replacer = frag.firstChild;\n\t    var tag = replacer.tagName && replacer.tagName.toLowerCase();\n\t    if (options.replace) {\n\t      /* istanbul ignore if */\n\t      if (el === document.body) {\n\t        (\"production\") !== 'production' && warn('You are mounting an instance with a template to ' + '<body>. This will replace <body> entirely. You ' + 'should probably use `replace: false` here.');\n\t      }\n\t      // there are many cases where the instance must\n\t      // become a fragment instance: basically anything that\n\t      // can create more than 1 root nodes.\n\t      if (\n\t      // multi-children template\n\t      frag.childNodes.length > 1 ||\n\t      // non-element template\n\t      replacer.nodeType !== 1 ||\n\t      // single nested component\n\t      tag === 'component' || resolveAsset(options, 'components', tag) || hasBindAttr(replacer, 'is') ||\n\t      // element directive\n\t      resolveAsset(options, 'elementDirectives', tag) ||\n\t      // for block\n\t      replacer.hasAttribute('v-for') ||\n\t      // if block\n\t      replacer.hasAttribute('v-if')) {\n\t        return frag;\n\t      } else {\n\t        options._replacerAttrs = extractAttrs(replacer);\n\t        mergeAttrs(el, replacer);\n\t        return replacer;\n\t      }\n\t    } else {\n\t      el.appendChild(frag);\n\t      return el;\n\t    }\n\t  } else {\n\t    (\"production\") !== 'production' && warn('Invalid template option: ' + template);\n\t  }\n\t}\n\t\n\t/**\n\t * Helper to extract a component container's attributes\n\t * into a plain object array.\n\t *\n\t * @param {Element} el\n\t * @return {Array}\n\t */\n\t\n\tfunction extractAttrs(el) {\n\t  if (el.nodeType === 1 && el.hasAttributes()) {\n\t    return toArray(el.attributes);\n\t  }\n\t}\n\t\n\t/**\n\t * Merge the attributes of two elements, and make sure\n\t * the class names are merged properly.\n\t *\n\t * @param {Element} from\n\t * @param {Element} to\n\t */\n\t\n\tfunction mergeAttrs(from, to) {\n\t  var attrs = from.attributes;\n\t  var i = attrs.length;\n\t  var name, value;\n\t  while (i--) {\n\t    name = attrs[i].name;\n\t    value = attrs[i].value;\n\t    if (!to.hasAttribute(name) && !specialCharRE.test(name)) {\n\t      to.setAttribute(name, value);\n\t    } else if (name === 'class' && !parseText(value)) {\n\t      value.trim().split(/\\s+/).forEach(function (cls) {\n\t        addClass(to, cls);\n\t      });\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Scan and determine slot content distribution.\n\t * We do this during transclusion instead at compile time so that\n\t * the distribution is decoupled from the compilation order of\n\t * the slots.\n\t *\n\t * @param {Element|DocumentFragment} template\n\t * @param {Element} content\n\t * @param {Vue} vm\n\t */\n\t\n\tfunction resolveSlots(vm, content) {\n\t  if (!content) {\n\t    return;\n\t  }\n\t  var contents = vm._slotContents = Object.create(null);\n\t  var el, name;\n\t  for (var i = 0, l = content.children.length; i < l; i++) {\n\t    el = content.children[i];\n\t    /* eslint-disable no-cond-assign */\n\t    if (name = el.getAttribute('slot')) {\n\t      (contents[name] || (contents[name] = [])).push(el);\n\t    }\n\t    /* eslint-enable no-cond-assign */\n\t    if (false) {\n\t      warn('The \"slot\" attribute must be static.', vm.$parent);\n\t    }\n\t  }\n\t  for (name in contents) {\n\t    contents[name] = extractFragment(contents[name], content);\n\t  }\n\t  if (content.hasChildNodes()) {\n\t    contents['default'] = extractFragment(content.childNodes, content);\n\t  }\n\t}\n\t\n\t/**\n\t * Extract qualified content nodes from a node list.\n\t *\n\t * @param {NodeList} nodes\n\t * @return {DocumentFragment}\n\t */\n\t\n\tfunction extractFragment(nodes, parent) {\n\t  var frag = document.createDocumentFragment();\n\t  nodes = toArray(nodes);\n\t  for (var i = 0, l = nodes.length; i < l; i++) {\n\t    var node = nodes[i];\n\t    if (isTemplate(node) && !node.hasAttribute('v-if') && !node.hasAttribute('v-for')) {\n\t      parent.removeChild(node);\n\t      node = parseTemplate(node);\n\t    }\n\t    frag.appendChild(node);\n\t  }\n\t  return frag;\n\t}\n\t\n\t\n\t\n\tvar compiler = Object.freeze({\n\t\tcompile: compile,\n\t\tcompileAndLinkProps: compileAndLinkProps,\n\t\tcompileRoot: compileRoot,\n\t\ttransclude: transclude,\n\t\tresolveSlots: resolveSlots\n\t});\n\t\n\tfunction stateMixin (Vue) {\n\t  /**\n\t   * Accessor for `$data` property, since setting $data\n\t   * requires observing the new object and updating\n\t   * proxied properties.\n\t   */\n\t\n\t  Object.defineProperty(Vue.prototype, '$data', {\n\t    get: function get() {\n\t      return this._data;\n\t    },\n\t    set: function set(newData) {\n\t      if (newData !== this._data) {\n\t        this._setData(newData);\n\t      }\n\t    }\n\t  });\n\t\n\t  /**\n\t   * Setup the scope of an instance, which contains:\n\t   * - observed data\n\t   * - computed properties\n\t   * - user methods\n\t   * - meta properties\n\t   */\n\t\n\t  Vue.prototype._initState = function () {\n\t    this._initProps();\n\t    this._initMeta();\n\t    this._initMethods();\n\t    this._initData();\n\t    this._initComputed();\n\t  };\n\t\n\t  /**\n\t   * Initialize props.\n\t   */\n\t\n\t  Vue.prototype._initProps = function () {\n\t    var options = this.$options;\n\t    var el = options.el;\n\t    var props = options.props;\n\t    if (props && !el) {\n\t      (\"production\") !== 'production' && warn('Props will not be compiled if no `el` option is ' + 'provided at instantiation.', this);\n\t    }\n\t    // make sure to convert string selectors into element now\n\t    el = options.el = query(el);\n\t    this._propsUnlinkFn = el && el.nodeType === 1 && props\n\t    // props must be linked in proper scope if inside v-for\n\t    ? compileAndLinkProps(this, el, props, this._scope) : null;\n\t  };\n\t\n\t  /**\n\t   * Initialize the data.\n\t   */\n\t\n\t  Vue.prototype._initData = function () {\n\t    var dataFn = this.$options.data;\n\t    var data = this._data = dataFn ? dataFn() : {};\n\t    if (!isPlainObject(data)) {\n\t      data = {};\n\t      (\"production\") !== 'production' && warn('data functions should return an object.', this);\n\t    }\n\t    var props = this._props;\n\t    var runtimeData = this._runtimeData ? typeof this._runtimeData === 'function' ? this._runtimeData() : this._runtimeData : null;\n\t    // proxy data on instance\n\t    var keys = Object.keys(data);\n\t    var i, key;\n\t    i = keys.length;\n\t    while (i--) {\n\t      key = keys[i];\n\t      // there are two scenarios where we can proxy a data key:\n\t      // 1. it's not already defined as a prop\n\t      // 2. it's provided via a instantiation option AND there are no\n\t      //    template prop present\n\t      if (!props || !hasOwn(props, key) || runtimeData && hasOwn(runtimeData, key) && props[key].raw === null) {\n\t        this._proxy(key);\n\t      } else if (false) {\n\t        warn('Data field \"' + key + '\" is already defined ' + 'as a prop. Use prop default value instead.', this);\n\t      }\n\t    }\n\t    // observe data\n\t    observe(data, this);\n\t  };\n\t\n\t  /**\n\t   * Swap the instance's $data. Called in $data's setter.\n\t   *\n\t   * @param {Object} newData\n\t   */\n\t\n\t  Vue.prototype._setData = function (newData) {\n\t    newData = newData || {};\n\t    var oldData = this._data;\n\t    this._data = newData;\n\t    var keys, key, i;\n\t    // unproxy keys not present in new data\n\t    keys = Object.keys(oldData);\n\t    i = keys.length;\n\t    while (i--) {\n\t      key = keys[i];\n\t      if (!(key in newData)) {\n\t        this._unproxy(key);\n\t      }\n\t    }\n\t    // proxy keys not already proxied,\n\t    // and trigger change for changed values\n\t    keys = Object.keys(newData);\n\t    i = keys.length;\n\t    while (i--) {\n\t      key = keys[i];\n\t      if (!hasOwn(this, key)) {\n\t        // new property\n\t        this._proxy(key);\n\t      }\n\t    }\n\t    oldData.__ob__.removeVm(this);\n\t    observe(newData, this);\n\t    this._digest();\n\t  };\n\t\n\t  /**\n\t   * Proxy a property, so that\n\t   * vm.prop === vm._data.prop\n\t   *\n\t   * @param {String} key\n\t   */\n\t\n\t  Vue.prototype._proxy = function (key) {\n\t    if (!isReserved(key)) {\n\t      // need to store ref to self here\n\t      // because these getter/setters might\n\t      // be called by child scopes via\n\t      // prototype inheritance.\n\t      var self = this;\n\t      Object.defineProperty(self, key, {\n\t        configurable: true,\n\t        enumerable: true,\n\t        get: function proxyGetter() {\n\t          return self._data[key];\n\t        },\n\t        set: function proxySetter(val) {\n\t          self._data[key] = val;\n\t        }\n\t      });\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Unproxy a property.\n\t   *\n\t   * @param {String} key\n\t   */\n\t\n\t  Vue.prototype._unproxy = function (key) {\n\t    if (!isReserved(key)) {\n\t      delete this[key];\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Force update on every watcher in scope.\n\t   */\n\t\n\t  Vue.prototype._digest = function () {\n\t    for (var i = 0, l = this._watchers.length; i < l; i++) {\n\t      this._watchers[i].update(true); // shallow updates\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Setup computed properties. They are essentially\n\t   * special getter/setters\n\t   */\n\t\n\t  function noop() {}\n\t  Vue.prototype._initComputed = function () {\n\t    var computed = this.$options.computed;\n\t    if (computed) {\n\t      for (var key in computed) {\n\t        var userDef = computed[key];\n\t        var def = {\n\t          enumerable: true,\n\t          configurable: true\n\t        };\n\t        if (typeof userDef === 'function') {\n\t          def.get = makeComputedGetter(userDef, this);\n\t          def.set = noop;\n\t        } else {\n\t          def.get = userDef.get ? userDef.cache !== false ? makeComputedGetter(userDef.get, this) : bind(userDef.get, this) : noop;\n\t          def.set = userDef.set ? bind(userDef.set, this) : noop;\n\t        }\n\t        Object.defineProperty(this, key, def);\n\t      }\n\t    }\n\t  };\n\t\n\t  function makeComputedGetter(getter, owner) {\n\t    var watcher = new Watcher(owner, getter, null, {\n\t      lazy: true\n\t    });\n\t    return function computedGetter() {\n\t      if (watcher.dirty) {\n\t        watcher.evaluate();\n\t      }\n\t      if (Dep.target) {\n\t        watcher.depend();\n\t      }\n\t      return watcher.value;\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Setup instance methods. Methods must be bound to the\n\t   * instance since they might be passed down as a prop to\n\t   * child components.\n\t   */\n\t\n\t  Vue.prototype._initMethods = function () {\n\t    var methods = this.$options.methods;\n\t    if (methods) {\n\t      for (var key in methods) {\n\t        this[key] = bind(methods[key], this);\n\t      }\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Initialize meta information like $index, $key & $value.\n\t   */\n\t\n\t  Vue.prototype._initMeta = function () {\n\t    var metas = this.$options._meta;\n\t    if (metas) {\n\t      for (var key in metas) {\n\t        defineReactive(this, key, metas[key]);\n\t      }\n\t    }\n\t  };\n\t}\n\t\n\tvar eventRE = /^v-on:|^@/;\n\t\n\tfunction eventsMixin (Vue) {\n\t  /**\n\t   * Setup the instance's option events & watchers.\n\t   * If the value is a string, we pull it from the\n\t   * instance's methods by name.\n\t   */\n\t\n\t  Vue.prototype._initEvents = function () {\n\t    var options = this.$options;\n\t    if (options._asComponent) {\n\t      registerComponentEvents(this, options.el);\n\t    }\n\t    registerCallbacks(this, '$on', options.events);\n\t    registerCallbacks(this, '$watch', options.watch);\n\t  };\n\t\n\t  /**\n\t   * Register v-on events on a child component\n\t   *\n\t   * @param {Vue} vm\n\t   * @param {Element} el\n\t   */\n\t\n\t  function registerComponentEvents(vm, el) {\n\t    var attrs = el.attributes;\n\t    var name, handler;\n\t    for (var i = 0, l = attrs.length; i < l; i++) {\n\t      name = attrs[i].name;\n\t      if (eventRE.test(name)) {\n\t        name = name.replace(eventRE, '');\n\t        handler = (vm._scope || vm._context).$eval(attrs[i].value, true);\n\t        if (typeof handler === 'function') {\n\t          handler._fromParent = true;\n\t          vm.$on(name.replace(eventRE), handler);\n\t        } else if (false) {\n\t          warn('v-on:' + name + '=\"' + attrs[i].value + '\" ' + 'expects a function value, got ' + handler, vm);\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Register callbacks for option events and watchers.\n\t   *\n\t   * @param {Vue} vm\n\t   * @param {String} action\n\t   * @param {Object} hash\n\t   */\n\t\n\t  function registerCallbacks(vm, action, hash) {\n\t    if (!hash) return;\n\t    var handlers, key, i, j;\n\t    for (key in hash) {\n\t      handlers = hash[key];\n\t      if (isArray(handlers)) {\n\t        for (i = 0, j = handlers.length; i < j; i++) {\n\t          register(vm, action, key, handlers[i]);\n\t        }\n\t      } else {\n\t        register(vm, action, key, handlers);\n\t      }\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Helper to register an event/watch callback.\n\t   *\n\t   * @param {Vue} vm\n\t   * @param {String} action\n\t   * @param {String} key\n\t   * @param {Function|String|Object} handler\n\t   * @param {Object} [options]\n\t   */\n\t\n\t  function register(vm, action, key, handler, options) {\n\t    var type = typeof handler;\n\t    if (type === 'function') {\n\t      vm[action](key, handler, options);\n\t    } else if (type === 'string') {\n\t      var methods = vm.$options.methods;\n\t      var method = methods && methods[handler];\n\t      if (method) {\n\t        vm[action](key, method, options);\n\t      } else {\n\t        (\"production\") !== 'production' && warn('Unknown method: \"' + handler + '\" when ' + 'registering callback for ' + action + ': \"' + key + '\".', vm);\n\t      }\n\t    } else if (handler && type === 'object') {\n\t      register(vm, action, key, handler.handler, handler);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Setup recursive attached/detached calls\n\t   */\n\t\n\t  Vue.prototype._initDOMHooks = function () {\n\t    this.$on('hook:attached', onAttached);\n\t    this.$on('hook:detached', onDetached);\n\t  };\n\t\n\t  /**\n\t   * Callback to recursively call attached hook on children\n\t   */\n\t\n\t  function onAttached() {\n\t    if (!this._isAttached) {\n\t      this._isAttached = true;\n\t      this.$children.forEach(callAttach);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Iterator to call attached hook\n\t   *\n\t   * @param {Vue} child\n\t   */\n\t\n\t  function callAttach(child) {\n\t    if (!child._isAttached && inDoc(child.$el)) {\n\t      child._callHook('attached');\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Callback to recursively call detached hook on children\n\t   */\n\t\n\t  function onDetached() {\n\t    if (this._isAttached) {\n\t      this._isAttached = false;\n\t      this.$children.forEach(callDetach);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Iterator to call detached hook\n\t   *\n\t   * @param {Vue} child\n\t   */\n\t\n\t  function callDetach(child) {\n\t    if (child._isAttached && !inDoc(child.$el)) {\n\t      child._callHook('detached');\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Trigger all handlers for a hook\n\t   *\n\t   * @param {String} hook\n\t   */\n\t\n\t  Vue.prototype._callHook = function (hook) {\n\t    this.$emit('pre-hook:' + hook);\n\t    var handlers = this.$options[hook];\n\t    if (handlers) {\n\t      for (var i = 0, j = handlers.length; i < j; i++) {\n\t        handlers[i].call(this);\n\t      }\n\t    }\n\t    this.$emit('hook:' + hook);\n\t  };\n\t}\n\t\n\tfunction noop() {}\n\t\n\t/**\n\t * A directive links a DOM element with a piece of data,\n\t * which is the result of evaluating an expression.\n\t * It registers a watcher with the expression and calls\n\t * the DOM update function when a change is triggered.\n\t *\n\t * @param {Object} descriptor\n\t *                 - {String} name\n\t *                 - {Object} def\n\t *                 - {String} expression\n\t *                 - {Array<Object>} [filters]\n\t *                 - {Object} [modifiers]\n\t *                 - {Boolean} literal\n\t *                 - {String} attr\n\t *                 - {String} arg\n\t *                 - {String} raw\n\t *                 - {String} [ref]\n\t *                 - {Array<Object>} [interp]\n\t *                 - {Boolean} [hasOneTime]\n\t * @param {Vue} vm\n\t * @param {Node} el\n\t * @param {Vue} [host] - transclusion host component\n\t * @param {Object} [scope] - v-for scope\n\t * @param {Fragment} [frag] - owner fragment\n\t * @constructor\n\t */\n\tfunction Directive(descriptor, vm, el, host, scope, frag) {\n\t  this.vm = vm;\n\t  this.el = el;\n\t  // copy descriptor properties\n\t  this.descriptor = descriptor;\n\t  this.name = descriptor.name;\n\t  this.expression = descriptor.expression;\n\t  this.arg = descriptor.arg;\n\t  this.modifiers = descriptor.modifiers;\n\t  this.filters = descriptor.filters;\n\t  this.literal = this.modifiers && this.modifiers.literal;\n\t  // private\n\t  this._locked = false;\n\t  this._bound = false;\n\t  this._listeners = null;\n\t  // link context\n\t  this._host = host;\n\t  this._scope = scope;\n\t  this._frag = frag;\n\t  // store directives on node in dev mode\n\t  if (false) {\n\t    this.el._vue_directives = this.el._vue_directives || [];\n\t    this.el._vue_directives.push(this);\n\t  }\n\t}\n\t\n\t/**\n\t * Initialize the directive, mixin definition properties,\n\t * setup the watcher, call definition bind() and update()\n\t * if present.\n\t */\n\t\n\tDirective.prototype._bind = function () {\n\t  var name = this.name;\n\t  var descriptor = this.descriptor;\n\t\n\t  // remove attribute\n\t  if ((name !== 'cloak' || this.vm._isCompiled) && this.el && this.el.removeAttribute) {\n\t    var attr = descriptor.attr || 'v-' + name;\n\t    this.el.removeAttribute(attr);\n\t  }\n\t\n\t  // copy def properties\n\t  var def = descriptor.def;\n\t  if (typeof def === 'function') {\n\t    this.update = def;\n\t  } else {\n\t    extend(this, def);\n\t  }\n\t\n\t  // setup directive params\n\t  this._setupParams();\n\t\n\t  // initial bind\n\t  if (this.bind) {\n\t    this.bind();\n\t  }\n\t  this._bound = true;\n\t\n\t  if (this.literal) {\n\t    this.update && this.update(descriptor.raw);\n\t  } else if ((this.expression || this.modifiers) && (this.update || this.twoWay) && !this._checkStatement()) {\n\t    // wrapped updater for context\n\t    var dir = this;\n\t    if (this.update) {\n\t      this._update = function (val, oldVal) {\n\t        if (!dir._locked) {\n\t          dir.update(val, oldVal);\n\t        }\n\t      };\n\t    } else {\n\t      this._update = noop;\n\t    }\n\t    var preProcess = this._preProcess ? bind(this._preProcess, this) : null;\n\t    var postProcess = this._postProcess ? bind(this._postProcess, this) : null;\n\t    var watcher = this._watcher = new Watcher(this.vm, this.expression, this._update, // callback\n\t    {\n\t      filters: this.filters,\n\t      twoWay: this.twoWay,\n\t      deep: this.deep,\n\t      preProcess: preProcess,\n\t      postProcess: postProcess,\n\t      scope: this._scope\n\t    });\n\t    // v-model with inital inline value need to sync back to\n\t    // model instead of update to DOM on init. They would\n\t    // set the afterBind hook to indicate that.\n\t    if (this.afterBind) {\n\t      this.afterBind();\n\t    } else if (this.update) {\n\t      this.update(watcher.value);\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Setup all param attributes, e.g. track-by,\n\t * transition-mode, etc...\n\t */\n\t\n\tDirective.prototype._setupParams = function () {\n\t  if (!this.params) {\n\t    return;\n\t  }\n\t  var params = this.params;\n\t  // swap the params array with a fresh object.\n\t  this.params = Object.create(null);\n\t  var i = params.length;\n\t  var key, val, mappedKey;\n\t  while (i--) {\n\t    key = hyphenate(params[i]);\n\t    mappedKey = camelize(key);\n\t    val = getBindAttr(this.el, key);\n\t    if (val != null) {\n\t      // dynamic\n\t      this._setupParamWatcher(mappedKey, val);\n\t    } else {\n\t      // static\n\t      val = getAttr(this.el, key);\n\t      if (val != null) {\n\t        this.params[mappedKey] = val === '' ? true : val;\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Setup a watcher for a dynamic param.\n\t *\n\t * @param {String} key\n\t * @param {String} expression\n\t */\n\t\n\tDirective.prototype._setupParamWatcher = function (key, expression) {\n\t  var self = this;\n\t  var called = false;\n\t  var unwatch = (this._scope || this.vm).$watch(expression, function (val, oldVal) {\n\t    self.params[key] = val;\n\t    // since we are in immediate mode,\n\t    // only call the param change callbacks if this is not the first update.\n\t    if (called) {\n\t      var cb = self.paramWatchers && self.paramWatchers[key];\n\t      if (cb) {\n\t        cb.call(self, val, oldVal);\n\t      }\n\t    } else {\n\t      called = true;\n\t    }\n\t  }, {\n\t    immediate: true,\n\t    user: false\n\t  });(this._paramUnwatchFns || (this._paramUnwatchFns = [])).push(unwatch);\n\t};\n\t\n\t/**\n\t * Check if the directive is a function caller\n\t * and if the expression is a callable one. If both true,\n\t * we wrap up the expression and use it as the event\n\t * handler.\n\t *\n\t * e.g. on-click=\"a++\"\n\t *\n\t * @return {Boolean}\n\t */\n\t\n\tDirective.prototype._checkStatement = function () {\n\t  var expression = this.expression;\n\t  if (expression && this.acceptStatement && !isSimplePath(expression)) {\n\t    var fn = parseExpression(expression).get;\n\t    var scope = this._scope || this.vm;\n\t    var handler = function handler(e) {\n\t      scope.$event = e;\n\t      fn.call(scope, scope);\n\t      scope.$event = null;\n\t    };\n\t    if (this.filters) {\n\t      handler = scope._applyFilters(handler, null, this.filters);\n\t    }\n\t    this.update(handler);\n\t    return true;\n\t  }\n\t};\n\t\n\t/**\n\t * Set the corresponding value with the setter.\n\t * This should only be used in two-way directives\n\t * e.g. v-model.\n\t *\n\t * @param {*} value\n\t * @public\n\t */\n\t\n\tDirective.prototype.set = function (value) {\n\t  /* istanbul ignore else */\n\t  if (this.twoWay) {\n\t    this._withLock(function () {\n\t      this._watcher.set(value);\n\t    });\n\t  } else if (false) {\n\t    warn('Directive.set() can only be used inside twoWay' + 'directives.');\n\t  }\n\t};\n\t\n\t/**\n\t * Execute a function while preventing that function from\n\t * triggering updates on this directive instance.\n\t *\n\t * @param {Function} fn\n\t */\n\t\n\tDirective.prototype._withLock = function (fn) {\n\t  var self = this;\n\t  self._locked = true;\n\t  fn.call(self);\n\t  nextTick(function () {\n\t    self._locked = false;\n\t  });\n\t};\n\t\n\t/**\n\t * Convenience method that attaches a DOM event listener\n\t * to the directive element and autometically tears it down\n\t * during unbind.\n\t *\n\t * @param {String} event\n\t * @param {Function} handler\n\t * @param {Boolean} [useCapture]\n\t */\n\t\n\tDirective.prototype.on = function (event, handler, useCapture) {\n\t  on(this.el, event, handler, useCapture);(this._listeners || (this._listeners = [])).push([event, handler]);\n\t};\n\t\n\t/**\n\t * Teardown the watcher and call unbind.\n\t */\n\t\n\tDirective.prototype._teardown = function () {\n\t  if (this._bound) {\n\t    this._bound = false;\n\t    if (this.unbind) {\n\t      this.unbind();\n\t    }\n\t    if (this._watcher) {\n\t      this._watcher.teardown();\n\t    }\n\t    var listeners = this._listeners;\n\t    var i;\n\t    if (listeners) {\n\t      i = listeners.length;\n\t      while (i--) {\n\t        off(this.el, listeners[i][0], listeners[i][1]);\n\t      }\n\t    }\n\t    var unwatchFns = this._paramUnwatchFns;\n\t    if (unwatchFns) {\n\t      i = unwatchFns.length;\n\t      while (i--) {\n\t        unwatchFns[i]();\n\t      }\n\t    }\n\t    if (false) {\n\t      this.el._vue_directives.$remove(this);\n\t    }\n\t    this.vm = this.el = this._watcher = this._listeners = null;\n\t  }\n\t};\n\t\n\tfunction lifecycleMixin (Vue) {\n\t  /**\n\t   * Update v-ref for component.\n\t   *\n\t   * @param {Boolean} remove\n\t   */\n\t\n\t  Vue.prototype._updateRef = function (remove) {\n\t    var ref = this.$options._ref;\n\t    if (ref) {\n\t      var refs = (this._scope || this._context).$refs;\n\t      if (remove) {\n\t        if (refs[ref] === this) {\n\t          refs[ref] = null;\n\t        }\n\t      } else {\n\t        refs[ref] = this;\n\t      }\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Transclude, compile and link element.\n\t   *\n\t   * If a pre-compiled linker is available, that means the\n\t   * passed in element will be pre-transcluded and compiled\n\t   * as well - all we need to do is to call the linker.\n\t   *\n\t   * Otherwise we need to call transclude/compile/link here.\n\t   *\n\t   * @param {Element} el\n\t   */\n\t\n\t  Vue.prototype._compile = function (el) {\n\t    var options = this.$options;\n\t\n\t    // transclude and init element\n\t    // transclude can potentially replace original\n\t    // so we need to keep reference; this step also injects\n\t    // the template and caches the original attributes\n\t    // on the container node and replacer node.\n\t    var original = el;\n\t    el = transclude(el, options);\n\t    this._initElement(el);\n\t\n\t    // handle v-pre on root node (#2026)\n\t    if (el.nodeType === 1 && getAttr(el, 'v-pre') !== null) {\n\t      return;\n\t    }\n\t\n\t    // root is always compiled per-instance, because\n\t    // container attrs and props can be different every time.\n\t    var contextOptions = this._context && this._context.$options;\n\t    var rootLinker = compileRoot(el, options, contextOptions);\n\t\n\t    // resolve slot distribution\n\t    resolveSlots(this, options._content);\n\t\n\t    // compile and link the rest\n\t    var contentLinkFn;\n\t    var ctor = this.constructor;\n\t    // component compilation can be cached\n\t    // as long as it's not using inline-template\n\t    if (options._linkerCachable) {\n\t      contentLinkFn = ctor.linker;\n\t      if (!contentLinkFn) {\n\t        contentLinkFn = ctor.linker = compile(el, options);\n\t      }\n\t    }\n\t\n\t    // link phase\n\t    // make sure to link root with prop scope!\n\t    var rootUnlinkFn = rootLinker(this, el, this._scope);\n\t    var contentUnlinkFn = contentLinkFn ? contentLinkFn(this, el) : compile(el, options)(this, el);\n\t\n\t    // register composite unlink function\n\t    // to be called during instance destruction\n\t    this._unlinkFn = function () {\n\t      rootUnlinkFn();\n\t      // passing destroying: true to avoid searching and\n\t      // splicing the directives\n\t      contentUnlinkFn(true);\n\t    };\n\t\n\t    // finally replace original\n\t    if (options.replace) {\n\t      replace(original, el);\n\t    }\n\t\n\t    this._isCompiled = true;\n\t    this._callHook('compiled');\n\t  };\n\t\n\t  /**\n\t   * Initialize instance element. Called in the public\n\t   * $mount() method.\n\t   *\n\t   * @param {Element} el\n\t   */\n\t\n\t  Vue.prototype._initElement = function (el) {\n\t    if (isFragment(el)) {\n\t      this._isFragment = true;\n\t      this.$el = this._fragmentStart = el.firstChild;\n\t      this._fragmentEnd = el.lastChild;\n\t      // set persisted text anchors to empty\n\t      if (this._fragmentStart.nodeType === 3) {\n\t        this._fragmentStart.data = this._fragmentEnd.data = '';\n\t      }\n\t      this._fragment = el;\n\t    } else {\n\t      this.$el = el;\n\t    }\n\t    this.$el.__vue__ = this;\n\t    this._callHook('beforeCompile');\n\t  };\n\t\n\t  /**\n\t   * Create and bind a directive to an element.\n\t   *\n\t   * @param {Object} descriptor - parsed directive descriptor\n\t   * @param {Node} node   - target node\n\t   * @param {Vue} [host] - transclusion host component\n\t   * @param {Object} [scope] - v-for scope\n\t   * @param {Fragment} [frag] - owner fragment\n\t   */\n\t\n\t  Vue.prototype._bindDir = function (descriptor, node, host, scope, frag) {\n\t    this._directives.push(new Directive(descriptor, this, node, host, scope, frag));\n\t  };\n\t\n\t  /**\n\t   * Teardown an instance, unobserves the data, unbind all the\n\t   * directives, turn off all the event listeners, etc.\n\t   *\n\t   * @param {Boolean} remove - whether to remove the DOM node.\n\t   * @param {Boolean} deferCleanup - if true, defer cleanup to\n\t   *                                 be called later\n\t   */\n\t\n\t  Vue.prototype._destroy = function (remove, deferCleanup) {\n\t    if (this._isBeingDestroyed) {\n\t      if (!deferCleanup) {\n\t        this._cleanup();\n\t      }\n\t      return;\n\t    }\n\t\n\t    var destroyReady;\n\t    var pendingRemoval;\n\t\n\t    var self = this;\n\t    // Cleanup should be called either synchronously or asynchronoysly as\n\t    // callback of this.$remove(), or if remove and deferCleanup are false.\n\t    // In any case it should be called after all other removing, unbinding and\n\t    // turning of is done\n\t    var cleanupIfPossible = function cleanupIfPossible() {\n\t      if (destroyReady && !pendingRemoval && !deferCleanup) {\n\t        self._cleanup();\n\t      }\n\t    };\n\t\n\t    // remove DOM element\n\t    if (remove && this.$el) {\n\t      pendingRemoval = true;\n\t      this.$remove(function () {\n\t        pendingRemoval = false;\n\t        cleanupIfPossible();\n\t      });\n\t    }\n\t\n\t    this._callHook('beforeDestroy');\n\t    this._isBeingDestroyed = true;\n\t    var i;\n\t    // remove self from parent. only necessary\n\t    // if parent is not being destroyed as well.\n\t    var parent = this.$parent;\n\t    if (parent && !parent._isBeingDestroyed) {\n\t      parent.$children.$remove(this);\n\t      // unregister ref (remove: true)\n\t      this._updateRef(true);\n\t    }\n\t    // destroy all children.\n\t    i = this.$children.length;\n\t    while (i--) {\n\t      this.$children[i].$destroy();\n\t    }\n\t    // teardown props\n\t    if (this._propsUnlinkFn) {\n\t      this._propsUnlinkFn();\n\t    }\n\t    // teardown all directives. this also tearsdown all\n\t    // directive-owned watchers.\n\t    if (this._unlinkFn) {\n\t      this._unlinkFn();\n\t    }\n\t    i = this._watchers.length;\n\t    while (i--) {\n\t      this._watchers[i].teardown();\n\t    }\n\t    // remove reference to self on $el\n\t    if (this.$el) {\n\t      this.$el.__vue__ = null;\n\t    }\n\t\n\t    destroyReady = true;\n\t    cleanupIfPossible();\n\t  };\n\t\n\t  /**\n\t   * Clean up to ensure garbage collection.\n\t   * This is called after the leave transition if there\n\t   * is any.\n\t   */\n\t\n\t  Vue.prototype._cleanup = function () {\n\t    if (this._isDestroyed) {\n\t      return;\n\t    }\n\t    // remove self from owner fragment\n\t    // do it in cleanup so that we can call $destroy with\n\t    // defer right when a fragment is about to be removed.\n\t    if (this._frag) {\n\t      this._frag.children.$remove(this);\n\t    }\n\t    // remove reference from data ob\n\t    // frozen object may not have observer.\n\t    if (this._data.__ob__) {\n\t      this._data.__ob__.removeVm(this);\n\t    }\n\t    // Clean up references to private properties and other\n\t    // instances. preserve reference to _data so that proxy\n\t    // accessors still work. The only potential side effect\n\t    // here is that mutating the instance after it's destroyed\n\t    // may affect the state of other components that are still\n\t    // observing the same object, but that seems to be a\n\t    // reasonable responsibility for the user rather than\n\t    // always throwing an error on them.\n\t    this.$el = this.$parent = this.$root = this.$children = this._watchers = this._context = this._scope = this._directives = null;\n\t    // call the last hook...\n\t    this._isDestroyed = true;\n\t    this._callHook('destroyed');\n\t    // turn off all instance listeners.\n\t    this.$off();\n\t  };\n\t}\n\t\n\tfunction miscMixin (Vue) {\n\t  /**\n\t   * Apply a list of filter (descriptors) to a value.\n\t   * Using plain for loops here because this will be called in\n\t   * the getter of any watcher with filters so it is very\n\t   * performance sensitive.\n\t   *\n\t   * @param {*} value\n\t   * @param {*} [oldValue]\n\t   * @param {Array} filters\n\t   * @param {Boolean} write\n\t   * @return {*}\n\t   */\n\t\n\t  Vue.prototype._applyFilters = function (value, oldValue, filters, write) {\n\t    var filter, fn, args, arg, offset, i, l, j, k;\n\t    for (i = 0, l = filters.length; i < l; i++) {\n\t      filter = filters[write ? l - i - 1 : i];\n\t      fn = resolveAsset(this.$options, 'filters', filter.name, true);\n\t      if (!fn) continue;\n\t      fn = write ? fn.write : fn.read || fn;\n\t      if (typeof fn !== 'function') continue;\n\t      args = write ? [value, oldValue] : [value];\n\t      offset = write ? 2 : 1;\n\t      if (filter.args) {\n\t        for (j = 0, k = filter.args.length; j < k; j++) {\n\t          arg = filter.args[j];\n\t          args[j + offset] = arg.dynamic ? this.$get(arg.value) : arg.value;\n\t        }\n\t      }\n\t      value = fn.apply(this, args);\n\t    }\n\t    return value;\n\t  };\n\t\n\t  /**\n\t   * Resolve a component, depending on whether the component\n\t   * is defined normally or using an async factory function.\n\t   * Resolves synchronously if already resolved, otherwise\n\t   * resolves asynchronously and caches the resolved\n\t   * constructor on the factory.\n\t   *\n\t   * @param {String|Function} value\n\t   * @param {Function} cb\n\t   */\n\t\n\t  Vue.prototype._resolveComponent = function (value, cb) {\n\t    var factory;\n\t    if (typeof value === 'function') {\n\t      factory = value;\n\t    } else {\n\t      factory = resolveAsset(this.$options, 'components', value, true);\n\t    }\n\t    if (!factory) {\n\t      return;\n\t    }\n\t    // async component factory\n\t    if (!factory.options) {\n\t      if (factory.resolved) {\n\t        // cached\n\t        cb(factory.resolved);\n\t      } else if (factory.requested) {\n\t        // pool callbacks\n\t        factory.pendingCallbacks.push(cb);\n\t      } else {\n\t        factory.requested = true;\n\t        var cbs = factory.pendingCallbacks = [cb];\n\t        factory.call(this, function resolve(res) {\n\t          if (isPlainObject(res)) {\n\t            res = Vue.extend(res);\n\t          }\n\t          // cache resolved\n\t          factory.resolved = res;\n\t          // invoke callbacks\n\t          for (var i = 0, l = cbs.length; i < l; i++) {\n\t            cbs[i](res);\n\t          }\n\t        }, function reject(reason) {\n\t          (\"production\") !== 'production' && warn('Failed to resolve async component' + (typeof value === 'string' ? ': ' + value : '') + '. ' + (reason ? '\\nReason: ' + reason : ''));\n\t        });\n\t      }\n\t    } else {\n\t      // normal component\n\t      cb(factory);\n\t    }\n\t  };\n\t}\n\t\n\tvar filterRE$1 = /[^|]\\|[^|]/;\n\t\n\tfunction dataAPI (Vue) {\n\t  /**\n\t   * Get the value from an expression on this vm.\n\t   *\n\t   * @param {String} exp\n\t   * @param {Boolean} [asStatement]\n\t   * @return {*}\n\t   */\n\t\n\t  Vue.prototype.$get = function (exp, asStatement) {\n\t    var res = parseExpression(exp);\n\t    if (res) {\n\t      if (asStatement && !isSimplePath(exp)) {\n\t        var self = this;\n\t        return function statementHandler() {\n\t          self.$arguments = toArray(arguments);\n\t          var result = res.get.call(self, self);\n\t          self.$arguments = null;\n\t          return result;\n\t        };\n\t      } else {\n\t        try {\n\t          return res.get.call(this, this);\n\t        } catch (e) {}\n\t      }\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Set the value from an expression on this vm.\n\t   * The expression must be a valid left-hand\n\t   * expression in an assignment.\n\t   *\n\t   * @param {String} exp\n\t   * @param {*} val\n\t   */\n\t\n\t  Vue.prototype.$set = function (exp, val) {\n\t    var res = parseExpression(exp, true);\n\t    if (res && res.set) {\n\t      res.set.call(this, this, val);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Delete a property on the VM\n\t   *\n\t   * @param {String} key\n\t   */\n\t\n\t  Vue.prototype.$delete = function (key) {\n\t    del(this._data, key);\n\t  };\n\t\n\t  /**\n\t   * Watch an expression, trigger callback when its\n\t   * value changes.\n\t   *\n\t   * @param {String|Function} expOrFn\n\t   * @param {Function} cb\n\t   * @param {Object} [options]\n\t   *                 - {Boolean} deep\n\t   *                 - {Boolean} immediate\n\t   * @return {Function} - unwatchFn\n\t   */\n\t\n\t  Vue.prototype.$watch = function (expOrFn, cb, options) {\n\t    var vm = this;\n\t    var parsed;\n\t    if (typeof expOrFn === 'string') {\n\t      parsed = parseDirective(expOrFn);\n\t      expOrFn = parsed.expression;\n\t    }\n\t    var watcher = new Watcher(vm, expOrFn, cb, {\n\t      deep: options && options.deep,\n\t      sync: options && options.sync,\n\t      filters: parsed && parsed.filters,\n\t      user: !options || options.user !== false\n\t    });\n\t    if (options && options.immediate) {\n\t      cb.call(vm, watcher.value);\n\t    }\n\t    return function unwatchFn() {\n\t      watcher.teardown();\n\t    };\n\t  };\n\t\n\t  /**\n\t   * Evaluate a text directive, including filters.\n\t   *\n\t   * @param {String} text\n\t   * @param {Boolean} [asStatement]\n\t   * @return {String}\n\t   */\n\t\n\t  Vue.prototype.$eval = function (text, asStatement) {\n\t    // check for filters.\n\t    if (filterRE$1.test(text)) {\n\t      var dir = parseDirective(text);\n\t      // the filter regex check might give false positive\n\t      // for pipes inside strings, so it's possible that\n\t      // we don't get any filters here\n\t      var val = this.$get(dir.expression, asStatement);\n\t      return dir.filters ? this._applyFilters(val, null, dir.filters) : val;\n\t    } else {\n\t      // no filter\n\t      return this.$get(text, asStatement);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Interpolate a piece of template text.\n\t   *\n\t   * @param {String} text\n\t   * @return {String}\n\t   */\n\t\n\t  Vue.prototype.$interpolate = function (text) {\n\t    var tokens = parseText(text);\n\t    var vm = this;\n\t    if (tokens) {\n\t      if (tokens.length === 1) {\n\t        return vm.$eval(tokens[0].value) + '';\n\t      } else {\n\t        return tokens.map(function (token) {\n\t          return token.tag ? vm.$eval(token.value) : token.value;\n\t        }).join('');\n\t      }\n\t    } else {\n\t      return text;\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Log instance data as a plain JS object\n\t   * so that it is easier to inspect in console.\n\t   * This method assumes console is available.\n\t   *\n\t   * @param {String} [path]\n\t   */\n\t\n\t  Vue.prototype.$log = function (path) {\n\t    var data = path ? getPath(this._data, path) : this._data;\n\t    if (data) {\n\t      data = clean(data);\n\t    }\n\t    // include computed fields\n\t    if (!path) {\n\t      var key;\n\t      for (key in this.$options.computed) {\n\t        data[key] = clean(this[key]);\n\t      }\n\t      if (this._props) {\n\t        for (key in this._props) {\n\t          data[key] = clean(this[key]);\n\t        }\n\t      }\n\t    }\n\t    console.log(data);\n\t  };\n\t\n\t  /**\n\t   * \"clean\" a getter/setter converted object into a plain\n\t   * object copy.\n\t   *\n\t   * @param {Object} - obj\n\t   * @return {Object}\n\t   */\n\t\n\t  function clean(obj) {\n\t    return JSON.parse(JSON.stringify(obj));\n\t  }\n\t}\n\t\n\tfunction domAPI (Vue) {\n\t  /**\n\t   * Convenience on-instance nextTick. The callback is\n\t   * auto-bound to the instance, and this avoids component\n\t   * modules having to rely on the global Vue.\n\t   *\n\t   * @param {Function} fn\n\t   */\n\t\n\t  Vue.prototype.$nextTick = function (fn) {\n\t    nextTick(fn, this);\n\t  };\n\t\n\t  /**\n\t   * Append instance to target\n\t   *\n\t   * @param {Node} target\n\t   * @param {Function} [cb]\n\t   * @param {Boolean} [withTransition] - defaults to true\n\t   */\n\t\n\t  Vue.prototype.$appendTo = function (target, cb, withTransition) {\n\t    return insert(this, target, cb, withTransition, append, appendWithTransition);\n\t  };\n\t\n\t  /**\n\t   * Prepend instance to target\n\t   *\n\t   * @param {Node} target\n\t   * @param {Function} [cb]\n\t   * @param {Boolean} [withTransition] - defaults to true\n\t   */\n\t\n\t  Vue.prototype.$prependTo = function (target, cb, withTransition) {\n\t    target = query(target);\n\t    if (target.hasChildNodes()) {\n\t      this.$before(target.firstChild, cb, withTransition);\n\t    } else {\n\t      this.$appendTo(target, cb, withTransition);\n\t    }\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Insert instance before target\n\t   *\n\t   * @param {Node} target\n\t   * @param {Function} [cb]\n\t   * @param {Boolean} [withTransition] - defaults to true\n\t   */\n\t\n\t  Vue.prototype.$before = function (target, cb, withTransition) {\n\t    return insert(this, target, cb, withTransition, beforeWithCb, beforeWithTransition);\n\t  };\n\t\n\t  /**\n\t   * Insert instance after target\n\t   *\n\t   * @param {Node} target\n\t   * @param {Function} [cb]\n\t   * @param {Boolean} [withTransition] - defaults to true\n\t   */\n\t\n\t  Vue.prototype.$after = function (target, cb, withTransition) {\n\t    target = query(target);\n\t    if (target.nextSibling) {\n\t      this.$before(target.nextSibling, cb, withTransition);\n\t    } else {\n\t      this.$appendTo(target.parentNode, cb, withTransition);\n\t    }\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Remove instance from DOM\n\t   *\n\t   * @param {Function} [cb]\n\t   * @param {Boolean} [withTransition] - defaults to true\n\t   */\n\t\n\t  Vue.prototype.$remove = function (cb, withTransition) {\n\t    if (!this.$el.parentNode) {\n\t      return cb && cb();\n\t    }\n\t    var inDocument = this._isAttached && inDoc(this.$el);\n\t    // if we are not in document, no need to check\n\t    // for transitions\n\t    if (!inDocument) withTransition = false;\n\t    var self = this;\n\t    var realCb = function realCb() {\n\t      if (inDocument) self._callHook('detached');\n\t      if (cb) cb();\n\t    };\n\t    if (this._isFragment) {\n\t      removeNodeRange(this._fragmentStart, this._fragmentEnd, this, this._fragment, realCb);\n\t    } else {\n\t      var op = withTransition === false ? removeWithCb : removeWithTransition;\n\t      op(this.$el, this, realCb);\n\t    }\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Shared DOM insertion function.\n\t   *\n\t   * @param {Vue} vm\n\t   * @param {Element} target\n\t   * @param {Function} [cb]\n\t   * @param {Boolean} [withTransition]\n\t   * @param {Function} op1 - op for non-transition insert\n\t   * @param {Function} op2 - op for transition insert\n\t   * @return vm\n\t   */\n\t\n\t  function insert(vm, target, cb, withTransition, op1, op2) {\n\t    target = query(target);\n\t    var targetIsDetached = !inDoc(target);\n\t    var op = withTransition === false || targetIsDetached ? op1 : op2;\n\t    var shouldCallHook = !targetIsDetached && !vm._isAttached && !inDoc(vm.$el);\n\t    if (vm._isFragment) {\n\t      mapNodeRange(vm._fragmentStart, vm._fragmentEnd, function (node) {\n\t        op(node, target, vm);\n\t      });\n\t      cb && cb();\n\t    } else {\n\t      op(vm.$el, target, vm, cb);\n\t    }\n\t    if (shouldCallHook) {\n\t      vm._callHook('attached');\n\t    }\n\t    return vm;\n\t  }\n\t\n\t  /**\n\t   * Check for selectors\n\t   *\n\t   * @param {String|Element} el\n\t   */\n\t\n\t  function query(el) {\n\t    return typeof el === 'string' ? document.querySelector(el) : el;\n\t  }\n\t\n\t  /**\n\t   * Append operation that takes a callback.\n\t   *\n\t   * @param {Node} el\n\t   * @param {Node} target\n\t   * @param {Vue} vm - unused\n\t   * @param {Function} [cb]\n\t   */\n\t\n\t  function append(el, target, vm, cb) {\n\t    target.appendChild(el);\n\t    if (cb) cb();\n\t  }\n\t\n\t  /**\n\t   * InsertBefore operation that takes a callback.\n\t   *\n\t   * @param {Node} el\n\t   * @param {Node} target\n\t   * @param {Vue} vm - unused\n\t   * @param {Function} [cb]\n\t   */\n\t\n\t  function beforeWithCb(el, target, vm, cb) {\n\t    before(el, target);\n\t    if (cb) cb();\n\t  }\n\t\n\t  /**\n\t   * Remove operation that takes a callback.\n\t   *\n\t   * @param {Node} el\n\t   * @param {Vue} vm - unused\n\t   * @param {Function} [cb]\n\t   */\n\t\n\t  function removeWithCb(el, vm, cb) {\n\t    remove(el);\n\t    if (cb) cb();\n\t  }\n\t}\n\t\n\tfunction eventsAPI (Vue) {\n\t  /**\n\t   * Listen on the given `event` with `fn`.\n\t   *\n\t   * @param {String} event\n\t   * @param {Function} fn\n\t   */\n\t\n\t  Vue.prototype.$on = function (event, fn) {\n\t    (this._events[event] || (this._events[event] = [])).push(fn);\n\t    modifyListenerCount(this, event, 1);\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Adds an `event` listener that will be invoked a single\n\t   * time then automatically removed.\n\t   *\n\t   * @param {String} event\n\t   * @param {Function} fn\n\t   */\n\t\n\t  Vue.prototype.$once = function (event, fn) {\n\t    var self = this;\n\t    function on() {\n\t      self.$off(event, on);\n\t      fn.apply(this, arguments);\n\t    }\n\t    on.fn = fn;\n\t    this.$on(event, on);\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Remove the given callback for `event` or all\n\t   * registered callbacks.\n\t   *\n\t   * @param {String} event\n\t   * @param {Function} fn\n\t   */\n\t\n\t  Vue.prototype.$off = function (event, fn) {\n\t    var cbs;\n\t    // all\n\t    if (!arguments.length) {\n\t      if (this.$parent) {\n\t        for (event in this._events) {\n\t          cbs = this._events[event];\n\t          if (cbs) {\n\t            modifyListenerCount(this, event, -cbs.length);\n\t          }\n\t        }\n\t      }\n\t      this._events = {};\n\t      return this;\n\t    }\n\t    // specific event\n\t    cbs = this._events[event];\n\t    if (!cbs) {\n\t      return this;\n\t    }\n\t    if (arguments.length === 1) {\n\t      modifyListenerCount(this, event, -cbs.length);\n\t      this._events[event] = null;\n\t      return this;\n\t    }\n\t    // specific handler\n\t    var cb;\n\t    var i = cbs.length;\n\t    while (i--) {\n\t      cb = cbs[i];\n\t      if (cb === fn || cb.fn === fn) {\n\t        modifyListenerCount(this, event, -1);\n\t        cbs.splice(i, 1);\n\t        break;\n\t      }\n\t    }\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Trigger an event on self.\n\t   *\n\t   * @param {String|Object} event\n\t   * @return {Boolean} shouldPropagate\n\t   */\n\t\n\t  Vue.prototype.$emit = function (event) {\n\t    var isSource = typeof event === 'string';\n\t    event = isSource ? event : event.name;\n\t    var cbs = this._events[event];\n\t    var shouldPropagate = isSource || !cbs;\n\t    if (cbs) {\n\t      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n\t      // this is a somewhat hacky solution to the question raised\n\t      // in #2102: for an inline component listener like <comp @test=\"doThis\">,\n\t      // the propagation handling is somewhat broken. Therefore we\n\t      // need to treat these inline callbacks differently.\n\t      var hasParentCbs = isSource && cbs.some(function (cb) {\n\t        return cb._fromParent;\n\t      });\n\t      if (hasParentCbs) {\n\t        shouldPropagate = false;\n\t      }\n\t      var args = toArray(arguments, 1);\n\t      for (var i = 0, l = cbs.length; i < l; i++) {\n\t        var cb = cbs[i];\n\t        var res = cb.apply(this, args);\n\t        if (res === true && (!hasParentCbs || cb._fromParent)) {\n\t          shouldPropagate = true;\n\t        }\n\t      }\n\t    }\n\t    return shouldPropagate;\n\t  };\n\t\n\t  /**\n\t   * Recursively broadcast an event to all children instances.\n\t   *\n\t   * @param {String|Object} event\n\t   * @param {...*} additional arguments\n\t   */\n\t\n\t  Vue.prototype.$broadcast = function (event) {\n\t    var isSource = typeof event === 'string';\n\t    event = isSource ? event : event.name;\n\t    // if no child has registered for this event,\n\t    // then there's no need to broadcast.\n\t    if (!this._eventsCount[event]) return;\n\t    var children = this.$children;\n\t    var args = toArray(arguments);\n\t    if (isSource) {\n\t      // use object event to indicate non-source emit\n\t      // on children\n\t      args[0] = { name: event, source: this };\n\t    }\n\t    for (var i = 0, l = children.length; i < l; i++) {\n\t      var child = children[i];\n\t      var shouldPropagate = child.$emit.apply(child, args);\n\t      if (shouldPropagate) {\n\t        child.$broadcast.apply(child, args);\n\t      }\n\t    }\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Recursively propagate an event up the parent chain.\n\t   *\n\t   * @param {String} event\n\t   * @param {...*} additional arguments\n\t   */\n\t\n\t  Vue.prototype.$dispatch = function (event) {\n\t    var shouldPropagate = this.$emit.apply(this, arguments);\n\t    if (!shouldPropagate) return;\n\t    var parent = this.$parent;\n\t    var args = toArray(arguments);\n\t    // use object event to indicate non-source emit\n\t    // on parents\n\t    args[0] = { name: event, source: this };\n\t    while (parent) {\n\t      shouldPropagate = parent.$emit.apply(parent, args);\n\t      parent = shouldPropagate ? parent.$parent : null;\n\t    }\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Modify the listener counts on all parents.\n\t   * This bookkeeping allows $broadcast to return early when\n\t   * no child has listened to a certain event.\n\t   *\n\t   * @param {Vue} vm\n\t   * @param {String} event\n\t   * @param {Number} count\n\t   */\n\t\n\t  var hookRE = /^hook:/;\n\t  function modifyListenerCount(vm, event, count) {\n\t    var parent = vm.$parent;\n\t    // hooks do not get broadcasted so no need\n\t    // to do bookkeeping for them\n\t    if (!parent || !count || hookRE.test(event)) return;\n\t    while (parent) {\n\t      parent._eventsCount[event] = (parent._eventsCount[event] || 0) + count;\n\t      parent = parent.$parent;\n\t    }\n\t  }\n\t}\n\t\n\tfunction lifecycleAPI (Vue) {\n\t  /**\n\t   * Set instance target element and kick off the compilation\n\t   * process. The passed in `el` can be a selector string, an\n\t   * existing Element, or a DocumentFragment (for block\n\t   * instances).\n\t   *\n\t   * @param {Element|DocumentFragment|string} el\n\t   * @public\n\t   */\n\t\n\t  Vue.prototype.$mount = function (el) {\n\t    if (this._isCompiled) {\n\t      (\"production\") !== 'production' && warn('$mount() should be called only once.', this);\n\t      return;\n\t    }\n\t    el = query(el);\n\t    if (!el) {\n\t      el = document.createElement('div');\n\t    }\n\t    this._compile(el);\n\t    this._initDOMHooks();\n\t    if (inDoc(this.$el)) {\n\t      this._callHook('attached');\n\t      ready.call(this);\n\t    } else {\n\t      this.$once('hook:attached', ready);\n\t    }\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Mark an instance as ready.\n\t   */\n\t\n\t  function ready() {\n\t    this._isAttached = true;\n\t    this._isReady = true;\n\t    this._callHook('ready');\n\t  }\n\t\n\t  /**\n\t   * Teardown the instance, simply delegate to the internal\n\t   * _destroy.\n\t   *\n\t   * @param {Boolean} remove\n\t   * @param {Boolean} deferCleanup\n\t   */\n\t\n\t  Vue.prototype.$destroy = function (remove, deferCleanup) {\n\t    this._destroy(remove, deferCleanup);\n\t  };\n\t\n\t  /**\n\t   * Partially compile a piece of DOM and return a\n\t   * decompile function.\n\t   *\n\t   * @param {Element|DocumentFragment} el\n\t   * @param {Vue} [host]\n\t   * @param {Object} [scope]\n\t   * @param {Fragment} [frag]\n\t   * @return {Function}\n\t   */\n\t\n\t  Vue.prototype.$compile = function (el, host, scope, frag) {\n\t    return compile(el, this.$options, true)(this, el, host, scope, frag);\n\t  };\n\t}\n\t\n\t/**\n\t * The exposed Vue constructor.\n\t *\n\t * API conventions:\n\t * - public API methods/properties are prefixed with `$`\n\t * - internal methods/properties are prefixed with `_`\n\t * - non-prefixed properties are assumed to be proxied user\n\t *   data.\n\t *\n\t * @constructor\n\t * @param {Object} [options]\n\t * @public\n\t */\n\t\n\tfunction Vue(options) {\n\t  this._init(options);\n\t}\n\t\n\t// install internals\n\tinitMixin(Vue);\n\tstateMixin(Vue);\n\teventsMixin(Vue);\n\tlifecycleMixin(Vue);\n\tmiscMixin(Vue);\n\t\n\t// install instance APIs\n\tdataAPI(Vue);\n\tdomAPI(Vue);\n\teventsAPI(Vue);\n\tlifecycleAPI(Vue);\n\t\n\tvar slot = {\n\t\n\t  priority: SLOT,\n\t  params: ['name'],\n\t\n\t  bind: function bind() {\n\t    // this was resolved during component transclusion\n\t    var name = this.params.name || 'default';\n\t    var content = this.vm._slotContents && this.vm._slotContents[name];\n\t    if (!content || !content.hasChildNodes()) {\n\t      this.fallback();\n\t    } else {\n\t      this.compile(content.cloneNode(true), this.vm._context, this.vm);\n\t    }\n\t  },\n\t\n\t  compile: function compile(content, context, host) {\n\t    if (content && context) {\n\t      if (this.el.hasChildNodes() && content.childNodes.length === 1 && content.childNodes[0].nodeType === 1 && content.childNodes[0].hasAttribute('v-if')) {\n\t        // if the inserted slot has v-if\n\t        // inject fallback content as the v-else\n\t        var elseBlock = document.createElement('template');\n\t        elseBlock.setAttribute('v-else', '');\n\t        elseBlock.innerHTML = this.el.innerHTML;\n\t        // the else block should be compiled in child scope\n\t        elseBlock._context = this.vm;\n\t        content.appendChild(elseBlock);\n\t      }\n\t      var scope = host ? host._scope : this._scope;\n\t      this.unlink = context.$compile(content, host, scope, this._frag);\n\t    }\n\t    if (content) {\n\t      replace(this.el, content);\n\t    } else {\n\t      remove(this.el);\n\t    }\n\t  },\n\t\n\t  fallback: function fallback() {\n\t    this.compile(extractContent(this.el, true), this.vm);\n\t  },\n\t\n\t  unbind: function unbind() {\n\t    if (this.unlink) {\n\t      this.unlink();\n\t    }\n\t  }\n\t};\n\t\n\tvar partial = {\n\t\n\t  priority: PARTIAL,\n\t\n\t  params: ['name'],\n\t\n\t  // watch changes to name for dynamic partials\n\t  paramWatchers: {\n\t    name: function name(value) {\n\t      vIf.remove.call(this);\n\t      if (value) {\n\t        this.insert(value);\n\t      }\n\t    }\n\t  },\n\t\n\t  bind: function bind() {\n\t    this.anchor = createAnchor('v-partial');\n\t    replace(this.el, this.anchor);\n\t    this.insert(this.params.name);\n\t  },\n\t\n\t  insert: function insert(id) {\n\t    var partial = resolveAsset(this.vm.$options, 'partials', id, true);\n\t    if (partial) {\n\t      this.factory = new FragmentFactory(this.vm, partial);\n\t      vIf.insert.call(this);\n\t    }\n\t  },\n\t\n\t  unbind: function unbind() {\n\t    if (this.frag) {\n\t      this.frag.destroy();\n\t    }\n\t  }\n\t};\n\t\n\tvar elementDirectives = {\n\t  slot: slot,\n\t  partial: partial\n\t};\n\t\n\tvar convertArray = vFor._postProcess;\n\t\n\t/**\n\t * Limit filter for arrays\n\t *\n\t * @param {Number} n\n\t * @param {Number} offset (Decimal expected)\n\t */\n\t\n\tfunction limitBy(arr, n, offset) {\n\t  offset = offset ? parseInt(offset, 10) : 0;\n\t  n = toNumber(n);\n\t  return typeof n === 'number' ? arr.slice(offset, offset + n) : arr;\n\t}\n\t\n\t/**\n\t * Filter filter for arrays\n\t *\n\t * @param {String} search\n\t * @param {String} [delimiter]\n\t * @param {String} ...dataKeys\n\t */\n\t\n\tfunction filterBy(arr, search, delimiter) {\n\t  arr = convertArray(arr);\n\t  if (search == null) {\n\t    return arr;\n\t  }\n\t  if (typeof search === 'function') {\n\t    return arr.filter(search);\n\t  }\n\t  // cast to lowercase string\n\t  search = ('' + search).toLowerCase();\n\t  // allow optional `in` delimiter\n\t  // because why not\n\t  var n = delimiter === 'in' ? 3 : 2;\n\t  // extract and flatten keys\n\t  var keys = Array.prototype.concat.apply([], toArray(arguments, n));\n\t  var res = [];\n\t  var item, key, val, j;\n\t  for (var i = 0, l = arr.length; i < l; i++) {\n\t    item = arr[i];\n\t    val = item && item.$value || item;\n\t    j = keys.length;\n\t    if (j) {\n\t      while (j--) {\n\t        key = keys[j];\n\t        if (key === '$key' && contains(item.$key, search) || contains(getPath(val, key), search)) {\n\t          res.push(item);\n\t          break;\n\t        }\n\t      }\n\t    } else if (contains(item, search)) {\n\t      res.push(item);\n\t    }\n\t  }\n\t  return res;\n\t}\n\t\n\t/**\n\t * Filter filter for arrays\n\t *\n\t * @param {String|Array<String>|Function} ...sortKeys\n\t * @param {Number} [order]\n\t */\n\t\n\tfunction orderBy(arr) {\n\t  var comparator = null;\n\t  var sortKeys = undefined;\n\t  arr = convertArray(arr);\n\t\n\t  // determine order (last argument)\n\t  var args = toArray(arguments, 1);\n\t  var order = args[args.length - 1];\n\t  if (typeof order === 'number') {\n\t    order = order < 0 ? -1 : 1;\n\t    args = args.length > 1 ? args.slice(0, -1) : args;\n\t  } else {\n\t    order = 1;\n\t  }\n\t\n\t  // determine sortKeys & comparator\n\t  var firstArg = args[0];\n\t  if (!firstArg) {\n\t    return arr;\n\t  } else if (typeof firstArg === 'function') {\n\t    // custom comparator\n\t    comparator = function (a, b) {\n\t      return firstArg(a, b) * order;\n\t    };\n\t  } else {\n\t    // string keys. flatten first\n\t    sortKeys = Array.prototype.concat.apply([], args);\n\t    comparator = function (a, b, i) {\n\t      i = i || 0;\n\t      return i >= sortKeys.length - 1 ? baseCompare(a, b, i) : baseCompare(a, b, i) || comparator(a, b, i + 1);\n\t    };\n\t  }\n\t\n\t  function baseCompare(a, b, sortKeyIndex) {\n\t    var sortKey = sortKeys[sortKeyIndex];\n\t    if (sortKey) {\n\t      if (sortKey !== '$key') {\n\t        if (isObject(a) && '$value' in a) a = a.$value;\n\t        if (isObject(b) && '$value' in b) b = b.$value;\n\t      }\n\t      a = isObject(a) ? getPath(a, sortKey) : a;\n\t      b = isObject(b) ? getPath(b, sortKey) : b;\n\t    }\n\t    return a === b ? 0 : a > b ? order : -order;\n\t  }\n\t\n\t  // sort on a copy to avoid mutating original array\n\t  return arr.slice().sort(comparator);\n\t}\n\t\n\t/**\n\t * String contain helper\n\t *\n\t * @param {*} val\n\t * @param {String} search\n\t */\n\t\n\tfunction contains(val, search) {\n\t  var i;\n\t  if (isPlainObject(val)) {\n\t    var keys = Object.keys(val);\n\t    i = keys.length;\n\t    while (i--) {\n\t      if (contains(val[keys[i]], search)) {\n\t        return true;\n\t      }\n\t    }\n\t  } else if (isArray(val)) {\n\t    i = val.length;\n\t    while (i--) {\n\t      if (contains(val[i], search)) {\n\t        return true;\n\t      }\n\t    }\n\t  } else if (val != null) {\n\t    return val.toString().toLowerCase().indexOf(search) > -1;\n\t  }\n\t}\n\t\n\tvar digitsRE = /(\\d{3})(?=\\d)/g;\n\t\n\t// asset collections must be a plain object.\n\tvar filters = {\n\t\n\t  orderBy: orderBy,\n\t  filterBy: filterBy,\n\t  limitBy: limitBy,\n\t\n\t  /**\n\t   * Stringify value.\n\t   *\n\t   * @param {Number} indent\n\t   */\n\t\n\t  json: {\n\t    read: function read(value, indent) {\n\t      return typeof value === 'string' ? value : JSON.stringify(value, null, Number(indent) || 2);\n\t    },\n\t    write: function write(value) {\n\t      try {\n\t        return JSON.parse(value);\n\t      } catch (e) {\n\t        return value;\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 'abc' => 'Abc'\n\t   */\n\t\n\t  capitalize: function capitalize(value) {\n\t    if (!value && value !== 0) return '';\n\t    value = value.toString();\n\t    return value.charAt(0).toUpperCase() + value.slice(1);\n\t  },\n\t\n\t  /**\n\t   * 'abc' => 'ABC'\n\t   */\n\t\n\t  uppercase: function uppercase(value) {\n\t    return value || value === 0 ? value.toString().toUpperCase() : '';\n\t  },\n\t\n\t  /**\n\t   * 'AbC' => 'abc'\n\t   */\n\t\n\t  lowercase: function lowercase(value) {\n\t    return value || value === 0 ? value.toString().toLowerCase() : '';\n\t  },\n\t\n\t  /**\n\t   * 12345 => $12,345.00\n\t   *\n\t   * @param {String} sign\n\t   */\n\t\n\t  currency: function currency(value, _currency) {\n\t    value = parseFloat(value);\n\t    if (!isFinite(value) || !value && value !== 0) return '';\n\t    _currency = _currency != null ? _currency : '$';\n\t    var stringified = Math.abs(value).toFixed(2);\n\t    var _int = stringified.slice(0, -3);\n\t    var i = _int.length % 3;\n\t    var head = i > 0 ? _int.slice(0, i) + (_int.length > 3 ? ',' : '') : '';\n\t    var _float = stringified.slice(-3);\n\t    var sign = value < 0 ? '-' : '';\n\t    return sign + _currency + head + _int.slice(i).replace(digitsRE, '$1,') + _float;\n\t  },\n\t\n\t  /**\n\t   * 'item' => 'items'\n\t   *\n\t   * @params\n\t   *  an array of strings corresponding to\n\t   *  the single, double, triple ... forms of the word to\n\t   *  be pluralized. When the number to be pluralized\n\t   *  exceeds the length of the args, it will use the last\n\t   *  entry in the array.\n\t   *\n\t   *  e.g. ['single', 'double', 'triple', 'multiple']\n\t   */\n\t\n\t  pluralize: function pluralize(value) {\n\t    var args = toArray(arguments, 1);\n\t    return args.length > 1 ? args[value % 10 - 1] || args[args.length - 1] : args[0] + (value === 1 ? '' : 's');\n\t  },\n\t\n\t  /**\n\t   * Debounce a handler function.\n\t   *\n\t   * @param {Function} handler\n\t   * @param {Number} delay = 300\n\t   * @return {Function}\n\t   */\n\t\n\t  debounce: function debounce(handler, delay) {\n\t    if (!handler) return;\n\t    if (!delay) {\n\t      delay = 300;\n\t    }\n\t    return _debounce(handler, delay);\n\t  }\n\t};\n\t\n\tfunction installGlobalAPI (Vue) {\n\t  /**\n\t   * Vue and every constructor that extends Vue has an\n\t   * associated options object, which can be accessed during\n\t   * compilation steps as `this.constructor.options`.\n\t   *\n\t   * These can be seen as the default options of every\n\t   * Vue instance.\n\t   */\n\t\n\t  Vue.options = {\n\t    directives: directives,\n\t    elementDirectives: elementDirectives,\n\t    filters: filters,\n\t    transitions: {},\n\t    components: {},\n\t    partials: {},\n\t    replace: true\n\t  };\n\t\n\t  /**\n\t   * Expose useful internals\n\t   */\n\t\n\t  Vue.util = util;\n\t  Vue.config = config;\n\t  Vue.set = set;\n\t  Vue['delete'] = del;\n\t  Vue.nextTick = nextTick;\n\t\n\t  /**\n\t   * The following are exposed for advanced usage / plugins\n\t   */\n\t\n\t  Vue.compiler = compiler;\n\t  Vue.FragmentFactory = FragmentFactory;\n\t  Vue.internalDirectives = internalDirectives;\n\t  Vue.parsers = {\n\t    path: path,\n\t    text: text,\n\t    template: template,\n\t    directive: directive,\n\t    expression: expression\n\t  };\n\t\n\t  /**\n\t   * Each instance constructor, including Vue, has a unique\n\t   * cid. This enables us to create wrapped \"child\n\t   * constructors\" for prototypal inheritance and cache them.\n\t   */\n\t\n\t  Vue.cid = 0;\n\t  var cid = 1;\n\t\n\t  /**\n\t   * Class inheritance\n\t   *\n\t   * @param {Object} extendOptions\n\t   */\n\t\n\t  Vue.extend = function (extendOptions) {\n\t    extendOptions = extendOptions || {};\n\t    var Super = this;\n\t    var isFirstExtend = Super.cid === 0;\n\t    if (isFirstExtend && extendOptions._Ctor) {\n\t      return extendOptions._Ctor;\n\t    }\n\t    var name = extendOptions.name || Super.options.name;\n\t    if (false) {\n\t      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n\t        warn('Invalid component name: \"' + name + '\". Component names ' + 'can only contain alphanumeric characaters and the hyphen.');\n\t        name = null;\n\t      }\n\t    }\n\t    var Sub = createClass(name || 'VueComponent');\n\t    Sub.prototype = Object.create(Super.prototype);\n\t    Sub.prototype.constructor = Sub;\n\t    Sub.cid = cid++;\n\t    Sub.options = mergeOptions(Super.options, extendOptions);\n\t    Sub['super'] = Super;\n\t    // allow further extension\n\t    Sub.extend = Super.extend;\n\t    // create asset registers, so extended classes\n\t    // can have their private assets too.\n\t    config._assetTypes.forEach(function (type) {\n\t      Sub[type] = Super[type];\n\t    });\n\t    // enable recursive self-lookup\n\t    if (name) {\n\t      Sub.options.components[name] = Sub;\n\t    }\n\t    // cache constructor\n\t    if (isFirstExtend) {\n\t      extendOptions._Ctor = Sub;\n\t    }\n\t    return Sub;\n\t  };\n\t\n\t  /**\n\t   * A function that returns a sub-class constructor with the\n\t   * given name. This gives us much nicer output when\n\t   * logging instances in the console.\n\t   *\n\t   * @param {String} name\n\t   * @return {Function}\n\t   */\n\t\n\t  function createClass(name) {\n\t    /* eslint-disable no-new-func */\n\t    return new Function('return function ' + classify(name) + ' (options) { this._init(options) }')();\n\t    /* eslint-enable no-new-func */\n\t  }\n\t\n\t  /**\n\t   * Plugin system\n\t   *\n\t   * @param {Object} plugin\n\t   */\n\t\n\t  Vue.use = function (plugin) {\n\t    /* istanbul ignore if */\n\t    if (plugin.installed) {\n\t      return;\n\t    }\n\t    // additional parameters\n\t    var args = toArray(arguments, 1);\n\t    args.unshift(this);\n\t    if (typeof plugin.install === 'function') {\n\t      plugin.install.apply(plugin, args);\n\t    } else {\n\t      plugin.apply(null, args);\n\t    }\n\t    plugin.installed = true;\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Apply a global mixin by merging it into the default\n\t   * options.\n\t   */\n\t\n\t  Vue.mixin = function (mixin) {\n\t    Vue.options = mergeOptions(Vue.options, mixin);\n\t  };\n\t\n\t  /**\n\t   * Create asset registration methods with the following\n\t   * signature:\n\t   *\n\t   * @param {String} id\n\t   * @param {*} definition\n\t   */\n\t\n\t  config._assetTypes.forEach(function (type) {\n\t    Vue[type] = function (id, definition) {\n\t      if (!definition) {\n\t        return this.options[type + 's'][id];\n\t      } else {\n\t        /* istanbul ignore if */\n\t        if (false) {\n\t          if (type === 'component' && (commonTagRE.test(id) || reservedTagRE.test(id))) {\n\t            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);\n\t          }\n\t        }\n\t        if (type === 'component' && isPlainObject(definition)) {\n\t          definition.name = id;\n\t          definition = Vue.extend(definition);\n\t        }\n\t        this.options[type + 's'][id] = definition;\n\t        return definition;\n\t      }\n\t    };\n\t  });\n\t\n\t  // expose internal transition API\n\t  extend(Vue.transition, transition);\n\t}\n\t\n\tinstallGlobalAPI(Vue);\n\t\n\tVue.version = '1.0.21';\n\t\n\t// devtools global hook\n\t/* istanbul ignore next */\n\tsetTimeout(function () {\n\t  if (config.devtools) {\n\t    if (devtools) {\n\t      devtools.emit('init', Vue);\n\t    } else if (false) {\n\t      console.log('Download the Vue Devtools for a better development experience:\\n' + 'https://github.com/vuejs/vue-devtools');\n\t    }\n\t  }\n\t}, 0);\n\t\n\tmodule.exports = Vue;\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(31).nextTick;\n\tvar apply = Function.prototype.apply;\n\tvar slice = Array.prototype.slice;\n\tvar immediateIds = {};\n\tvar nextImmediateId = 0;\n\t\n\t// DOM APIs, for completeness\n\t\n\texports.setTimeout = function() {\n\t  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n\t};\n\texports.setInterval = function() {\n\t  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n\t};\n\texports.clearTimeout =\n\texports.clearInterval = function(timeout) { timeout.close(); };\n\t\n\tfunction Timeout(id, clearFn) {\n\t  this._id = id;\n\t  this._clearFn = clearFn;\n\t}\n\tTimeout.prototype.unref = Timeout.prototype.ref = function() {};\n\tTimeout.prototype.close = function() {\n\t  this._clearFn.call(window, this._id);\n\t};\n\t\n\t// Does not start the time, just sets up the members needed.\n\texports.enroll = function(item, msecs) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = msecs;\n\t};\n\t\n\texports.unenroll = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = -1;\n\t};\n\t\n\texports._unrefActive = exports.active = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t\n\t  var msecs = item._idleTimeout;\n\t  if (msecs >= 0) {\n\t    item._idleTimeoutId = setTimeout(function onTimeout() {\n\t      if (item._onTimeout)\n\t        item._onTimeout();\n\t    }, msecs);\n\t  }\n\t};\n\t\n\t// That's not how node.js implements it but the exposed api is the same.\n\texports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n\t  var id = nextImmediateId++;\n\t  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\t\n\t  immediateIds[id] = true;\n\t\n\t  nextTick(function onNextTick() {\n\t    if (immediateIds[id]) {\n\t      // fn.call() is faster so we optimize for the common use-case\n\t      // @see http://jsperf.com/call-apply-segu\n\t      if (args) {\n\t        fn.apply(null, args);\n\t      } else {\n\t        fn.call(null);\n\t      }\n\t      // Prevent ids from leaking\n\t      exports.clearImmediate(id);\n\t    }\n\t  });\n\t\n\t  return id;\n\t};\n\t\n\texports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n\t  delete immediateIds[id];\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(17).setImmediate, __webpack_require__(17).clearImmediate))\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _vue = __webpack_require__(16);\n\t\n\tvar _vue2 = _interopRequireDefault(_vue);\n\t\n\tvar _q = __webpack_require__(15);\n\t\n\tvar _q2 = _interopRequireDefault(_q);\n\t\n\tvar _deferredReady = __webpack_require__(19);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t_vue2.default.use(_deferredReady.DeferredReady);\n\t\n\texports.default = _vue2.default.extend({\n\t    mixins: [_deferredReady.DeferredReadyMixin],\n\t    created: function created() {\n\t        this.$map = null;\n\t    },\n\t    deferredReady: function deferredReady() {\n\t        this.$dispatch('register-component', this);\n\t    },\n\t\n\t    events: {\n\t        'map-ready': function mapReady(map) {\n\t            this.$map = map;\n\t        }\n\t    }\n\t});\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.DeferredReadyMixin = exports.DeferredReady = undefined;\n\t\n\tvar _promise = __webpack_require__(36);\n\t\n\tvar _promise2 = _interopRequireDefault(_promise);\n\t\n\tvar _q = __webpack_require__(15);\n\t\n\tvar _q2 = _interopRequireDefault(_q);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar DeferredReady = exports.DeferredReady = {\n\t  install: function install(Vue, options) {\n\t    Vue.config.optionMergeStrategies.deferredReady = Vue.config.optionMergeStrategies.created;\n\t  }\n\t};\n\t\n\tfunction runHooks(vm) {\n\t  var hooks = vm.$options.deferredReady || [];\n\t  if (typeof hooks === 'function') {\n\t    hooks = [hooks];\n\t  }\n\t  _promise2.default.all(hooks.map(function (x) {\n\t    var rv;\n\t    try {\n\t      rv = x.apply(vm);\n\t    } catch (err) {\n\t      console.error(err.stack);\n\t    }\n\t    return rv;\n\t  })).then(function () {\n\t    vm.$deferredReadyDeferred.resolve();\n\t  });\n\t}\n\t\n\tvar DeferredReadyMixin = exports.DeferredReadyMixin = {\n\t  created: function created() {\n\t    this.$hasDeferredReadyAncestors = false;\n\t    this.$deferredReadyDeferred = _q2.default.defer();\n\t  },\n\t  ready: function ready() {\n\t    var _this = this;\n\t\n\t    this.$dispatch('register-deferredReadyChild', this);\n\t\n\t    if (!this.$hasDeferredReadyAncestors) {\n\t      this.$nextTick(function () {\n\t        return runHooks(_this);\n\t      });\n\t    }\n\t  },\n\t\n\t\n\t  events: {\n\t    'register-deferredReadyChild': function registerDeferredReadyChild(child) {\n\t      if (this == child) return true;\n\t\n\t      child.$hasDeferredReadyAncestors = true;\n\t\n\t      this.$deferredReadyDeferred.promise.then(function () {\n\t        return runHooks(child);\n\t      });\n\t    }\n\t  }\n\t};\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// getting tag from 19.1.3.6 Object.prototype.toString()\n\tvar cof = __webpack_require__(8)\n\t  , TAG = __webpack_require__(1)('toStringTag')\n\t  // ES3 wrong here\n\t  , ARG = cof(function(){ return arguments; }()) == 'Arguments';\n\t\n\tmodule.exports = function(it){\n\t  var O, T, B;\n\t  return it === undefined ? 'Undefined' : it === null ? 'Null'\n\t    // @@toStringTag case\n\t    : typeof (T = (O = Object(it))[TAG]) == 'string' ? T\n\t    // builtinTag case\n\t    : ARG ? cof(O)\n\t    // ES3 arguments fallback\n\t    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n\t};\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\t// 7.2.1 RequireObjectCoercible(argument)\n\tmodule.exports = function(it){\n\t  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n\t  return it;\n\t};\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global    = __webpack_require__(2)\n\t  , core      = __webpack_require__(5)\n\t  , ctx       = __webpack_require__(6)\n\t  , PROTOTYPE = 'prototype';\n\t\n\tvar $export = function(type, name, source){\n\t  var IS_FORCED = type & $export.F\n\t    , IS_GLOBAL = type & $export.G\n\t    , IS_STATIC = type & $export.S\n\t    , IS_PROTO  = type & $export.P\n\t    , IS_BIND   = type & $export.B\n\t    , IS_WRAP   = type & $export.W\n\t    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n\t    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n\t    , key, own, out;\n\t  if(IS_GLOBAL)source = name;\n\t  for(key in source){\n\t    // contains in native\n\t    own = !IS_FORCED && target && key in target;\n\t    if(own && key in exports)continue;\n\t    // export native or passed\n\t    out = own ? target[key] : source[key];\n\t    // prevent global pollution for namespaces\n\t    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n\t    // bind timers to global for call from export context\n\t    : IS_BIND && own ? ctx(out, global)\n\t    // wrap global constructors for prevent change them in library\n\t    : IS_WRAP && target[key] == out ? (function(C){\n\t      var F = function(param){\n\t        return this instanceof C ? new C(param) : C(param);\n\t      };\n\t      F[PROTOTYPE] = C[PROTOTYPE];\n\t      return F;\n\t    // make static versions for prototype methods\n\t    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n\t    if(IS_PROTO)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;\n\t  }\n\t};\n\t// type bitmap\n\t$export.F = 1;  // forced\n\t$export.G = 2;  // global\n\t$export.S = 4;  // static\n\t$export.P = 8;  // proto\n\t$export.B = 16; // bind\n\t$export.W = 32; // wrap\n\tmodule.exports = $export;\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\tvar hasOwnProperty = {}.hasOwnProperty;\n\tmodule.exports = function(it, key){\n\t  return hasOwnProperty.call(it, key);\n\t};\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar LIBRARY        = __webpack_require__(25)\n\t  , $export        = __webpack_require__(22)\n\t  , redefine       = __webpack_require__(27)\n\t  , hide           = __webpack_require__(12)\n\t  , has            = __webpack_require__(23)\n\t  , Iterators      = __webpack_require__(7)\n\t  , $iterCreate    = __webpack_require__(47)\n\t  , setToStringTag = __webpack_require__(13)\n\t  , getProto       = __webpack_require__(3).getProto\n\t  , ITERATOR       = __webpack_require__(1)('iterator')\n\t  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n\t  , FF_ITERATOR    = '@@iterator'\n\t  , KEYS           = 'keys'\n\t  , VALUES         = 'values';\n\t\n\tvar returnThis = function(){ return this; };\n\t\n\tmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n\t  $iterCreate(Constructor, NAME, next);\n\t  var getMethod = function(kind){\n\t    if(!BUGGY && kind in proto)return proto[kind];\n\t    switch(kind){\n\t      case KEYS: return function keys(){ return new Constructor(this, kind); };\n\t      case VALUES: return function values(){ return new Constructor(this, kind); };\n\t    } return function entries(){ return new Constructor(this, kind); };\n\t  };\n\t  var TAG        = NAME + ' Iterator'\n\t    , DEF_VALUES = DEFAULT == VALUES\n\t    , VALUES_BUG = false\n\t    , proto      = Base.prototype\n\t    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n\t    , $default   = $native || getMethod(DEFAULT)\n\t    , methods, key;\n\t  // Fix native\n\t  if($native){\n\t    var IteratorPrototype = getProto($default.call(new Base));\n\t    // Set @@toStringTag to native iterators\n\t    setToStringTag(IteratorPrototype, TAG, true);\n\t    // FF fix\n\t    if(!LIBRARY && has(proto, FF_ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n\t    // fix Array#{values, @@iterator}.name in V8 / FF\n\t    if(DEF_VALUES && $native.name !== VALUES){\n\t      VALUES_BUG = true;\n\t      $default = function values(){ return $native.call(this); };\n\t    }\n\t  }\n\t  // Define iterator\n\t  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n\t    hide(proto, ITERATOR, $default);\n\t  }\n\t  // Plug for library\n\t  Iterators[NAME] = $default;\n\t  Iterators[TAG]  = returnThis;\n\t  if(DEFAULT){\n\t    methods = {\n\t      values:  DEF_VALUES  ? $default : getMethod(VALUES),\n\t      keys:    IS_SET      ? $default : getMethod(KEYS),\n\t      entries: !DEF_VALUES ? $default : getMethod('entries')\n\t    };\n\t    if(FORCED)for(key in methods){\n\t      if(!(key in proto))redefine(proto, key, methods[key]);\n\t    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n\t  }\n\t  return methods;\n\t};\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\tmodule.exports = true;\n\n/***/ },\n/* 26 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(bitmap, value){\n\t  return {\n\t    enumerable  : !(bitmap & 1),\n\t    configurable: !(bitmap & 2),\n\t    writable    : !(bitmap & 4),\n\t    value       : value\n\t  };\n\t};\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(12);\n\n/***/ },\n/* 28 */\n/***/ function(module, exports) {\n\n\t// 7.1.4 ToInteger\n\tvar ceil  = Math.ceil\n\t  , floor = Math.floor;\n\tmodule.exports = function(it){\n\t  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n\t};\n\n/***/ },\n/* 29 */\n/***/ function(module, exports) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\t// css base code, injected by the css-loader\r\n\tmodule.exports = function() {\r\n\t\tvar list = [];\r\n\t\r\n\t\t// return the list of modules as css string\r\n\t\tlist.toString = function toString() {\r\n\t\t\tvar result = [];\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar item = this[i];\r\n\t\t\t\tif(item[2]) {\r\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult.push(item[1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result.join(\"\");\r\n\t\t};\r\n\t\r\n\t\t// import a list of modules into the list\r\n\t\tlist.i = function(modules, mediaQuery) {\r\n\t\t\tif(typeof modules === \"string\")\r\n\t\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\t\tvar alreadyImportedModules = {};\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar id = this[i][0];\r\n\t\t\t\tif(typeof id === \"number\")\r\n\t\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t\t}\r\n\t\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\t\tvar item = modules[i];\r\n\t\t\t\t// skip already imported module\r\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlist.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn list;\r\n\t};\r\n\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\n\t\tAuthor Tobias Koppers @sokra\n\t*/\n\tvar stylesInDom = {},\n\t\tmemoize = function(fn) {\n\t\t\tvar memo;\n\t\t\treturn function () {\n\t\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\t\treturn memo;\n\t\t\t};\n\t\t},\n\t\tisOldIE = memoize(function() {\n\t\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\n\t\t}),\n\t\tgetHeadElement = memoize(function () {\n\t\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t\t}),\n\t\tsingletonElement = null,\n\t\tsingletonCounter = 0,\n\t\tstyleElementsInsertedAtTop = [];\n\t\n\tmodule.exports = function(list, options) {\n\t\tif(false) {\n\t\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t\t}\n\t\n\t\toptions = options || {};\n\t\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t\t// tags it will allow on a page\n\t\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\t\n\t\t// By default, add <style> tags to the bottom of <head>.\n\t\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\t\n\t\tvar styles = listToStyles(list);\n\t\taddStylesToDom(styles, options);\n\t\n\t\treturn function update(newList) {\n\t\t\tvar mayRemove = [];\n\t\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\t\tvar item = styles[i];\n\t\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\t\tdomStyle.refs--;\n\t\t\t\tmayRemove.push(domStyle);\n\t\t\t}\n\t\t\tif(newList) {\n\t\t\t\tvar newStyles = listToStyles(newList);\n\t\t\t\taddStylesToDom(newStyles, options);\n\t\t\t}\n\t\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\t\tvar domStyle = mayRemove[i];\n\t\t\t\tif(domStyle.refs === 0) {\n\t\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\t\n\tfunction addStylesToDom(styles, options) {\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tif(domStyle) {\n\t\t\t\tdomStyle.refs++;\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t\t}\n\t\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar parts = [];\n\t\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t\t}\n\t\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction listToStyles(list) {\n\t\tvar styles = [];\n\t\tvar newStyles = {};\n\t\tfor(var i = 0; i < list.length; i++) {\n\t\t\tvar item = list[i];\n\t\t\tvar id = item[0];\n\t\t\tvar css = item[1];\n\t\t\tvar media = item[2];\n\t\t\tvar sourceMap = item[3];\n\t\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\t\tif(!newStyles[id])\n\t\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\t\telse\n\t\t\t\tnewStyles[id].parts.push(part);\n\t\t}\n\t\treturn styles;\n\t}\n\t\n\tfunction insertStyleElement(options, styleElement) {\n\t\tvar head = getHeadElement();\n\t\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\t\tif (options.insertAt === \"top\") {\n\t\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\t\thead.insertBefore(styleElement, head.firstChild);\n\t\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t\t} else {\n\t\t\t\thead.appendChild(styleElement);\n\t\t\t}\n\t\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t\t} else if (options.insertAt === \"bottom\") {\n\t\t\thead.appendChild(styleElement);\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t\t}\n\t}\n\t\n\tfunction removeStyleElement(styleElement) {\n\t\tstyleElement.parentNode.removeChild(styleElement);\n\t\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\t\tif(idx >= 0) {\n\t\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t\t}\n\t}\n\t\n\tfunction createStyleElement(options) {\n\t\tvar styleElement = document.createElement(\"style\");\n\t\tstyleElement.type = \"text/css\";\n\t\tinsertStyleElement(options, styleElement);\n\t\treturn styleElement;\n\t}\n\t\n\tfunction addStyle(obj, options) {\n\t\tvar styleElement, update, remove;\n\t\n\t\tif (options.singleton) {\n\t\t\tvar styleIndex = singletonCounter++;\n\t\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t\t} else {\n\t\t\tstyleElement = createStyleElement(options);\n\t\t\tupdate = applyToTag.bind(null, styleElement);\n\t\t\tremove = function() {\n\t\t\t\tremoveStyleElement(styleElement);\n\t\t\t};\n\t\t}\n\t\n\t\tupdate(obj);\n\t\n\t\treturn function updateStyle(newObj) {\n\t\t\tif(newObj) {\n\t\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\t\treturn;\n\t\t\t\tupdate(obj = newObj);\n\t\t\t} else {\n\t\t\t\tremove();\n\t\t\t}\n\t\t};\n\t}\n\t\n\tvar replaceText = (function () {\n\t\tvar textStore = [];\n\t\n\t\treturn function (index, replacement) {\n\t\t\ttextStore[index] = replacement;\n\t\t\treturn textStore.filter(Boolean).join('\\n');\n\t\t};\n\t})();\n\t\n\tfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\t\tvar css = remove ? \"\" : obj.css;\n\t\n\t\tif (styleElement.styleSheet) {\n\t\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t\t} else {\n\t\t\tvar cssNode = document.createTextNode(css);\n\t\t\tvar childNodes = styleElement.childNodes;\n\t\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\t\tif (childNodes.length) {\n\t\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t\t} else {\n\t\t\t\tstyleElement.appendChild(cssNode);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction applyToTag(styleElement, obj) {\n\t\tvar css = obj.css;\n\t\tvar media = obj.media;\n\t\tvar sourceMap = obj.sourceMap;\n\t\n\t\tif (media) {\n\t\t\tstyleElement.setAttribute(\"media\", media);\n\t\t}\n\t\n\t\tif (sourceMap) {\n\t\t\t// https://developer.chrome.com/devtools/docs/javascript-debugging\n\t\t\t// this makes source maps inside style tags work properly in Chrome\n\t\t\tcss += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */';\n\t\t\t// http://stackoverflow.com/a/26603875\n\t\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t\t}\n\t\n\t\tif (styleElement.styleSheet) {\n\t\t\tstyleElement.styleSheet.cssText = css;\n\t\t} else {\n\t\t\twhile(styleElement.firstChild) {\n\t\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t\t}\n\t\t\tstyleElement.appendChild(document.createTextNode(css));\n\t\t}\n\t}\n\n\n/***/ },\n/* 31 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = setTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    clearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        setTimeout(drainQueue, 0);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _mapComponent = __webpack_require__(18);\n\t\n\tvar _mapComponent2 = _interopRequireDefault(_mapComponent);\n\t\n\tvar _leaflet = __webpack_require__(14);\n\t\n\tvar _leaflet2 = _interopRequireDefault(_leaflet);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = _mapComponent2.default.extend({\n\t    props: ['position'],\n\t    deferredReady: function deferredReady() {\n\t        console.log(this.position);\n\t        _leaflet2.default.Icon.Default.imagePath = \"http://cdn.leafletjs.com/leaflet/v0.7.7/images\";\n\t        _leaflet2.default.marker(this.position).addTo(this.$map);\n\t    }\n\t});\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _mapComponent = __webpack_require__(18);\n\t\n\tvar _mapComponent2 = _interopRequireDefault(_mapComponent);\n\t\n\tvar _leaflet = __webpack_require__(14);\n\t\n\tvar _leaflet2 = _interopRequireDefault(_leaflet);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = _mapComponent2.default.extend({\n\t    props: ['url', 'attribution'],\n\t    deferredReady: function deferredReady() {\n\t        _leaflet2.default.tileLayer(this.url, { attribution: this.attribution }).addTo(this.$map);\n\t    }\n\t});\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _Map = __webpack_require__(74);\n\t\n\tvar _Map2 = _interopRequireDefault(_Map);\n\t\n\tvar _TileLayer = __webpack_require__(33);\n\t\n\tvar _TileLayer2 = _interopRequireDefault(_TileLayer);\n\t\n\tvar _Marker = __webpack_require__(32);\n\t\n\tvar _Marker2 = _interopRequireDefault(_Marker);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t  data: function data() {\n\t    return {\n\t      title: 'Vue Leaflet Demo',\n\t      zoom: 13,\n\t      center: [51.505, -0.09],\n\t      minZoom: 8,\n\t      maxZoom: 15,\n\t      url: \"http://{s}.tile.osm.org/{z}/{x}/{y}.png\",\n\t      attribution: \"mymap\"\n\t    };\n\t  },\n\t\n\t  components: { map: _Map2.default, tilelayer: _TileLayer2.default, marker: _Marker2.default }\n\t};\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _q = __webpack_require__(15);\n\t\n\tvar _q2 = _interopRequireDefault(_q);\n\t\n\tvar _vue = __webpack_require__(16);\n\t\n\tvar _vue2 = _interopRequireDefault(_vue);\n\t\n\tvar _deferredReady = __webpack_require__(19);\n\t\n\tvar _leaflet = __webpack_require__(14);\n\t\n\tvar _leaflet2 = _interopRequireDefault(_leaflet);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t_vue2.default.use(_deferredReady.DeferredReady);\n\t\n\tvar registerChild = function registerChild(child, type) {\n\t\tif (!this.mapObject) throw new Error(\"Map not initialized\");\n\t\tchild.$emit('map-ready', this.mapObject);\n\t};\n\t\n\tvar eventListeners = {\n\t\t'register-component': registerChild\n\t};\n\t\n\texports.default = {\n\t\tmixins: [_deferredReady.DeferredReadyMixin],\n\t\tprops: ['center', 'zoom', 'minZoom', 'maxZoom'],\n\t\tcreated: function created() {\n\t\t\tthis.mapCreatedDefered = new _q2.default.defer();\n\t\t\tthis.mapCreated = this.mapCreatedDefered.promise;\n\t\t},\n\t\tready: function ready() {\n\t\t\tthis.mapObject = _leaflet2.default.map(\"map\", {\n\t\t\t\tcenter: this.center,\n\t\t\t\tzoom: this.zoom,\n\t\t\t\tminZoom: this.minZoom,\n\t\t\t\tmaxZoom: this.maxZoom\n\t\t\t});\n\t\t},\n\t\n\t\tevents: eventListeners\n\t};\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(37), __esModule: true };\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(65);\n\t__webpack_require__(67);\n\t__webpack_require__(68);\n\t__webpack_require__(66);\n\tmodule.exports = __webpack_require__(5).Promise;\n\n/***/ },\n/* 38 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(){ /* empty */ };\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(9)\n\t  , document = __webpack_require__(2).document\n\t  // in old IE typeof document.createElement is 'object'\n\t  , is = isObject(document) && isObject(document.createElement);\n\tmodule.exports = function(it){\n\t  return is ? document.createElement(it) : {};\n\t};\n\n/***/ },\n/* 40 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(exec){\n\t  try {\n\t    return !!exec();\n\t  } catch(e){\n\t    return true;\n\t  }\n\t};\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ctx         = __webpack_require__(6)\n\t  , call        = __webpack_require__(46)\n\t  , isArrayIter = __webpack_require__(45)\n\t  , anObject    = __webpack_require__(4)\n\t  , toLength    = __webpack_require__(61)\n\t  , getIterFn   = __webpack_require__(63);\n\tmodule.exports = function(iterable, entries, fn, that){\n\t  var iterFn = getIterFn(iterable)\n\t    , f      = ctx(fn, that, entries ? 2 : 1)\n\t    , index  = 0\n\t    , length, step, iterator;\n\t  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');\n\t  // fast case for arrays with default iterator\n\t  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){\n\t    entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\n\t  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){\n\t    call(iterator, f, step.value, entries);\n\t  }\n\t};\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(2).document && document.documentElement;\n\n/***/ },\n/* 43 */\n/***/ function(module, exports) {\n\n\t// fast apply, http://jsperf.lnkit.com/fast-apply/5\n\tmodule.exports = function(fn, args, that){\n\t  var un = that === undefined;\n\t  switch(args.length){\n\t    case 0: return un ? fn()\n\t                      : fn.call(that);\n\t    case 1: return un ? fn(args[0])\n\t                      : fn.call(that, args[0]);\n\t    case 2: return un ? fn(args[0], args[1])\n\t                      : fn.call(that, args[0], args[1]);\n\t    case 3: return un ? fn(args[0], args[1], args[2])\n\t                      : fn.call(that, args[0], args[1], args[2]);\n\t    case 4: return un ? fn(args[0], args[1], args[2], args[3])\n\t                      : fn.call(that, args[0], args[1], args[2], args[3]);\n\t  } return              fn.apply(that, args);\n\t};\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// fallback for non-array-like ES3 and non-enumerable old V8 strings\n\tvar cof = __webpack_require__(8);\n\tmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n\t  return cof(it) == 'String' ? it.split('') : Object(it);\n\t};\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// check on default Array iterator\n\tvar Iterators  = __webpack_require__(7)\n\t  , ITERATOR   = __webpack_require__(1)('iterator')\n\t  , ArrayProto = Array.prototype;\n\t\n\tmodule.exports = function(it){\n\t  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n\t};\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// call something on iterator step with safe closing on error\n\tvar anObject = __webpack_require__(4);\n\tmodule.exports = function(iterator, fn, value, entries){\n\t  try {\n\t    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\n\t  // 7.4.6 IteratorClose(iterator, completion)\n\t  } catch(e){\n\t    var ret = iterator['return'];\n\t    if(ret !== undefined)anObject(ret.call(iterator));\n\t    throw e;\n\t  }\n\t};\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar $              = __webpack_require__(3)\n\t  , descriptor     = __webpack_require__(26)\n\t  , setToStringTag = __webpack_require__(13)\n\t  , IteratorPrototype = {};\n\t\n\t// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n\t__webpack_require__(12)(IteratorPrototype, __webpack_require__(1)('iterator'), function(){ return this; });\n\t\n\tmodule.exports = function(Constructor, NAME, next){\n\t  Constructor.prototype = $.create(IteratorPrototype, {next: descriptor(1, next)});\n\t  setToStringTag(Constructor, NAME + ' Iterator');\n\t};\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ITERATOR     = __webpack_require__(1)('iterator')\n\t  , SAFE_CLOSING = false;\n\t\n\ttry {\n\t  var riter = [7][ITERATOR]();\n\t  riter['return'] = function(){ SAFE_CLOSING = true; };\n\t  Array.from(riter, function(){ throw 2; });\n\t} catch(e){ /* empty */ }\n\t\n\tmodule.exports = function(exec, skipClosing){\n\t  if(!skipClosing && !SAFE_CLOSING)return false;\n\t  var safe = false;\n\t  try {\n\t    var arr  = [7]\n\t      , iter = arr[ITERATOR]();\n\t    iter.next = function(){ safe = true; };\n\t    arr[ITERATOR] = function(){ return iter; };\n\t    exec(arr);\n\t  } catch(e){ /* empty */ }\n\t  return safe;\n\t};\n\n/***/ },\n/* 49 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(done, value){\n\t  return {value: value, done: !!done};\n\t};\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global    = __webpack_require__(2)\n\t  , macrotask = __webpack_require__(59).set\n\t  , Observer  = global.MutationObserver || global.WebKitMutationObserver\n\t  , process   = global.process\n\t  , Promise   = global.Promise\n\t  , isNode    = __webpack_require__(8)(process) == 'process'\n\t  , head, last, notify;\n\t\n\tvar flush = function(){\n\t  var parent, domain, fn;\n\t  if(isNode && (parent = process.domain)){\n\t    process.domain = null;\n\t    parent.exit();\n\t  }\n\t  while(head){\n\t    domain = head.domain;\n\t    fn     = head.fn;\n\t    if(domain)domain.enter();\n\t    fn(); // <- currently we use it only for Promise - try / catch not required\n\t    if(domain)domain.exit();\n\t    head = head.next;\n\t  } last = undefined;\n\t  if(parent)parent.enter();\n\t};\n\t\n\t// Node.js\n\tif(isNode){\n\t  notify = function(){\n\t    process.nextTick(flush);\n\t  };\n\t// browsers with MutationObserver\n\t} else if(Observer){\n\t  var toggle = 1\n\t    , node   = document.createTextNode('');\n\t  new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new\n\t  notify = function(){\n\t    node.data = toggle = -toggle;\n\t  };\n\t// environments with maybe non-completely correct, but existent Promise\n\t} else if(Promise && Promise.resolve){\n\t  notify = function(){\n\t    Promise.resolve().then(flush);\n\t  };\n\t// for other environments - macrotask based on:\n\t// - setImmediate\n\t// - MessageChannel\n\t// - window.postMessag\n\t// - onreadystatechange\n\t// - setTimeout\n\t} else {\n\t  notify = function(){\n\t    // strange IE + webpack dev server bug - use .call(global)\n\t    macrotask.call(global, flush);\n\t  };\n\t}\n\t\n\tmodule.exports = function asap(fn){\n\t  var task = {fn: fn, next: undefined, domain: isNode && process.domain};\n\t  if(last)last.next = task;\n\t  if(!head){\n\t    head = task;\n\t    notify();\n\t  } last = task;\n\t};\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar redefine = __webpack_require__(27);\n\tmodule.exports = function(target, src){\n\t  for(var key in src)redefine(target, key, src[key]);\n\t  return target;\n\t};\n\n/***/ },\n/* 52 */\n/***/ function(module, exports) {\n\n\t// 7.2.9 SameValue(x, y)\n\tmodule.exports = Object.is || function is(x, y){\n\t  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;\n\t};\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Works with __proto__ only. Old v8 can't work with null proto objects.\n\t/* eslint-disable no-proto */\n\tvar getDesc  = __webpack_require__(3).getDesc\n\t  , isObject = __webpack_require__(9)\n\t  , anObject = __webpack_require__(4);\n\tvar check = function(O, proto){\n\t  anObject(O);\n\t  if(!isObject(proto) && proto !== null)throw TypeError(proto + \": can't set as prototype!\");\n\t};\n\tmodule.exports = {\n\t  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line\n\t    function(test, buggy, set){\n\t      try {\n\t        set = __webpack_require__(6)(Function.call, getDesc(Object.prototype, '__proto__').set, 2);\n\t        set(test, []);\n\t        buggy = !(test instanceof Array);\n\t      } catch(e){ buggy = true; }\n\t      return function setPrototypeOf(O, proto){\n\t        check(O, proto);\n\t        if(buggy)O.__proto__ = proto;\n\t        else set(O, proto);\n\t        return O;\n\t      };\n\t    }({}, false) : undefined),\n\t  check: check\n\t};\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar core        = __webpack_require__(5)\n\t  , $           = __webpack_require__(3)\n\t  , DESCRIPTORS = __webpack_require__(11)\n\t  , SPECIES     = __webpack_require__(1)('species');\n\t\n\tmodule.exports = function(KEY){\n\t  var C = core[KEY];\n\t  if(DESCRIPTORS && C && !C[SPECIES])$.setDesc(C, SPECIES, {\n\t    configurable: true,\n\t    get: function(){ return this; }\n\t  });\n\t};\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global = __webpack_require__(2)\n\t  , SHARED = '__core-js_shared__'\n\t  , store  = global[SHARED] || (global[SHARED] = {});\n\tmodule.exports = function(key){\n\t  return store[key] || (store[key] = {});\n\t};\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.3.20 SpeciesConstructor(O, defaultConstructor)\n\tvar anObject  = __webpack_require__(4)\n\t  , aFunction = __webpack_require__(10)\n\t  , SPECIES   = __webpack_require__(1)('species');\n\tmodule.exports = function(O, D){\n\t  var C = anObject(O).constructor, S;\n\t  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);\n\t};\n\n/***/ },\n/* 57 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(it, Constructor, name){\n\t  if(!(it instanceof Constructor))throw TypeError(name + \": use the 'new' operator!\");\n\t  return it;\n\t};\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar toInteger = __webpack_require__(28)\n\t  , defined   = __webpack_require__(21);\n\t// true  -> String#at\n\t// false -> String#codePointAt\n\tmodule.exports = function(TO_STRING){\n\t  return function(that, pos){\n\t    var s = String(defined(that))\n\t      , i = toInteger(pos)\n\t      , l = s.length\n\t      , a, b;\n\t    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n\t    a = s.charCodeAt(i);\n\t    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n\t      ? TO_STRING ? s.charAt(i) : a\n\t      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n\t  };\n\t};\n\n/***/ },\n/* 59 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ctx                = __webpack_require__(6)\n\t  , invoke             = __webpack_require__(43)\n\t  , html               = __webpack_require__(42)\n\t  , cel                = __webpack_require__(39)\n\t  , global             = __webpack_require__(2)\n\t  , process            = global.process\n\t  , setTask            = global.setImmediate\n\t  , clearTask          = global.clearImmediate\n\t  , MessageChannel     = global.MessageChannel\n\t  , counter            = 0\n\t  , queue              = {}\n\t  , ONREADYSTATECHANGE = 'onreadystatechange'\n\t  , defer, channel, port;\n\tvar run = function(){\n\t  var id = +this;\n\t  if(queue.hasOwnProperty(id)){\n\t    var fn = queue[id];\n\t    delete queue[id];\n\t    fn();\n\t  }\n\t};\n\tvar listner = function(event){\n\t  run.call(event.data);\n\t};\n\t// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\n\tif(!setTask || !clearTask){\n\t  setTask = function setImmediate(fn){\n\t    var args = [], i = 1;\n\t    while(arguments.length > i)args.push(arguments[i++]);\n\t    queue[++counter] = function(){\n\t      invoke(typeof fn == 'function' ? fn : Function(fn), args);\n\t    };\n\t    defer(counter);\n\t    return counter;\n\t  };\n\t  clearTask = function clearImmediate(id){\n\t    delete queue[id];\n\t  };\n\t  // Node.js 0.8-\n\t  if(__webpack_require__(8)(process) == 'process'){\n\t    defer = function(id){\n\t      process.nextTick(ctx(run, id, 1));\n\t    };\n\t  // Browsers with MessageChannel, includes WebWorkers\n\t  } else if(MessageChannel){\n\t    channel = new MessageChannel;\n\t    port    = channel.port2;\n\t    channel.port1.onmessage = listner;\n\t    defer = ctx(port.postMessage, port, 1);\n\t  // Browsers with postMessage, skip WebWorkers\n\t  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n\t  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){\n\t    defer = function(id){\n\t      global.postMessage(id + '', '*');\n\t    };\n\t    global.addEventListener('message', listner, false);\n\t  // IE8-\n\t  } else if(ONREADYSTATECHANGE in cel('script')){\n\t    defer = function(id){\n\t      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){\n\t        html.removeChild(this);\n\t        run.call(id);\n\t      };\n\t    };\n\t  // Rest old browsers\n\t  } else {\n\t    defer = function(id){\n\t      setTimeout(ctx(run, id, 1), 0);\n\t    };\n\t  }\n\t}\n\tmodule.exports = {\n\t  set:   setTask,\n\t  clear: clearTask\n\t};\n\n/***/ },\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// to indexed object, toObject with fallback for non-array-like ES3 strings\n\tvar IObject = __webpack_require__(44)\n\t  , defined = __webpack_require__(21);\n\tmodule.exports = function(it){\n\t  return IObject(defined(it));\n\t};\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.15 ToLength\n\tvar toInteger = __webpack_require__(28)\n\t  , min       = Math.min;\n\tmodule.exports = function(it){\n\t  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n\t};\n\n/***/ },\n/* 62 */\n/***/ function(module, exports) {\n\n\tvar id = 0\n\t  , px = Math.random();\n\tmodule.exports = function(key){\n\t  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n\t};\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar classof   = __webpack_require__(20)\n\t  , ITERATOR  = __webpack_require__(1)('iterator')\n\t  , Iterators = __webpack_require__(7);\n\tmodule.exports = __webpack_require__(5).getIteratorMethod = function(it){\n\t  if(it != undefined)return it[ITERATOR]\n\t    || it['@@iterator']\n\t    || Iterators[classof(it)];\n\t};\n\n/***/ },\n/* 64 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar addToUnscopables = __webpack_require__(38)\n\t  , step             = __webpack_require__(49)\n\t  , Iterators        = __webpack_require__(7)\n\t  , toIObject        = __webpack_require__(60);\n\t\n\t// 22.1.3.4 Array.prototype.entries()\n\t// 22.1.3.13 Array.prototype.keys()\n\t// 22.1.3.29 Array.prototype.values()\n\t// 22.1.3.30 Array.prototype[@@iterator]()\n\tmodule.exports = __webpack_require__(24)(Array, 'Array', function(iterated, kind){\n\t  this._t = toIObject(iterated); // target\n\t  this._i = 0;                   // next index\n\t  this._k = kind;                // kind\n\t// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n\t}, function(){\n\t  var O     = this._t\n\t    , kind  = this._k\n\t    , index = this._i++;\n\t  if(!O || index >= O.length){\n\t    this._t = undefined;\n\t    return step(1);\n\t  }\n\t  if(kind == 'keys'  )return step(0, index);\n\t  if(kind == 'values')return step(0, O[index]);\n\t  return step(0, [index, O[index]]);\n\t}, 'values');\n\t\n\t// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\n\tIterators.Arguments = Iterators.Array;\n\t\n\taddToUnscopables('keys');\n\taddToUnscopables('values');\n\taddToUnscopables('entries');\n\n/***/ },\n/* 65 */\n/***/ function(module, exports) {\n\n\n\n/***/ },\n/* 66 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar $          = __webpack_require__(3)\n\t  , LIBRARY    = __webpack_require__(25)\n\t  , global     = __webpack_require__(2)\n\t  , ctx        = __webpack_require__(6)\n\t  , classof    = __webpack_require__(20)\n\t  , $export    = __webpack_require__(22)\n\t  , isObject   = __webpack_require__(9)\n\t  , anObject   = __webpack_require__(4)\n\t  , aFunction  = __webpack_require__(10)\n\t  , strictNew  = __webpack_require__(57)\n\t  , forOf      = __webpack_require__(41)\n\t  , setProto   = __webpack_require__(53).set\n\t  , same       = __webpack_require__(52)\n\t  , SPECIES    = __webpack_require__(1)('species')\n\t  , speciesConstructor = __webpack_require__(56)\n\t  , asap       = __webpack_require__(50)\n\t  , PROMISE    = 'Promise'\n\t  , process    = global.process\n\t  , isNode     = classof(process) == 'process'\n\t  , P          = global[PROMISE]\n\t  , Wrapper;\n\t\n\tvar testResolve = function(sub){\n\t  var test = new P(function(){});\n\t  if(sub)test.constructor = Object;\n\t  return P.resolve(test) === test;\n\t};\n\t\n\tvar USE_NATIVE = function(){\n\t  var works = false;\n\t  function P2(x){\n\t    var self = new P(x);\n\t    setProto(self, P2.prototype);\n\t    return self;\n\t  }\n\t  try {\n\t    works = P && P.resolve && testResolve();\n\t    setProto(P2, P);\n\t    P2.prototype = $.create(P.prototype, {constructor: {value: P2}});\n\t    // actual Firefox has broken subclass support, test that\n\t    if(!(P2.resolve(5).then(function(){}) instanceof P2)){\n\t      works = false;\n\t    }\n\t    // actual V8 bug, https://code.google.com/p/v8/issues/detail?id=4162\n\t    if(works && __webpack_require__(11)){\n\t      var thenableThenGotten = false;\n\t      P.resolve($.setDesc({}, 'then', {\n\t        get: function(){ thenableThenGotten = true; }\n\t      }));\n\t      works = thenableThenGotten;\n\t    }\n\t  } catch(e){ works = false; }\n\t  return works;\n\t}();\n\t\n\t// helpers\n\tvar sameConstructor = function(a, b){\n\t  // library wrapper special case\n\t  if(LIBRARY && a === P && b === Wrapper)return true;\n\t  return same(a, b);\n\t};\n\tvar getConstructor = function(C){\n\t  var S = anObject(C)[SPECIES];\n\t  return S != undefined ? S : C;\n\t};\n\tvar isThenable = function(it){\n\t  var then;\n\t  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;\n\t};\n\tvar PromiseCapability = function(C){\n\t  var resolve, reject;\n\t  this.promise = new C(function($$resolve, $$reject){\n\t    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');\n\t    resolve = $$resolve;\n\t    reject  = $$reject;\n\t  });\n\t  this.resolve = aFunction(resolve),\n\t  this.reject  = aFunction(reject)\n\t};\n\tvar perform = function(exec){\n\t  try {\n\t    exec();\n\t  } catch(e){\n\t    return {error: e};\n\t  }\n\t};\n\tvar notify = function(record, isReject){\n\t  if(record.n)return;\n\t  record.n = true;\n\t  var chain = record.c;\n\t  asap(function(){\n\t    var value = record.v\n\t      , ok    = record.s == 1\n\t      , i     = 0;\n\t    var run = function(reaction){\n\t      var handler = ok ? reaction.ok : reaction.fail\n\t        , resolve = reaction.resolve\n\t        , reject  = reaction.reject\n\t        , result, then;\n\t      try {\n\t        if(handler){\n\t          if(!ok)record.h = true;\n\t          result = handler === true ? value : handler(value);\n\t          if(result === reaction.promise){\n\t            reject(TypeError('Promise-chain cycle'));\n\t          } else if(then = isThenable(result)){\n\t            then.call(result, resolve, reject);\n\t          } else resolve(result);\n\t        } else reject(value);\n\t      } catch(e){\n\t        reject(e);\n\t      }\n\t    };\n\t    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach\n\t    chain.length = 0;\n\t    record.n = false;\n\t    if(isReject)setTimeout(function(){\n\t      var promise = record.p\n\t        , handler, console;\n\t      if(isUnhandled(promise)){\n\t        if(isNode){\n\t          process.emit('unhandledRejection', value, promise);\n\t        } else if(handler = global.onunhandledrejection){\n\t          handler({promise: promise, reason: value});\n\t        } else if((console = global.console) && console.error){\n\t          console.error('Unhandled promise rejection', value);\n\t        }\n\t      } record.a = undefined;\n\t    }, 1);\n\t  });\n\t};\n\tvar isUnhandled = function(promise){\n\t  var record = promise._d\n\t    , chain  = record.a || record.c\n\t    , i      = 0\n\t    , reaction;\n\t  if(record.h)return false;\n\t  while(chain.length > i){\n\t    reaction = chain[i++];\n\t    if(reaction.fail || !isUnhandled(reaction.promise))return false;\n\t  } return true;\n\t};\n\tvar $reject = function(value){\n\t  var record = this;\n\t  if(record.d)return;\n\t  record.d = true;\n\t  record = record.r || record; // unwrap\n\t  record.v = value;\n\t  record.s = 2;\n\t  record.a = record.c.slice();\n\t  notify(record, true);\n\t};\n\tvar $resolve = function(value){\n\t  var record = this\n\t    , then;\n\t  if(record.d)return;\n\t  record.d = true;\n\t  record = record.r || record; // unwrap\n\t  try {\n\t    if(record.p === value)throw TypeError(\"Promise can't be resolved itself\");\n\t    if(then = isThenable(value)){\n\t      asap(function(){\n\t        var wrapper = {r: record, d: false}; // wrap\n\t        try {\n\t          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));\n\t        } catch(e){\n\t          $reject.call(wrapper, e);\n\t        }\n\t      });\n\t    } else {\n\t      record.v = value;\n\t      record.s = 1;\n\t      notify(record, false);\n\t    }\n\t  } catch(e){\n\t    $reject.call({r: record, d: false}, e); // wrap\n\t  }\n\t};\n\t\n\t// constructor polyfill\n\tif(!USE_NATIVE){\n\t  // 25.4.3.1 Promise(executor)\n\t  P = function Promise(executor){\n\t    aFunction(executor);\n\t    var record = this._d = {\n\t      p: strictNew(this, P, PROMISE),         // <- promise\n\t      c: [],                                  // <- awaiting reactions\n\t      a: undefined,                           // <- checked in isUnhandled reactions\n\t      s: 0,                                   // <- state\n\t      d: false,                               // <- done\n\t      v: undefined,                           // <- value\n\t      h: false,                               // <- handled rejection\n\t      n: false                                // <- notify\n\t    };\n\t    try {\n\t      executor(ctx($resolve, record, 1), ctx($reject, record, 1));\n\t    } catch(err){\n\t      $reject.call(record, err);\n\t    }\n\t  };\n\t  __webpack_require__(51)(P.prototype, {\n\t    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\n\t    then: function then(onFulfilled, onRejected){\n\t      var reaction = new PromiseCapability(speciesConstructor(this, P))\n\t        , promise  = reaction.promise\n\t        , record   = this._d;\n\t      reaction.ok   = typeof onFulfilled == 'function' ? onFulfilled : true;\n\t      reaction.fail = typeof onRejected == 'function' && onRejected;\n\t      record.c.push(reaction);\n\t      if(record.a)record.a.push(reaction);\n\t      if(record.s)notify(record, false);\n\t      return promise;\n\t    },\n\t    // 25.4.5.1 Promise.prototype.catch(onRejected)\n\t    'catch': function(onRejected){\n\t      return this.then(undefined, onRejected);\n\t    }\n\t  });\n\t}\n\t\n\t$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: P});\n\t__webpack_require__(13)(P, PROMISE);\n\t__webpack_require__(54)(PROMISE);\n\tWrapper = __webpack_require__(5)[PROMISE];\n\t\n\t// statics\n\t$export($export.S + $export.F * !USE_NATIVE, PROMISE, {\n\t  // 25.4.4.5 Promise.reject(r)\n\t  reject: function reject(r){\n\t    var capability = new PromiseCapability(this)\n\t      , $$reject   = capability.reject;\n\t    $$reject(r);\n\t    return capability.promise;\n\t  }\n\t});\n\t$export($export.S + $export.F * (!USE_NATIVE || testResolve(true)), PROMISE, {\n\t  // 25.4.4.6 Promise.resolve(x)\n\t  resolve: function resolve(x){\n\t    // instanceof instead of internal slot check because we should fix it without replacement native Promise core\n\t    if(x instanceof P && sameConstructor(x.constructor, this))return x;\n\t    var capability = new PromiseCapability(this)\n\t      , $$resolve  = capability.resolve;\n\t    $$resolve(x);\n\t    return capability.promise;\n\t  }\n\t});\n\t$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(48)(function(iter){\n\t  P.all(iter)['catch'](function(){});\n\t})), PROMISE, {\n\t  // 25.4.4.1 Promise.all(iterable)\n\t  all: function all(iterable){\n\t    var C          = getConstructor(this)\n\t      , capability = new PromiseCapability(C)\n\t      , resolve    = capability.resolve\n\t      , reject     = capability.reject\n\t      , values     = [];\n\t    var abrupt = perform(function(){\n\t      forOf(iterable, false, values.push, values);\n\t      var remaining = values.length\n\t        , results   = Array(remaining);\n\t      if(remaining)$.each.call(values, function(promise, index){\n\t        var alreadyCalled = false;\n\t        C.resolve(promise).then(function(value){\n\t          if(alreadyCalled)return;\n\t          alreadyCalled = true;\n\t          results[index] = value;\n\t          --remaining || resolve(results);\n\t        }, reject);\n\t      });\n\t      else resolve(results);\n\t    });\n\t    if(abrupt)reject(abrupt.error);\n\t    return capability.promise;\n\t  },\n\t  // 25.4.4.4 Promise.race(iterable)\n\t  race: function race(iterable){\n\t    var C          = getConstructor(this)\n\t      , capability = new PromiseCapability(C)\n\t      , reject     = capability.reject;\n\t    var abrupt = perform(function(){\n\t      forOf(iterable, false, function(promise){\n\t        C.resolve(promise).then(capability.resolve, reject);\n\t      });\n\t    });\n\t    if(abrupt)reject(abrupt.error);\n\t    return capability.promise;\n\t  }\n\t});\n\n/***/ },\n/* 67 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar $at  = __webpack_require__(58)(true);\n\t\n\t// 21.1.3.27 String.prototype[@@iterator]()\n\t__webpack_require__(24)(String, 'String', function(iterated){\n\t  this._t = String(iterated); // target\n\t  this._i = 0;                // next index\n\t// 21.1.5.2.1 %StringIteratorPrototype%.next()\n\t}, function(){\n\t  var O     = this._t\n\t    , index = this._i\n\t    , point;\n\t  if(index >= O.length)return {value: undefined, done: true};\n\t  point = $at(O, index);\n\t  this._i += point.length;\n\t  return {value: point, done: false};\n\t});\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(64);\n\tvar Iterators = __webpack_require__(7);\n\tIterators.NodeList = Iterators.HTMLCollection = Iterators.Array;\n\n/***/ },\n/* 69 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(29)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"body{font-family:Helvetica,sans-serif}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(29)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"#map{height:800px;width:800px}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 71 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div id=app> <h1>{{ title }}</h1> <map :zoom=zoom :center=center :min-zoom=minZoom :max-zoom=maxZoom> <tilelayer :url=url :attribution=attribution></tilelayer> <marker :position=center></marker> </map> </div>\";\n\n/***/ },\n/* 72 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div id=map> <slot></slot> </div>\";\n\n/***/ },\n/* 73 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __vue_script__, __vue_template__\n\t__webpack_require__(75)\n\t__vue_script__ = __webpack_require__(34)\n\t__vue_template__ = __webpack_require__(71)\n\tmodule.exports = __vue_script__ || {}\n\tif (module.exports.__esModule) module.exports = module.exports.default\n\tif (__vue_template__) {\n\t(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n\t}\n\n\n/***/ },\n/* 74 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __vue_script__, __vue_template__\n\t__webpack_require__(76)\n\t__vue_script__ = __webpack_require__(35)\n\t__vue_template__ = __webpack_require__(72)\n\tmodule.exports = __vue_script__ || {}\n\tif (module.exports.__esModule) module.exports = module.exports.default\n\tif (__vue_template__) {\n\t(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n\t}\n\n\n/***/ },\n/* 75 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(69);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(30)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../node_modules/css-loader/index.js!./../node_modules/vue-loader/lib/style-rewriter.js!./../node_modules/vue-loader/lib/selector.js?type=style&index=0!./App.vue\", function() {\n\t\t\t\tvar newContent = require(\"!!./../node_modules/css-loader/index.js!./../node_modules/vue-loader/lib/style-rewriter.js!./../node_modules/vue-loader/lib/selector.js?type=style&index=0!./App.vue\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 76 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(70);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(30)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/vue-loader/lib/style-rewriter.js!./../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./Map.vue\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/vue-loader/lib/style-rewriter.js!./../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./Map.vue\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** build.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap cc559e26e8dff1b5d368\n **/","import Vue from 'vue'\nimport App from './App.vue'\n\nnew Vue({\n  el: 'body',\n  components: { App }\n})\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/main.js\n **/","var store  = require('./$.shared')('wks')\n  , uid    = require('./$.uid')\n  , Symbol = require('./$.global').Symbol;\nmodule.exports = function(name){\n  return store[name] || (store[name] =\n    Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.wks.js\n ** module id = 1\n ** module chunks = 0\n **/","// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\nif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.global.js\n ** module id = 2\n ** module chunks = 0\n **/","var $Object = Object;\nmodule.exports = {\n  create:     $Object.create,\n  getProto:   $Object.getPrototypeOf,\n  isEnum:     {}.propertyIsEnumerable,\n  getDesc:    $Object.getOwnPropertyDescriptor,\n  setDesc:    $Object.defineProperty,\n  setDescs:   $Object.defineProperties,\n  getKeys:    $Object.keys,\n  getNames:   $Object.getOwnPropertyNames,\n  getSymbols: $Object.getOwnPropertySymbols,\n  each:       [].forEach\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.js\n ** module id = 3\n ** module chunks = 0\n **/","var isObject = require('./$.is-object');\nmodule.exports = function(it){\n  if(!isObject(it))throw TypeError(it + ' is not an object!');\n  return it;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.an-object.js\n ** module id = 4\n ** module chunks = 0\n **/","var core = module.exports = {version: '1.2.6'};\nif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.core.js\n ** module id = 5\n ** module chunks = 0\n **/","// optional / simple context binding\nvar aFunction = require('./$.a-function');\nmodule.exports = function(fn, that, length){\n  aFunction(fn);\n  if(that === undefined)return fn;\n  switch(length){\n    case 1: return function(a){\n      return fn.call(that, a);\n    };\n    case 2: return function(a, b){\n      return fn.call(that, a, b);\n    };\n    case 3: return function(a, b, c){\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function(/* ...args */){\n    return fn.apply(that, arguments);\n  };\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.ctx.js\n ** module id = 6\n ** module chunks = 0\n **/","module.exports = {};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.iterators.js\n ** module id = 7\n ** module chunks = 0\n **/","var toString = {}.toString;\n\nmodule.exports = function(it){\n  return toString.call(it).slice(8, -1);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.cof.js\n ** module id = 8\n ** module chunks = 0\n **/","module.exports = function(it){\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.is-object.js\n ** module id = 9\n ** module chunks = 0\n **/","module.exports = function(it){\n  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.a-function.js\n ** module id = 10\n ** module chunks = 0\n **/","// Thank's IE8 for his funny defineProperty\nmodule.exports = !require('./$.fails')(function(){\n  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.descriptors.js\n ** module id = 11\n ** module chunks = 0\n **/","var $          = require('./$')\n  , createDesc = require('./$.property-desc');\nmodule.exports = require('./$.descriptors') ? function(object, key, value){\n  return $.setDesc(object, key, createDesc(1, value));\n} : function(object, key, value){\n  object[key] = value;\n  return object;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.hide.js\n ** module id = 12\n ** module chunks = 0\n **/","var def = require('./$').setDesc\n  , has = require('./$.has')\n  , TAG = require('./$.wks')('toStringTag');\n\nmodule.exports = function(it, tag, stat){\n  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.set-to-string-tag.js\n ** module id = 13\n ** module chunks = 0\n **/","/*\n Leaflet, a JavaScript library for mobile-friendly interactive maps. http://leafletjs.com\n (c) 2010-2013, Vladimir Agafonkin\n (c) 2010-2011, CloudMade\n*/\n(function (window, document, undefined) {\r\nvar oldL = window.L,\r\n    L = {};\r\n\r\nL.version = '0.7.7';\r\n\r\n// define Leaflet for Node module pattern loaders, including Browserify\r\nif (typeof module === 'object' && typeof module.exports === 'object') {\r\n\tmodule.exports = L;\r\n\r\n// define Leaflet as an AMD module\r\n} else if (typeof define === 'function' && define.amd) {\r\n\tdefine(L);\r\n}\r\n\r\n// define Leaflet as a global L variable, saving the original L to restore later if needed\r\n\r\nL.noConflict = function () {\r\n\twindow.L = oldL;\r\n\treturn this;\r\n};\r\n\r\nwindow.L = L;\r\n\n\n/*\r\n * L.Util contains various utility functions used throughout Leaflet code.\r\n */\r\n\r\nL.Util = {\r\n\textend: function (dest) { // (Object[, Object, ...]) ->\r\n\t\tvar sources = Array.prototype.slice.call(arguments, 1),\r\n\t\t    i, j, len, src;\r\n\r\n\t\tfor (j = 0, len = sources.length; j < len; j++) {\r\n\t\t\tsrc = sources[j] || {};\r\n\t\t\tfor (i in src) {\r\n\t\t\t\tif (src.hasOwnProperty(i)) {\r\n\t\t\t\t\tdest[i] = src[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn dest;\r\n\t},\r\n\r\n\tbind: function (fn, obj) { // (Function, Object) -> Function\r\n\t\tvar args = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;\r\n\t\treturn function () {\r\n\t\t\treturn fn.apply(obj, args || arguments);\r\n\t\t};\r\n\t},\r\n\r\n\tstamp: (function () {\r\n\t\tvar lastId = 0,\r\n\t\t    key = '_leaflet_id';\r\n\t\treturn function (obj) {\r\n\t\t\tobj[key] = obj[key] || ++lastId;\r\n\t\t\treturn obj[key];\r\n\t\t};\r\n\t}()),\r\n\r\n\tinvokeEach: function (obj, method, context) {\r\n\t\tvar i, args;\r\n\r\n\t\tif (typeof obj === 'object') {\r\n\t\t\targs = Array.prototype.slice.call(arguments, 3);\r\n\r\n\t\t\tfor (i in obj) {\r\n\t\t\t\tmethod.apply(context, [i, obj[i]].concat(args));\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t},\r\n\r\n\tlimitExecByInterval: function (fn, time, context) {\r\n\t\tvar lock, execOnUnlock;\r\n\r\n\t\treturn function wrapperFn() {\r\n\t\t\tvar args = arguments;\r\n\r\n\t\t\tif (lock) {\r\n\t\t\t\texecOnUnlock = true;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tlock = true;\r\n\r\n\t\t\tsetTimeout(function () {\r\n\t\t\t\tlock = false;\r\n\r\n\t\t\t\tif (execOnUnlock) {\r\n\t\t\t\t\twrapperFn.apply(context, args);\r\n\t\t\t\t\texecOnUnlock = false;\r\n\t\t\t\t}\r\n\t\t\t}, time);\r\n\r\n\t\t\tfn.apply(context, args);\r\n\t\t};\r\n\t},\r\n\r\n\tfalseFn: function () {\r\n\t\treturn false;\r\n\t},\r\n\r\n\tformatNum: function (num, digits) {\r\n\t\tvar pow = Math.pow(10, digits || 5);\r\n\t\treturn Math.round(num * pow) / pow;\r\n\t},\r\n\r\n\ttrim: function (str) {\r\n\t\treturn str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\r\n\t},\r\n\r\n\tsplitWords: function (str) {\r\n\t\treturn L.Util.trim(str).split(/\\s+/);\r\n\t},\r\n\r\n\tsetOptions: function (obj, options) {\r\n\t\tobj.options = L.extend({}, obj.options, options);\r\n\t\treturn obj.options;\r\n\t},\r\n\r\n\tgetParamString: function (obj, existingUrl, uppercase) {\r\n\t\tvar params = [];\r\n\t\tfor (var i in obj) {\r\n\t\t\tparams.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));\r\n\t\t}\r\n\t\treturn ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');\r\n\t},\r\n\ttemplate: function (str, data) {\r\n\t\treturn str.replace(/\\{ *([\\w_]+) *\\}/g, function (str, key) {\r\n\t\t\tvar value = data[key];\r\n\t\t\tif (value === undefined) {\r\n\t\t\t\tthrow new Error('No value provided for variable ' + str);\r\n\t\t\t} else if (typeof value === 'function') {\r\n\t\t\t\tvalue = value(data);\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t});\r\n\t},\r\n\r\n\tisArray: Array.isArray || function (obj) {\r\n\t\treturn (Object.prototype.toString.call(obj) === '[object Array]');\r\n\t},\r\n\r\n\temptyImageUrl: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='\r\n};\r\n\r\n(function () {\r\n\r\n\t// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/\r\n\r\n\tfunction getPrefixed(name) {\r\n\t\tvar i, fn,\r\n\t\t    prefixes = ['webkit', 'moz', 'o', 'ms'];\r\n\r\n\t\tfor (i = 0; i < prefixes.length && !fn; i++) {\r\n\t\t\tfn = window[prefixes[i] + name];\r\n\t\t}\r\n\r\n\t\treturn fn;\r\n\t}\r\n\r\n\tvar lastTime = 0;\r\n\r\n\tfunction timeoutDefer(fn) {\r\n\t\tvar time = +new Date(),\r\n\t\t    timeToCall = Math.max(0, 16 - (time - lastTime));\r\n\r\n\t\tlastTime = time + timeToCall;\r\n\t\treturn window.setTimeout(fn, timeToCall);\r\n\t}\r\n\r\n\tvar requestFn = window.requestAnimationFrame ||\r\n\t        getPrefixed('RequestAnimationFrame') || timeoutDefer;\r\n\r\n\tvar cancelFn = window.cancelAnimationFrame ||\r\n\t        getPrefixed('CancelAnimationFrame') ||\r\n\t        getPrefixed('CancelRequestAnimationFrame') ||\r\n\t        function (id) { window.clearTimeout(id); };\r\n\r\n\r\n\tL.Util.requestAnimFrame = function (fn, context, immediate, element) {\r\n\t\tfn = L.bind(fn, context);\r\n\r\n\t\tif (immediate && requestFn === timeoutDefer) {\r\n\t\t\tfn();\r\n\t\t} else {\r\n\t\t\treturn requestFn.call(window, fn, element);\r\n\t\t}\r\n\t};\r\n\r\n\tL.Util.cancelAnimFrame = function (id) {\r\n\t\tif (id) {\r\n\t\t\tcancelFn.call(window, id);\r\n\t\t}\r\n\t};\r\n\r\n}());\r\n\r\n// shortcuts for most used utility functions\r\nL.extend = L.Util.extend;\r\nL.bind = L.Util.bind;\r\nL.stamp = L.Util.stamp;\r\nL.setOptions = L.Util.setOptions;\r\n\n\n/*\r\n * L.Class powers the OOP facilities of the library.\r\n * Thanks to John Resig and Dean Edwards for inspiration!\r\n */\r\n\r\nL.Class = function () {};\r\n\r\nL.Class.extend = function (props) {\r\n\r\n\t// extended class with the new prototype\r\n\tvar NewClass = function () {\r\n\r\n\t\t// call the constructor\r\n\t\tif (this.initialize) {\r\n\t\t\tthis.initialize.apply(this, arguments);\r\n\t\t}\r\n\r\n\t\t// call all constructor hooks\r\n\t\tif (this._initHooks) {\r\n\t\t\tthis.callInitHooks();\r\n\t\t}\r\n\t};\r\n\r\n\t// instantiate class without calling constructor\r\n\tvar F = function () {};\r\n\tF.prototype = this.prototype;\r\n\r\n\tvar proto = new F();\r\n\tproto.constructor = NewClass;\r\n\r\n\tNewClass.prototype = proto;\r\n\r\n\t//inherit parent's statics\r\n\tfor (var i in this) {\r\n\t\tif (this.hasOwnProperty(i) && i !== 'prototype') {\r\n\t\t\tNewClass[i] = this[i];\r\n\t\t}\r\n\t}\r\n\r\n\t// mix static properties into the class\r\n\tif (props.statics) {\r\n\t\tL.extend(NewClass, props.statics);\r\n\t\tdelete props.statics;\r\n\t}\r\n\r\n\t// mix includes into the prototype\r\n\tif (props.includes) {\r\n\t\tL.Util.extend.apply(null, [proto].concat(props.includes));\r\n\t\tdelete props.includes;\r\n\t}\r\n\r\n\t// merge options\r\n\tif (props.options && proto.options) {\r\n\t\tprops.options = L.extend({}, proto.options, props.options);\r\n\t}\r\n\r\n\t// mix given properties into the prototype\r\n\tL.extend(proto, props);\r\n\r\n\tproto._initHooks = [];\r\n\r\n\tvar parent = this;\r\n\t// jshint camelcase: false\r\n\tNewClass.__super__ = parent.prototype;\r\n\r\n\t// add method for calling all hooks\r\n\tproto.callInitHooks = function () {\r\n\r\n\t\tif (this._initHooksCalled) { return; }\r\n\r\n\t\tif (parent.prototype.callInitHooks) {\r\n\t\t\tparent.prototype.callInitHooks.call(this);\r\n\t\t}\r\n\r\n\t\tthis._initHooksCalled = true;\r\n\r\n\t\tfor (var i = 0, len = proto._initHooks.length; i < len; i++) {\r\n\t\t\tproto._initHooks[i].call(this);\r\n\t\t}\r\n\t};\r\n\r\n\treturn NewClass;\r\n};\r\n\r\n\r\n// method for adding properties to prototype\r\nL.Class.include = function (props) {\r\n\tL.extend(this.prototype, props);\r\n};\r\n\r\n// merge new default options to the Class\r\nL.Class.mergeOptions = function (options) {\r\n\tL.extend(this.prototype.options, options);\r\n};\r\n\r\n// add a constructor hook\r\nL.Class.addInitHook = function (fn) { // (Function) || (String, args...)\r\n\tvar args = Array.prototype.slice.call(arguments, 1);\r\n\r\n\tvar init = typeof fn === 'function' ? fn : function () {\r\n\t\tthis[fn].apply(this, args);\r\n\t};\r\n\r\n\tthis.prototype._initHooks = this.prototype._initHooks || [];\r\n\tthis.prototype._initHooks.push(init);\r\n};\r\n\n\n/*\r\n * L.Mixin.Events is used to add custom events functionality to Leaflet classes.\r\n */\r\n\r\nvar eventsKey = '_leaflet_events';\r\n\r\nL.Mixin = {};\r\n\r\nL.Mixin.Events = {\r\n\r\n\taddEventListener: function (types, fn, context) { // (String, Function[, Object]) or (Object[, Object])\r\n\r\n\t\t// types can be a map of types/handlers\r\n\t\tif (L.Util.invokeEach(types, this.addEventListener, this, fn, context)) { return this; }\r\n\r\n\t\tvar events = this[eventsKey] = this[eventsKey] || {},\r\n\t\t    contextId = context && context !== this && L.stamp(context),\r\n\t\t    i, len, event, type, indexKey, indexLenKey, typeIndex;\r\n\r\n\t\t// types can be a string of space-separated words\r\n\t\ttypes = L.Util.splitWords(types);\r\n\r\n\t\tfor (i = 0, len = types.length; i < len; i++) {\r\n\t\t\tevent = {\r\n\t\t\t\taction: fn,\r\n\t\t\t\tcontext: context || this\r\n\t\t\t};\r\n\t\t\ttype = types[i];\r\n\r\n\t\t\tif (contextId) {\r\n\t\t\t\t// store listeners of a particular context in a separate hash (if it has an id)\r\n\t\t\t\t// gives a major performance boost when removing thousands of map layers\r\n\r\n\t\t\t\tindexKey = type + '_idx';\r\n\t\t\t\tindexLenKey = indexKey + '_len';\r\n\r\n\t\t\t\ttypeIndex = events[indexKey] = events[indexKey] || {};\r\n\r\n\t\t\t\tif (!typeIndex[contextId]) {\r\n\t\t\t\t\ttypeIndex[contextId] = [];\r\n\r\n\t\t\t\t\t// keep track of the number of keys in the index to quickly check if it's empty\r\n\t\t\t\t\tevents[indexLenKey] = (events[indexLenKey] || 0) + 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttypeIndex[contextId].push(event);\r\n\r\n\r\n\t\t\t} else {\r\n\t\t\t\tevents[type] = events[type] || [];\r\n\t\t\t\tevents[type].push(event);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\thasEventListeners: function (type) { // (String) -> Boolean\r\n\t\tvar events = this[eventsKey];\r\n\t\treturn !!events && ((type in events && events[type].length > 0) ||\r\n\t\t                    (type + '_idx' in events && events[type + '_idx_len'] > 0));\r\n\t},\r\n\r\n\tremoveEventListener: function (types, fn, context) { // ([String, Function, Object]) or (Object[, Object])\r\n\r\n\t\tif (!this[eventsKey]) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tif (!types) {\r\n\t\t\treturn this.clearAllEventListeners();\r\n\t\t}\r\n\r\n\t\tif (L.Util.invokeEach(types, this.removeEventListener, this, fn, context)) { return this; }\r\n\r\n\t\tvar events = this[eventsKey],\r\n\t\t    contextId = context && context !== this && L.stamp(context),\r\n\t\t    i, len, type, listeners, j, indexKey, indexLenKey, typeIndex, removed;\r\n\r\n\t\ttypes = L.Util.splitWords(types);\r\n\r\n\t\tfor (i = 0, len = types.length; i < len; i++) {\r\n\t\t\ttype = types[i];\r\n\t\t\tindexKey = type + '_idx';\r\n\t\t\tindexLenKey = indexKey + '_len';\r\n\r\n\t\t\ttypeIndex = events[indexKey];\r\n\r\n\t\t\tif (!fn) {\r\n\t\t\t\t// clear all listeners for a type if function isn't specified\r\n\t\t\t\tdelete events[type];\r\n\t\t\t\tdelete events[indexKey];\r\n\t\t\t\tdelete events[indexLenKey];\r\n\r\n\t\t\t} else {\r\n\t\t\t\tlisteners = contextId && typeIndex ? typeIndex[contextId] : events[type];\r\n\r\n\t\t\t\tif (listeners) {\r\n\t\t\t\t\tfor (j = listeners.length - 1; j >= 0; j--) {\r\n\t\t\t\t\t\tif ((listeners[j].action === fn) && (!context || (listeners[j].context === context))) {\r\n\t\t\t\t\t\t\tremoved = listeners.splice(j, 1);\r\n\t\t\t\t\t\t\t// set the old action to a no-op, because it is possible\r\n\t\t\t\t\t\t\t// that the listener is being iterated over as part of a dispatch\r\n\t\t\t\t\t\t\tremoved[0].action = L.Util.falseFn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (context && typeIndex && (listeners.length === 0)) {\r\n\t\t\t\t\t\tdelete typeIndex[contextId];\r\n\t\t\t\t\t\tevents[indexLenKey]--;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tclearAllEventListeners: function () {\r\n\t\tdelete this[eventsKey];\r\n\t\treturn this;\r\n\t},\r\n\r\n\tfireEvent: function (type, data) { // (String[, Object])\r\n\t\tif (!this.hasEventListeners(type)) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tvar event = L.Util.extend({}, data, { type: type, target: this });\r\n\r\n\t\tvar events = this[eventsKey],\r\n\t\t    listeners, i, len, typeIndex, contextId;\r\n\r\n\t\tif (events[type]) {\r\n\t\t\t// make sure adding/removing listeners inside other listeners won't cause infinite loop\r\n\t\t\tlisteners = events[type].slice();\r\n\r\n\t\t\tfor (i = 0, len = listeners.length; i < len; i++) {\r\n\t\t\t\tlisteners[i].action.call(listeners[i].context, event);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// fire event for the context-indexed listeners as well\r\n\t\ttypeIndex = events[type + '_idx'];\r\n\r\n\t\tfor (contextId in typeIndex) {\r\n\t\t\tlisteners = typeIndex[contextId].slice();\r\n\r\n\t\t\tif (listeners) {\r\n\t\t\t\tfor (i = 0, len = listeners.length; i < len; i++) {\r\n\t\t\t\t\tlisteners[i].action.call(listeners[i].context, event);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\taddOneTimeEventListener: function (types, fn, context) {\r\n\r\n\t\tif (L.Util.invokeEach(types, this.addOneTimeEventListener, this, fn, context)) { return this; }\r\n\r\n\t\tvar handler = L.bind(function () {\r\n\t\t\tthis\r\n\t\t\t    .removeEventListener(types, fn, context)\r\n\t\t\t    .removeEventListener(types, handler, context);\r\n\t\t}, this);\r\n\r\n\t\treturn this\r\n\t\t    .addEventListener(types, fn, context)\r\n\t\t    .addEventListener(types, handler, context);\r\n\t}\r\n};\r\n\r\nL.Mixin.Events.on = L.Mixin.Events.addEventListener;\r\nL.Mixin.Events.off = L.Mixin.Events.removeEventListener;\r\nL.Mixin.Events.once = L.Mixin.Events.addOneTimeEventListener;\r\nL.Mixin.Events.fire = L.Mixin.Events.fireEvent;\r\n\n\n/*\r\n * L.Browser handles different browser and feature detections for internal Leaflet use.\r\n */\r\n\r\n(function () {\r\n\r\n\tvar ie = 'ActiveXObject' in window,\r\n\t\tielt9 = ie && !document.addEventListener,\r\n\r\n\t    // terrible browser detection to work around Safari / iOS / Android browser bugs\r\n\t    ua = navigator.userAgent.toLowerCase(),\r\n\t    webkit = ua.indexOf('webkit') !== -1,\r\n\t    chrome = ua.indexOf('chrome') !== -1,\r\n\t    phantomjs = ua.indexOf('phantom') !== -1,\r\n\t    android = ua.indexOf('android') !== -1,\r\n\t    android23 = ua.search('android [23]') !== -1,\r\n\t\tgecko = ua.indexOf('gecko') !== -1,\r\n\r\n\t    mobile = typeof orientation !== undefined + '',\r\n\t    msPointer = !window.PointerEvent && window.MSPointerEvent,\r\n\t\tpointer = (window.PointerEvent && window.navigator.pointerEnabled) ||\r\n\t\t\t\t  msPointer,\r\n\t    retina = ('devicePixelRatio' in window && window.devicePixelRatio > 1) ||\r\n\t             ('matchMedia' in window && window.matchMedia('(min-resolution:144dpi)') &&\r\n\t              window.matchMedia('(min-resolution:144dpi)').matches),\r\n\r\n\t    doc = document.documentElement,\r\n\t    ie3d = ie && ('transition' in doc.style),\r\n\t    webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,\r\n\t    gecko3d = 'MozPerspective' in doc.style,\r\n\t    opera3d = 'OTransition' in doc.style,\r\n\t    any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d || opera3d) && !phantomjs;\r\n\r\n\tvar touch = !window.L_NO_TOUCH && !phantomjs && (pointer || 'ontouchstart' in window ||\r\n\t\t(window.DocumentTouch && document instanceof window.DocumentTouch));\r\n\r\n\tL.Browser = {\r\n\t\tie: ie,\r\n\t\tielt9: ielt9,\r\n\t\twebkit: webkit,\r\n\t\tgecko: gecko && !webkit && !window.opera && !ie,\r\n\r\n\t\tandroid: android,\r\n\t\tandroid23: android23,\r\n\r\n\t\tchrome: chrome,\r\n\r\n\t\tie3d: ie3d,\r\n\t\twebkit3d: webkit3d,\r\n\t\tgecko3d: gecko3d,\r\n\t\topera3d: opera3d,\r\n\t\tany3d: any3d,\r\n\r\n\t\tmobile: mobile,\r\n\t\tmobileWebkit: mobile && webkit,\r\n\t\tmobileWebkit3d: mobile && webkit3d,\r\n\t\tmobileOpera: mobile && window.opera,\r\n\r\n\t\ttouch: touch,\r\n\t\tmsPointer: msPointer,\r\n\t\tpointer: pointer,\r\n\r\n\t\tretina: retina\r\n\t};\r\n\r\n}());\r\n\n\n/*\r\n * L.Point represents a point with x and y coordinates.\r\n */\r\n\r\nL.Point = function (/*Number*/ x, /*Number*/ y, /*Boolean*/ round) {\r\n\tthis.x = (round ? Math.round(x) : x);\r\n\tthis.y = (round ? Math.round(y) : y);\r\n};\r\n\r\nL.Point.prototype = {\r\n\r\n\tclone: function () {\r\n\t\treturn new L.Point(this.x, this.y);\r\n\t},\r\n\r\n\t// non-destructive, returns a new point\r\n\tadd: function (point) {\r\n\t\treturn this.clone()._add(L.point(point));\r\n\t},\r\n\r\n\t// destructive, used directly for performance in situations where it's safe to modify existing point\r\n\t_add: function (point) {\r\n\t\tthis.x += point.x;\r\n\t\tthis.y += point.y;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsubtract: function (point) {\r\n\t\treturn this.clone()._subtract(L.point(point));\r\n\t},\r\n\r\n\t_subtract: function (point) {\r\n\t\tthis.x -= point.x;\r\n\t\tthis.y -= point.y;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tdivideBy: function (num) {\r\n\t\treturn this.clone()._divideBy(num);\r\n\t},\r\n\r\n\t_divideBy: function (num) {\r\n\t\tthis.x /= num;\r\n\t\tthis.y /= num;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tmultiplyBy: function (num) {\r\n\t\treturn this.clone()._multiplyBy(num);\r\n\t},\r\n\r\n\t_multiplyBy: function (num) {\r\n\t\tthis.x *= num;\r\n\t\tthis.y *= num;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tround: function () {\r\n\t\treturn this.clone()._round();\r\n\t},\r\n\r\n\t_round: function () {\r\n\t\tthis.x = Math.round(this.x);\r\n\t\tthis.y = Math.round(this.y);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tfloor: function () {\r\n\t\treturn this.clone()._floor();\r\n\t},\r\n\r\n\t_floor: function () {\r\n\t\tthis.x = Math.floor(this.x);\r\n\t\tthis.y = Math.floor(this.y);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tdistanceTo: function (point) {\r\n\t\tpoint = L.point(point);\r\n\r\n\t\tvar x = point.x - this.x,\r\n\t\t    y = point.y - this.y;\r\n\r\n\t\treturn Math.sqrt(x * x + y * y);\r\n\t},\r\n\r\n\tequals: function (point) {\r\n\t\tpoint = L.point(point);\r\n\r\n\t\treturn point.x === this.x &&\r\n\t\t       point.y === this.y;\r\n\t},\r\n\r\n\tcontains: function (point) {\r\n\t\tpoint = L.point(point);\r\n\r\n\t\treturn Math.abs(point.x) <= Math.abs(this.x) &&\r\n\t\t       Math.abs(point.y) <= Math.abs(this.y);\r\n\t},\r\n\r\n\ttoString: function () {\r\n\t\treturn 'Point(' +\r\n\t\t        L.Util.formatNum(this.x) + ', ' +\r\n\t\t        L.Util.formatNum(this.y) + ')';\r\n\t}\r\n};\r\n\r\nL.point = function (x, y, round) {\r\n\tif (x instanceof L.Point) {\r\n\t\treturn x;\r\n\t}\r\n\tif (L.Util.isArray(x)) {\r\n\t\treturn new L.Point(x[0], x[1]);\r\n\t}\r\n\tif (x === undefined || x === null) {\r\n\t\treturn x;\r\n\t}\r\n\treturn new L.Point(x, y, round);\r\n};\r\n\n\n/*\r\n * L.Bounds represents a rectangular area on the screen in pixel coordinates.\r\n */\r\n\r\nL.Bounds = function (a, b) { //(Point, Point) or Point[]\r\n\tif (!a) { return; }\r\n\r\n\tvar points = b ? [a, b] : a;\r\n\r\n\tfor (var i = 0, len = points.length; i < len; i++) {\r\n\t\tthis.extend(points[i]);\r\n\t}\r\n};\r\n\r\nL.Bounds.prototype = {\r\n\t// extend the bounds to contain the given point\r\n\textend: function (point) { // (Point)\r\n\t\tpoint = L.point(point);\r\n\r\n\t\tif (!this.min && !this.max) {\r\n\t\t\tthis.min = point.clone();\r\n\t\t\tthis.max = point.clone();\r\n\t\t} else {\r\n\t\t\tthis.min.x = Math.min(point.x, this.min.x);\r\n\t\t\tthis.max.x = Math.max(point.x, this.max.x);\r\n\t\t\tthis.min.y = Math.min(point.y, this.min.y);\r\n\t\t\tthis.max.y = Math.max(point.y, this.max.y);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetCenter: function (round) { // (Boolean) -> Point\r\n\t\treturn new L.Point(\r\n\t\t        (this.min.x + this.max.x) / 2,\r\n\t\t        (this.min.y + this.max.y) / 2, round);\r\n\t},\r\n\r\n\tgetBottomLeft: function () { // -> Point\r\n\t\treturn new L.Point(this.min.x, this.max.y);\r\n\t},\r\n\r\n\tgetTopRight: function () { // -> Point\r\n\t\treturn new L.Point(this.max.x, this.min.y);\r\n\t},\r\n\r\n\tgetSize: function () {\r\n\t\treturn this.max.subtract(this.min);\r\n\t},\r\n\r\n\tcontains: function (obj) { // (Bounds) or (Point) -> Boolean\r\n\t\tvar min, max;\r\n\r\n\t\tif (typeof obj[0] === 'number' || obj instanceof L.Point) {\r\n\t\t\tobj = L.point(obj);\r\n\t\t} else {\r\n\t\t\tobj = L.bounds(obj);\r\n\t\t}\r\n\r\n\t\tif (obj instanceof L.Bounds) {\r\n\t\t\tmin = obj.min;\r\n\t\t\tmax = obj.max;\r\n\t\t} else {\r\n\t\t\tmin = max = obj;\r\n\t\t}\r\n\r\n\t\treturn (min.x >= this.min.x) &&\r\n\t\t       (max.x <= this.max.x) &&\r\n\t\t       (min.y >= this.min.y) &&\r\n\t\t       (max.y <= this.max.y);\r\n\t},\r\n\r\n\tintersects: function (bounds) { // (Bounds) -> Boolean\r\n\t\tbounds = L.bounds(bounds);\r\n\r\n\t\tvar min = this.min,\r\n\t\t    max = this.max,\r\n\t\t    min2 = bounds.min,\r\n\t\t    max2 = bounds.max,\r\n\t\t    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),\r\n\t\t    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);\r\n\r\n\t\treturn xIntersects && yIntersects;\r\n\t},\r\n\r\n\tisValid: function () {\r\n\t\treturn !!(this.min && this.max);\r\n\t}\r\n};\r\n\r\nL.bounds = function (a, b) { // (Bounds) or (Point, Point) or (Point[])\r\n\tif (!a || a instanceof L.Bounds) {\r\n\t\treturn a;\r\n\t}\r\n\treturn new L.Bounds(a, b);\r\n};\r\n\n\n/*\r\n * L.Transformation is an utility class to perform simple point transformations through a 2d-matrix.\r\n */\r\n\r\nL.Transformation = function (a, b, c, d) {\r\n\tthis._a = a;\r\n\tthis._b = b;\r\n\tthis._c = c;\r\n\tthis._d = d;\r\n};\r\n\r\nL.Transformation.prototype = {\r\n\ttransform: function (point, scale) { // (Point, Number) -> Point\r\n\t\treturn this._transform(point.clone(), scale);\r\n\t},\r\n\r\n\t// destructive transform (faster)\r\n\t_transform: function (point, scale) {\r\n\t\tscale = scale || 1;\r\n\t\tpoint.x = scale * (this._a * point.x + this._b);\r\n\t\tpoint.y = scale * (this._c * point.y + this._d);\r\n\t\treturn point;\r\n\t},\r\n\r\n\tuntransform: function (point, scale) {\r\n\t\tscale = scale || 1;\r\n\t\treturn new L.Point(\r\n\t\t        (point.x / scale - this._b) / this._a,\r\n\t\t        (point.y / scale - this._d) / this._c);\r\n\t}\r\n};\r\n\n\n/*\r\n * L.DomUtil contains various utility functions for working with DOM.\r\n */\r\n\r\nL.DomUtil = {\r\n\tget: function (id) {\r\n\t\treturn (typeof id === 'string' ? document.getElementById(id) : id);\r\n\t},\r\n\r\n\tgetStyle: function (el, style) {\r\n\r\n\t\tvar value = el.style[style];\r\n\r\n\t\tif (!value && el.currentStyle) {\r\n\t\t\tvalue = el.currentStyle[style];\r\n\t\t}\r\n\r\n\t\tif ((!value || value === 'auto') && document.defaultView) {\r\n\t\t\tvar css = document.defaultView.getComputedStyle(el, null);\r\n\t\t\tvalue = css ? css[style] : null;\r\n\t\t}\r\n\r\n\t\treturn value === 'auto' ? null : value;\r\n\t},\r\n\r\n\tgetViewportOffset: function (element) {\r\n\r\n\t\tvar top = 0,\r\n\t\t    left = 0,\r\n\t\t    el = element,\r\n\t\t    docBody = document.body,\r\n\t\t    docEl = document.documentElement,\r\n\t\t    pos;\r\n\r\n\t\tdo {\r\n\t\t\ttop  += el.offsetTop  || 0;\r\n\t\t\tleft += el.offsetLeft || 0;\r\n\r\n\t\t\t//add borders\r\n\t\t\ttop += parseInt(L.DomUtil.getStyle(el, 'borderTopWidth'), 10) || 0;\r\n\t\t\tleft += parseInt(L.DomUtil.getStyle(el, 'borderLeftWidth'), 10) || 0;\r\n\r\n\t\t\tpos = L.DomUtil.getStyle(el, 'position');\r\n\r\n\t\t\tif (el.offsetParent === docBody && pos === 'absolute') { break; }\r\n\r\n\t\t\tif (pos === 'fixed') {\r\n\t\t\t\ttop  += docBody.scrollTop  || docEl.scrollTop  || 0;\r\n\t\t\t\tleft += docBody.scrollLeft || docEl.scrollLeft || 0;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tif (pos === 'relative' && !el.offsetLeft) {\r\n\t\t\t\tvar width = L.DomUtil.getStyle(el, 'width'),\r\n\t\t\t\t    maxWidth = L.DomUtil.getStyle(el, 'max-width'),\r\n\t\t\t\t    r = el.getBoundingClientRect();\r\n\r\n\t\t\t\tif (width !== 'none' || maxWidth !== 'none') {\r\n\t\t\t\t\tleft += r.left + el.clientLeft;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//calculate full y offset since we're breaking out of the loop\r\n\t\t\t\ttop += r.top + (docBody.scrollTop  || docEl.scrollTop  || 0);\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tel = el.offsetParent;\r\n\r\n\t\t} while (el);\r\n\r\n\t\tel = element;\r\n\r\n\t\tdo {\r\n\t\t\tif (el === docBody) { break; }\r\n\r\n\t\t\ttop  -= el.scrollTop  || 0;\r\n\t\t\tleft -= el.scrollLeft || 0;\r\n\r\n\t\t\tel = el.parentNode;\r\n\t\t} while (el);\r\n\r\n\t\treturn new L.Point(left, top);\r\n\t},\r\n\r\n\tdocumentIsLtr: function () {\r\n\t\tif (!L.DomUtil._docIsLtrCached) {\r\n\t\t\tL.DomUtil._docIsLtrCached = true;\r\n\t\t\tL.DomUtil._docIsLtr = L.DomUtil.getStyle(document.body, 'direction') === 'ltr';\r\n\t\t}\r\n\t\treturn L.DomUtil._docIsLtr;\r\n\t},\r\n\r\n\tcreate: function (tagName, className, container) {\r\n\r\n\t\tvar el = document.createElement(tagName);\r\n\t\tel.className = className;\r\n\r\n\t\tif (container) {\r\n\t\t\tcontainer.appendChild(el);\r\n\t\t}\r\n\r\n\t\treturn el;\r\n\t},\r\n\r\n\thasClass: function (el, name) {\r\n\t\tif (el.classList !== undefined) {\r\n\t\t\treturn el.classList.contains(name);\r\n\t\t}\r\n\t\tvar className = L.DomUtil._getClass(el);\r\n\t\treturn className.length > 0 && new RegExp('(^|\\\\s)' + name + '(\\\\s|$)').test(className);\r\n\t},\r\n\r\n\taddClass: function (el, name) {\r\n\t\tif (el.classList !== undefined) {\r\n\t\t\tvar classes = L.Util.splitWords(name);\r\n\t\t\tfor (var i = 0, len = classes.length; i < len; i++) {\r\n\t\t\t\tel.classList.add(classes[i]);\r\n\t\t\t}\r\n\t\t} else if (!L.DomUtil.hasClass(el, name)) {\r\n\t\t\tvar className = L.DomUtil._getClass(el);\r\n\t\t\tL.DomUtil._setClass(el, (className ? className + ' ' : '') + name);\r\n\t\t}\r\n\t},\r\n\r\n\tremoveClass: function (el, name) {\r\n\t\tif (el.classList !== undefined) {\r\n\t\t\tel.classList.remove(name);\r\n\t\t} else {\r\n\t\t\tL.DomUtil._setClass(el, L.Util.trim((' ' + L.DomUtil._getClass(el) + ' ').replace(' ' + name + ' ', ' ')));\r\n\t\t}\r\n\t},\r\n\r\n\t_setClass: function (el, name) {\r\n\t\tif (el.className.baseVal === undefined) {\r\n\t\t\tel.className = name;\r\n\t\t} else {\r\n\t\t\t// in case of SVG element\r\n\t\t\tel.className.baseVal = name;\r\n\t\t}\r\n\t},\r\n\r\n\t_getClass: function (el) {\r\n\t\treturn el.className.baseVal === undefined ? el.className : el.className.baseVal;\r\n\t},\r\n\r\n\tsetOpacity: function (el, value) {\r\n\r\n\t\tif ('opacity' in el.style) {\r\n\t\t\tel.style.opacity = value;\r\n\r\n\t\t} else if ('filter' in el.style) {\r\n\r\n\t\t\tvar filter = false,\r\n\t\t\t    filterName = 'DXImageTransform.Microsoft.Alpha';\r\n\r\n\t\t\t// filters collection throws an error if we try to retrieve a filter that doesn't exist\r\n\t\t\ttry {\r\n\t\t\t\tfilter = el.filters.item(filterName);\r\n\t\t\t} catch (e) {\r\n\t\t\t\t// don't set opacity to 1 if we haven't already set an opacity,\r\n\t\t\t\t// it isn't needed and breaks transparent pngs.\r\n\t\t\t\tif (value === 1) { return; }\r\n\t\t\t}\r\n\r\n\t\t\tvalue = Math.round(value * 100);\r\n\r\n\t\t\tif (filter) {\r\n\t\t\t\tfilter.Enabled = (value !== 100);\r\n\t\t\t\tfilter.Opacity = value;\r\n\t\t\t} else {\r\n\t\t\t\tel.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\ttestProp: function (props) {\r\n\r\n\t\tvar style = document.documentElement.style;\r\n\r\n\t\tfor (var i = 0; i < props.length; i++) {\r\n\t\t\tif (props[i] in style) {\r\n\t\t\t\treturn props[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\r\n\tgetTranslateString: function (point) {\r\n\t\t// on WebKit browsers (Chrome/Safari/iOS Safari/Android) using translate3d instead of translate\r\n\t\t// makes animation smoother as it ensures HW accel is used. Firefox 13 doesn't care\r\n\t\t// (same speed either way), Opera 12 doesn't support translate3d\r\n\r\n\t\tvar is3d = L.Browser.webkit3d,\r\n\t\t    open = 'translate' + (is3d ? '3d' : '') + '(',\r\n\t\t    close = (is3d ? ',0' : '') + ')';\r\n\r\n\t\treturn open + point.x + 'px,' + point.y + 'px' + close;\r\n\t},\r\n\r\n\tgetScaleString: function (scale, origin) {\r\n\r\n\t\tvar preTranslateStr = L.DomUtil.getTranslateString(origin.add(origin.multiplyBy(-1 * scale))),\r\n\t\t    scaleStr = ' scale(' + scale + ') ';\r\n\r\n\t\treturn preTranslateStr + scaleStr;\r\n\t},\r\n\r\n\tsetPosition: function (el, point, disable3D) { // (HTMLElement, Point[, Boolean])\r\n\r\n\t\t// jshint camelcase: false\r\n\t\tel._leaflet_pos = point;\r\n\r\n\t\tif (!disable3D && L.Browser.any3d) {\r\n\t\t\tel.style[L.DomUtil.TRANSFORM] =  L.DomUtil.getTranslateString(point);\r\n\t\t} else {\r\n\t\t\tel.style.left = point.x + 'px';\r\n\t\t\tel.style.top = point.y + 'px';\r\n\t\t}\r\n\t},\r\n\r\n\tgetPosition: function (el) {\r\n\t\t// this method is only used for elements previously positioned using setPosition,\r\n\t\t// so it's safe to cache the position for performance\r\n\r\n\t\t// jshint camelcase: false\r\n\t\treturn el._leaflet_pos;\r\n\t}\r\n};\r\n\r\n\r\n// prefix style property names\r\n\r\nL.DomUtil.TRANSFORM = L.DomUtil.testProp(\r\n        ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);\r\n\r\n// webkitTransition comes first because some browser versions that drop vendor prefix don't do\r\n// the same for the transitionend event, in particular the Android 4.1 stock browser\r\n\r\nL.DomUtil.TRANSITION = L.DomUtil.testProp(\r\n        ['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);\r\n\r\nL.DomUtil.TRANSITION_END =\r\n        L.DomUtil.TRANSITION === 'webkitTransition' || L.DomUtil.TRANSITION === 'OTransition' ?\r\n        L.DomUtil.TRANSITION + 'End' : 'transitionend';\r\n\r\n(function () {\r\n    if ('onselectstart' in document) {\r\n        L.extend(L.DomUtil, {\r\n            disableTextSelection: function () {\r\n                L.DomEvent.on(window, 'selectstart', L.DomEvent.preventDefault);\r\n            },\r\n\r\n            enableTextSelection: function () {\r\n                L.DomEvent.off(window, 'selectstart', L.DomEvent.preventDefault);\r\n            }\r\n        });\r\n    } else {\r\n        var userSelectProperty = L.DomUtil.testProp(\r\n            ['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);\r\n\r\n        L.extend(L.DomUtil, {\r\n            disableTextSelection: function () {\r\n                if (userSelectProperty) {\r\n                    var style = document.documentElement.style;\r\n                    this._userSelect = style[userSelectProperty];\r\n                    style[userSelectProperty] = 'none';\r\n                }\r\n            },\r\n\r\n            enableTextSelection: function () {\r\n                if (userSelectProperty) {\r\n                    document.documentElement.style[userSelectProperty] = this._userSelect;\r\n                    delete this._userSelect;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n\tL.extend(L.DomUtil, {\r\n\t\tdisableImageDrag: function () {\r\n\t\t\tL.DomEvent.on(window, 'dragstart', L.DomEvent.preventDefault);\r\n\t\t},\r\n\r\n\t\tenableImageDrag: function () {\r\n\t\t\tL.DomEvent.off(window, 'dragstart', L.DomEvent.preventDefault);\r\n\t\t}\r\n\t});\r\n})();\r\n\n\n/*\r\n * L.LatLng represents a geographical point with latitude and longitude coordinates.\r\n */\r\n\r\nL.LatLng = function (lat, lng, alt) { // (Number, Number, Number)\r\n\tlat = parseFloat(lat);\r\n\tlng = parseFloat(lng);\r\n\r\n\tif (isNaN(lat) || isNaN(lng)) {\r\n\t\tthrow new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');\r\n\t}\r\n\r\n\tthis.lat = lat;\r\n\tthis.lng = lng;\r\n\r\n\tif (alt !== undefined) {\r\n\t\tthis.alt = parseFloat(alt);\r\n\t}\r\n};\r\n\r\nL.extend(L.LatLng, {\r\n\tDEG_TO_RAD: Math.PI / 180,\r\n\tRAD_TO_DEG: 180 / Math.PI,\r\n\tMAX_MARGIN: 1.0E-9 // max margin of error for the \"equals\" check\r\n});\r\n\r\nL.LatLng.prototype = {\r\n\tequals: function (obj) { // (LatLng) -> Boolean\r\n\t\tif (!obj) { return false; }\r\n\r\n\t\tobj = L.latLng(obj);\r\n\r\n\t\tvar margin = Math.max(\r\n\t\t        Math.abs(this.lat - obj.lat),\r\n\t\t        Math.abs(this.lng - obj.lng));\r\n\r\n\t\treturn margin <= L.LatLng.MAX_MARGIN;\r\n\t},\r\n\r\n\ttoString: function (precision) { // (Number) -> String\r\n\t\treturn 'LatLng(' +\r\n\t\t        L.Util.formatNum(this.lat, precision) + ', ' +\r\n\t\t        L.Util.formatNum(this.lng, precision) + ')';\r\n\t},\r\n\r\n\t// Haversine distance formula, see http://en.wikipedia.org/wiki/Haversine_formula\r\n\t// TODO move to projection code, LatLng shouldn't know about Earth\r\n\tdistanceTo: function (other) { // (LatLng) -> Number\r\n\t\tother = L.latLng(other);\r\n\r\n\t\tvar R = 6378137, // earth radius in meters\r\n\t\t    d2r = L.LatLng.DEG_TO_RAD,\r\n\t\t    dLat = (other.lat - this.lat) * d2r,\r\n\t\t    dLon = (other.lng - this.lng) * d2r,\r\n\t\t    lat1 = this.lat * d2r,\r\n\t\t    lat2 = other.lat * d2r,\r\n\t\t    sin1 = Math.sin(dLat / 2),\r\n\t\t    sin2 = Math.sin(dLon / 2);\r\n\r\n\t\tvar a = sin1 * sin1 + sin2 * sin2 * Math.cos(lat1) * Math.cos(lat2);\r\n\r\n\t\treturn R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n\t},\r\n\r\n\twrap: function (a, b) { // (Number, Number) -> LatLng\r\n\t\tvar lng = this.lng;\r\n\r\n\t\ta = a || -180;\r\n\t\tb = b ||  180;\r\n\r\n\t\tlng = (lng + b) % (b - a) + (lng < a || lng === b ? b : a);\r\n\r\n\t\treturn new L.LatLng(this.lat, lng);\r\n\t}\r\n};\r\n\r\nL.latLng = function (a, b) { // (LatLng) or ([Number, Number]) or (Number, Number)\r\n\tif (a instanceof L.LatLng) {\r\n\t\treturn a;\r\n\t}\r\n\tif (L.Util.isArray(a)) {\r\n\t\tif (typeof a[0] === 'number' || typeof a[0] === 'string') {\r\n\t\t\treturn new L.LatLng(a[0], a[1], a[2]);\r\n\t\t} else {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\tif (a === undefined || a === null) {\r\n\t\treturn a;\r\n\t}\r\n\tif (typeof a === 'object' && 'lat' in a) {\r\n\t\treturn new L.LatLng(a.lat, 'lng' in a ? a.lng : a.lon);\r\n\t}\r\n\tif (b === undefined) {\r\n\t\treturn null;\r\n\t}\r\n\treturn new L.LatLng(a, b);\r\n};\r\n\r\n\n\n/*\r\n * L.LatLngBounds represents a rectangular area on the map in geographical coordinates.\r\n */\r\n\r\nL.LatLngBounds = function (southWest, northEast) { // (LatLng, LatLng) or (LatLng[])\r\n\tif (!southWest) { return; }\r\n\r\n\tvar latlngs = northEast ? [southWest, northEast] : southWest;\r\n\r\n\tfor (var i = 0, len = latlngs.length; i < len; i++) {\r\n\t\tthis.extend(latlngs[i]);\r\n\t}\r\n};\r\n\r\nL.LatLngBounds.prototype = {\r\n\t// extend the bounds to contain the given point or bounds\r\n\textend: function (obj) { // (LatLng) or (LatLngBounds)\r\n\t\tif (!obj) { return this; }\r\n\r\n\t\tvar latLng = L.latLng(obj);\r\n\t\tif (latLng !== null) {\r\n\t\t\tobj = latLng;\r\n\t\t} else {\r\n\t\t\tobj = L.latLngBounds(obj);\r\n\t\t}\r\n\r\n\t\tif (obj instanceof L.LatLng) {\r\n\t\t\tif (!this._southWest && !this._northEast) {\r\n\t\t\t\tthis._southWest = new L.LatLng(obj.lat, obj.lng);\r\n\t\t\t\tthis._northEast = new L.LatLng(obj.lat, obj.lng);\r\n\t\t\t} else {\r\n\t\t\t\tthis._southWest.lat = Math.min(obj.lat, this._southWest.lat);\r\n\t\t\t\tthis._southWest.lng = Math.min(obj.lng, this._southWest.lng);\r\n\r\n\t\t\t\tthis._northEast.lat = Math.max(obj.lat, this._northEast.lat);\r\n\t\t\t\tthis._northEast.lng = Math.max(obj.lng, this._northEast.lng);\r\n\t\t\t}\r\n\t\t} else if (obj instanceof L.LatLngBounds) {\r\n\t\t\tthis.extend(obj._southWest);\r\n\t\t\tthis.extend(obj._northEast);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// extend the bounds by a percentage\r\n\tpad: function (bufferRatio) { // (Number) -> LatLngBounds\r\n\t\tvar sw = this._southWest,\r\n\t\t    ne = this._northEast,\r\n\t\t    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,\r\n\t\t    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;\r\n\r\n\t\treturn new L.LatLngBounds(\r\n\t\t        new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),\r\n\t\t        new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));\r\n\t},\r\n\r\n\tgetCenter: function () { // -> LatLng\r\n\t\treturn new L.LatLng(\r\n\t\t        (this._southWest.lat + this._northEast.lat) / 2,\r\n\t\t        (this._southWest.lng + this._northEast.lng) / 2);\r\n\t},\r\n\r\n\tgetSouthWest: function () {\r\n\t\treturn this._southWest;\r\n\t},\r\n\r\n\tgetNorthEast: function () {\r\n\t\treturn this._northEast;\r\n\t},\r\n\r\n\tgetNorthWest: function () {\r\n\t\treturn new L.LatLng(this.getNorth(), this.getWest());\r\n\t},\r\n\r\n\tgetSouthEast: function () {\r\n\t\treturn new L.LatLng(this.getSouth(), this.getEast());\r\n\t},\r\n\r\n\tgetWest: function () {\r\n\t\treturn this._southWest.lng;\r\n\t},\r\n\r\n\tgetSouth: function () {\r\n\t\treturn this._southWest.lat;\r\n\t},\r\n\r\n\tgetEast: function () {\r\n\t\treturn this._northEast.lng;\r\n\t},\r\n\r\n\tgetNorth: function () {\r\n\t\treturn this._northEast.lat;\r\n\t},\r\n\r\n\tcontains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean\r\n\t\tif (typeof obj[0] === 'number' || obj instanceof L.LatLng) {\r\n\t\t\tobj = L.latLng(obj);\r\n\t\t} else {\r\n\t\t\tobj = L.latLngBounds(obj);\r\n\t\t}\r\n\r\n\t\tvar sw = this._southWest,\r\n\t\t    ne = this._northEast,\r\n\t\t    sw2, ne2;\r\n\r\n\t\tif (obj instanceof L.LatLngBounds) {\r\n\t\t\tsw2 = obj.getSouthWest();\r\n\t\t\tne2 = obj.getNorthEast();\r\n\t\t} else {\r\n\t\t\tsw2 = ne2 = obj;\r\n\t\t}\r\n\r\n\t\treturn (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&\r\n\t\t       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);\r\n\t},\r\n\r\n\tintersects: function (bounds) { // (LatLngBounds)\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\tvar sw = this._southWest,\r\n\t\t    ne = this._northEast,\r\n\t\t    sw2 = bounds.getSouthWest(),\r\n\t\t    ne2 = bounds.getNorthEast(),\r\n\r\n\t\t    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),\r\n\t\t    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);\r\n\r\n\t\treturn latIntersects && lngIntersects;\r\n\t},\r\n\r\n\ttoBBoxString: function () {\r\n\t\treturn [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');\r\n\t},\r\n\r\n\tequals: function (bounds) { // (LatLngBounds)\r\n\t\tif (!bounds) { return false; }\r\n\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\treturn this._southWest.equals(bounds.getSouthWest()) &&\r\n\t\t       this._northEast.equals(bounds.getNorthEast());\r\n\t},\r\n\r\n\tisValid: function () {\r\n\t\treturn !!(this._southWest && this._northEast);\r\n\t}\r\n};\r\n\r\n//TODO International date line?\r\n\r\nL.latLngBounds = function (a, b) { // (LatLngBounds) or (LatLng, LatLng)\r\n\tif (!a || a instanceof L.LatLngBounds) {\r\n\t\treturn a;\r\n\t}\r\n\treturn new L.LatLngBounds(a, b);\r\n};\r\n\n\n/*\r\n * L.Projection contains various geographical projections used by CRS classes.\r\n */\r\n\r\nL.Projection = {};\r\n\n\n/*\r\n * Spherical Mercator is the most popular map projection, used by EPSG:3857 CRS used by default.\r\n */\r\n\r\nL.Projection.SphericalMercator = {\r\n\tMAX_LATITUDE: 85.0511287798,\r\n\r\n\tproject: function (latlng) { // (LatLng) -> Point\r\n\t\tvar d = L.LatLng.DEG_TO_RAD,\r\n\t\t    max = this.MAX_LATITUDE,\r\n\t\t    lat = Math.max(Math.min(max, latlng.lat), -max),\r\n\t\t    x = latlng.lng * d,\r\n\t\t    y = lat * d;\r\n\r\n\t\ty = Math.log(Math.tan((Math.PI / 4) + (y / 2)));\r\n\r\n\t\treturn new L.Point(x, y);\r\n\t},\r\n\r\n\tunproject: function (point) { // (Point, Boolean) -> LatLng\r\n\t\tvar d = L.LatLng.RAD_TO_DEG,\r\n\t\t    lng = point.x * d,\r\n\t\t    lat = (2 * Math.atan(Math.exp(point.y)) - (Math.PI / 2)) * d;\r\n\r\n\t\treturn new L.LatLng(lat, lng);\r\n\t}\r\n};\r\n\n\n/*\r\n * Simple equirectangular (Plate Carree) projection, used by CRS like EPSG:4326 and Simple.\r\n */\r\n\r\nL.Projection.LonLat = {\r\n\tproject: function (latlng) {\r\n\t\treturn new L.Point(latlng.lng, latlng.lat);\r\n\t},\r\n\r\n\tunproject: function (point) {\r\n\t\treturn new L.LatLng(point.y, point.x);\r\n\t}\r\n};\r\n\n\n/*\r\n * L.CRS is a base object for all defined CRS (Coordinate Reference Systems) in Leaflet.\r\n */\r\n\r\nL.CRS = {\r\n\tlatLngToPoint: function (latlng, zoom) { // (LatLng, Number) -> Point\r\n\t\tvar projectedPoint = this.projection.project(latlng),\r\n\t\t    scale = this.scale(zoom);\r\n\r\n\t\treturn this.transformation._transform(projectedPoint, scale);\r\n\t},\r\n\r\n\tpointToLatLng: function (point, zoom) { // (Point, Number[, Boolean]) -> LatLng\r\n\t\tvar scale = this.scale(zoom),\r\n\t\t    untransformedPoint = this.transformation.untransform(point, scale);\r\n\r\n\t\treturn this.projection.unproject(untransformedPoint);\r\n\t},\r\n\r\n\tproject: function (latlng) {\r\n\t\treturn this.projection.project(latlng);\r\n\t},\r\n\r\n\tscale: function (zoom) {\r\n\t\treturn 256 * Math.pow(2, zoom);\r\n\t},\r\n\r\n\tgetSize: function (zoom) {\r\n\t\tvar s = this.scale(zoom);\r\n\t\treturn L.point(s, s);\r\n\t}\r\n};\r\n\n\n/*\n * A simple CRS that can be used for flat non-Earth maps like panoramas or game maps.\n */\n\nL.CRS.Simple = L.extend({}, L.CRS, {\n\tprojection: L.Projection.LonLat,\n\ttransformation: new L.Transformation(1, 0, -1, 0),\n\n\tscale: function (zoom) {\n\t\treturn Math.pow(2, zoom);\n\t}\n});\n\n\n/*\r\n * L.CRS.EPSG3857 (Spherical Mercator) is the most common CRS for web mapping\r\n * and is used by Leaflet by default.\r\n */\r\n\r\nL.CRS.EPSG3857 = L.extend({}, L.CRS, {\r\n\tcode: 'EPSG:3857',\r\n\r\n\tprojection: L.Projection.SphericalMercator,\r\n\ttransformation: new L.Transformation(0.5 / Math.PI, 0.5, -0.5 / Math.PI, 0.5),\r\n\r\n\tproject: function (latlng) { // (LatLng) -> Point\r\n\t\tvar projectedPoint = this.projection.project(latlng),\r\n\t\t    earthRadius = 6378137;\r\n\t\treturn projectedPoint.multiplyBy(earthRadius);\r\n\t}\r\n});\r\n\r\nL.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {\r\n\tcode: 'EPSG:900913'\r\n});\r\n\n\n/*\r\n * L.CRS.EPSG4326 is a CRS popular among advanced GIS specialists.\r\n */\r\n\r\nL.CRS.EPSG4326 = L.extend({}, L.CRS, {\r\n\tcode: 'EPSG:4326',\r\n\r\n\tprojection: L.Projection.LonLat,\r\n\ttransformation: new L.Transformation(1 / 360, 0.5, -1 / 360, 0.5)\r\n});\r\n\n\n/*\r\n * L.Map is the central class of the API - it is used to create a map.\r\n */\r\n\r\nL.Map = L.Class.extend({\r\n\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\tcrs: L.CRS.EPSG3857,\r\n\r\n\t\t/*\r\n\t\tcenter: LatLng,\r\n\t\tzoom: Number,\r\n\t\tlayers: Array,\r\n\t\t*/\r\n\r\n\t\tfadeAnimation: L.DomUtil.TRANSITION && !L.Browser.android23,\r\n\t\ttrackResize: true,\r\n\t\tmarkerZoomAnimation: L.DomUtil.TRANSITION && L.Browser.any3d\r\n\t},\r\n\r\n\tinitialize: function (id, options) { // (HTMLElement or String, Object)\r\n\t\toptions = L.setOptions(this, options);\r\n\r\n\r\n\t\tthis._initContainer(id);\r\n\t\tthis._initLayout();\r\n\r\n\t\t// hack for https://github.com/Leaflet/Leaflet/issues/1980\r\n\t\tthis._onResize = L.bind(this._onResize, this);\r\n\r\n\t\tthis._initEvents();\r\n\r\n\t\tif (options.maxBounds) {\r\n\t\t\tthis.setMaxBounds(options.maxBounds);\r\n\t\t}\r\n\r\n\t\tif (options.center && options.zoom !== undefined) {\r\n\t\t\tthis.setView(L.latLng(options.center), options.zoom, {reset: true});\r\n\t\t}\r\n\r\n\t\tthis._handlers = [];\r\n\r\n\t\tthis._layers = {};\r\n\t\tthis._zoomBoundLayers = {};\r\n\t\tthis._tileLayersNum = 0;\r\n\r\n\t\tthis.callInitHooks();\r\n\r\n\t\tthis._addLayers(options.layers);\r\n\t},\r\n\r\n\r\n\t// public methods that modify map state\r\n\r\n\t// replaced by animation-powered implementation in Map.PanAnimation.js\r\n\tsetView: function (center, zoom) {\r\n\t\tzoom = zoom === undefined ? this.getZoom() : zoom;\r\n\t\tthis._resetView(L.latLng(center), this._limitZoom(zoom));\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetZoom: function (zoom, options) {\r\n\t\tif (!this._loaded) {\r\n\t\t\tthis._zoom = this._limitZoom(zoom);\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\treturn this.setView(this.getCenter(), zoom, {zoom: options});\r\n\t},\r\n\r\n\tzoomIn: function (delta, options) {\r\n\t\treturn this.setZoom(this._zoom + (delta || 1), options);\r\n\t},\r\n\r\n\tzoomOut: function (delta, options) {\r\n\t\treturn this.setZoom(this._zoom - (delta || 1), options);\r\n\t},\r\n\r\n\tsetZoomAround: function (latlng, zoom, options) {\r\n\t\tvar scale = this.getZoomScale(zoom),\r\n\t\t    viewHalf = this.getSize().divideBy(2),\r\n\t\t    containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng),\r\n\r\n\t\t    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),\r\n\t\t    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));\r\n\r\n\t\treturn this.setView(newCenter, zoom, {zoom: options});\r\n\t},\r\n\r\n\tfitBounds: function (bounds, options) {\r\n\r\n\t\toptions = options || {};\r\n\t\tbounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);\r\n\r\n\t\tvar paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),\r\n\t\t    paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),\r\n\r\n\t\t    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));\r\n\r\n\t\tzoom = (options.maxZoom) ? Math.min(options.maxZoom, zoom) : zoom;\r\n\r\n\t\tvar paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),\r\n\r\n\t\t    swPoint = this.project(bounds.getSouthWest(), zoom),\r\n\t\t    nePoint = this.project(bounds.getNorthEast(), zoom),\r\n\t\t    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);\r\n\r\n\t\treturn this.setView(center, zoom, options);\r\n\t},\r\n\r\n\tfitWorld: function (options) {\r\n\t\treturn this.fitBounds([[-90, -180], [90, 180]], options);\r\n\t},\r\n\r\n\tpanTo: function (center, options) { // (LatLng)\r\n\t\treturn this.setView(center, this._zoom, {pan: options});\r\n\t},\r\n\r\n\tpanBy: function (offset) { // (Point)\r\n\t\t// replaced with animated panBy in Map.PanAnimation.js\r\n\t\tthis.fire('movestart');\r\n\r\n\t\tthis._rawPanBy(L.point(offset));\r\n\r\n\t\tthis.fire('move');\r\n\t\treturn this.fire('moveend');\r\n\t},\r\n\r\n\tsetMaxBounds: function (bounds) {\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\tthis.options.maxBounds = bounds;\r\n\r\n\t\tif (!bounds) {\r\n\t\t\treturn this.off('moveend', this._panInsideMaxBounds, this);\r\n\t\t}\r\n\r\n\t\tif (this._loaded) {\r\n\t\t\tthis._panInsideMaxBounds();\r\n\t\t}\r\n\r\n\t\treturn this.on('moveend', this._panInsideMaxBounds, this);\r\n\t},\r\n\r\n\tpanInsideBounds: function (bounds, options) {\r\n\t\tvar center = this.getCenter(),\r\n\t\t\tnewCenter = this._limitCenter(center, this._zoom, bounds);\r\n\r\n\t\tif (center.equals(newCenter)) { return this; }\r\n\r\n\t\treturn this.panTo(newCenter, options);\r\n\t},\r\n\r\n\taddLayer: function (layer) {\r\n\t\t// TODO method is too big, refactor\r\n\r\n\t\tvar id = L.stamp(layer);\r\n\r\n\t\tif (this._layers[id]) { return this; }\r\n\r\n\t\tthis._layers[id] = layer;\r\n\r\n\t\t// TODO getMaxZoom, getMinZoom in ILayer (instead of options)\r\n\t\tif (layer.options && (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom))) {\r\n\t\t\tthis._zoomBoundLayers[id] = layer;\r\n\t\t\tthis._updateZoomLevels();\r\n\t\t}\r\n\r\n\t\t// TODO looks ugly, refactor!!!\r\n\t\tif (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {\r\n\t\t\tthis._tileLayersNum++;\r\n\t\t\tthis._tileLayersToLoad++;\r\n\t\t\tlayer.on('load', this._onTileLayerLoad, this);\r\n\t\t}\r\n\r\n\t\tif (this._loaded) {\r\n\t\t\tthis._layerAdd(layer);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\t\tvar id = L.stamp(layer);\r\n\r\n\t\tif (!this._layers[id]) { return this; }\r\n\r\n\t\tif (this._loaded) {\r\n\t\t\tlayer.onRemove(this);\r\n\t\t}\r\n\r\n\t\tdelete this._layers[id];\r\n\r\n\t\tif (this._loaded) {\r\n\t\t\tthis.fire('layerremove', {layer: layer});\r\n\t\t}\r\n\r\n\t\tif (this._zoomBoundLayers[id]) {\r\n\t\t\tdelete this._zoomBoundLayers[id];\r\n\t\t\tthis._updateZoomLevels();\r\n\t\t}\r\n\r\n\t\t// TODO looks ugly, refactor\r\n\t\tif (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {\r\n\t\t\tthis._tileLayersNum--;\r\n\t\t\tthis._tileLayersToLoad--;\r\n\t\t\tlayer.off('load', this._onTileLayerLoad, this);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\thasLayer: function (layer) {\r\n\t\tif (!layer) { return false; }\r\n\r\n\t\treturn (L.stamp(layer) in this._layers);\r\n\t},\r\n\r\n\teachLayer: function (method, context) {\r\n\t\tfor (var i in this._layers) {\r\n\t\t\tmethod.call(context, this._layers[i]);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tinvalidateSize: function (options) {\r\n\t\tif (!this._loaded) { return this; }\r\n\r\n\t\toptions = L.extend({\r\n\t\t\tanimate: false,\r\n\t\t\tpan: true\r\n\t\t}, options === true ? {animate: true} : options);\r\n\r\n\t\tvar oldSize = this.getSize();\r\n\t\tthis._sizeChanged = true;\r\n\t\tthis._initialCenter = null;\r\n\r\n\t\tvar newSize = this.getSize(),\r\n\t\t    oldCenter = oldSize.divideBy(2).round(),\r\n\t\t    newCenter = newSize.divideBy(2).round(),\r\n\t\t    offset = oldCenter.subtract(newCenter);\r\n\r\n\t\tif (!offset.x && !offset.y) { return this; }\r\n\r\n\t\tif (options.animate && options.pan) {\r\n\t\t\tthis.panBy(offset);\r\n\r\n\t\t} else {\r\n\t\t\tif (options.pan) {\r\n\t\t\t\tthis._rawPanBy(offset);\r\n\t\t\t}\r\n\r\n\t\t\tthis.fire('move');\r\n\r\n\t\t\tif (options.debounceMoveend) {\r\n\t\t\t\tclearTimeout(this._sizeTimer);\r\n\t\t\t\tthis._sizeTimer = setTimeout(L.bind(this.fire, this, 'moveend'), 200);\r\n\t\t\t} else {\r\n\t\t\t\tthis.fire('moveend');\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this.fire('resize', {\r\n\t\t\toldSize: oldSize,\r\n\t\t\tnewSize: newSize\r\n\t\t});\r\n\t},\r\n\r\n\t// TODO handler.addTo\r\n\taddHandler: function (name, HandlerClass) {\r\n\t\tif (!HandlerClass) { return this; }\r\n\r\n\t\tvar handler = this[name] = new HandlerClass(this);\r\n\r\n\t\tthis._handlers.push(handler);\r\n\r\n\t\tif (this.options[name]) {\r\n\t\t\thandler.enable();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremove: function () {\r\n\t\tif (this._loaded) {\r\n\t\t\tthis.fire('unload');\r\n\t\t}\r\n\r\n\t\tthis._initEvents('off');\r\n\r\n\t\ttry {\r\n\t\t\t// throws error in IE6-8\r\n\t\t\tdelete this._container._leaflet;\r\n\t\t} catch (e) {\r\n\t\t\tthis._container._leaflet = undefined;\r\n\t\t}\r\n\r\n\t\tthis._clearPanes();\r\n\t\tif (this._clearControlPos) {\r\n\t\t\tthis._clearControlPos();\r\n\t\t}\r\n\r\n\t\tthis._clearHandlers();\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\r\n\t// public methods for getting map state\r\n\r\n\tgetCenter: function () { // (Boolean) -> LatLng\r\n\t\tthis._checkIfLoaded();\r\n\r\n\t\tif (this._initialCenter && !this._moved()) {\r\n\t\t\treturn this._initialCenter;\r\n\t\t}\r\n\t\treturn this.layerPointToLatLng(this._getCenterLayerPoint());\r\n\t},\r\n\r\n\tgetZoom: function () {\r\n\t\treturn this._zoom;\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\tvar bounds = this.getPixelBounds(),\r\n\t\t    sw = this.unproject(bounds.getBottomLeft()),\r\n\t\t    ne = this.unproject(bounds.getTopRight());\r\n\r\n\t\treturn new L.LatLngBounds(sw, ne);\r\n\t},\r\n\r\n\tgetMinZoom: function () {\r\n\t\treturn this.options.minZoom === undefined ?\r\n\t\t\t(this._layersMinZoom === undefined ? 0 : this._layersMinZoom) :\r\n\t\t\tthis.options.minZoom;\r\n\t},\r\n\r\n\tgetMaxZoom: function () {\r\n\t\treturn this.options.maxZoom === undefined ?\r\n\t\t\t(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :\r\n\t\t\tthis.options.maxZoom;\r\n\t},\r\n\r\n\tgetBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\tvar zoom = this.getMinZoom() - (inside ? 1 : 0),\r\n\t\t    maxZoom = this.getMaxZoom(),\r\n\t\t    size = this.getSize(),\r\n\r\n\t\t    nw = bounds.getNorthWest(),\r\n\t\t    se = bounds.getSouthEast(),\r\n\r\n\t\t    zoomNotFound = true,\r\n\t\t    boundsSize;\r\n\r\n\t\tpadding = L.point(padding || [0, 0]);\r\n\r\n\t\tdo {\r\n\t\t\tzoom++;\r\n\t\t\tboundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)).add(padding);\r\n\t\t\tzoomNotFound = !inside ? size.contains(boundsSize) : boundsSize.x < size.x || boundsSize.y < size.y;\r\n\r\n\t\t} while (zoomNotFound && zoom <= maxZoom);\r\n\r\n\t\tif (zoomNotFound && inside) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn inside ? zoom : zoom - 1;\r\n\t},\r\n\r\n\tgetSize: function () {\r\n\t\tif (!this._size || this._sizeChanged) {\r\n\t\t\tthis._size = new L.Point(\r\n\t\t\t\tthis._container.clientWidth,\r\n\t\t\t\tthis._container.clientHeight);\r\n\r\n\t\t\tthis._sizeChanged = false;\r\n\t\t}\r\n\t\treturn this._size.clone();\r\n\t},\r\n\r\n\tgetPixelBounds: function () {\r\n\t\tvar topLeftPoint = this._getTopLeftPoint();\r\n\t\treturn new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));\r\n\t},\r\n\r\n\tgetPixelOrigin: function () {\r\n\t\tthis._checkIfLoaded();\r\n\t\treturn this._initialTopLeftPoint;\r\n\t},\r\n\r\n\tgetPanes: function () {\r\n\t\treturn this._panes;\r\n\t},\r\n\r\n\tgetContainer: function () {\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\r\n\t// TODO replace with universal implementation after refactoring projections\r\n\r\n\tgetZoomScale: function (toZoom) {\r\n\t\tvar crs = this.options.crs;\r\n\t\treturn crs.scale(toZoom) / crs.scale(this._zoom);\r\n\t},\r\n\r\n\tgetScaleZoom: function (scale) {\r\n\t\treturn this._zoom + (Math.log(scale) / Math.LN2);\r\n\t},\r\n\r\n\r\n\t// conversion methods\r\n\r\n\tproject: function (latlng, zoom) { // (LatLng[, Number]) -> Point\r\n\t\tzoom = zoom === undefined ? this._zoom : zoom;\r\n\t\treturn this.options.crs.latLngToPoint(L.latLng(latlng), zoom);\r\n\t},\r\n\r\n\tunproject: function (point, zoom) { // (Point[, Number]) -> LatLng\r\n\t\tzoom = zoom === undefined ? this._zoom : zoom;\r\n\t\treturn this.options.crs.pointToLatLng(L.point(point), zoom);\r\n\t},\r\n\r\n\tlayerPointToLatLng: function (point) { // (Point)\r\n\t\tvar projectedPoint = L.point(point).add(this.getPixelOrigin());\r\n\t\treturn this.unproject(projectedPoint);\r\n\t},\r\n\r\n\tlatLngToLayerPoint: function (latlng) { // (LatLng)\r\n\t\tvar projectedPoint = this.project(L.latLng(latlng))._round();\r\n\t\treturn projectedPoint._subtract(this.getPixelOrigin());\r\n\t},\r\n\r\n\tcontainerPointToLayerPoint: function (point) { // (Point)\r\n\t\treturn L.point(point).subtract(this._getMapPanePos());\r\n\t},\r\n\r\n\tlayerPointToContainerPoint: function (point) { // (Point)\r\n\t\treturn L.point(point).add(this._getMapPanePos());\r\n\t},\r\n\r\n\tcontainerPointToLatLng: function (point) {\r\n\t\tvar layerPoint = this.containerPointToLayerPoint(L.point(point));\r\n\t\treturn this.layerPointToLatLng(layerPoint);\r\n\t},\r\n\r\n\tlatLngToContainerPoint: function (latlng) {\r\n\t\treturn this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)));\r\n\t},\r\n\r\n\tmouseEventToContainerPoint: function (e) { // (MouseEvent)\r\n\t\treturn L.DomEvent.getMousePosition(e, this._container);\r\n\t},\r\n\r\n\tmouseEventToLayerPoint: function (e) { // (MouseEvent)\r\n\t\treturn this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));\r\n\t},\r\n\r\n\tmouseEventToLatLng: function (e) { // (MouseEvent)\r\n\t\treturn this.layerPointToLatLng(this.mouseEventToLayerPoint(e));\r\n\t},\r\n\r\n\r\n\t// map initialization methods\r\n\r\n\t_initContainer: function (id) {\r\n\t\tvar container = this._container = L.DomUtil.get(id);\r\n\r\n\t\tif (!container) {\r\n\t\t\tthrow new Error('Map container not found.');\r\n\t\t} else if (container._leaflet) {\r\n\t\t\tthrow new Error('Map container is already initialized.');\r\n\t\t}\r\n\r\n\t\tcontainer._leaflet = true;\r\n\t},\r\n\r\n\t_initLayout: function () {\r\n\t\tvar container = this._container;\r\n\r\n\t\tL.DomUtil.addClass(container, 'leaflet-container' +\r\n\t\t\t(L.Browser.touch ? ' leaflet-touch' : '') +\r\n\t\t\t(L.Browser.retina ? ' leaflet-retina' : '') +\r\n\t\t\t(L.Browser.ielt9 ? ' leaflet-oldie' : '') +\r\n\t\t\t(this.options.fadeAnimation ? ' leaflet-fade-anim' : ''));\r\n\r\n\t\tvar position = L.DomUtil.getStyle(container, 'position');\r\n\r\n\t\tif (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {\r\n\t\t\tcontainer.style.position = 'relative';\r\n\t\t}\r\n\r\n\t\tthis._initPanes();\r\n\r\n\t\tif (this._initControlPos) {\r\n\t\t\tthis._initControlPos();\r\n\t\t}\r\n\t},\r\n\r\n\t_initPanes: function () {\r\n\t\tvar panes = this._panes = {};\r\n\r\n\t\tthis._mapPane = panes.mapPane = this._createPane('leaflet-map-pane', this._container);\r\n\r\n\t\tthis._tilePane = panes.tilePane = this._createPane('leaflet-tile-pane', this._mapPane);\r\n\t\tpanes.objectsPane = this._createPane('leaflet-objects-pane', this._mapPane);\r\n\t\tpanes.shadowPane = this._createPane('leaflet-shadow-pane');\r\n\t\tpanes.overlayPane = this._createPane('leaflet-overlay-pane');\r\n\t\tpanes.markerPane = this._createPane('leaflet-marker-pane');\r\n\t\tpanes.popupPane = this._createPane('leaflet-popup-pane');\r\n\r\n\t\tvar zoomHide = ' leaflet-zoom-hide';\r\n\r\n\t\tif (!this.options.markerZoomAnimation) {\r\n\t\t\tL.DomUtil.addClass(panes.markerPane, zoomHide);\r\n\t\t\tL.DomUtil.addClass(panes.shadowPane, zoomHide);\r\n\t\t\tL.DomUtil.addClass(panes.popupPane, zoomHide);\r\n\t\t}\r\n\t},\r\n\r\n\t_createPane: function (className, container) {\r\n\t\treturn L.DomUtil.create('div', className, container || this._panes.objectsPane);\r\n\t},\r\n\r\n\t_clearPanes: function () {\r\n\t\tthis._container.removeChild(this._mapPane);\r\n\t},\r\n\r\n\t_addLayers: function (layers) {\r\n\t\tlayers = layers ? (L.Util.isArray(layers) ? layers : [layers]) : [];\r\n\r\n\t\tfor (var i = 0, len = layers.length; i < len; i++) {\r\n\t\t\tthis.addLayer(layers[i]);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// private methods that modify map state\r\n\r\n\t_resetView: function (center, zoom, preserveMapOffset, afterZoomAnim) {\r\n\r\n\t\tvar zoomChanged = (this._zoom !== zoom);\r\n\r\n\t\tif (!afterZoomAnim) {\r\n\t\t\tthis.fire('movestart');\r\n\r\n\t\t\tif (zoomChanged) {\r\n\t\t\t\tthis.fire('zoomstart');\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._zoom = zoom;\r\n\t\tthis._initialCenter = center;\r\n\r\n\t\tthis._initialTopLeftPoint = this._getNewTopLeftPoint(center);\r\n\r\n\t\tif (!preserveMapOffset) {\r\n\t\t\tL.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));\r\n\t\t} else {\r\n\t\t\tthis._initialTopLeftPoint._add(this._getMapPanePos());\r\n\t\t}\r\n\r\n\t\tthis._tileLayersToLoad = this._tileLayersNum;\r\n\r\n\t\tvar loading = !this._loaded;\r\n\t\tthis._loaded = true;\r\n\r\n\t\tthis.fire('viewreset', {hard: !preserveMapOffset});\r\n\r\n\t\tif (loading) {\r\n\t\t\tthis.fire('load');\r\n\t\t\tthis.eachLayer(this._layerAdd, this);\r\n\t\t}\r\n\r\n\t\tthis.fire('move');\r\n\r\n\t\tif (zoomChanged || afterZoomAnim) {\r\n\t\t\tthis.fire('zoomend');\r\n\t\t}\r\n\r\n\t\tthis.fire('moveend', {hard: !preserveMapOffset});\r\n\t},\r\n\r\n\t_rawPanBy: function (offset) {\r\n\t\tL.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));\r\n\t},\r\n\r\n\t_getZoomSpan: function () {\r\n\t\treturn this.getMaxZoom() - this.getMinZoom();\r\n\t},\r\n\r\n\t_updateZoomLevels: function () {\r\n\t\tvar i,\r\n\t\t\tminZoom = Infinity,\r\n\t\t\tmaxZoom = -Infinity,\r\n\t\t\toldZoomSpan = this._getZoomSpan();\r\n\r\n\t\tfor (i in this._zoomBoundLayers) {\r\n\t\t\tvar layer = this._zoomBoundLayers[i];\r\n\t\t\tif (!isNaN(layer.options.minZoom)) {\r\n\t\t\t\tminZoom = Math.min(minZoom, layer.options.minZoom);\r\n\t\t\t}\r\n\t\t\tif (!isNaN(layer.options.maxZoom)) {\r\n\t\t\t\tmaxZoom = Math.max(maxZoom, layer.options.maxZoom);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (i === undefined) { // we have no tilelayers\r\n\t\t\tthis._layersMaxZoom = this._layersMinZoom = undefined;\r\n\t\t} else {\r\n\t\t\tthis._layersMaxZoom = maxZoom;\r\n\t\t\tthis._layersMinZoom = minZoom;\r\n\t\t}\r\n\r\n\t\tif (oldZoomSpan !== this._getZoomSpan()) {\r\n\t\t\tthis.fire('zoomlevelschange');\r\n\t\t}\r\n\t},\r\n\r\n\t_panInsideMaxBounds: function () {\r\n\t\tthis.panInsideBounds(this.options.maxBounds);\r\n\t},\r\n\r\n\t_checkIfLoaded: function () {\r\n\t\tif (!this._loaded) {\r\n\t\t\tthrow new Error('Set map center and zoom first.');\r\n\t\t}\r\n\t},\r\n\r\n\t// map events\r\n\r\n\t_initEvents: function (onOff) {\r\n\t\tif (!L.DomEvent) { return; }\r\n\r\n\t\tonOff = onOff || 'on';\r\n\r\n\t\tL.DomEvent[onOff](this._container, 'click', this._onMouseClick, this);\r\n\r\n\t\tvar events = ['dblclick', 'mousedown', 'mouseup', 'mouseenter',\r\n\t\t              'mouseleave', 'mousemove', 'contextmenu'],\r\n\t\t    i, len;\r\n\r\n\t\tfor (i = 0, len = events.length; i < len; i++) {\r\n\t\t\tL.DomEvent[onOff](this._container, events[i], this._fireMouseEvent, this);\r\n\t\t}\r\n\r\n\t\tif (this.options.trackResize) {\r\n\t\t\tL.DomEvent[onOff](window, 'resize', this._onResize, this);\r\n\t\t}\r\n\t},\r\n\r\n\t_onResize: function () {\r\n\t\tL.Util.cancelAnimFrame(this._resizeRequest);\r\n\t\tthis._resizeRequest = L.Util.requestAnimFrame(\r\n\t\t        function () { this.invalidateSize({debounceMoveend: true}); }, this, false, this._container);\r\n\t},\r\n\r\n\t_onMouseClick: function (e) {\r\n\t\tif (!this._loaded || (!e._simulated &&\r\n\t\t        ((this.dragging && this.dragging.moved()) ||\r\n\t\t         (this.boxZoom  && this.boxZoom.moved()))) ||\r\n\t\t            L.DomEvent._skipped(e)) { return; }\r\n\r\n\t\tthis.fire('preclick');\r\n\t\tthis._fireMouseEvent(e);\r\n\t},\r\n\r\n\t_fireMouseEvent: function (e) {\r\n\t\tif (!this._loaded || L.DomEvent._skipped(e)) { return; }\r\n\r\n\t\tvar type = e.type;\r\n\r\n\t\ttype = (type === 'mouseenter' ? 'mouseover' : (type === 'mouseleave' ? 'mouseout' : type));\r\n\r\n\t\tif (!this.hasEventListeners(type)) { return; }\r\n\r\n\t\tif (type === 'contextmenu') {\r\n\t\t\tL.DomEvent.preventDefault(e);\r\n\t\t}\r\n\r\n\t\tvar containerPoint = this.mouseEventToContainerPoint(e),\r\n\t\t    layerPoint = this.containerPointToLayerPoint(containerPoint),\r\n\t\t    latlng = this.layerPointToLatLng(layerPoint);\r\n\r\n\t\tthis.fire(type, {\r\n\t\t\tlatlng: latlng,\r\n\t\t\tlayerPoint: layerPoint,\r\n\t\t\tcontainerPoint: containerPoint,\r\n\t\t\toriginalEvent: e\r\n\t\t});\r\n\t},\r\n\r\n\t_onTileLayerLoad: function () {\r\n\t\tthis._tileLayersToLoad--;\r\n\t\tif (this._tileLayersNum && !this._tileLayersToLoad) {\r\n\t\t\tthis.fire('tilelayersload');\r\n\t\t}\r\n\t},\r\n\r\n\t_clearHandlers: function () {\r\n\t\tfor (var i = 0, len = this._handlers.length; i < len; i++) {\r\n\t\t\tthis._handlers[i].disable();\r\n\t\t}\r\n\t},\r\n\r\n\twhenReady: function (callback, context) {\r\n\t\tif (this._loaded) {\r\n\t\t\tcallback.call(context || this, this);\r\n\t\t} else {\r\n\t\t\tthis.on('load', callback, context);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_layerAdd: function (layer) {\r\n\t\tlayer.onAdd(this);\r\n\t\tthis.fire('layeradd', {layer: layer});\r\n\t},\r\n\r\n\r\n\t// private methods for getting map state\r\n\r\n\t_getMapPanePos: function () {\r\n\t\treturn L.DomUtil.getPosition(this._mapPane);\r\n\t},\r\n\r\n\t_moved: function () {\r\n\t\tvar pos = this._getMapPanePos();\r\n\t\treturn pos && !pos.equals([0, 0]);\r\n\t},\r\n\r\n\t_getTopLeftPoint: function () {\r\n\t\treturn this.getPixelOrigin().subtract(this._getMapPanePos());\r\n\t},\r\n\r\n\t_getNewTopLeftPoint: function (center, zoom) {\r\n\t\tvar viewHalf = this.getSize()._divideBy(2);\r\n\t\t// TODO round on display, not calculation to increase precision?\r\n\t\treturn this.project(center, zoom)._subtract(viewHalf)._round();\r\n\t},\r\n\r\n\t_latLngToNewLayerPoint: function (latlng, newZoom, newCenter) {\r\n\t\tvar topLeft = this._getNewTopLeftPoint(newCenter, newZoom).add(this._getMapPanePos());\r\n\t\treturn this.project(latlng, newZoom)._subtract(topLeft);\r\n\t},\r\n\r\n\t// layer point of the current center\r\n\t_getCenterLayerPoint: function () {\r\n\t\treturn this.containerPointToLayerPoint(this.getSize()._divideBy(2));\r\n\t},\r\n\r\n\t// offset of the specified place to the current center in pixels\r\n\t_getCenterOffset: function (latlng) {\r\n\t\treturn this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());\r\n\t},\r\n\r\n\t// adjust center for view to get inside bounds\r\n\t_limitCenter: function (center, zoom, bounds) {\r\n\r\n\t\tif (!bounds) { return center; }\r\n\r\n\t\tvar centerPoint = this.project(center, zoom),\r\n\t\t    viewHalf = this.getSize().divideBy(2),\r\n\t\t    viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),\r\n\t\t    offset = this._getBoundsOffset(viewBounds, bounds, zoom);\r\n\r\n\t\treturn this.unproject(centerPoint.add(offset), zoom);\r\n\t},\r\n\r\n\t// adjust offset for view to get inside bounds\r\n\t_limitOffset: function (offset, bounds) {\r\n\t\tif (!bounds) { return offset; }\r\n\r\n\t\tvar viewBounds = this.getPixelBounds(),\r\n\t\t    newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));\r\n\r\n\t\treturn offset.add(this._getBoundsOffset(newBounds, bounds));\r\n\t},\r\n\r\n\t// returns offset needed for pxBounds to get inside maxBounds at a specified zoom\r\n\t_getBoundsOffset: function (pxBounds, maxBounds, zoom) {\r\n\t\tvar nwOffset = this.project(maxBounds.getNorthWest(), zoom).subtract(pxBounds.min),\r\n\t\t    seOffset = this.project(maxBounds.getSouthEast(), zoom).subtract(pxBounds.max),\r\n\r\n\t\t    dx = this._rebound(nwOffset.x, -seOffset.x),\r\n\t\t    dy = this._rebound(nwOffset.y, -seOffset.y);\r\n\r\n\t\treturn new L.Point(dx, dy);\r\n\t},\r\n\r\n\t_rebound: function (left, right) {\r\n\t\treturn left + right > 0 ?\r\n\t\t\tMath.round(left - right) / 2 :\r\n\t\t\tMath.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));\r\n\t},\r\n\r\n\t_limitZoom: function (zoom) {\r\n\t\tvar min = this.getMinZoom(),\r\n\t\t    max = this.getMaxZoom();\r\n\r\n\t\treturn Math.max(min, Math.min(max, zoom));\r\n\t}\r\n});\r\n\r\nL.map = function (id, options) {\r\n\treturn new L.Map(id, options);\r\n};\r\n\n\n/*\r\n * Mercator projection that takes into account that the Earth is not a perfect sphere.\r\n * Less popular than spherical mercator; used by projections like EPSG:3395.\r\n */\r\n\r\nL.Projection.Mercator = {\r\n\tMAX_LATITUDE: 85.0840591556,\r\n\r\n\tR_MINOR: 6356752.314245179,\r\n\tR_MAJOR: 6378137,\r\n\r\n\tproject: function (latlng) { // (LatLng) -> Point\r\n\t\tvar d = L.LatLng.DEG_TO_RAD,\r\n\t\t    max = this.MAX_LATITUDE,\r\n\t\t    lat = Math.max(Math.min(max, latlng.lat), -max),\r\n\t\t    r = this.R_MAJOR,\r\n\t\t    r2 = this.R_MINOR,\r\n\t\t    x = latlng.lng * d * r,\r\n\t\t    y = lat * d,\r\n\t\t    tmp = r2 / r,\r\n\t\t    eccent = Math.sqrt(1.0 - tmp * tmp),\r\n\t\t    con = eccent * Math.sin(y);\r\n\r\n\t\tcon = Math.pow((1 - con) / (1 + con), eccent * 0.5);\r\n\r\n\t\tvar ts = Math.tan(0.5 * ((Math.PI * 0.5) - y)) / con;\r\n\t\ty = -r * Math.log(ts);\r\n\r\n\t\treturn new L.Point(x, y);\r\n\t},\r\n\r\n\tunproject: function (point) { // (Point, Boolean) -> LatLng\r\n\t\tvar d = L.LatLng.RAD_TO_DEG,\r\n\t\t    r = this.R_MAJOR,\r\n\t\t    r2 = this.R_MINOR,\r\n\t\t    lng = point.x * d / r,\r\n\t\t    tmp = r2 / r,\r\n\t\t    eccent = Math.sqrt(1 - (tmp * tmp)),\r\n\t\t    ts = Math.exp(- point.y / r),\r\n\t\t    phi = (Math.PI / 2) - 2 * Math.atan(ts),\r\n\t\t    numIter = 15,\r\n\t\t    tol = 1e-7,\r\n\t\t    i = numIter,\r\n\t\t    dphi = 0.1,\r\n\t\t    con;\r\n\r\n\t\twhile ((Math.abs(dphi) > tol) && (--i > 0)) {\r\n\t\t\tcon = eccent * Math.sin(phi);\r\n\t\t\tdphi = (Math.PI / 2) - 2 * Math.atan(ts *\r\n\t\t\t            Math.pow((1.0 - con) / (1.0 + con), 0.5 * eccent)) - phi;\r\n\t\t\tphi += dphi;\r\n\t\t}\r\n\r\n\t\treturn new L.LatLng(phi * d, lng);\r\n\t}\r\n};\r\n\n\n\r\nL.CRS.EPSG3395 = L.extend({}, L.CRS, {\r\n\tcode: 'EPSG:3395',\r\n\r\n\tprojection: L.Projection.Mercator,\r\n\r\n\ttransformation: (function () {\r\n\t\tvar m = L.Projection.Mercator,\r\n\t\t    r = m.R_MAJOR,\r\n\t\t    scale = 0.5 / (Math.PI * r);\r\n\r\n\t\treturn new L.Transformation(scale, 0.5, -scale, 0.5);\r\n\t}())\r\n});\r\n\n\n/*\r\n * L.TileLayer is used for standard xyz-numbered tile layers.\r\n */\r\n\r\nL.TileLayer = L.Class.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\tminZoom: 0,\r\n\t\tmaxZoom: 18,\r\n\t\ttileSize: 256,\r\n\t\tsubdomains: 'abc',\r\n\t\terrorTileUrl: '',\r\n\t\tattribution: '',\r\n\t\tzoomOffset: 0,\r\n\t\topacity: 1,\r\n\t\t/*\r\n\t\tmaxNativeZoom: null,\r\n\t\tzIndex: null,\r\n\t\ttms: false,\r\n\t\tcontinuousWorld: false,\r\n\t\tnoWrap: false,\r\n\t\tzoomReverse: false,\r\n\t\tdetectRetina: false,\r\n\t\treuseTiles: false,\r\n\t\tbounds: false,\r\n\t\t*/\r\n\t\tunloadInvisibleTiles: L.Browser.mobile,\r\n\t\tupdateWhenIdle: L.Browser.mobile\r\n\t},\r\n\r\n\tinitialize: function (url, options) {\r\n\t\toptions = L.setOptions(this, options);\r\n\r\n\t\t// detecting retina displays, adjusting tileSize and zoom levels\r\n\t\tif (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {\r\n\r\n\t\t\toptions.tileSize = Math.floor(options.tileSize / 2);\r\n\t\t\toptions.zoomOffset++;\r\n\r\n\t\t\tif (options.minZoom > 0) {\r\n\t\t\t\toptions.minZoom--;\r\n\t\t\t}\r\n\t\t\tthis.options.maxZoom--;\r\n\t\t}\r\n\r\n\t\tif (options.bounds) {\r\n\t\t\toptions.bounds = L.latLngBounds(options.bounds);\r\n\t\t}\r\n\r\n\t\tthis._url = url;\r\n\r\n\t\tvar subdomains = this.options.subdomains;\r\n\r\n\t\tif (typeof subdomains === 'string') {\r\n\t\t\tthis.options.subdomains = subdomains.split('');\r\n\t\t}\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\t\tthis._animated = map._zoomAnimated;\r\n\r\n\t\t// create a container div for tiles\r\n\t\tthis._initContainer();\r\n\r\n\t\t// set up events\r\n\t\tmap.on({\r\n\t\t\t'viewreset': this._reset,\r\n\t\t\t'moveend': this._update\r\n\t\t}, this);\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tmap.on({\r\n\t\t\t\t'zoomanim': this._animateZoom,\r\n\t\t\t\t'zoomend': this._endZoomAnim\r\n\t\t\t}, this);\r\n\t\t}\r\n\r\n\t\tif (!this.options.updateWhenIdle) {\r\n\t\t\tthis._limitedUpdate = L.Util.limitExecByInterval(this._update, 150, this);\r\n\t\t\tmap.on('move', this._limitedUpdate, this);\r\n\t\t}\r\n\r\n\t\tthis._reset();\r\n\t\tthis._update();\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tthis._container.parentNode.removeChild(this._container);\r\n\r\n\t\tmap.off({\r\n\t\t\t'viewreset': this._reset,\r\n\t\t\t'moveend': this._update\r\n\t\t}, this);\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tmap.off({\r\n\t\t\t\t'zoomanim': this._animateZoom,\r\n\t\t\t\t'zoomend': this._endZoomAnim\r\n\t\t\t}, this);\r\n\t\t}\r\n\r\n\t\tif (!this.options.updateWhenIdle) {\r\n\t\t\tmap.off('move', this._limitedUpdate, this);\r\n\t\t}\r\n\r\n\t\tthis._container = null;\r\n\t\tthis._map = null;\r\n\t},\r\n\r\n\tbringToFront: function () {\r\n\t\tvar pane = this._map._panes.tilePane;\r\n\r\n\t\tif (this._container) {\r\n\t\t\tpane.appendChild(this._container);\r\n\t\t\tthis._setAutoZIndex(pane, Math.max);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tbringToBack: function () {\r\n\t\tvar pane = this._map._panes.tilePane;\r\n\r\n\t\tif (this._container) {\r\n\t\t\tpane.insertBefore(this._container, pane.firstChild);\r\n\t\t\tthis._setAutoZIndex(pane, Math.min);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetAttribution: function () {\r\n\t\treturn this.options.attribution;\r\n\t},\r\n\r\n\tgetContainer: function () {\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\tsetOpacity: function (opacity) {\r\n\t\tthis.options.opacity = opacity;\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._updateOpacity();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetZIndex: function (zIndex) {\r\n\t\tthis.options.zIndex = zIndex;\r\n\t\tthis._updateZIndex();\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetUrl: function (url, noRedraw) {\r\n\t\tthis._url = url;\r\n\r\n\t\tif (!noRedraw) {\r\n\t\t\tthis.redraw();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tredraw: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._reset({hard: true});\r\n\t\t\tthis._update();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_updateZIndex: function () {\r\n\t\tif (this._container && this.options.zIndex !== undefined) {\r\n\t\t\tthis._container.style.zIndex = this.options.zIndex;\r\n\t\t}\r\n\t},\r\n\r\n\t_setAutoZIndex: function (pane, compare) {\r\n\r\n\t\tvar layers = pane.children,\r\n\t\t    edgeZIndex = -compare(Infinity, -Infinity), // -Infinity for max, Infinity for min\r\n\t\t    zIndex, i, len;\r\n\r\n\t\tfor (i = 0, len = layers.length; i < len; i++) {\r\n\r\n\t\t\tif (layers[i] !== this._container) {\r\n\t\t\t\tzIndex = parseInt(layers[i].style.zIndex, 10);\r\n\r\n\t\t\t\tif (!isNaN(zIndex)) {\r\n\t\t\t\t\tedgeZIndex = compare(edgeZIndex, zIndex);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.options.zIndex = this._container.style.zIndex =\r\n\t\t        (isFinite(edgeZIndex) ? edgeZIndex : 0) + compare(1, -1);\r\n\t},\r\n\r\n\t_updateOpacity: function () {\r\n\t\tvar i,\r\n\t\t    tiles = this._tiles;\r\n\r\n\t\tif (L.Browser.ielt9) {\r\n\t\t\tfor (i in tiles) {\r\n\t\t\t\tL.DomUtil.setOpacity(tiles[i], this.options.opacity);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tL.DomUtil.setOpacity(this._container, this.options.opacity);\r\n\t\t}\r\n\t},\r\n\r\n\t_initContainer: function () {\r\n\t\tvar tilePane = this._map._panes.tilePane;\r\n\r\n\t\tif (!this._container) {\r\n\t\t\tthis._container = L.DomUtil.create('div', 'leaflet-layer');\r\n\r\n\t\t\tthis._updateZIndex();\r\n\r\n\t\t\tif (this._animated) {\r\n\t\t\t\tvar className = 'leaflet-tile-container';\r\n\r\n\t\t\t\tthis._bgBuffer = L.DomUtil.create('div', className, this._container);\r\n\t\t\t\tthis._tileContainer = L.DomUtil.create('div', className, this._container);\r\n\r\n\t\t\t} else {\r\n\t\t\t\tthis._tileContainer = this._container;\r\n\t\t\t}\r\n\r\n\t\t\ttilePane.appendChild(this._container);\r\n\r\n\t\t\tif (this.options.opacity < 1) {\r\n\t\t\t\tthis._updateOpacity();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_reset: function (e) {\r\n\t\tfor (var key in this._tiles) {\r\n\t\t\tthis.fire('tileunload', {tile: this._tiles[key]});\r\n\t\t}\r\n\r\n\t\tthis._tiles = {};\r\n\t\tthis._tilesToLoad = 0;\r\n\r\n\t\tif (this.options.reuseTiles) {\r\n\t\t\tthis._unusedTiles = [];\r\n\t\t}\r\n\r\n\t\tthis._tileContainer.innerHTML = '';\r\n\r\n\t\tif (this._animated && e && e.hard) {\r\n\t\t\tthis._clearBgBuffer();\r\n\t\t}\r\n\r\n\t\tthis._initContainer();\r\n\t},\r\n\r\n\t_getTileSize: function () {\r\n\t\tvar map = this._map,\r\n\t\t    zoom = map.getZoom() + this.options.zoomOffset,\r\n\t\t    zoomN = this.options.maxNativeZoom,\r\n\t\t    tileSize = this.options.tileSize;\r\n\r\n\t\tif (zoomN && zoom > zoomN) {\r\n\t\t\ttileSize = Math.round(map.getZoomScale(zoom) / map.getZoomScale(zoomN) * tileSize);\r\n\t\t}\r\n\r\n\t\treturn tileSize;\r\n\t},\r\n\r\n\t_update: function () {\r\n\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tvar map = this._map,\r\n\t\t    bounds = map.getPixelBounds(),\r\n\t\t    zoom = map.getZoom(),\r\n\t\t    tileSize = this._getTileSize();\r\n\r\n\t\tif (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar tileBounds = L.bounds(\r\n\t\t        bounds.min.divideBy(tileSize)._floor(),\r\n\t\t        bounds.max.divideBy(tileSize)._floor());\r\n\r\n\t\tthis._addTilesFromCenterOut(tileBounds);\r\n\r\n\t\tif (this.options.unloadInvisibleTiles || this.options.reuseTiles) {\r\n\t\t\tthis._removeOtherTiles(tileBounds);\r\n\t\t}\r\n\t},\r\n\r\n\t_addTilesFromCenterOut: function (bounds) {\r\n\t\tvar queue = [],\r\n\t\t    center = bounds.getCenter();\r\n\r\n\t\tvar j, i, point;\r\n\r\n\t\tfor (j = bounds.min.y; j <= bounds.max.y; j++) {\r\n\t\t\tfor (i = bounds.min.x; i <= bounds.max.x; i++) {\r\n\t\t\t\tpoint = new L.Point(i, j);\r\n\r\n\t\t\t\tif (this._tileShouldBeLoaded(point)) {\r\n\t\t\t\t\tqueue.push(point);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar tilesToLoad = queue.length;\r\n\r\n\t\tif (tilesToLoad === 0) { return; }\r\n\r\n\t\t// load tiles in order of their distance to center\r\n\t\tqueue.sort(function (a, b) {\r\n\t\t\treturn a.distanceTo(center) - b.distanceTo(center);\r\n\t\t});\r\n\r\n\t\tvar fragment = document.createDocumentFragment();\r\n\r\n\t\t// if its the first batch of tiles to load\r\n\t\tif (!this._tilesToLoad) {\r\n\t\t\tthis.fire('loading');\r\n\t\t}\r\n\r\n\t\tthis._tilesToLoad += tilesToLoad;\r\n\r\n\t\tfor (i = 0; i < tilesToLoad; i++) {\r\n\t\t\tthis._addTile(queue[i], fragment);\r\n\t\t}\r\n\r\n\t\tthis._tileContainer.appendChild(fragment);\r\n\t},\r\n\r\n\t_tileShouldBeLoaded: function (tilePoint) {\r\n\t\tif ((tilePoint.x + ':' + tilePoint.y) in this._tiles) {\r\n\t\t\treturn false; // already loaded\r\n\t\t}\r\n\r\n\t\tvar options = this.options;\r\n\r\n\t\tif (!options.continuousWorld) {\r\n\t\t\tvar limit = this._getWrapTileNum();\r\n\r\n\t\t\t// don't load if exceeds world bounds\r\n\t\t\tif ((options.noWrap && (tilePoint.x < 0 || tilePoint.x >= limit.x)) ||\r\n\t\t\t\ttilePoint.y < 0 || tilePoint.y >= limit.y) { return false; }\r\n\t\t}\r\n\r\n\t\tif (options.bounds) {\r\n\t\t\tvar tileSize = this._getTileSize(),\r\n\t\t\t    nwPoint = tilePoint.multiplyBy(tileSize),\r\n\t\t\t    sePoint = nwPoint.add([tileSize, tileSize]),\r\n\t\t\t    nw = this._map.unproject(nwPoint),\r\n\t\t\t    se = this._map.unproject(sePoint);\r\n\r\n\t\t\t// TODO temporary hack, will be removed after refactoring projections\r\n\t\t\t// https://github.com/Leaflet/Leaflet/issues/1618\r\n\t\t\tif (!options.continuousWorld && !options.noWrap) {\r\n\t\t\t\tnw = nw.wrap();\r\n\t\t\t\tse = se.wrap();\r\n\t\t\t}\r\n\r\n\t\t\tif (!options.bounds.intersects([nw, se])) { return false; }\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t},\r\n\r\n\t_removeOtherTiles: function (bounds) {\r\n\t\tvar kArr, x, y, key;\r\n\r\n\t\tfor (key in this._tiles) {\r\n\t\t\tkArr = key.split(':');\r\n\t\t\tx = parseInt(kArr[0], 10);\r\n\t\t\ty = parseInt(kArr[1], 10);\r\n\r\n\t\t\t// remove tile if it's out of bounds\r\n\t\t\tif (x < bounds.min.x || x > bounds.max.x || y < bounds.min.y || y > bounds.max.y) {\r\n\t\t\t\tthis._removeTile(key);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_removeTile: function (key) {\r\n\t\tvar tile = this._tiles[key];\r\n\r\n\t\tthis.fire('tileunload', {tile: tile, url: tile.src});\r\n\r\n\t\tif (this.options.reuseTiles) {\r\n\t\t\tL.DomUtil.removeClass(tile, 'leaflet-tile-loaded');\r\n\t\t\tthis._unusedTiles.push(tile);\r\n\r\n\t\t} else if (tile.parentNode === this._tileContainer) {\r\n\t\t\tthis._tileContainer.removeChild(tile);\r\n\t\t}\r\n\r\n\t\t// for https://github.com/CloudMade/Leaflet/issues/137\r\n\t\tif (!L.Browser.android) {\r\n\t\t\ttile.onload = null;\r\n\t\t\ttile.src = L.Util.emptyImageUrl;\r\n\t\t}\r\n\r\n\t\tdelete this._tiles[key];\r\n\t},\r\n\r\n\t_addTile: function (tilePoint, container) {\r\n\t\tvar tilePos = this._getTilePos(tilePoint);\r\n\r\n\t\t// get unused tile - or create a new tile\r\n\t\tvar tile = this._getTile();\r\n\r\n\t\t/*\r\n\t\tChrome 20 layouts much faster with top/left (verify with timeline, frames)\r\n\t\tAndroid 4 browser has display issues with top/left and requires transform instead\r\n\t\t(other browsers don't currently care) - see debug/hacks/jitter.html for an example\r\n\t\t*/\r\n\t\tL.DomUtil.setPosition(tile, tilePos, L.Browser.chrome);\r\n\r\n\t\tthis._tiles[tilePoint.x + ':' + tilePoint.y] = tile;\r\n\r\n\t\tthis._loadTile(tile, tilePoint);\r\n\r\n\t\tif (tile.parentNode !== this._tileContainer) {\r\n\t\t\tcontainer.appendChild(tile);\r\n\t\t}\r\n\t},\r\n\r\n\t_getZoomForUrl: function () {\r\n\r\n\t\tvar options = this.options,\r\n\t\t    zoom = this._map.getZoom();\r\n\r\n\t\tif (options.zoomReverse) {\r\n\t\t\tzoom = options.maxZoom - zoom;\r\n\t\t}\r\n\r\n\t\tzoom += options.zoomOffset;\r\n\r\n\t\treturn options.maxNativeZoom ? Math.min(zoom, options.maxNativeZoom) : zoom;\r\n\t},\r\n\r\n\t_getTilePos: function (tilePoint) {\r\n\t\tvar origin = this._map.getPixelOrigin(),\r\n\t\t    tileSize = this._getTileSize();\r\n\r\n\t\treturn tilePoint.multiplyBy(tileSize).subtract(origin);\r\n\t},\r\n\r\n\t// image-specific code (override to implement e.g. Canvas or SVG tile layer)\r\n\r\n\tgetTileUrl: function (tilePoint) {\r\n\t\treturn L.Util.template(this._url, L.extend({\r\n\t\t\ts: this._getSubdomain(tilePoint),\r\n\t\t\tz: tilePoint.z,\r\n\t\t\tx: tilePoint.x,\r\n\t\t\ty: tilePoint.y\r\n\t\t}, this.options));\r\n\t},\r\n\r\n\t_getWrapTileNum: function () {\r\n\t\tvar crs = this._map.options.crs,\r\n\t\t    size = crs.getSize(this._map.getZoom());\r\n\t\treturn size.divideBy(this._getTileSize())._floor();\r\n\t},\r\n\r\n\t_adjustTilePoint: function (tilePoint) {\r\n\r\n\t\tvar limit = this._getWrapTileNum();\r\n\r\n\t\t// wrap tile coordinates\r\n\t\tif (!this.options.continuousWorld && !this.options.noWrap) {\r\n\t\t\ttilePoint.x = ((tilePoint.x % limit.x) + limit.x) % limit.x;\r\n\t\t}\r\n\r\n\t\tif (this.options.tms) {\r\n\t\t\ttilePoint.y = limit.y - tilePoint.y - 1;\r\n\t\t}\r\n\r\n\t\ttilePoint.z = this._getZoomForUrl();\r\n\t},\r\n\r\n\t_getSubdomain: function (tilePoint) {\r\n\t\tvar index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;\r\n\t\treturn this.options.subdomains[index];\r\n\t},\r\n\r\n\t_getTile: function () {\r\n\t\tif (this.options.reuseTiles && this._unusedTiles.length > 0) {\r\n\t\t\tvar tile = this._unusedTiles.pop();\r\n\t\t\tthis._resetTile(tile);\r\n\t\t\treturn tile;\r\n\t\t}\r\n\t\treturn this._createTile();\r\n\t},\r\n\r\n\t// Override if data stored on a tile needs to be cleaned up before reuse\r\n\t_resetTile: function (/*tile*/) {},\r\n\r\n\t_createTile: function () {\r\n\t\tvar tile = L.DomUtil.create('img', 'leaflet-tile');\r\n\t\ttile.style.width = tile.style.height = this._getTileSize() + 'px';\r\n\t\ttile.galleryimg = 'no';\r\n\r\n\t\ttile.onselectstart = tile.onmousemove = L.Util.falseFn;\r\n\r\n\t\tif (L.Browser.ielt9 && this.options.opacity !== undefined) {\r\n\t\t\tL.DomUtil.setOpacity(tile, this.options.opacity);\r\n\t\t}\r\n\t\t// without this hack, tiles disappear after zoom on Chrome for Android\r\n\t\t// https://github.com/Leaflet/Leaflet/issues/2078\r\n\t\tif (L.Browser.mobileWebkit3d) {\r\n\t\t\ttile.style.WebkitBackfaceVisibility = 'hidden';\r\n\t\t}\r\n\t\treturn tile;\r\n\t},\r\n\r\n\t_loadTile: function (tile, tilePoint) {\r\n\t\ttile._layer  = this;\r\n\t\ttile.onload  = this._tileOnLoad;\r\n\t\ttile.onerror = this._tileOnError;\r\n\r\n\t\tthis._adjustTilePoint(tilePoint);\r\n\t\ttile.src     = this.getTileUrl(tilePoint);\r\n\r\n\t\tthis.fire('tileloadstart', {\r\n\t\t\ttile: tile,\r\n\t\t\turl: tile.src\r\n\t\t});\r\n\t},\r\n\r\n\t_tileLoaded: function () {\r\n\t\tthis._tilesToLoad--;\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tL.DomUtil.addClass(this._tileContainer, 'leaflet-zoom-animated');\r\n\t\t}\r\n\r\n\t\tif (!this._tilesToLoad) {\r\n\t\t\tthis.fire('load');\r\n\r\n\t\t\tif (this._animated) {\r\n\t\t\t\t// clear scaled tiles after all new tiles are loaded (for performance)\r\n\t\t\t\tclearTimeout(this._clearBgBufferTimer);\r\n\t\t\t\tthis._clearBgBufferTimer = setTimeout(L.bind(this._clearBgBuffer, this), 500);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_tileOnLoad: function () {\r\n\t\tvar layer = this._layer;\r\n\r\n\t\t//Only if we are loading an actual image\r\n\t\tif (this.src !== L.Util.emptyImageUrl) {\r\n\t\t\tL.DomUtil.addClass(this, 'leaflet-tile-loaded');\r\n\r\n\t\t\tlayer.fire('tileload', {\r\n\t\t\t\ttile: this,\r\n\t\t\t\turl: this.src\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tlayer._tileLoaded();\r\n\t},\r\n\r\n\t_tileOnError: function () {\r\n\t\tvar layer = this._layer;\r\n\r\n\t\tlayer.fire('tileerror', {\r\n\t\t\ttile: this,\r\n\t\t\turl: this.src\r\n\t\t});\r\n\r\n\t\tvar newUrl = layer.options.errorTileUrl;\r\n\t\tif (newUrl) {\r\n\t\t\tthis.src = newUrl;\r\n\t\t}\r\n\r\n\t\tlayer._tileLoaded();\r\n\t}\r\n});\r\n\r\nL.tileLayer = function (url, options) {\r\n\treturn new L.TileLayer(url, options);\r\n};\r\n\n\n/*\r\n * L.TileLayer.WMS is used for putting WMS tile layers on the map.\r\n */\r\n\r\nL.TileLayer.WMS = L.TileLayer.extend({\r\n\r\n\tdefaultWmsParams: {\r\n\t\tservice: 'WMS',\r\n\t\trequest: 'GetMap',\r\n\t\tversion: '1.1.1',\r\n\t\tlayers: '',\r\n\t\tstyles: '',\r\n\t\tformat: 'image/jpeg',\r\n\t\ttransparent: false\r\n\t},\r\n\r\n\tinitialize: function (url, options) { // (String, Object)\r\n\r\n\t\tthis._url = url;\r\n\r\n\t\tvar wmsParams = L.extend({}, this.defaultWmsParams),\r\n\t\t    tileSize = options.tileSize || this.options.tileSize;\r\n\r\n\t\tif (options.detectRetina && L.Browser.retina) {\r\n\t\t\twmsParams.width = wmsParams.height = tileSize * 2;\r\n\t\t} else {\r\n\t\t\twmsParams.width = wmsParams.height = tileSize;\r\n\t\t}\r\n\r\n\t\tfor (var i in options) {\r\n\t\t\t// all keys that are not TileLayer options go to WMS params\r\n\t\t\tif (!this.options.hasOwnProperty(i) && i !== 'crs') {\r\n\t\t\t\twmsParams[i] = options[i];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.wmsParams = wmsParams;\r\n\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\r\n\t\tthis._crs = this.options.crs || map.options.crs;\r\n\r\n\t\tthis._wmsVersion = parseFloat(this.wmsParams.version);\r\n\r\n\t\tvar projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';\r\n\t\tthis.wmsParams[projectionKey] = this._crs.code;\r\n\r\n\t\tL.TileLayer.prototype.onAdd.call(this, map);\r\n\t},\r\n\r\n\tgetTileUrl: function (tilePoint) { // (Point, Number) -> String\r\n\r\n\t\tvar map = this._map,\r\n\t\t    tileSize = this.options.tileSize,\r\n\r\n\t\t    nwPoint = tilePoint.multiplyBy(tileSize),\r\n\t\t    sePoint = nwPoint.add([tileSize, tileSize]),\r\n\r\n\t\t    nw = this._crs.project(map.unproject(nwPoint, tilePoint.z)),\r\n\t\t    se = this._crs.project(map.unproject(sePoint, tilePoint.z)),\r\n\t\t    bbox = this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ?\r\n\t\t        [se.y, nw.x, nw.y, se.x].join(',') :\r\n\t\t        [nw.x, se.y, se.x, nw.y].join(','),\r\n\r\n\t\t    url = L.Util.template(this._url, {s: this._getSubdomain(tilePoint)});\r\n\r\n\t\treturn url + L.Util.getParamString(this.wmsParams, url, true) + '&BBOX=' + bbox;\r\n\t},\r\n\r\n\tsetParams: function (params, noRedraw) {\r\n\r\n\t\tL.extend(this.wmsParams, params);\r\n\r\n\t\tif (!noRedraw) {\r\n\t\t\tthis.redraw();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n});\r\n\r\nL.tileLayer.wms = function (url, options) {\r\n\treturn new L.TileLayer.WMS(url, options);\r\n};\r\n\n\n/*\r\n * L.TileLayer.Canvas is a class that you can use as a base for creating\r\n * dynamically drawn Canvas-based tile layers.\r\n */\r\n\r\nL.TileLayer.Canvas = L.TileLayer.extend({\r\n\toptions: {\r\n\t\tasync: false\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tredraw: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._reset({hard: true});\r\n\t\t\tthis._update();\r\n\t\t}\r\n\r\n\t\tfor (var i in this._tiles) {\r\n\t\t\tthis._redrawTile(this._tiles[i]);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_redrawTile: function (tile) {\r\n\t\tthis.drawTile(tile, tile._tilePoint, this._map._zoom);\r\n\t},\r\n\r\n\t_createTile: function () {\r\n\t\tvar tile = L.DomUtil.create('canvas', 'leaflet-tile');\r\n\t\ttile.width = tile.height = this.options.tileSize;\r\n\t\ttile.onselectstart = tile.onmousemove = L.Util.falseFn;\r\n\t\treturn tile;\r\n\t},\r\n\r\n\t_loadTile: function (tile, tilePoint) {\r\n\t\ttile._layer = this;\r\n\t\ttile._tilePoint = tilePoint;\r\n\r\n\t\tthis._redrawTile(tile);\r\n\r\n\t\tif (!this.options.async) {\r\n\t\t\tthis.tileDrawn(tile);\r\n\t\t}\r\n\t},\r\n\r\n\tdrawTile: function (/*tile, tilePoint*/) {\r\n\t\t// override with rendering code\r\n\t},\r\n\r\n\ttileDrawn: function (tile) {\r\n\t\tthis._tileOnLoad.call(tile);\r\n\t}\r\n});\r\n\r\n\r\nL.tileLayer.canvas = function (options) {\r\n\treturn new L.TileLayer.Canvas(options);\r\n};\r\n\n\n/*\r\n * L.ImageOverlay is used to overlay images over the map (to specific geographical bounds).\r\n */\r\n\r\nL.ImageOverlay = L.Class.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\topacity: 1\r\n\t},\r\n\r\n\tinitialize: function (url, bounds, options) { // (String, LatLngBounds, Object)\r\n\t\tthis._url = url;\r\n\t\tthis._bounds = L.latLngBounds(bounds);\r\n\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tif (!this._image) {\r\n\t\t\tthis._initImage();\r\n\t\t}\r\n\r\n\t\tmap._panes.overlayPane.appendChild(this._image);\r\n\r\n\t\tmap.on('viewreset', this._reset, this);\r\n\r\n\t\tif (map.options.zoomAnimation && L.Browser.any3d) {\r\n\t\t\tmap.on('zoomanim', this._animateZoom, this);\r\n\t\t}\r\n\r\n\t\tthis._reset();\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap.getPanes().overlayPane.removeChild(this._image);\r\n\r\n\t\tmap.off('viewreset', this._reset, this);\r\n\r\n\t\tif (map.options.zoomAnimation) {\r\n\t\t\tmap.off('zoomanim', this._animateZoom, this);\r\n\t\t}\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetOpacity: function (opacity) {\r\n\t\tthis.options.opacity = opacity;\r\n\t\tthis._updateOpacity();\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// TODO remove bringToFront/bringToBack duplication from TileLayer/Path\r\n\tbringToFront: function () {\r\n\t\tif (this._image) {\r\n\t\t\tthis._map._panes.overlayPane.appendChild(this._image);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tbringToBack: function () {\r\n\t\tvar pane = this._map._panes.overlayPane;\r\n\t\tif (this._image) {\r\n\t\t\tpane.insertBefore(this._image, pane.firstChild);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetUrl: function (url) {\r\n\t\tthis._url = url;\r\n\t\tthis._image.src = this._url;\r\n\t},\r\n\r\n\tgetAttribution: function () {\r\n\t\treturn this.options.attribution;\r\n\t},\r\n\r\n\t_initImage: function () {\r\n\t\tthis._image = L.DomUtil.create('img', 'leaflet-image-layer');\r\n\r\n\t\tif (this._map.options.zoomAnimation && L.Browser.any3d) {\r\n\t\t\tL.DomUtil.addClass(this._image, 'leaflet-zoom-animated');\r\n\t\t} else {\r\n\t\t\tL.DomUtil.addClass(this._image, 'leaflet-zoom-hide');\r\n\t\t}\r\n\r\n\t\tthis._updateOpacity();\r\n\r\n\t\t//TODO createImage util method to remove duplication\r\n\t\tL.extend(this._image, {\r\n\t\t\tgalleryimg: 'no',\r\n\t\t\tonselectstart: L.Util.falseFn,\r\n\t\t\tonmousemove: L.Util.falseFn,\r\n\t\t\tonload: L.bind(this._onImageLoad, this),\r\n\t\t\tsrc: this._url\r\n\t\t});\r\n\t},\r\n\r\n\t_animateZoom: function (e) {\r\n\t\tvar map = this._map,\r\n\t\t    image = this._image,\r\n\t\t    scale = map.getZoomScale(e.zoom),\r\n\t\t    nw = this._bounds.getNorthWest(),\r\n\t\t    se = this._bounds.getSouthEast(),\r\n\r\n\t\t    topLeft = map._latLngToNewLayerPoint(nw, e.zoom, e.center),\r\n\t\t    size = map._latLngToNewLayerPoint(se, e.zoom, e.center)._subtract(topLeft),\r\n\t\t    origin = topLeft._add(size._multiplyBy((1 / 2) * (1 - 1 / scale)));\r\n\r\n\t\timage.style[L.DomUtil.TRANSFORM] =\r\n\t\t        L.DomUtil.getTranslateString(origin) + ' scale(' + scale + ') ';\r\n\t},\r\n\r\n\t_reset: function () {\r\n\t\tvar image   = this._image,\r\n\t\t    topLeft = this._map.latLngToLayerPoint(this._bounds.getNorthWest()),\r\n\t\t    size = this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(topLeft);\r\n\r\n\t\tL.DomUtil.setPosition(image, topLeft);\r\n\r\n\t\timage.style.width  = size.x + 'px';\r\n\t\timage.style.height = size.y + 'px';\r\n\t},\r\n\r\n\t_onImageLoad: function () {\r\n\t\tthis.fire('load');\r\n\t},\r\n\r\n\t_updateOpacity: function () {\r\n\t\tL.DomUtil.setOpacity(this._image, this.options.opacity);\r\n\t}\r\n});\r\n\r\nL.imageOverlay = function (url, bounds, options) {\r\n\treturn new L.ImageOverlay(url, bounds, options);\r\n};\r\n\n\n/*\r\n * L.Icon is an image-based icon class that you can use with L.Marker for custom markers.\r\n */\r\n\r\nL.Icon = L.Class.extend({\r\n\toptions: {\r\n\t\t/*\r\n\t\ticonUrl: (String) (required)\r\n\t\ticonRetinaUrl: (String) (optional, used for retina devices if detected)\r\n\t\ticonSize: (Point) (can be set through CSS)\r\n\t\ticonAnchor: (Point) (centered by default, can be set in CSS with negative margins)\r\n\t\tpopupAnchor: (Point) (if not specified, popup opens in the anchor point)\r\n\t\tshadowUrl: (String) (no shadow by default)\r\n\t\tshadowRetinaUrl: (String) (optional, used for retina devices if detected)\r\n\t\tshadowSize: (Point)\r\n\t\tshadowAnchor: (Point)\r\n\t\t*/\r\n\t\tclassName: ''\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tcreateIcon: function (oldIcon) {\r\n\t\treturn this._createIcon('icon', oldIcon);\r\n\t},\r\n\r\n\tcreateShadow: function (oldIcon) {\r\n\t\treturn this._createIcon('shadow', oldIcon);\r\n\t},\r\n\r\n\t_createIcon: function (name, oldIcon) {\r\n\t\tvar src = this._getIconUrl(name);\r\n\r\n\t\tif (!src) {\r\n\t\t\tif (name === 'icon') {\r\n\t\t\t\tthrow new Error('iconUrl not set in Icon options (see the docs).');\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tvar img;\r\n\t\tif (!oldIcon || oldIcon.tagName !== 'IMG') {\r\n\t\t\timg = this._createImg(src);\r\n\t\t} else {\r\n\t\t\timg = this._createImg(src, oldIcon);\r\n\t\t}\r\n\t\tthis._setIconStyles(img, name);\r\n\r\n\t\treturn img;\r\n\t},\r\n\r\n\t_setIconStyles: function (img, name) {\r\n\t\tvar options = this.options,\r\n\t\t    size = L.point(options[name + 'Size']),\r\n\t\t    anchor;\r\n\r\n\t\tif (name === 'shadow') {\r\n\t\t\tanchor = L.point(options.shadowAnchor || options.iconAnchor);\r\n\t\t} else {\r\n\t\t\tanchor = L.point(options.iconAnchor);\r\n\t\t}\r\n\r\n\t\tif (!anchor && size) {\r\n\t\t\tanchor = size.divideBy(2, true);\r\n\t\t}\r\n\r\n\t\timg.className = 'leaflet-marker-' + name + ' ' + options.className;\r\n\r\n\t\tif (anchor) {\r\n\t\t\timg.style.marginLeft = (-anchor.x) + 'px';\r\n\t\t\timg.style.marginTop  = (-anchor.y) + 'px';\r\n\t\t}\r\n\r\n\t\tif (size) {\r\n\t\t\timg.style.width  = size.x + 'px';\r\n\t\t\timg.style.height = size.y + 'px';\r\n\t\t}\r\n\t},\r\n\r\n\t_createImg: function (src, el) {\r\n\t\tel = el || document.createElement('img');\r\n\t\tel.src = src;\r\n\t\treturn el;\r\n\t},\r\n\r\n\t_getIconUrl: function (name) {\r\n\t\tif (L.Browser.retina && this.options[name + 'RetinaUrl']) {\r\n\t\t\treturn this.options[name + 'RetinaUrl'];\r\n\t\t}\r\n\t\treturn this.options[name + 'Url'];\r\n\t}\r\n});\r\n\r\nL.icon = function (options) {\r\n\treturn new L.Icon(options);\r\n};\r\n\n\n/*\n * L.Icon.Default is the blue marker icon used by default in Leaflet.\n */\n\nL.Icon.Default = L.Icon.extend({\n\n\toptions: {\n\t\ticonSize: [25, 41],\n\t\ticonAnchor: [12, 41],\n\t\tpopupAnchor: [1, -34],\n\n\t\tshadowSize: [41, 41]\n\t},\n\n\t_getIconUrl: function (name) {\n\t\tvar key = name + 'Url';\n\n\t\tif (this.options[key]) {\n\t\t\treturn this.options[key];\n\t\t}\n\n\t\tif (L.Browser.retina && name === 'icon') {\n\t\t\tname += '-2x';\n\t\t}\n\n\t\tvar path = L.Icon.Default.imagePath;\n\n\t\tif (!path) {\n\t\t\tthrow new Error('Couldn\\'t autodetect L.Icon.Default.imagePath, set it manually.');\n\t\t}\n\n\t\treturn path + '/marker-' + name + '.png';\n\t}\n});\n\nL.Icon.Default.imagePath = (function () {\n\tvar scripts = document.getElementsByTagName('script'),\n\t    leafletRe = /[\\/^]leaflet[\\-\\._]?([\\w\\-\\._]*)\\.js\\??/;\n\n\tvar i, len, src, matches, path;\n\n\tfor (i = 0, len = scripts.length; i < len; i++) {\n\t\tsrc = scripts[i].src;\n\t\tmatches = src.match(leafletRe);\n\n\t\tif (matches) {\n\t\t\tpath = src.split(leafletRe)[0];\n\t\t\treturn (path ? path + '/' : '') + 'images';\n\t\t}\n\t}\n}());\n\n\n/*\r\n * L.Marker is used to display clickable/draggable icons on the map.\r\n */\r\n\r\nL.Marker = L.Class.extend({\r\n\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\ticon: new L.Icon.Default(),\r\n\t\ttitle: '',\r\n\t\talt: '',\r\n\t\tclickable: true,\r\n\t\tdraggable: false,\r\n\t\tkeyboard: true,\r\n\t\tzIndexOffset: 0,\r\n\t\topacity: 1,\r\n\t\triseOnHover: false,\r\n\t\triseOffset: 250\r\n\t},\r\n\r\n\tinitialize: function (latlng, options) {\r\n\t\tL.setOptions(this, options);\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tmap.on('viewreset', this.update, this);\r\n\r\n\t\tthis._initIcon();\r\n\t\tthis.update();\r\n\t\tthis.fire('add');\r\n\r\n\t\tif (map.options.zoomAnimation && map.options.markerZoomAnimation) {\r\n\t\t\tmap.on('zoomanim', this._animateZoom, this);\r\n\t\t}\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tif (this.dragging) {\r\n\t\t\tthis.dragging.disable();\r\n\t\t}\r\n\r\n\t\tthis._removeIcon();\r\n\t\tthis._removeShadow();\r\n\r\n\t\tthis.fire('remove');\r\n\r\n\t\tmap.off({\r\n\t\t\t'viewreset': this.update,\r\n\t\t\t'zoomanim': this._animateZoom\r\n\t\t}, this);\r\n\r\n\t\tthis._map = null;\r\n\t},\r\n\r\n\tgetLatLng: function () {\r\n\t\treturn this._latlng;\r\n\t},\r\n\r\n\tsetLatLng: function (latlng) {\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\r\n\t\tthis.update();\r\n\r\n\t\treturn this.fire('move', { latlng: this._latlng });\r\n\t},\r\n\r\n\tsetZIndexOffset: function (offset) {\r\n\t\tthis.options.zIndexOffset = offset;\r\n\t\tthis.update();\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetIcon: function (icon) {\r\n\r\n\t\tthis.options.icon = icon;\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._initIcon();\r\n\t\t\tthis.update();\r\n\t\t}\r\n\r\n\t\tif (this._popup) {\r\n\t\t\tthis.bindPopup(this._popup);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tupdate: function () {\r\n\t\tif (this._icon) {\r\n\t\t\tthis._setPos(this._map.latLngToLayerPoint(this._latlng).round());\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_initIcon: function () {\r\n\t\tvar options = this.options,\r\n\t\t    map = this._map,\r\n\t\t    animation = (map.options.zoomAnimation && map.options.markerZoomAnimation),\r\n\t\t    classToAdd = animation ? 'leaflet-zoom-animated' : 'leaflet-zoom-hide';\r\n\r\n\t\tvar icon = options.icon.createIcon(this._icon),\r\n\t\t\taddIcon = false;\r\n\r\n\t\t// if we're not reusing the icon, remove the old one and init new one\r\n\t\tif (icon !== this._icon) {\r\n\t\t\tif (this._icon) {\r\n\t\t\t\tthis._removeIcon();\r\n\t\t\t}\r\n\t\t\taddIcon = true;\r\n\r\n\t\t\tif (options.title) {\r\n\t\t\t\ticon.title = options.title;\r\n\t\t\t}\r\n\r\n\t\t\tif (options.alt) {\r\n\t\t\t\ticon.alt = options.alt;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tL.DomUtil.addClass(icon, classToAdd);\r\n\r\n\t\tif (options.keyboard) {\r\n\t\t\ticon.tabIndex = '0';\r\n\t\t}\r\n\r\n\t\tthis._icon = icon;\r\n\r\n\t\tthis._initInteraction();\r\n\r\n\t\tif (options.riseOnHover) {\r\n\t\t\tL.DomEvent\r\n\t\t\t\t.on(icon, 'mouseover', this._bringToFront, this)\r\n\t\t\t\t.on(icon, 'mouseout', this._resetZIndex, this);\r\n\t\t}\r\n\r\n\t\tvar newShadow = options.icon.createShadow(this._shadow),\r\n\t\t\taddShadow = false;\r\n\r\n\t\tif (newShadow !== this._shadow) {\r\n\t\t\tthis._removeShadow();\r\n\t\t\taddShadow = true;\r\n\t\t}\r\n\r\n\t\tif (newShadow) {\r\n\t\t\tL.DomUtil.addClass(newShadow, classToAdd);\r\n\t\t}\r\n\t\tthis._shadow = newShadow;\r\n\r\n\r\n\t\tif (options.opacity < 1) {\r\n\t\t\tthis._updateOpacity();\r\n\t\t}\r\n\r\n\r\n\t\tvar panes = this._map._panes;\r\n\r\n\t\tif (addIcon) {\r\n\t\t\tpanes.markerPane.appendChild(this._icon);\r\n\t\t}\r\n\r\n\t\tif (newShadow && addShadow) {\r\n\t\t\tpanes.shadowPane.appendChild(this._shadow);\r\n\t\t}\r\n\t},\r\n\r\n\t_removeIcon: function () {\r\n\t\tif (this.options.riseOnHover) {\r\n\t\t\tL.DomEvent\r\n\t\t\t    .off(this._icon, 'mouseover', this._bringToFront)\r\n\t\t\t    .off(this._icon, 'mouseout', this._resetZIndex);\r\n\t\t}\r\n\r\n\t\tthis._map._panes.markerPane.removeChild(this._icon);\r\n\r\n\t\tthis._icon = null;\r\n\t},\r\n\r\n\t_removeShadow: function () {\r\n\t\tif (this._shadow) {\r\n\t\t\tthis._map._panes.shadowPane.removeChild(this._shadow);\r\n\t\t}\r\n\t\tthis._shadow = null;\r\n\t},\r\n\r\n\t_setPos: function (pos) {\r\n\t\tL.DomUtil.setPosition(this._icon, pos);\r\n\r\n\t\tif (this._shadow) {\r\n\t\t\tL.DomUtil.setPosition(this._shadow, pos);\r\n\t\t}\r\n\r\n\t\tthis._zIndex = pos.y + this.options.zIndexOffset;\r\n\r\n\t\tthis._resetZIndex();\r\n\t},\r\n\r\n\t_updateZIndex: function (offset) {\r\n\t\tthis._icon.style.zIndex = this._zIndex + offset;\r\n\t},\r\n\r\n\t_animateZoom: function (opt) {\r\n\t\tvar pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();\r\n\r\n\t\tthis._setPos(pos);\r\n\t},\r\n\r\n\t_initInteraction: function () {\r\n\r\n\t\tif (!this.options.clickable) { return; }\r\n\r\n\t\t// TODO refactor into something shared with Map/Path/etc. to DRY it up\r\n\r\n\t\tvar icon = this._icon,\r\n\t\t    events = ['dblclick', 'mousedown', 'mouseover', 'mouseout', 'contextmenu'];\r\n\r\n\t\tL.DomUtil.addClass(icon, 'leaflet-clickable');\r\n\t\tL.DomEvent.on(icon, 'click', this._onMouseClick, this);\r\n\t\tL.DomEvent.on(icon, 'keypress', this._onKeyPress, this);\r\n\r\n\t\tfor (var i = 0; i < events.length; i++) {\r\n\t\t\tL.DomEvent.on(icon, events[i], this._fireMouseEvent, this);\r\n\t\t}\r\n\r\n\t\tif (L.Handler.MarkerDrag) {\r\n\t\t\tthis.dragging = new L.Handler.MarkerDrag(this);\r\n\r\n\t\t\tif (this.options.draggable) {\r\n\t\t\t\tthis.dragging.enable();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_onMouseClick: function (e) {\r\n\t\tvar wasDragged = this.dragging && this.dragging.moved();\r\n\r\n\t\tif (this.hasEventListeners(e.type) || wasDragged) {\r\n\t\t\tL.DomEvent.stopPropagation(e);\r\n\t\t}\r\n\r\n\t\tif (wasDragged) { return; }\r\n\r\n\t\tif ((!this.dragging || !this.dragging._enabled) && this._map.dragging && this._map.dragging.moved()) { return; }\r\n\r\n\t\tthis.fire(e.type, {\r\n\t\t\toriginalEvent: e,\r\n\t\t\tlatlng: this._latlng\r\n\t\t});\r\n\t},\r\n\r\n\t_onKeyPress: function (e) {\r\n\t\tif (e.keyCode === 13) {\r\n\t\t\tthis.fire('click', {\r\n\t\t\t\toriginalEvent: e,\r\n\t\t\t\tlatlng: this._latlng\r\n\t\t\t});\r\n\t\t}\r\n\t},\r\n\r\n\t_fireMouseEvent: function (e) {\r\n\r\n\t\tthis.fire(e.type, {\r\n\t\t\toriginalEvent: e,\r\n\t\t\tlatlng: this._latlng\r\n\t\t});\r\n\r\n\t\t// TODO proper custom event propagation\r\n\t\t// this line will always be called if marker is in a FeatureGroup\r\n\t\tif (e.type === 'contextmenu' && this.hasEventListeners(e.type)) {\r\n\t\t\tL.DomEvent.preventDefault(e);\r\n\t\t}\r\n\t\tif (e.type !== 'mousedown') {\r\n\t\t\tL.DomEvent.stopPropagation(e);\r\n\t\t} else {\r\n\t\t\tL.DomEvent.preventDefault(e);\r\n\t\t}\r\n\t},\r\n\r\n\tsetOpacity: function (opacity) {\r\n\t\tthis.options.opacity = opacity;\r\n\t\tif (this._map) {\r\n\t\t\tthis._updateOpacity();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_updateOpacity: function () {\r\n\t\tL.DomUtil.setOpacity(this._icon, this.options.opacity);\r\n\t\tif (this._shadow) {\r\n\t\t\tL.DomUtil.setOpacity(this._shadow, this.options.opacity);\r\n\t\t}\r\n\t},\r\n\r\n\t_bringToFront: function () {\r\n\t\tthis._updateZIndex(this.options.riseOffset);\r\n\t},\r\n\r\n\t_resetZIndex: function () {\r\n\t\tthis._updateZIndex(0);\r\n\t}\r\n});\r\n\r\nL.marker = function (latlng, options) {\r\n\treturn new L.Marker(latlng, options);\r\n};\r\n\n\n/*\n * L.DivIcon is a lightweight HTML-based icon class (as opposed to the image-based L.Icon)\n * to use with L.Marker.\n */\n\nL.DivIcon = L.Icon.extend({\n\toptions: {\n\t\ticonSize: [12, 12], // also can be set through CSS\n\t\t/*\n\t\ticonAnchor: (Point)\n\t\tpopupAnchor: (Point)\n\t\thtml: (String)\n\t\tbgPos: (Point)\n\t\t*/\n\t\tclassName: 'leaflet-div-icon',\n\t\thtml: false\n\t},\n\n\tcreateIcon: function (oldIcon) {\n\t\tvar div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),\n\t\t    options = this.options;\n\n\t\tif (options.html !== false) {\n\t\t\tdiv.innerHTML = options.html;\n\t\t} else {\n\t\t\tdiv.innerHTML = '';\n\t\t}\n\n\t\tif (options.bgPos) {\n\t\t\tdiv.style.backgroundPosition =\n\t\t\t        (-options.bgPos.x) + 'px ' + (-options.bgPos.y) + 'px';\n\t\t}\n\n\t\tthis._setIconStyles(div, 'icon');\n\t\treturn div;\n\t},\n\n\tcreateShadow: function () {\n\t\treturn null;\n\t}\n});\n\nL.divIcon = function (options) {\n\treturn new L.DivIcon(options);\n};\n\n\n/*\r\n * L.Popup is used for displaying popups on the map.\r\n */\r\n\r\nL.Map.mergeOptions({\r\n\tclosePopupOnClick: true\r\n});\r\n\r\nL.Popup = L.Class.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\tminWidth: 50,\r\n\t\tmaxWidth: 300,\r\n\t\t// maxHeight: null,\r\n\t\tautoPan: true,\r\n\t\tcloseButton: true,\r\n\t\toffset: [0, 7],\r\n\t\tautoPanPadding: [5, 5],\r\n\t\t// autoPanPaddingTopLeft: null,\r\n\t\t// autoPanPaddingBottomRight: null,\r\n\t\tkeepInView: false,\r\n\t\tclassName: '',\r\n\t\tzoomAnimation: true\r\n\t},\r\n\r\n\tinitialize: function (options, source) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._source = source;\r\n\t\tthis._animated = L.Browser.any3d && this.options.zoomAnimation;\r\n\t\tthis._isOpen = false;\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tif (!this._container) {\r\n\t\t\tthis._initLayout();\r\n\t\t}\r\n\r\n\t\tvar animFade = map.options.fadeAnimation;\r\n\r\n\t\tif (animFade) {\r\n\t\t\tL.DomUtil.setOpacity(this._container, 0);\r\n\t\t}\r\n\t\tmap._panes.popupPane.appendChild(this._container);\r\n\r\n\t\tmap.on(this._getEvents(), this);\r\n\r\n\t\tthis.update();\r\n\r\n\t\tif (animFade) {\r\n\t\t\tL.DomUtil.setOpacity(this._container, 1);\r\n\t\t}\r\n\r\n\t\tthis.fire('open');\r\n\r\n\t\tmap.fire('popupopen', {popup: this});\r\n\r\n\t\tif (this._source) {\r\n\t\t\tthis._source.fire('popupopen', {popup: this});\r\n\t\t}\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\topenOn: function (map) {\r\n\t\tmap.openPopup(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap._panes.popupPane.removeChild(this._container);\r\n\r\n\t\tL.Util.falseFn(this._container.offsetWidth); // force reflow\r\n\r\n\t\tmap.off(this._getEvents(), this);\r\n\r\n\t\tif (map.options.fadeAnimation) {\r\n\t\t\tL.DomUtil.setOpacity(this._container, 0);\r\n\t\t}\r\n\r\n\t\tthis._map = null;\r\n\r\n\t\tthis.fire('close');\r\n\r\n\t\tmap.fire('popupclose', {popup: this});\r\n\r\n\t\tif (this._source) {\r\n\t\t\tthis._source.fire('popupclose', {popup: this});\r\n\t\t}\r\n\t},\r\n\r\n\tgetLatLng: function () {\r\n\t\treturn this._latlng;\r\n\t},\r\n\r\n\tsetLatLng: function (latlng) {\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t\tif (this._map) {\r\n\t\t\tthis._updatePosition();\r\n\t\t\tthis._adjustPan();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetContent: function () {\r\n\t\treturn this._content;\r\n\t},\r\n\r\n\tsetContent: function (content) {\r\n\t\tthis._content = content;\r\n\t\tthis.update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\tupdate: function () {\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tthis._container.style.visibility = 'hidden';\r\n\r\n\t\tthis._updateContent();\r\n\t\tthis._updateLayout();\r\n\t\tthis._updatePosition();\r\n\r\n\t\tthis._container.style.visibility = '';\r\n\r\n\t\tthis._adjustPan();\r\n\t},\r\n\r\n\t_getEvents: function () {\r\n\t\tvar events = {\r\n\t\t\tviewreset: this._updatePosition\r\n\t\t};\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tevents.zoomanim = this._zoomAnimation;\r\n\t\t}\r\n\t\tif ('closeOnClick' in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) {\r\n\t\t\tevents.preclick = this._close;\r\n\t\t}\r\n\t\tif (this.options.keepInView) {\r\n\t\t\tevents.moveend = this._adjustPan;\r\n\t\t}\r\n\r\n\t\treturn events;\r\n\t},\r\n\r\n\t_close: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._map.closePopup(this);\r\n\t\t}\r\n\t},\r\n\r\n\t_initLayout: function () {\r\n\t\tvar prefix = 'leaflet-popup',\r\n\t\t\tcontainerClass = prefix + ' ' + this.options.className + ' leaflet-zoom-' +\r\n\t\t\t        (this._animated ? 'animated' : 'hide'),\r\n\t\t\tcontainer = this._container = L.DomUtil.create('div', containerClass),\r\n\t\t\tcloseButton;\r\n\r\n\t\tif (this.options.closeButton) {\r\n\t\t\tcloseButton = this._closeButton =\r\n\t\t\t        L.DomUtil.create('a', prefix + '-close-button', container);\r\n\t\t\tcloseButton.href = '#close';\r\n\t\t\tcloseButton.innerHTML = '&#215;';\r\n\t\t\tL.DomEvent.disableClickPropagation(closeButton);\r\n\r\n\t\t\tL.DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);\r\n\t\t}\r\n\r\n\t\tvar wrapper = this._wrapper =\r\n\t\t        L.DomUtil.create('div', prefix + '-content-wrapper', container);\r\n\t\tL.DomEvent.disableClickPropagation(wrapper);\r\n\r\n\t\tthis._contentNode = L.DomUtil.create('div', prefix + '-content', wrapper);\r\n\r\n\t\tL.DomEvent.disableScrollPropagation(this._contentNode);\r\n\t\tL.DomEvent.on(wrapper, 'contextmenu', L.DomEvent.stopPropagation);\r\n\r\n\t\tthis._tipContainer = L.DomUtil.create('div', prefix + '-tip-container', container);\r\n\t\tthis._tip = L.DomUtil.create('div', prefix + '-tip', this._tipContainer);\r\n\t},\r\n\r\n\t_updateContent: function () {\r\n\t\tif (!this._content) { return; }\r\n\r\n\t\tif (typeof this._content === 'string') {\r\n\t\t\tthis._contentNode.innerHTML = this._content;\r\n\t\t} else {\r\n\t\t\twhile (this._contentNode.hasChildNodes()) {\r\n\t\t\t\tthis._contentNode.removeChild(this._contentNode.firstChild);\r\n\t\t\t}\r\n\t\t\tthis._contentNode.appendChild(this._content);\r\n\t\t}\r\n\t\tthis.fire('contentupdate');\r\n\t},\r\n\r\n\t_updateLayout: function () {\r\n\t\tvar container = this._contentNode,\r\n\t\t    style = container.style;\r\n\r\n\t\tstyle.width = '';\r\n\t\tstyle.whiteSpace = 'nowrap';\r\n\r\n\t\tvar width = container.offsetWidth;\r\n\t\twidth = Math.min(width, this.options.maxWidth);\r\n\t\twidth = Math.max(width, this.options.minWidth);\r\n\r\n\t\tstyle.width = (width + 1) + 'px';\r\n\t\tstyle.whiteSpace = '';\r\n\r\n\t\tstyle.height = '';\r\n\r\n\t\tvar height = container.offsetHeight,\r\n\t\t    maxHeight = this.options.maxHeight,\r\n\t\t    scrolledClass = 'leaflet-popup-scrolled';\r\n\r\n\t\tif (maxHeight && height > maxHeight) {\r\n\t\t\tstyle.height = maxHeight + 'px';\r\n\t\t\tL.DomUtil.addClass(container, scrolledClass);\r\n\t\t} else {\r\n\t\t\tL.DomUtil.removeClass(container, scrolledClass);\r\n\t\t}\r\n\r\n\t\tthis._containerWidth = this._container.offsetWidth;\r\n\t},\r\n\r\n\t_updatePosition: function () {\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tvar pos = this._map.latLngToLayerPoint(this._latlng),\r\n\t\t    animated = this._animated,\r\n\t\t    offset = L.point(this.options.offset);\r\n\r\n\t\tif (animated) {\r\n\t\t\tL.DomUtil.setPosition(this._container, pos);\r\n\t\t}\r\n\r\n\t\tthis._containerBottom = -offset.y - (animated ? 0 : pos.y);\r\n\t\tthis._containerLeft = -Math.round(this._containerWidth / 2) + offset.x + (animated ? 0 : pos.x);\r\n\r\n\t\t// bottom position the popup in case the height of the popup changes (images loading etc)\r\n\t\tthis._container.style.bottom = this._containerBottom + 'px';\r\n\t\tthis._container.style.left = this._containerLeft + 'px';\r\n\t},\r\n\r\n\t_zoomAnimation: function (opt) {\r\n\t\tvar pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center);\r\n\r\n\t\tL.DomUtil.setPosition(this._container, pos);\r\n\t},\r\n\r\n\t_adjustPan: function () {\r\n\t\tif (!this.options.autoPan) { return; }\r\n\r\n\t\tvar map = this._map,\r\n\t\t    containerHeight = this._container.offsetHeight,\r\n\t\t    containerWidth = this._containerWidth,\r\n\r\n\t\t    layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tlayerPos._add(L.DomUtil.getPosition(this._container));\r\n\t\t}\r\n\r\n\t\tvar containerPos = map.layerPointToContainerPoint(layerPos),\r\n\t\t    padding = L.point(this.options.autoPanPadding),\r\n\t\t    paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),\r\n\t\t    paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),\r\n\t\t    size = map.getSize(),\r\n\t\t    dx = 0,\r\n\t\t    dy = 0;\r\n\r\n\t\tif (containerPos.x + containerWidth + paddingBR.x > size.x) { // right\r\n\t\t\tdx = containerPos.x + containerWidth - size.x + paddingBR.x;\r\n\t\t}\r\n\t\tif (containerPos.x - dx - paddingTL.x < 0) { // left\r\n\t\t\tdx = containerPos.x - paddingTL.x;\r\n\t\t}\r\n\t\tif (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom\r\n\t\t\tdy = containerPos.y + containerHeight - size.y + paddingBR.y;\r\n\t\t}\r\n\t\tif (containerPos.y - dy - paddingTL.y < 0) { // top\r\n\t\t\tdy = containerPos.y - paddingTL.y;\r\n\t\t}\r\n\r\n\t\tif (dx || dy) {\r\n\t\t\tmap\r\n\t\t\t    .fire('autopanstart')\r\n\t\t\t    .panBy([dx, dy]);\r\n\t\t}\r\n\t},\r\n\r\n\t_onCloseButtonClick: function (e) {\r\n\t\tthis._close();\r\n\t\tL.DomEvent.stop(e);\r\n\t}\r\n});\r\n\r\nL.popup = function (options, source) {\r\n\treturn new L.Popup(options, source);\r\n};\r\n\r\n\r\nL.Map.include({\r\n\topenPopup: function (popup, latlng, options) { // (Popup) or (String || HTMLElement, LatLng[, Object])\r\n\t\tthis.closePopup();\r\n\r\n\t\tif (!(popup instanceof L.Popup)) {\r\n\t\t\tvar content = popup;\r\n\r\n\t\t\tpopup = new L.Popup(options)\r\n\t\t\t    .setLatLng(latlng)\r\n\t\t\t    .setContent(content);\r\n\t\t}\r\n\t\tpopup._isOpen = true;\r\n\r\n\t\tthis._popup = popup;\r\n\t\treturn this.addLayer(popup);\r\n\t},\r\n\r\n\tclosePopup: function (popup) {\r\n\t\tif (!popup || popup === this._popup) {\r\n\t\t\tpopup = this._popup;\r\n\t\t\tthis._popup = null;\r\n\t\t}\r\n\t\tif (popup) {\r\n\t\t\tthis.removeLayer(popup);\r\n\t\t\tpopup._isOpen = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n});\r\n\n\n/*\r\n * Popup extension to L.Marker, adding popup-related methods.\r\n */\r\n\r\nL.Marker.include({\r\n\topenPopup: function () {\r\n\t\tif (this._popup && this._map && !this._map.hasLayer(this._popup)) {\r\n\t\t\tthis._popup.setLatLng(this._latlng);\r\n\t\t\tthis._map.openPopup(this._popup);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tclosePopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup._close();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\ttogglePopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tif (this._popup._isOpen) {\r\n\t\t\t\tthis.closePopup();\r\n\t\t\t} else {\r\n\t\t\t\tthis.openPopup();\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tbindPopup: function (content, options) {\r\n\t\tvar anchor = L.point(this.options.icon.options.popupAnchor || [0, 0]);\r\n\r\n\t\tanchor = anchor.add(L.Popup.prototype.options.offset);\r\n\r\n\t\tif (options && options.offset) {\r\n\t\t\tanchor = anchor.add(options.offset);\r\n\t\t}\r\n\r\n\t\toptions = L.extend({offset: anchor}, options);\r\n\r\n\t\tif (!this._popupHandlersAdded) {\r\n\t\t\tthis\r\n\t\t\t    .on('click', this.togglePopup, this)\r\n\t\t\t    .on('remove', this.closePopup, this)\r\n\t\t\t    .on('move', this._movePopup, this);\r\n\t\t\tthis._popupHandlersAdded = true;\r\n\t\t}\r\n\r\n\t\tif (content instanceof L.Popup) {\r\n\t\t\tL.setOptions(content, options);\r\n\t\t\tthis._popup = content;\r\n\t\t\tcontent._source = this;\r\n\t\t} else {\r\n\t\t\tthis._popup = new L.Popup(options, this)\r\n\t\t\t\t.setContent(content);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetPopupContent: function (content) {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup.setContent(content);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tunbindPopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup = null;\r\n\t\t\tthis\r\n\t\t\t    .off('click', this.togglePopup, this)\r\n\t\t\t    .off('remove', this.closePopup, this)\r\n\t\t\t    .off('move', this._movePopup, this);\r\n\t\t\tthis._popupHandlersAdded = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetPopup: function () {\r\n\t\treturn this._popup;\r\n\t},\r\n\r\n\t_movePopup: function (e) {\r\n\t\tthis._popup.setLatLng(e.latlng);\r\n\t}\r\n});\r\n\n\n/*\r\n * L.LayerGroup is a class to combine several layers into one so that\r\n * you can manipulate the group (e.g. add/remove it) as one layer.\r\n */\r\n\r\nL.LayerGroup = L.Class.extend({\r\n\tinitialize: function (layers) {\r\n\t\tthis._layers = {};\r\n\r\n\t\tvar i, len;\r\n\r\n\t\tif (layers) {\r\n\t\t\tfor (i = 0, len = layers.length; i < len; i++) {\r\n\t\t\t\tthis.addLayer(layers[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\taddLayer: function (layer) {\r\n\t\tvar id = this.getLayerId(layer);\r\n\r\n\t\tthis._layers[id] = layer;\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._map.addLayer(layer);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\t\tvar id = layer in this._layers ? layer : this.getLayerId(layer);\r\n\r\n\t\tif (this._map && this._layers[id]) {\r\n\t\t\tthis._map.removeLayer(this._layers[id]);\r\n\t\t}\r\n\r\n\t\tdelete this._layers[id];\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\thasLayer: function (layer) {\r\n\t\tif (!layer) { return false; }\r\n\r\n\t\treturn (layer in this._layers || this.getLayerId(layer) in this._layers);\r\n\t},\r\n\r\n\tclearLayers: function () {\r\n\t\tthis.eachLayer(this.removeLayer, this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tinvoke: function (methodName) {\r\n\t\tvar args = Array.prototype.slice.call(arguments, 1),\r\n\t\t    i, layer;\r\n\r\n\t\tfor (i in this._layers) {\r\n\t\t\tlayer = this._layers[i];\r\n\r\n\t\t\tif (layer[methodName]) {\r\n\t\t\t\tlayer[methodName].apply(layer, args);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\t\tthis.eachLayer(map.addLayer, map);\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tthis.eachLayer(map.removeLayer, map);\r\n\t\tthis._map = null;\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\teachLayer: function (method, context) {\r\n\t\tfor (var i in this._layers) {\r\n\t\t\tmethod.call(context, this._layers[i]);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetLayer: function (id) {\r\n\t\treturn this._layers[id];\r\n\t},\r\n\r\n\tgetLayers: function () {\r\n\t\tvar layers = [];\r\n\r\n\t\tfor (var i in this._layers) {\r\n\t\t\tlayers.push(this._layers[i]);\r\n\t\t}\r\n\t\treturn layers;\r\n\t},\r\n\r\n\tsetZIndex: function (zIndex) {\r\n\t\treturn this.invoke('setZIndex', zIndex);\r\n\t},\r\n\r\n\tgetLayerId: function (layer) {\r\n\t\treturn L.stamp(layer);\r\n\t}\r\n});\r\n\r\nL.layerGroup = function (layers) {\r\n\treturn new L.LayerGroup(layers);\r\n};\r\n\n\n/*\r\n * L.FeatureGroup extends L.LayerGroup by introducing mouse events and additional methods\r\n * shared between a group of interactive layers (like vectors or markers).\r\n */\r\n\r\nL.FeatureGroup = L.LayerGroup.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\tstatics: {\r\n\t\tEVENTS: 'click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose'\r\n\t},\r\n\r\n\taddLayer: function (layer) {\r\n\t\tif (this.hasLayer(layer)) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tif ('on' in layer) {\r\n\t\t\tlayer.on(L.FeatureGroup.EVENTS, this._propagateEvent, this);\r\n\t\t}\r\n\r\n\t\tL.LayerGroup.prototype.addLayer.call(this, layer);\r\n\r\n\t\tif (this._popupContent && layer.bindPopup) {\r\n\t\t\tlayer.bindPopup(this._popupContent, this._popupOptions);\r\n\t\t}\r\n\r\n\t\treturn this.fire('layeradd', {layer: layer});\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\t\tif (!this.hasLayer(layer)) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\tif (layer in this._layers) {\r\n\t\t\tlayer = this._layers[layer];\r\n\t\t}\r\n\r\n\t\tif ('off' in layer) {\r\n\t\t\tlayer.off(L.FeatureGroup.EVENTS, this._propagateEvent, this);\r\n\t\t}\r\n\r\n\t\tL.LayerGroup.prototype.removeLayer.call(this, layer);\r\n\r\n\t\tif (this._popupContent) {\r\n\t\t\tthis.invoke('unbindPopup');\r\n\t\t}\r\n\r\n\t\treturn this.fire('layerremove', {layer: layer});\r\n\t},\r\n\r\n\tbindPopup: function (content, options) {\r\n\t\tthis._popupContent = content;\r\n\t\tthis._popupOptions = options;\r\n\t\treturn this.invoke('bindPopup', content, options);\r\n\t},\r\n\r\n\topenPopup: function (latlng) {\r\n\t\t// open popup on the first layer\r\n\t\tfor (var id in this._layers) {\r\n\t\t\tthis._layers[id].openPopup(latlng);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetStyle: function (style) {\r\n\t\treturn this.invoke('setStyle', style);\r\n\t},\r\n\r\n\tbringToFront: function () {\r\n\t\treturn this.invoke('bringToFront');\r\n\t},\r\n\r\n\tbringToBack: function () {\r\n\t\treturn this.invoke('bringToBack');\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\tvar bounds = new L.LatLngBounds();\r\n\r\n\t\tthis.eachLayer(function (layer) {\r\n\t\t\tbounds.extend(layer instanceof L.Marker ? layer.getLatLng() : layer.getBounds());\r\n\t\t});\r\n\r\n\t\treturn bounds;\r\n\t},\r\n\r\n\t_propagateEvent: function (e) {\r\n\t\te = L.extend({\r\n\t\t\tlayer: e.target,\r\n\t\t\ttarget: this\r\n\t\t}, e);\r\n\t\tthis.fire(e.type, e);\r\n\t}\r\n});\r\n\r\nL.featureGroup = function (layers) {\r\n\treturn new L.FeatureGroup(layers);\r\n};\r\n\n\n/*\r\n * L.Path is a base class for rendering vector paths on a map. Inherited by Polyline, Circle, etc.\r\n */\r\n\r\nL.Path = L.Class.extend({\r\n\tincludes: [L.Mixin.Events],\r\n\r\n\tstatics: {\r\n\t\t// how much to extend the clip area around the map view\r\n\t\t// (relative to its size, e.g. 0.5 is half the screen in each direction)\r\n\t\t// set it so that SVG element doesn't exceed 1280px (vectors flicker on dragend if it is)\r\n\t\tCLIP_PADDING: (function () {\r\n\t\t\tvar max = L.Browser.mobile ? 1280 : 2000,\r\n\t\t\t    target = (max / Math.max(window.outerWidth, window.outerHeight) - 1) / 2;\r\n\t\t\treturn Math.max(0, Math.min(0.5, target));\r\n\t\t})()\r\n\t},\r\n\r\n\toptions: {\r\n\t\tstroke: true,\r\n\t\tcolor: '#0033ff',\r\n\t\tdashArray: null,\r\n\t\tlineCap: null,\r\n\t\tlineJoin: null,\r\n\t\tweight: 5,\r\n\t\topacity: 0.5,\r\n\r\n\t\tfill: false,\r\n\t\tfillColor: null, //same as color by default\r\n\t\tfillOpacity: 0.2,\r\n\r\n\t\tclickable: true\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tif (!this._container) {\r\n\t\t\tthis._initElements();\r\n\t\t\tthis._initEvents();\r\n\t\t}\r\n\r\n\t\tthis.projectLatlngs();\r\n\t\tthis._updatePath();\r\n\r\n\t\tif (this._container) {\r\n\t\t\tthis._map._pathRoot.appendChild(this._container);\r\n\t\t}\r\n\r\n\t\tthis.fire('add');\r\n\r\n\t\tmap.on({\r\n\t\t\t'viewreset': this.projectLatlngs,\r\n\t\t\t'moveend': this._updatePath\r\n\t\t}, this);\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap._pathRoot.removeChild(this._container);\r\n\r\n\t\t// Need to fire remove event before we set _map to null as the event hooks might need the object\r\n\t\tthis.fire('remove');\r\n\t\tthis._map = null;\r\n\r\n\t\tif (L.Browser.vml) {\r\n\t\t\tthis._container = null;\r\n\t\t\tthis._stroke = null;\r\n\t\t\tthis._fill = null;\r\n\t\t}\r\n\r\n\t\tmap.off({\r\n\t\t\t'viewreset': this.projectLatlngs,\r\n\t\t\t'moveend': this._updatePath\r\n\t\t}, this);\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\t// do all projection stuff here\r\n\t},\r\n\r\n\tsetStyle: function (style) {\r\n\t\tL.setOptions(this, style);\r\n\r\n\t\tif (this._container) {\r\n\t\t\tthis._updateStyle();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tredraw: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis.projectLatlngs();\r\n\t\t\tthis._updatePath();\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n});\r\n\r\nL.Map.include({\r\n\t_updatePathViewport: function () {\r\n\t\tvar p = L.Path.CLIP_PADDING,\r\n\t\t    size = this.getSize(),\r\n\t\t    panePos = L.DomUtil.getPosition(this._mapPane),\r\n\t\t    min = panePos.multiplyBy(-1)._subtract(size.multiplyBy(p)._round()),\r\n\t\t    max = min.add(size.multiplyBy(1 + p * 2)._round());\r\n\r\n\t\tthis._pathViewport = new L.Bounds(min, max);\r\n\t}\r\n});\r\n\n\n/*\r\n * Extends L.Path with SVG-specific rendering code.\r\n */\r\n\r\nL.Path.SVG_NS = 'http://www.w3.org/2000/svg';\r\n\r\nL.Browser.svg = !!(document.createElementNS && document.createElementNS(L.Path.SVG_NS, 'svg').createSVGRect);\r\n\r\nL.Path = L.Path.extend({\r\n\tstatics: {\r\n\t\tSVG: L.Browser.svg\r\n\t},\r\n\r\n\tbringToFront: function () {\r\n\t\tvar root = this._map._pathRoot,\r\n\t\t    path = this._container;\r\n\r\n\t\tif (path && root.lastChild !== path) {\r\n\t\t\troot.appendChild(path);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tbringToBack: function () {\r\n\t\tvar root = this._map._pathRoot,\r\n\t\t    path = this._container,\r\n\t\t    first = root.firstChild;\r\n\r\n\t\tif (path && first !== path) {\r\n\t\t\troot.insertBefore(path, first);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetPathString: function () {\r\n\t\t// form path string here\r\n\t},\r\n\r\n\t_createElement: function (name) {\r\n\t\treturn document.createElementNS(L.Path.SVG_NS, name);\r\n\t},\r\n\r\n\t_initElements: function () {\r\n\t\tthis._map._initPathRoot();\r\n\t\tthis._initPath();\r\n\t\tthis._initStyle();\r\n\t},\r\n\r\n\t_initPath: function () {\r\n\t\tthis._container = this._createElement('g');\r\n\r\n\t\tthis._path = this._createElement('path');\r\n\r\n\t\tif (this.options.className) {\r\n\t\t\tL.DomUtil.addClass(this._path, this.options.className);\r\n\t\t}\r\n\r\n\t\tthis._container.appendChild(this._path);\r\n\t},\r\n\r\n\t_initStyle: function () {\r\n\t\tif (this.options.stroke) {\r\n\t\t\tthis._path.setAttribute('stroke-linejoin', 'round');\r\n\t\t\tthis._path.setAttribute('stroke-linecap', 'round');\r\n\t\t}\r\n\t\tif (this.options.fill) {\r\n\t\t\tthis._path.setAttribute('fill-rule', 'evenodd');\r\n\t\t}\r\n\t\tif (this.options.pointerEvents) {\r\n\t\t\tthis._path.setAttribute('pointer-events', this.options.pointerEvents);\r\n\t\t}\r\n\t\tif (!this.options.clickable && !this.options.pointerEvents) {\r\n\t\t\tthis._path.setAttribute('pointer-events', 'none');\r\n\t\t}\r\n\t\tthis._updateStyle();\r\n\t},\r\n\r\n\t_updateStyle: function () {\r\n\t\tif (this.options.stroke) {\r\n\t\t\tthis._path.setAttribute('stroke', this.options.color);\r\n\t\t\tthis._path.setAttribute('stroke-opacity', this.options.opacity);\r\n\t\t\tthis._path.setAttribute('stroke-width', this.options.weight);\r\n\t\t\tif (this.options.dashArray) {\r\n\t\t\t\tthis._path.setAttribute('stroke-dasharray', this.options.dashArray);\r\n\t\t\t} else {\r\n\t\t\t\tthis._path.removeAttribute('stroke-dasharray');\r\n\t\t\t}\r\n\t\t\tif (this.options.lineCap) {\r\n\t\t\t\tthis._path.setAttribute('stroke-linecap', this.options.lineCap);\r\n\t\t\t}\r\n\t\t\tif (this.options.lineJoin) {\r\n\t\t\t\tthis._path.setAttribute('stroke-linejoin', this.options.lineJoin);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthis._path.setAttribute('stroke', 'none');\r\n\t\t}\r\n\t\tif (this.options.fill) {\r\n\t\t\tthis._path.setAttribute('fill', this.options.fillColor || this.options.color);\r\n\t\t\tthis._path.setAttribute('fill-opacity', this.options.fillOpacity);\r\n\t\t} else {\r\n\t\t\tthis._path.setAttribute('fill', 'none');\r\n\t\t}\r\n\t},\r\n\r\n\t_updatePath: function () {\r\n\t\tvar str = this.getPathString();\r\n\t\tif (!str) {\r\n\t\t\t// fix webkit empty string parsing bug\r\n\t\t\tstr = 'M0 0';\r\n\t\t}\r\n\t\tthis._path.setAttribute('d', str);\r\n\t},\r\n\r\n\t// TODO remove duplication with L.Map\r\n\t_initEvents: function () {\r\n\t\tif (this.options.clickable) {\r\n\t\t\tif (L.Browser.svg || !L.Browser.vml) {\r\n\t\t\t\tL.DomUtil.addClass(this._path, 'leaflet-clickable');\r\n\t\t\t}\r\n\r\n\t\t\tL.DomEvent.on(this._container, 'click', this._onMouseClick, this);\r\n\r\n\t\t\tvar events = ['dblclick', 'mousedown', 'mouseover',\r\n\t\t\t              'mouseout', 'mousemove', 'contextmenu'];\r\n\t\t\tfor (var i = 0; i < events.length; i++) {\r\n\t\t\t\tL.DomEvent.on(this._container, events[i], this._fireMouseEvent, this);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_onMouseClick: function (e) {\r\n\t\tif (this._map.dragging && this._map.dragging.moved()) { return; }\r\n\r\n\t\tthis._fireMouseEvent(e);\r\n\t},\r\n\r\n\t_fireMouseEvent: function (e) {\r\n\t\tif (!this._map || !this.hasEventListeners(e.type)) { return; }\r\n\r\n\t\tvar map = this._map,\r\n\t\t    containerPoint = map.mouseEventToContainerPoint(e),\r\n\t\t    layerPoint = map.containerPointToLayerPoint(containerPoint),\r\n\t\t    latlng = map.layerPointToLatLng(layerPoint);\r\n\r\n\t\tthis.fire(e.type, {\r\n\t\t\tlatlng: latlng,\r\n\t\t\tlayerPoint: layerPoint,\r\n\t\t\tcontainerPoint: containerPoint,\r\n\t\t\toriginalEvent: e\r\n\t\t});\r\n\r\n\t\tif (e.type === 'contextmenu') {\r\n\t\t\tL.DomEvent.preventDefault(e);\r\n\t\t}\r\n\t\tif (e.type !== 'mousemove') {\r\n\t\t\tL.DomEvent.stopPropagation(e);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Map.include({\r\n\t_initPathRoot: function () {\r\n\t\tif (!this._pathRoot) {\r\n\t\t\tthis._pathRoot = L.Path.prototype._createElement('svg');\r\n\t\t\tthis._panes.overlayPane.appendChild(this._pathRoot);\r\n\r\n\t\t\tif (this.options.zoomAnimation && L.Browser.any3d) {\r\n\t\t\t\tL.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-animated');\r\n\r\n\t\t\t\tthis.on({\r\n\t\t\t\t\t'zoomanim': this._animatePathZoom,\r\n\t\t\t\t\t'zoomend': this._endPathZoom\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tL.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-hide');\r\n\t\t\t}\r\n\r\n\t\t\tthis.on('moveend', this._updateSvgViewport);\r\n\t\t\tthis._updateSvgViewport();\r\n\t\t}\r\n\t},\r\n\r\n\t_animatePathZoom: function (e) {\r\n\t\tvar scale = this.getZoomScale(e.zoom),\r\n\t\t    offset = this._getCenterOffset(e.center)._multiplyBy(-scale)._add(this._pathViewport.min);\r\n\r\n\t\tthis._pathRoot.style[L.DomUtil.TRANSFORM] =\r\n\t\t        L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ') ';\r\n\r\n\t\tthis._pathZooming = true;\r\n\t},\r\n\r\n\t_endPathZoom: function () {\r\n\t\tthis._pathZooming = false;\r\n\t},\r\n\r\n\t_updateSvgViewport: function () {\r\n\r\n\t\tif (this._pathZooming) {\r\n\t\t\t// Do not update SVGs while a zoom animation is going on otherwise the animation will break.\r\n\t\t\t// When the zoom animation ends we will be updated again anyway\r\n\t\t\t// This fixes the case where you do a momentum move and zoom while the move is still ongoing.\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._updatePathViewport();\r\n\r\n\t\tvar vp = this._pathViewport,\r\n\t\t    min = vp.min,\r\n\t\t    max = vp.max,\r\n\t\t    width = max.x - min.x,\r\n\t\t    height = max.y - min.y,\r\n\t\t    root = this._pathRoot,\r\n\t\t    pane = this._panes.overlayPane;\r\n\r\n\t\t// Hack to make flicker on drag end on mobile webkit less irritating\r\n\t\tif (L.Browser.mobileWebkit) {\r\n\t\t\tpane.removeChild(root);\r\n\t\t}\r\n\r\n\t\tL.DomUtil.setPosition(root, min);\r\n\t\troot.setAttribute('width', width);\r\n\t\troot.setAttribute('height', height);\r\n\t\troot.setAttribute('viewBox', [min.x, min.y, width, height].join(' '));\r\n\r\n\t\tif (L.Browser.mobileWebkit) {\r\n\t\t\tpane.appendChild(root);\r\n\t\t}\r\n\t}\r\n});\r\n\n\n/*\r\n * Popup extension to L.Path (polylines, polygons, circles), adding popup-related methods.\r\n */\r\n\r\nL.Path.include({\r\n\r\n\tbindPopup: function (content, options) {\r\n\r\n\t\tif (content instanceof L.Popup) {\r\n\t\t\tthis._popup = content;\r\n\t\t} else {\r\n\t\t\tif (!this._popup || options) {\r\n\t\t\t\tthis._popup = new L.Popup(options, this);\r\n\t\t\t}\r\n\t\t\tthis._popup.setContent(content);\r\n\t\t}\r\n\r\n\t\tif (!this._popupHandlersAdded) {\r\n\t\t\tthis\r\n\t\t\t    .on('click', this._openPopup, this)\r\n\t\t\t    .on('remove', this.closePopup, this);\r\n\r\n\t\t\tthis._popupHandlersAdded = true;\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tunbindPopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup = null;\r\n\t\t\tthis\r\n\t\t\t    .off('click', this._openPopup)\r\n\t\t\t    .off('remove', this.closePopup);\r\n\r\n\t\t\tthis._popupHandlersAdded = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\topenPopup: function (latlng) {\r\n\r\n\t\tif (this._popup) {\r\n\t\t\t// open the popup from one of the path's points if not specified\r\n\t\t\tlatlng = latlng || this._latlng ||\r\n\t\t\t         this._latlngs[Math.floor(this._latlngs.length / 2)];\r\n\r\n\t\t\tthis._openPopup({latlng: latlng});\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tclosePopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup._close();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_openPopup: function (e) {\r\n\t\tthis._popup.setLatLng(e.latlng);\r\n\t\tthis._map.openPopup(this._popup);\r\n\t}\r\n});\r\n\n\n/*\r\n * Vector rendering for IE6-8 through VML.\r\n * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!\r\n */\r\n\r\nL.Browser.vml = !L.Browser.svg && (function () {\r\n\ttry {\r\n\t\tvar div = document.createElement('div');\r\n\t\tdiv.innerHTML = '<v:shape adj=\"1\"/>';\r\n\r\n\t\tvar shape = div.firstChild;\r\n\t\tshape.style.behavior = 'url(#default#VML)';\r\n\r\n\t\treturn shape && (typeof shape.adj === 'object');\r\n\r\n\t} catch (e) {\r\n\t\treturn false;\r\n\t}\r\n}());\r\n\r\nL.Path = L.Browser.svg || !L.Browser.vml ? L.Path : L.Path.extend({\r\n\tstatics: {\r\n\t\tVML: true,\r\n\t\tCLIP_PADDING: 0.02\r\n\t},\r\n\r\n\t_createElement: (function () {\r\n\t\ttry {\r\n\t\t\tdocument.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');\r\n\t\t\treturn function (name) {\r\n\t\t\t\treturn document.createElement('<lvml:' + name + ' class=\"lvml\">');\r\n\t\t\t};\r\n\t\t} catch (e) {\r\n\t\t\treturn function (name) {\r\n\t\t\t\treturn document.createElement(\r\n\t\t\t\t        '<' + name + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"lvml\">');\r\n\t\t\t};\r\n\t\t}\r\n\t}()),\r\n\r\n\t_initPath: function () {\r\n\t\tvar container = this._container = this._createElement('shape');\r\n\r\n\t\tL.DomUtil.addClass(container, 'leaflet-vml-shape' +\r\n\t\t\t(this.options.className ? ' ' + this.options.className : ''));\r\n\r\n\t\tif (this.options.clickable) {\r\n\t\t\tL.DomUtil.addClass(container, 'leaflet-clickable');\r\n\t\t}\r\n\r\n\t\tcontainer.coordsize = '1 1';\r\n\r\n\t\tthis._path = this._createElement('path');\r\n\t\tcontainer.appendChild(this._path);\r\n\r\n\t\tthis._map._pathRoot.appendChild(container);\r\n\t},\r\n\r\n\t_initStyle: function () {\r\n\t\tthis._updateStyle();\r\n\t},\r\n\r\n\t_updateStyle: function () {\r\n\t\tvar stroke = this._stroke,\r\n\t\t    fill = this._fill,\r\n\t\t    options = this.options,\r\n\t\t    container = this._container;\r\n\r\n\t\tcontainer.stroked = options.stroke;\r\n\t\tcontainer.filled = options.fill;\r\n\r\n\t\tif (options.stroke) {\r\n\t\t\tif (!stroke) {\r\n\t\t\t\tstroke = this._stroke = this._createElement('stroke');\r\n\t\t\t\tstroke.endcap = 'round';\r\n\t\t\t\tcontainer.appendChild(stroke);\r\n\t\t\t}\r\n\t\t\tstroke.weight = options.weight + 'px';\r\n\t\t\tstroke.color = options.color;\r\n\t\t\tstroke.opacity = options.opacity;\r\n\r\n\t\t\tif (options.dashArray) {\r\n\t\t\t\tstroke.dashStyle = L.Util.isArray(options.dashArray) ?\r\n\t\t\t\t    options.dashArray.join(' ') :\r\n\t\t\t\t    options.dashArray.replace(/( *, *)/g, ' ');\r\n\t\t\t} else {\r\n\t\t\t\tstroke.dashStyle = '';\r\n\t\t\t}\r\n\t\t\tif (options.lineCap) {\r\n\t\t\t\tstroke.endcap = options.lineCap.replace('butt', 'flat');\r\n\t\t\t}\r\n\t\t\tif (options.lineJoin) {\r\n\t\t\t\tstroke.joinstyle = options.lineJoin;\r\n\t\t\t}\r\n\r\n\t\t} else if (stroke) {\r\n\t\t\tcontainer.removeChild(stroke);\r\n\t\t\tthis._stroke = null;\r\n\t\t}\r\n\r\n\t\tif (options.fill) {\r\n\t\t\tif (!fill) {\r\n\t\t\t\tfill = this._fill = this._createElement('fill');\r\n\t\t\t\tcontainer.appendChild(fill);\r\n\t\t\t}\r\n\t\t\tfill.color = options.fillColor || options.color;\r\n\t\t\tfill.opacity = options.fillOpacity;\r\n\r\n\t\t} else if (fill) {\r\n\t\t\tcontainer.removeChild(fill);\r\n\t\t\tthis._fill = null;\r\n\t\t}\r\n\t},\r\n\r\n\t_updatePath: function () {\r\n\t\tvar style = this._container.style;\r\n\r\n\t\tstyle.display = 'none';\r\n\t\tthis._path.v = this.getPathString() + ' '; // the space fixes IE empty path string bug\r\n\t\tstyle.display = '';\r\n\t}\r\n});\r\n\r\nL.Map.include(L.Browser.svg || !L.Browser.vml ? {} : {\r\n\t_initPathRoot: function () {\r\n\t\tif (this._pathRoot) { return; }\r\n\r\n\t\tvar root = this._pathRoot = document.createElement('div');\r\n\t\troot.className = 'leaflet-vml-container';\r\n\t\tthis._panes.overlayPane.appendChild(root);\r\n\r\n\t\tthis.on('moveend', this._updatePathViewport);\r\n\t\tthis._updatePathViewport();\r\n\t}\r\n});\r\n\n\n/*\r\n * Vector rendering for all browsers that support canvas.\r\n */\r\n\r\nL.Browser.canvas = (function () {\r\n\treturn !!document.createElement('canvas').getContext;\r\n}());\r\n\r\nL.Path = (L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? L.Path : L.Path.extend({\r\n\tstatics: {\r\n\t\t//CLIP_PADDING: 0.02, // not sure if there's a need to set it to a small value\r\n\t\tCANVAS: true,\r\n\t\tSVG: false\r\n\t},\r\n\r\n\tredraw: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis.projectLatlngs();\r\n\t\t\tthis._requestUpdate();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetStyle: function (style) {\r\n\t\tL.setOptions(this, style);\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._updateStyle();\r\n\t\t\tthis._requestUpdate();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap\r\n\t\t    .off('viewreset', this.projectLatlngs, this)\r\n\t\t    .off('moveend', this._updatePath, this);\r\n\r\n\t\tif (this.options.clickable) {\r\n\t\t\tthis._map.off('click', this._onClick, this);\r\n\t\t\tthis._map.off('mousemove', this._onMouseMove, this);\r\n\t\t}\r\n\r\n\t\tthis._requestUpdate();\r\n\t\t\r\n\t\tthis.fire('remove');\r\n\t\tthis._map = null;\r\n\t},\r\n\r\n\t_requestUpdate: function () {\r\n\t\tif (this._map && !L.Path._updateRequest) {\r\n\t\t\tL.Path._updateRequest = L.Util.requestAnimFrame(this._fireMapMoveEnd, this._map);\r\n\t\t}\r\n\t},\r\n\r\n\t_fireMapMoveEnd: function () {\r\n\t\tL.Path._updateRequest = null;\r\n\t\tthis.fire('moveend');\r\n\t},\r\n\r\n\t_initElements: function () {\r\n\t\tthis._map._initPathRoot();\r\n\t\tthis._ctx = this._map._canvasCtx;\r\n\t},\r\n\r\n\t_updateStyle: function () {\r\n\t\tvar options = this.options;\r\n\r\n\t\tif (options.stroke) {\r\n\t\t\tthis._ctx.lineWidth = options.weight;\r\n\t\t\tthis._ctx.strokeStyle = options.color;\r\n\t\t}\r\n\t\tif (options.fill) {\r\n\t\t\tthis._ctx.fillStyle = options.fillColor || options.color;\r\n\t\t}\r\n\r\n\t\tif (options.lineCap) {\r\n\t\t\tthis._ctx.lineCap = options.lineCap;\r\n\t\t}\r\n\t\tif (options.lineJoin) {\r\n\t\t\tthis._ctx.lineJoin = options.lineJoin;\r\n\t\t}\r\n\t},\r\n\r\n\t_drawPath: function () {\r\n\t\tvar i, j, len, len2, point, drawMethod;\r\n\r\n\t\tthis._ctx.beginPath();\r\n\r\n\t\tfor (i = 0, len = this._parts.length; i < len; i++) {\r\n\t\t\tfor (j = 0, len2 = this._parts[i].length; j < len2; j++) {\r\n\t\t\t\tpoint = this._parts[i][j];\r\n\t\t\t\tdrawMethod = (j === 0 ? 'move' : 'line') + 'To';\r\n\r\n\t\t\t\tthis._ctx[drawMethod](point.x, point.y);\r\n\t\t\t}\r\n\t\t\t// TODO refactor ugly hack\r\n\t\t\tif (this instanceof L.Polygon) {\r\n\t\t\t\tthis._ctx.closePath();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_checkIfEmpty: function () {\r\n\t\treturn !this._parts.length;\r\n\t},\r\n\r\n\t_updatePath: function () {\r\n\t\tif (this._checkIfEmpty()) { return; }\r\n\r\n\t\tvar ctx = this._ctx,\r\n\t\t    options = this.options;\r\n\r\n\t\tthis._drawPath();\r\n\t\tctx.save();\r\n\t\tthis._updateStyle();\r\n\r\n\t\tif (options.fill) {\r\n\t\t\tctx.globalAlpha = options.fillOpacity;\r\n\t\t\tctx.fill(options.fillRule || 'evenodd');\r\n\t\t}\r\n\r\n\t\tif (options.stroke) {\r\n\t\t\tctx.globalAlpha = options.opacity;\r\n\t\t\tctx.stroke();\r\n\t\t}\r\n\r\n\t\tctx.restore();\r\n\r\n\t\t// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature\r\n\t},\r\n\r\n\t_initEvents: function () {\r\n\t\tif (this.options.clickable) {\r\n\t\t\tthis._map.on('mousemove', this._onMouseMove, this);\r\n\t\t\tthis._map.on('click dblclick contextmenu', this._fireMouseEvent, this);\r\n\t\t}\r\n\t},\r\n\r\n\t_fireMouseEvent: function (e) {\r\n\t\tif (this._containsPoint(e.layerPoint)) {\r\n\t\t\tthis.fire(e.type, e);\r\n\t\t}\r\n\t},\r\n\r\n\t_onMouseMove: function (e) {\r\n\t\tif (!this._map || this._map._animatingZoom) { return; }\r\n\r\n\t\t// TODO don't do on each move\r\n\t\tif (this._containsPoint(e.layerPoint)) {\r\n\t\t\tthis._ctx.canvas.style.cursor = 'pointer';\r\n\t\t\tthis._mouseInside = true;\r\n\t\t\tthis.fire('mouseover', e);\r\n\r\n\t\t} else if (this._mouseInside) {\r\n\t\t\tthis._ctx.canvas.style.cursor = '';\r\n\t\t\tthis._mouseInside = false;\r\n\t\t\tthis.fire('mouseout', e);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Map.include((L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? {} : {\r\n\t_initPathRoot: function () {\r\n\t\tvar root = this._pathRoot,\r\n\t\t    ctx;\r\n\r\n\t\tif (!root) {\r\n\t\t\troot = this._pathRoot = document.createElement('canvas');\r\n\t\t\troot.style.position = 'absolute';\r\n\t\t\tctx = this._canvasCtx = root.getContext('2d');\r\n\r\n\t\t\tctx.lineCap = 'round';\r\n\t\t\tctx.lineJoin = 'round';\r\n\r\n\t\t\tthis._panes.overlayPane.appendChild(root);\r\n\r\n\t\t\tif (this.options.zoomAnimation) {\r\n\t\t\t\tthis._pathRoot.className = 'leaflet-zoom-animated';\r\n\t\t\t\tthis.on('zoomanim', this._animatePathZoom);\r\n\t\t\t\tthis.on('zoomend', this._endPathZoom);\r\n\t\t\t}\r\n\t\t\tthis.on('moveend', this._updateCanvasViewport);\r\n\t\t\tthis._updateCanvasViewport();\r\n\t\t}\r\n\t},\r\n\r\n\t_updateCanvasViewport: function () {\r\n\t\t// don't redraw while zooming. See _updateSvgViewport for more details\r\n\t\tif (this._pathZooming) { return; }\r\n\t\tthis._updatePathViewport();\r\n\r\n\t\tvar vp = this._pathViewport,\r\n\t\t    min = vp.min,\r\n\t\t    size = vp.max.subtract(min),\r\n\t\t    root = this._pathRoot;\r\n\r\n\t\t//TODO check if this works properly on mobile webkit\r\n\t\tL.DomUtil.setPosition(root, min);\r\n\t\troot.width = size.x;\r\n\t\troot.height = size.y;\r\n\t\troot.getContext('2d').translate(-min.x, -min.y);\r\n\t}\r\n});\r\n\n\n/*\r\n * L.LineUtil contains different utility functions for line segments\r\n * and polylines (clipping, simplification, distances, etc.)\r\n */\r\n\r\n/*jshint bitwise:false */ // allow bitwise operations for this file\r\n\r\nL.LineUtil = {\r\n\r\n\t// Simplify polyline with vertex reduction and Douglas-Peucker simplification.\r\n\t// Improves rendering performance dramatically by lessening the number of points to draw.\r\n\r\n\tsimplify: function (/*Point[]*/ points, /*Number*/ tolerance) {\r\n\t\tif (!tolerance || !points.length) {\r\n\t\t\treturn points.slice();\r\n\t\t}\r\n\r\n\t\tvar sqTolerance = tolerance * tolerance;\r\n\r\n\t\t// stage 1: vertex reduction\r\n\t\tpoints = this._reducePoints(points, sqTolerance);\r\n\r\n\t\t// stage 2: Douglas-Peucker simplification\r\n\t\tpoints = this._simplifyDP(points, sqTolerance);\r\n\r\n\t\treturn points;\r\n\t},\r\n\r\n\t// distance from a point to a segment between two points\r\n\tpointToSegmentDistance:  function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {\r\n\t\treturn Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));\r\n\t},\r\n\r\n\tclosestPointOnSegment: function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {\r\n\t\treturn this._sqClosestPointOnSegment(p, p1, p2);\r\n\t},\r\n\r\n\t// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm\r\n\t_simplifyDP: function (points, sqTolerance) {\r\n\r\n\t\tvar len = points.length,\r\n\t\t    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,\r\n\t\t    markers = new ArrayConstructor(len);\r\n\r\n\t\tmarkers[0] = markers[len - 1] = 1;\r\n\r\n\t\tthis._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);\r\n\r\n\t\tvar i,\r\n\t\t    newPoints = [];\r\n\r\n\t\tfor (i = 0; i < len; i++) {\r\n\t\t\tif (markers[i]) {\r\n\t\t\t\tnewPoints.push(points[i]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn newPoints;\r\n\t},\r\n\r\n\t_simplifyDPStep: function (points, markers, sqTolerance, first, last) {\r\n\r\n\t\tvar maxSqDist = 0,\r\n\t\t    index, i, sqDist;\r\n\r\n\t\tfor (i = first + 1; i <= last - 1; i++) {\r\n\t\t\tsqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);\r\n\r\n\t\t\tif (sqDist > maxSqDist) {\r\n\t\t\t\tindex = i;\r\n\t\t\t\tmaxSqDist = sqDist;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (maxSqDist > sqTolerance) {\r\n\t\t\tmarkers[index] = 1;\r\n\r\n\t\t\tthis._simplifyDPStep(points, markers, sqTolerance, first, index);\r\n\t\t\tthis._simplifyDPStep(points, markers, sqTolerance, index, last);\r\n\t\t}\r\n\t},\r\n\r\n\t// reduce points that are too close to each other to a single point\r\n\t_reducePoints: function (points, sqTolerance) {\r\n\t\tvar reducedPoints = [points[0]];\r\n\r\n\t\tfor (var i = 1, prev = 0, len = points.length; i < len; i++) {\r\n\t\t\tif (this._sqDist(points[i], points[prev]) > sqTolerance) {\r\n\t\t\t\treducedPoints.push(points[i]);\r\n\t\t\t\tprev = i;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (prev < len - 1) {\r\n\t\t\treducedPoints.push(points[len - 1]);\r\n\t\t}\r\n\t\treturn reducedPoints;\r\n\t},\r\n\r\n\t// Cohen-Sutherland line clipping algorithm.\r\n\t// Used to avoid rendering parts of a polyline that are not currently visible.\r\n\r\n\tclipSegment: function (a, b, bounds, useLastCode) {\r\n\t\tvar codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds),\r\n\t\t    codeB = this._getBitCode(b, bounds),\r\n\r\n\t\t    codeOut, p, newCode;\r\n\r\n\t\t// save 2nd code to avoid calculating it on the next segment\r\n\t\tthis._lastCode = codeB;\r\n\r\n\t\twhile (true) {\r\n\t\t\t// if a,b is inside the clip window (trivial accept)\r\n\t\t\tif (!(codeA | codeB)) {\r\n\t\t\t\treturn [a, b];\r\n\t\t\t// if a,b is outside the clip window (trivial reject)\r\n\t\t\t} else if (codeA & codeB) {\r\n\t\t\t\treturn false;\r\n\t\t\t// other cases\r\n\t\t\t} else {\r\n\t\t\t\tcodeOut = codeA || codeB;\r\n\t\t\t\tp = this._getEdgeIntersection(a, b, codeOut, bounds);\r\n\t\t\t\tnewCode = this._getBitCode(p, bounds);\r\n\r\n\t\t\t\tif (codeOut === codeA) {\r\n\t\t\t\t\ta = p;\r\n\t\t\t\t\tcodeA = newCode;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tb = p;\r\n\t\t\t\t\tcodeB = newCode;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_getEdgeIntersection: function (a, b, code, bounds) {\r\n\t\tvar dx = b.x - a.x,\r\n\t\t    dy = b.y - a.y,\r\n\t\t    min = bounds.min,\r\n\t\t    max = bounds.max;\r\n\r\n\t\tif (code & 8) { // top\r\n\t\t\treturn new L.Point(a.x + dx * (max.y - a.y) / dy, max.y);\r\n\t\t} else if (code & 4) { // bottom\r\n\t\t\treturn new L.Point(a.x + dx * (min.y - a.y) / dy, min.y);\r\n\t\t} else if (code & 2) { // right\r\n\t\t\treturn new L.Point(max.x, a.y + dy * (max.x - a.x) / dx);\r\n\t\t} else if (code & 1) { // left\r\n\t\t\treturn new L.Point(min.x, a.y + dy * (min.x - a.x) / dx);\r\n\t\t}\r\n\t},\r\n\r\n\t_getBitCode: function (/*Point*/ p, bounds) {\r\n\t\tvar code = 0;\r\n\r\n\t\tif (p.x < bounds.min.x) { // left\r\n\t\t\tcode |= 1;\r\n\t\t} else if (p.x > bounds.max.x) { // right\r\n\t\t\tcode |= 2;\r\n\t\t}\r\n\t\tif (p.y < bounds.min.y) { // bottom\r\n\t\t\tcode |= 4;\r\n\t\t} else if (p.y > bounds.max.y) { // top\r\n\t\t\tcode |= 8;\r\n\t\t}\r\n\r\n\t\treturn code;\r\n\t},\r\n\r\n\t// square distance (to avoid unnecessary Math.sqrt calls)\r\n\t_sqDist: function (p1, p2) {\r\n\t\tvar dx = p2.x - p1.x,\r\n\t\t    dy = p2.y - p1.y;\r\n\t\treturn dx * dx + dy * dy;\r\n\t},\r\n\r\n\t// return closest point on segment or distance to that point\r\n\t_sqClosestPointOnSegment: function (p, p1, p2, sqDist) {\r\n\t\tvar x = p1.x,\r\n\t\t    y = p1.y,\r\n\t\t    dx = p2.x - x,\r\n\t\t    dy = p2.y - y,\r\n\t\t    dot = dx * dx + dy * dy,\r\n\t\t    t;\r\n\r\n\t\tif (dot > 0) {\r\n\t\t\tt = ((p.x - x) * dx + (p.y - y) * dy) / dot;\r\n\r\n\t\t\tif (t > 1) {\r\n\t\t\t\tx = p2.x;\r\n\t\t\t\ty = p2.y;\r\n\t\t\t} else if (t > 0) {\r\n\t\t\t\tx += dx * t;\r\n\t\t\t\ty += dy * t;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tdx = p.x - x;\r\n\t\tdy = p.y - y;\r\n\r\n\t\treturn sqDist ? dx * dx + dy * dy : new L.Point(x, y);\r\n\t}\r\n};\r\n\n\n/*\r\n * L.Polyline is used to display polylines on a map.\r\n */\r\n\r\nL.Polyline = L.Path.extend({\r\n\tinitialize: function (latlngs, options) {\r\n\t\tL.Path.prototype.initialize.call(this, options);\r\n\r\n\t\tthis._latlngs = this._convertLatLngs(latlngs);\r\n\t},\r\n\r\n\toptions: {\r\n\t\t// how much to simplify the polyline on each zoom level\r\n\t\t// more = better performance and smoother look, less = more accurate\r\n\t\tsmoothFactor: 1.0,\r\n\t\tnoClip: false\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\tthis._originalPoints = [];\r\n\r\n\t\tfor (var i = 0, len = this._latlngs.length; i < len; i++) {\r\n\t\t\tthis._originalPoints[i] = this._map.latLngToLayerPoint(this._latlngs[i]);\r\n\t\t}\r\n\t},\r\n\r\n\tgetPathString: function () {\r\n\t\tfor (var i = 0, len = this._parts.length, str = ''; i < len; i++) {\r\n\t\t\tstr += this._getPathPartStr(this._parts[i]);\r\n\t\t}\r\n\t\treturn str;\r\n\t},\r\n\r\n\tgetLatLngs: function () {\r\n\t\treturn this._latlngs;\r\n\t},\r\n\r\n\tsetLatLngs: function (latlngs) {\r\n\t\tthis._latlngs = this._convertLatLngs(latlngs);\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\taddLatLng: function (latlng) {\r\n\t\tthis._latlngs.push(L.latLng(latlng));\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\tspliceLatLngs: function () { // (Number index, Number howMany)\r\n\t\tvar removed = [].splice.apply(this._latlngs, arguments);\r\n\t\tthis._convertLatLngs(this._latlngs, true);\r\n\t\tthis.redraw();\r\n\t\treturn removed;\r\n\t},\r\n\r\n\tclosestLayerPoint: function (p) {\r\n\t\tvar minDistance = Infinity, parts = this._parts, p1, p2, minPoint = null;\r\n\r\n\t\tfor (var j = 0, jLen = parts.length; j < jLen; j++) {\r\n\t\t\tvar points = parts[j];\r\n\t\t\tfor (var i = 1, len = points.length; i < len; i++) {\r\n\t\t\t\tp1 = points[i - 1];\r\n\t\t\t\tp2 = points[i];\r\n\t\t\t\tvar sqDist = L.LineUtil._sqClosestPointOnSegment(p, p1, p2, true);\r\n\t\t\t\tif (sqDist < minDistance) {\r\n\t\t\t\t\tminDistance = sqDist;\r\n\t\t\t\t\tminPoint = L.LineUtil._sqClosestPointOnSegment(p, p1, p2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (minPoint) {\r\n\t\t\tminPoint.distance = Math.sqrt(minDistance);\r\n\t\t}\r\n\t\treturn minPoint;\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\treturn new L.LatLngBounds(this.getLatLngs());\r\n\t},\r\n\r\n\t_convertLatLngs: function (latlngs, overwrite) {\r\n\t\tvar i, len, target = overwrite ? latlngs : [];\r\n\r\n\t\tfor (i = 0, len = latlngs.length; i < len; i++) {\r\n\t\t\tif (L.Util.isArray(latlngs[i]) && typeof latlngs[i][0] !== 'number') {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\ttarget[i] = L.latLng(latlngs[i]);\r\n\t\t}\r\n\t\treturn target;\r\n\t},\r\n\r\n\t_initEvents: function () {\r\n\t\tL.Path.prototype._initEvents.call(this);\r\n\t},\r\n\r\n\t_getPathPartStr: function (points) {\r\n\t\tvar round = L.Path.VML;\r\n\r\n\t\tfor (var j = 0, len2 = points.length, str = '', p; j < len2; j++) {\r\n\t\t\tp = points[j];\r\n\t\t\tif (round) {\r\n\t\t\t\tp._round();\r\n\t\t\t}\r\n\t\t\tstr += (j ? 'L' : 'M') + p.x + ' ' + p.y;\r\n\t\t}\r\n\t\treturn str;\r\n\t},\r\n\r\n\t_clipPoints: function () {\r\n\t\tvar points = this._originalPoints,\r\n\t\t    len = points.length,\r\n\t\t    i, k, segment;\r\n\r\n\t\tif (this.options.noClip) {\r\n\t\t\tthis._parts = [points];\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._parts = [];\r\n\r\n\t\tvar parts = this._parts,\r\n\t\t    vp = this._map._pathViewport,\r\n\t\t    lu = L.LineUtil;\r\n\r\n\t\tfor (i = 0, k = 0; i < len - 1; i++) {\r\n\t\t\tsegment = lu.clipSegment(points[i], points[i + 1], vp, i);\r\n\t\t\tif (!segment) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tparts[k] = parts[k] || [];\r\n\t\t\tparts[k].push(segment[0]);\r\n\r\n\t\t\t// if segment goes out of screen, or it's the last one, it's the end of the line part\r\n\t\t\tif ((segment[1] !== points[i + 1]) || (i === len - 2)) {\r\n\t\t\t\tparts[k].push(segment[1]);\r\n\t\t\t\tk++;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t// simplify each clipped part of the polyline\r\n\t_simplifyPoints: function () {\r\n\t\tvar parts = this._parts,\r\n\t\t    lu = L.LineUtil;\r\n\r\n\t\tfor (var i = 0, len = parts.length; i < len; i++) {\r\n\t\t\tparts[i] = lu.simplify(parts[i], this.options.smoothFactor);\r\n\t\t}\r\n\t},\r\n\r\n\t_updatePath: function () {\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tthis._clipPoints();\r\n\t\tthis._simplifyPoints();\r\n\r\n\t\tL.Path.prototype._updatePath.call(this);\r\n\t}\r\n});\r\n\r\nL.polyline = function (latlngs, options) {\r\n\treturn new L.Polyline(latlngs, options);\r\n};\r\n\n\n/*\r\n * L.PolyUtil contains utility functions for polygons (clipping, etc.).\r\n */\r\n\r\n/*jshint bitwise:false */ // allow bitwise operations here\r\n\r\nL.PolyUtil = {};\r\n\r\n/*\r\n * Sutherland-Hodgeman polygon clipping algorithm.\r\n * Used to avoid rendering parts of a polygon that are not currently visible.\r\n */\r\nL.PolyUtil.clipPolygon = function (points, bounds) {\r\n\tvar clippedPoints,\r\n\t    edges = [1, 4, 2, 8],\r\n\t    i, j, k,\r\n\t    a, b,\r\n\t    len, edge, p,\r\n\t    lu = L.LineUtil;\r\n\r\n\tfor (i = 0, len = points.length; i < len; i++) {\r\n\t\tpoints[i]._code = lu._getBitCode(points[i], bounds);\r\n\t}\r\n\r\n\t// for each edge (left, bottom, right, top)\r\n\tfor (k = 0; k < 4; k++) {\r\n\t\tedge = edges[k];\r\n\t\tclippedPoints = [];\r\n\r\n\t\tfor (i = 0, len = points.length, j = len - 1; i < len; j = i++) {\r\n\t\t\ta = points[i];\r\n\t\t\tb = points[j];\r\n\r\n\t\t\t// if a is inside the clip window\r\n\t\t\tif (!(a._code & edge)) {\r\n\t\t\t\t// if b is outside the clip window (a->b goes out of screen)\r\n\t\t\t\tif (b._code & edge) {\r\n\t\t\t\t\tp = lu._getEdgeIntersection(b, a, edge, bounds);\r\n\t\t\t\t\tp._code = lu._getBitCode(p, bounds);\r\n\t\t\t\t\tclippedPoints.push(p);\r\n\t\t\t\t}\r\n\t\t\t\tclippedPoints.push(a);\r\n\r\n\t\t\t// else if b is inside the clip window (a->b enters the screen)\r\n\t\t\t} else if (!(b._code & edge)) {\r\n\t\t\t\tp = lu._getEdgeIntersection(b, a, edge, bounds);\r\n\t\t\t\tp._code = lu._getBitCode(p, bounds);\r\n\t\t\t\tclippedPoints.push(p);\r\n\t\t\t}\r\n\t\t}\r\n\t\tpoints = clippedPoints;\r\n\t}\r\n\r\n\treturn points;\r\n};\r\n\n\n/*\r\n * L.Polygon is used to display polygons on a map.\r\n */\r\n\r\nL.Polygon = L.Polyline.extend({\r\n\toptions: {\r\n\t\tfill: true\r\n\t},\r\n\r\n\tinitialize: function (latlngs, options) {\r\n\t\tL.Polyline.prototype.initialize.call(this, latlngs, options);\r\n\t\tthis._initWithHoles(latlngs);\r\n\t},\r\n\r\n\t_initWithHoles: function (latlngs) {\r\n\t\tvar i, len, hole;\r\n\t\tif (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {\r\n\t\t\tthis._latlngs = this._convertLatLngs(latlngs[0]);\r\n\t\t\tthis._holes = latlngs.slice(1);\r\n\r\n\t\t\tfor (i = 0, len = this._holes.length; i < len; i++) {\r\n\t\t\t\thole = this._holes[i] = this._convertLatLngs(this._holes[i]);\r\n\t\t\t\tif (hole[0].equals(hole[hole.length - 1])) {\r\n\t\t\t\t\thole.pop();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// filter out last point if its equal to the first one\r\n\t\tlatlngs = this._latlngs;\r\n\r\n\t\tif (latlngs.length >= 2 && latlngs[0].equals(latlngs[latlngs.length - 1])) {\r\n\t\t\tlatlngs.pop();\r\n\t\t}\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\tL.Polyline.prototype.projectLatlngs.call(this);\r\n\r\n\t\t// project polygon holes points\r\n\t\t// TODO move this logic to Polyline to get rid of duplication\r\n\t\tthis._holePoints = [];\r\n\r\n\t\tif (!this._holes) { return; }\r\n\r\n\t\tvar i, j, len, len2;\r\n\r\n\t\tfor (i = 0, len = this._holes.length; i < len; i++) {\r\n\t\t\tthis._holePoints[i] = [];\r\n\r\n\t\t\tfor (j = 0, len2 = this._holes[i].length; j < len2; j++) {\r\n\t\t\t\tthis._holePoints[i][j] = this._map.latLngToLayerPoint(this._holes[i][j]);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tsetLatLngs: function (latlngs) {\r\n\t\tif (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {\r\n\t\t\tthis._initWithHoles(latlngs);\r\n\t\t\treturn this.redraw();\r\n\t\t} else {\r\n\t\t\treturn L.Polyline.prototype.setLatLngs.call(this, latlngs);\r\n\t\t}\r\n\t},\r\n\r\n\t_clipPoints: function () {\r\n\t\tvar points = this._originalPoints,\r\n\t\t    newParts = [];\r\n\r\n\t\tthis._parts = [points].concat(this._holePoints);\r\n\r\n\t\tif (this.options.noClip) { return; }\r\n\r\n\t\tfor (var i = 0, len = this._parts.length; i < len; i++) {\r\n\t\t\tvar clipped = L.PolyUtil.clipPolygon(this._parts[i], this._map._pathViewport);\r\n\t\t\tif (clipped.length) {\r\n\t\t\t\tnewParts.push(clipped);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._parts = newParts;\r\n\t},\r\n\r\n\t_getPathPartStr: function (points) {\r\n\t\tvar str = L.Polyline.prototype._getPathPartStr.call(this, points);\r\n\t\treturn str + (L.Browser.svg ? 'z' : 'x');\r\n\t}\r\n});\r\n\r\nL.polygon = function (latlngs, options) {\r\n\treturn new L.Polygon(latlngs, options);\r\n};\r\n\n\n/*\r\n * Contains L.MultiPolyline and L.MultiPolygon layers.\r\n */\r\n\r\n(function () {\r\n\tfunction createMulti(Klass) {\r\n\r\n\t\treturn L.FeatureGroup.extend({\r\n\r\n\t\t\tinitialize: function (latlngs, options) {\r\n\t\t\t\tthis._layers = {};\r\n\t\t\t\tthis._options = options;\r\n\t\t\t\tthis.setLatLngs(latlngs);\r\n\t\t\t},\r\n\r\n\t\t\tsetLatLngs: function (latlngs) {\r\n\t\t\t\tvar i = 0,\r\n\t\t\t\t    len = latlngs.length;\r\n\r\n\t\t\t\tthis.eachLayer(function (layer) {\r\n\t\t\t\t\tif (i < len) {\r\n\t\t\t\t\t\tlayer.setLatLngs(latlngs[i++]);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.removeLayer(layer);\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this);\r\n\r\n\t\t\t\twhile (i < len) {\r\n\t\t\t\t\tthis.addLayer(new Klass(latlngs[i++], this._options));\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\r\n\t\t\tgetLatLngs: function () {\r\n\t\t\t\tvar latlngs = [];\r\n\r\n\t\t\t\tthis.eachLayer(function (layer) {\r\n\t\t\t\t\tlatlngs.push(layer.getLatLngs());\r\n\t\t\t\t});\r\n\r\n\t\t\t\treturn latlngs;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tL.MultiPolyline = createMulti(L.Polyline);\r\n\tL.MultiPolygon = createMulti(L.Polygon);\r\n\r\n\tL.multiPolyline = function (latlngs, options) {\r\n\t\treturn new L.MultiPolyline(latlngs, options);\r\n\t};\r\n\r\n\tL.multiPolygon = function (latlngs, options) {\r\n\t\treturn new L.MultiPolygon(latlngs, options);\r\n\t};\r\n}());\r\n\n\n/*\r\n * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.\r\n */\r\n\r\nL.Rectangle = L.Polygon.extend({\r\n\tinitialize: function (latLngBounds, options) {\r\n\t\tL.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);\r\n\t},\r\n\r\n\tsetBounds: function (latLngBounds) {\r\n\t\tthis.setLatLngs(this._boundsToLatLngs(latLngBounds));\r\n\t},\r\n\r\n\t_boundsToLatLngs: function (latLngBounds) {\r\n\t\tlatLngBounds = L.latLngBounds(latLngBounds);\r\n\t\treturn [\r\n\t\t\tlatLngBounds.getSouthWest(),\r\n\t\t\tlatLngBounds.getNorthWest(),\r\n\t\t\tlatLngBounds.getNorthEast(),\r\n\t\t\tlatLngBounds.getSouthEast()\r\n\t\t];\r\n\t}\r\n});\r\n\r\nL.rectangle = function (latLngBounds, options) {\r\n\treturn new L.Rectangle(latLngBounds, options);\r\n};\r\n\n\n/*\r\n * L.Circle is a circle overlay (with a certain radius in meters).\r\n */\r\n\r\nL.Circle = L.Path.extend({\r\n\tinitialize: function (latlng, radius, options) {\r\n\t\tL.Path.prototype.initialize.call(this, options);\r\n\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t\tthis._mRadius = radius;\r\n\t},\r\n\r\n\toptions: {\r\n\t\tfill: true\r\n\t},\r\n\r\n\tsetLatLng: function (latlng) {\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\tsetRadius: function (radius) {\r\n\t\tthis._mRadius = radius;\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\tvar lngRadius = this._getLngRadius(),\r\n\t\t    latlng = this._latlng,\r\n\t\t    pointLeft = this._map.latLngToLayerPoint([latlng.lat, latlng.lng - lngRadius]);\r\n\r\n\t\tthis._point = this._map.latLngToLayerPoint(latlng);\r\n\t\tthis._radius = Math.max(this._point.x - pointLeft.x, 1);\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\tvar lngRadius = this._getLngRadius(),\r\n\t\t    latRadius = (this._mRadius / 40075017) * 360,\r\n\t\t    latlng = this._latlng;\r\n\r\n\t\treturn new L.LatLngBounds(\r\n\t\t        [latlng.lat - latRadius, latlng.lng - lngRadius],\r\n\t\t        [latlng.lat + latRadius, latlng.lng + lngRadius]);\r\n\t},\r\n\r\n\tgetLatLng: function () {\r\n\t\treturn this._latlng;\r\n\t},\r\n\r\n\tgetPathString: function () {\r\n\t\tvar p = this._point,\r\n\t\t    r = this._radius;\r\n\r\n\t\tif (this._checkIfEmpty()) {\r\n\t\t\treturn '';\r\n\t\t}\r\n\r\n\t\tif (L.Browser.svg) {\r\n\t\t\treturn 'M' + p.x + ',' + (p.y - r) +\r\n\t\t\t       'A' + r + ',' + r + ',0,1,1,' +\r\n\t\t\t       (p.x - 0.1) + ',' + (p.y - r) + ' z';\r\n\t\t} else {\r\n\t\t\tp._round();\r\n\t\t\tr = Math.round(r);\r\n\t\t\treturn 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r + ' 0,' + (65535 * 360);\r\n\t\t}\r\n\t},\r\n\r\n\tgetRadius: function () {\r\n\t\treturn this._mRadius;\r\n\t},\r\n\r\n\t// TODO Earth hardcoded, move into projection code!\r\n\r\n\t_getLatRadius: function () {\r\n\t\treturn (this._mRadius / 40075017) * 360;\r\n\t},\r\n\r\n\t_getLngRadius: function () {\r\n\t\treturn this._getLatRadius() / Math.cos(L.LatLng.DEG_TO_RAD * this._latlng.lat);\r\n\t},\r\n\r\n\t_checkIfEmpty: function () {\r\n\t\tif (!this._map) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tvar vp = this._map._pathViewport,\r\n\t\t    r = this._radius,\r\n\t\t    p = this._point;\r\n\r\n\t\treturn p.x - r > vp.max.x || p.y - r > vp.max.y ||\r\n\t\t       p.x + r < vp.min.x || p.y + r < vp.min.y;\r\n\t}\r\n});\r\n\r\nL.circle = function (latlng, radius, options) {\r\n\treturn new L.Circle(latlng, radius, options);\r\n};\r\n\n\n/*\r\n * L.CircleMarker is a circle overlay with a permanent pixel radius.\r\n */\r\n\r\nL.CircleMarker = L.Circle.extend({\r\n\toptions: {\r\n\t\tradius: 10,\r\n\t\tweight: 2\r\n\t},\r\n\r\n\tinitialize: function (latlng, options) {\r\n\t\tL.Circle.prototype.initialize.call(this, latlng, null, options);\r\n\t\tthis._radius = this.options.radius;\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\tthis._point = this._map.latLngToLayerPoint(this._latlng);\r\n\t},\r\n\r\n\t_updateStyle : function () {\r\n\t\tL.Circle.prototype._updateStyle.call(this);\r\n\t\tthis.setRadius(this.options.radius);\r\n\t},\r\n\r\n\tsetLatLng: function (latlng) {\r\n\t\tL.Circle.prototype.setLatLng.call(this, latlng);\r\n\t\tif (this._popup && this._popup._isOpen) {\r\n\t\t\tthis._popup.setLatLng(latlng);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetRadius: function (radius) {\r\n\t\tthis.options.radius = this._radius = radius;\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\tgetRadius: function () {\r\n\t\treturn this._radius;\r\n\t}\r\n});\r\n\r\nL.circleMarker = function (latlng, options) {\r\n\treturn new L.CircleMarker(latlng, options);\r\n};\r\n\n\n/*\r\n * Extends L.Polyline to be able to manually detect clicks on Canvas-rendered polylines.\r\n */\r\n\r\nL.Polyline.include(!L.Path.CANVAS ? {} : {\r\n\t_containsPoint: function (p, closed) {\r\n\t\tvar i, j, k, len, len2, dist, part,\r\n\t\t    w = this.options.weight / 2;\r\n\r\n\t\tif (L.Browser.touch) {\r\n\t\t\tw += 10; // polyline click tolerance on touch devices\r\n\t\t}\r\n\r\n\t\tfor (i = 0, len = this._parts.length; i < len; i++) {\r\n\t\t\tpart = this._parts[i];\r\n\t\t\tfor (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\r\n\t\t\t\tif (!closed && (j === 0)) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdist = L.LineUtil.pointToSegmentDistance(p, part[k], part[j]);\r\n\r\n\t\t\t\tif (dist <= w) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n});\r\n\n\n/*\r\n * Extends L.Polygon to be able to manually detect clicks on Canvas-rendered polygons.\r\n */\r\n\r\nL.Polygon.include(!L.Path.CANVAS ? {} : {\r\n\t_containsPoint: function (p) {\r\n\t\tvar inside = false,\r\n\t\t    part, p1, p2,\r\n\t\t    i, j, k,\r\n\t\t    len, len2;\r\n\r\n\t\t// TODO optimization: check if within bounds first\r\n\r\n\t\tif (L.Polyline.prototype._containsPoint.call(this, p, true)) {\r\n\t\t\t// click on polygon border\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// ray casting algorithm for detecting if point is in polygon\r\n\r\n\t\tfor (i = 0, len = this._parts.length; i < len; i++) {\r\n\t\t\tpart = this._parts[i];\r\n\r\n\t\t\tfor (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\r\n\t\t\t\tp1 = part[j];\r\n\t\t\t\tp2 = part[k];\r\n\r\n\t\t\t\tif (((p1.y > p.y) !== (p2.y > p.y)) &&\r\n\t\t\t\t\t\t(p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {\r\n\t\t\t\t\tinside = !inside;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn inside;\r\n\t}\r\n});\r\n\n\n/*\r\n * Extends L.Circle with Canvas-specific code.\r\n */\r\n\r\nL.Circle.include(!L.Path.CANVAS ? {} : {\r\n\t_drawPath: function () {\r\n\t\tvar p = this._point;\r\n\t\tthis._ctx.beginPath();\r\n\t\tthis._ctx.arc(p.x, p.y, this._radius, 0, Math.PI * 2, false);\r\n\t},\r\n\r\n\t_containsPoint: function (p) {\r\n\t\tvar center = this._point,\r\n\t\t    w2 = this.options.stroke ? this.options.weight / 2 : 0;\r\n\r\n\t\treturn (p.distanceTo(center) <= this._radius + w2);\r\n\t}\r\n});\r\n\n\n/*\n * CircleMarker canvas specific drawing parts.\n */\n\nL.CircleMarker.include(!L.Path.CANVAS ? {} : {\n\t_updateStyle: function () {\n\t\tL.Path.prototype._updateStyle.call(this);\n\t}\n});\n\n\n/*\r\n * L.GeoJSON turns any GeoJSON data into a Leaflet layer.\r\n */\r\n\r\nL.GeoJSON = L.FeatureGroup.extend({\r\n\r\n\tinitialize: function (geojson, options) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._layers = {};\r\n\r\n\t\tif (geojson) {\r\n\t\t\tthis.addData(geojson);\r\n\t\t}\r\n\t},\r\n\r\n\taddData: function (geojson) {\r\n\t\tvar features = L.Util.isArray(geojson) ? geojson : geojson.features,\r\n\t\t    i, len, feature;\r\n\r\n\t\tif (features) {\r\n\t\t\tfor (i = 0, len = features.length; i < len; i++) {\r\n\t\t\t\t// Only add this if geometry or geometries are set and not null\r\n\t\t\t\tfeature = features[i];\r\n\t\t\t\tif (feature.geometries || feature.geometry || feature.features || feature.coordinates) {\r\n\t\t\t\t\tthis.addData(features[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tvar options = this.options;\r\n\r\n\t\tif (options.filter && !options.filter(geojson)) { return; }\r\n\r\n\t\tvar layer = L.GeoJSON.geometryToLayer(geojson, options.pointToLayer, options.coordsToLatLng, options);\r\n\t\tlayer.feature = L.GeoJSON.asFeature(geojson);\r\n\r\n\t\tlayer.defaultOptions = layer.options;\r\n\t\tthis.resetStyle(layer);\r\n\r\n\t\tif (options.onEachFeature) {\r\n\t\t\toptions.onEachFeature(geojson, layer);\r\n\t\t}\r\n\r\n\t\treturn this.addLayer(layer);\r\n\t},\r\n\r\n\tresetStyle: function (layer) {\r\n\t\tvar style = this.options.style;\r\n\t\tif (style) {\r\n\t\t\t// reset any custom styles\r\n\t\t\tL.Util.extend(layer.options, layer.defaultOptions);\r\n\r\n\t\t\tthis._setLayerStyle(layer, style);\r\n\t\t}\r\n\t},\r\n\r\n\tsetStyle: function (style) {\r\n\t\tthis.eachLayer(function (layer) {\r\n\t\t\tthis._setLayerStyle(layer, style);\r\n\t\t}, this);\r\n\t},\r\n\r\n\t_setLayerStyle: function (layer, style) {\r\n\t\tif (typeof style === 'function') {\r\n\t\t\tstyle = style(layer.feature);\r\n\t\t}\r\n\t\tif (layer.setStyle) {\r\n\t\t\tlayer.setStyle(style);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.extend(L.GeoJSON, {\r\n\tgeometryToLayer: function (geojson, pointToLayer, coordsToLatLng, vectorOptions) {\r\n\t\tvar geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,\r\n\t\t    coords = geometry.coordinates,\r\n\t\t    layers = [],\r\n\t\t    latlng, latlngs, i, len;\r\n\r\n\t\tcoordsToLatLng = coordsToLatLng || this.coordsToLatLng;\r\n\r\n\t\tswitch (geometry.type) {\r\n\t\tcase 'Point':\r\n\t\t\tlatlng = coordsToLatLng(coords);\r\n\t\t\treturn pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);\r\n\r\n\t\tcase 'MultiPoint':\r\n\t\t\tfor (i = 0, len = coords.length; i < len; i++) {\r\n\t\t\t\tlatlng = coordsToLatLng(coords[i]);\r\n\t\t\t\tlayers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));\r\n\t\t\t}\r\n\t\t\treturn new L.FeatureGroup(layers);\r\n\r\n\t\tcase 'LineString':\r\n\t\t\tlatlngs = this.coordsToLatLngs(coords, 0, coordsToLatLng);\r\n\t\t\treturn new L.Polyline(latlngs, vectorOptions);\r\n\r\n\t\tcase 'Polygon':\r\n\t\t\tif (coords.length === 2 && !coords[1].length) {\r\n\t\t\t\tthrow new Error('Invalid GeoJSON object.');\r\n\t\t\t}\r\n\t\t\tlatlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);\r\n\t\t\treturn new L.Polygon(latlngs, vectorOptions);\r\n\r\n\t\tcase 'MultiLineString':\r\n\t\t\tlatlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);\r\n\t\t\treturn new L.MultiPolyline(latlngs, vectorOptions);\r\n\r\n\t\tcase 'MultiPolygon':\r\n\t\t\tlatlngs = this.coordsToLatLngs(coords, 2, coordsToLatLng);\r\n\t\t\treturn new L.MultiPolygon(latlngs, vectorOptions);\r\n\r\n\t\tcase 'GeometryCollection':\r\n\t\t\tfor (i = 0, len = geometry.geometries.length; i < len; i++) {\r\n\r\n\t\t\t\tlayers.push(this.geometryToLayer({\r\n\t\t\t\t\tgeometry: geometry.geometries[i],\r\n\t\t\t\t\ttype: 'Feature',\r\n\t\t\t\t\tproperties: geojson.properties\r\n\t\t\t\t}, pointToLayer, coordsToLatLng, vectorOptions));\r\n\t\t\t}\r\n\t\t\treturn new L.FeatureGroup(layers);\r\n\r\n\t\tdefault:\r\n\t\t\tthrow new Error('Invalid GeoJSON object.');\r\n\t\t}\r\n\t},\r\n\r\n\tcoordsToLatLng: function (coords) { // (Array[, Boolean]) -> LatLng\r\n\t\treturn new L.LatLng(coords[1], coords[0], coords[2]);\r\n\t},\r\n\r\n\tcoordsToLatLngs: function (coords, levelsDeep, coordsToLatLng) { // (Array[, Number, Function]) -> Array\r\n\t\tvar latlng, i, len,\r\n\t\t    latlngs = [];\r\n\r\n\t\tfor (i = 0, len = coords.length; i < len; i++) {\r\n\t\t\tlatlng = levelsDeep ?\r\n\t\t\t        this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) :\r\n\t\t\t        (coordsToLatLng || this.coordsToLatLng)(coords[i]);\r\n\r\n\t\t\tlatlngs.push(latlng);\r\n\t\t}\r\n\r\n\t\treturn latlngs;\r\n\t},\r\n\r\n\tlatLngToCoords: function (latlng) {\r\n\t\tvar coords = [latlng.lng, latlng.lat];\r\n\r\n\t\tif (latlng.alt !== undefined) {\r\n\t\t\tcoords.push(latlng.alt);\r\n\t\t}\r\n\t\treturn coords;\r\n\t},\r\n\r\n\tlatLngsToCoords: function (latLngs) {\r\n\t\tvar coords = [];\r\n\r\n\t\tfor (var i = 0, len = latLngs.length; i < len; i++) {\r\n\t\t\tcoords.push(L.GeoJSON.latLngToCoords(latLngs[i]));\r\n\t\t}\r\n\r\n\t\treturn coords;\r\n\t},\r\n\r\n\tgetFeature: function (layer, newGeometry) {\r\n\t\treturn layer.feature ? L.extend({}, layer.feature, {geometry: newGeometry}) : L.GeoJSON.asFeature(newGeometry);\r\n\t},\r\n\r\n\tasFeature: function (geoJSON) {\r\n\t\tif (geoJSON.type === 'Feature') {\r\n\t\t\treturn geoJSON;\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\ttype: 'Feature',\r\n\t\t\tproperties: {},\r\n\t\t\tgeometry: geoJSON\r\n\t\t};\r\n\t}\r\n});\r\n\r\nvar PointToGeoJSON = {\r\n\ttoGeoJSON: function () {\r\n\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\ttype: 'Point',\r\n\t\t\tcoordinates: L.GeoJSON.latLngToCoords(this.getLatLng())\r\n\t\t});\r\n\t}\r\n};\r\n\r\nL.Marker.include(PointToGeoJSON);\r\nL.Circle.include(PointToGeoJSON);\r\nL.CircleMarker.include(PointToGeoJSON);\r\n\r\nL.Polyline.include({\r\n\ttoGeoJSON: function () {\r\n\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\ttype: 'LineString',\r\n\t\t\tcoordinates: L.GeoJSON.latLngsToCoords(this.getLatLngs())\r\n\t\t});\r\n\t}\r\n});\r\n\r\nL.Polygon.include({\r\n\ttoGeoJSON: function () {\r\n\t\tvar coords = [L.GeoJSON.latLngsToCoords(this.getLatLngs())],\r\n\t\t    i, len, hole;\r\n\r\n\t\tcoords[0].push(coords[0][0]);\r\n\r\n\t\tif (this._holes) {\r\n\t\t\tfor (i = 0, len = this._holes.length; i < len; i++) {\r\n\t\t\t\thole = L.GeoJSON.latLngsToCoords(this._holes[i]);\r\n\t\t\t\thole.push(hole[0]);\r\n\t\t\t\tcoords.push(hole);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\ttype: 'Polygon',\r\n\t\t\tcoordinates: coords\r\n\t\t});\r\n\t}\r\n});\r\n\r\n(function () {\r\n\tfunction multiToGeoJSON(type) {\r\n\t\treturn function () {\r\n\t\t\tvar coords = [];\r\n\r\n\t\t\tthis.eachLayer(function (layer) {\r\n\t\t\t\tcoords.push(layer.toGeoJSON().geometry.coordinates);\r\n\t\t\t});\r\n\r\n\t\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\t\ttype: type,\r\n\t\t\t\tcoordinates: coords\r\n\t\t\t});\r\n\t\t};\r\n\t}\r\n\r\n\tL.MultiPolyline.include({toGeoJSON: multiToGeoJSON('MultiLineString')});\r\n\tL.MultiPolygon.include({toGeoJSON: multiToGeoJSON('MultiPolygon')});\r\n\r\n\tL.LayerGroup.include({\r\n\t\ttoGeoJSON: function () {\r\n\r\n\t\t\tvar geometry = this.feature && this.feature.geometry,\r\n\t\t\t\tjsons = [],\r\n\t\t\t\tjson;\r\n\r\n\t\t\tif (geometry && geometry.type === 'MultiPoint') {\r\n\t\t\t\treturn multiToGeoJSON('MultiPoint').call(this);\r\n\t\t\t}\r\n\r\n\t\t\tvar isGeometryCollection = geometry && geometry.type === 'GeometryCollection';\r\n\r\n\t\t\tthis.eachLayer(function (layer) {\r\n\t\t\t\tif (layer.toGeoJSON) {\r\n\t\t\t\t\tjson = layer.toGeoJSON();\r\n\t\t\t\t\tjsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json));\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tif (isGeometryCollection) {\r\n\t\t\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\t\t\tgeometries: jsons,\r\n\t\t\t\t\ttype: 'GeometryCollection'\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\treturn {\r\n\t\t\t\ttype: 'FeatureCollection',\r\n\t\t\t\tfeatures: jsons\r\n\t\t\t};\r\n\t\t}\r\n\t});\r\n}());\r\n\r\nL.geoJson = function (geojson, options) {\r\n\treturn new L.GeoJSON(geojson, options);\r\n};\r\n\n\n/*\r\n * L.DomEvent contains functions for working with DOM events.\r\n */\r\n\r\nL.DomEvent = {\r\n\t/* inspired by John Resig, Dean Edwards and YUI addEvent implementations */\r\n\taddListener: function (obj, type, fn, context) { // (HTMLElement, String, Function[, Object])\r\n\r\n\t\tvar id = L.stamp(fn),\r\n\t\t    key = '_leaflet_' + type + id,\r\n\t\t    handler, originalHandler, newType;\r\n\r\n\t\tif (obj[key]) { return this; }\r\n\r\n\t\thandler = function (e) {\r\n\t\t\treturn fn.call(context || obj, e || L.DomEvent._getEvent());\r\n\t\t};\r\n\r\n\t\tif (L.Browser.pointer && type.indexOf('touch') === 0) {\r\n\t\t\treturn this.addPointerListener(obj, type, handler, id);\r\n\t\t}\r\n\t\tif (L.Browser.touch && (type === 'dblclick') && this.addDoubleTapListener) {\r\n\t\t\tthis.addDoubleTapListener(obj, handler, id);\r\n\t\t}\r\n\r\n\t\tif ('addEventListener' in obj) {\r\n\r\n\t\t\tif (type === 'mousewheel') {\r\n\t\t\t\tobj.addEventListener('DOMMouseScroll', handler, false);\r\n\t\t\t\tobj.addEventListener(type, handler, false);\r\n\r\n\t\t\t} else if ((type === 'mouseenter') || (type === 'mouseleave')) {\r\n\r\n\t\t\t\toriginalHandler = handler;\r\n\t\t\t\tnewType = (type === 'mouseenter' ? 'mouseover' : 'mouseout');\r\n\r\n\t\t\t\thandler = function (e) {\r\n\t\t\t\t\tif (!L.DomEvent._checkMouse(obj, e)) { return; }\r\n\t\t\t\t\treturn originalHandler(e);\r\n\t\t\t\t};\r\n\r\n\t\t\t\tobj.addEventListener(newType, handler, false);\r\n\r\n\t\t\t} else if (type === 'click' && L.Browser.android) {\r\n\t\t\t\toriginalHandler = handler;\r\n\t\t\t\thandler = function (e) {\r\n\t\t\t\t\treturn L.DomEvent._filterClick(e, originalHandler);\r\n\t\t\t\t};\r\n\r\n\t\t\t\tobj.addEventListener(type, handler, false);\r\n\t\t\t} else {\r\n\t\t\t\tobj.addEventListener(type, handler, false);\r\n\t\t\t}\r\n\r\n\t\t} else if ('attachEvent' in obj) {\r\n\t\t\tobj.attachEvent('on' + type, handler);\r\n\t\t}\r\n\r\n\t\tobj[key] = handler;\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveListener: function (obj, type, fn) {  // (HTMLElement, String, Function)\r\n\r\n\t\tvar id = L.stamp(fn),\r\n\t\t    key = '_leaflet_' + type + id,\r\n\t\t    handler = obj[key];\r\n\r\n\t\tif (!handler) { return this; }\r\n\r\n\t\tif (L.Browser.pointer && type.indexOf('touch') === 0) {\r\n\t\t\tthis.removePointerListener(obj, type, id);\r\n\t\t} else if (L.Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {\r\n\t\t\tthis.removeDoubleTapListener(obj, id);\r\n\r\n\t\t} else if ('removeEventListener' in obj) {\r\n\r\n\t\t\tif (type === 'mousewheel') {\r\n\t\t\t\tobj.removeEventListener('DOMMouseScroll', handler, false);\r\n\t\t\t\tobj.removeEventListener(type, handler, false);\r\n\r\n\t\t\t} else if ((type === 'mouseenter') || (type === 'mouseleave')) {\r\n\t\t\t\tobj.removeEventListener((type === 'mouseenter' ? 'mouseover' : 'mouseout'), handler, false);\r\n\t\t\t} else {\r\n\t\t\t\tobj.removeEventListener(type, handler, false);\r\n\t\t\t}\r\n\t\t} else if ('detachEvent' in obj) {\r\n\t\t\tobj.detachEvent('on' + type, handler);\r\n\t\t}\r\n\r\n\t\tobj[key] = null;\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tstopPropagation: function (e) {\r\n\r\n\t\tif (e.stopPropagation) {\r\n\t\t\te.stopPropagation();\r\n\t\t} else {\r\n\t\t\te.cancelBubble = true;\r\n\t\t}\r\n\t\tL.DomEvent._skipped(e);\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tdisableScrollPropagation: function (el) {\r\n\t\tvar stop = L.DomEvent.stopPropagation;\r\n\r\n\t\treturn L.DomEvent\r\n\t\t\t.on(el, 'mousewheel', stop)\r\n\t\t\t.on(el, 'MozMousePixelScroll', stop);\r\n\t},\r\n\r\n\tdisableClickPropagation: function (el) {\r\n\t\tvar stop = L.DomEvent.stopPropagation;\r\n\r\n\t\tfor (var i = L.Draggable.START.length - 1; i >= 0; i--) {\r\n\t\t\tL.DomEvent.on(el, L.Draggable.START[i], stop);\r\n\t\t}\r\n\r\n\t\treturn L.DomEvent\r\n\t\t\t.on(el, 'click', L.DomEvent._fakeStop)\r\n\t\t\t.on(el, 'dblclick', stop);\r\n\t},\r\n\r\n\tpreventDefault: function (e) {\r\n\r\n\t\tif (e.preventDefault) {\r\n\t\t\te.preventDefault();\r\n\t\t} else {\r\n\t\t\te.returnValue = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tstop: function (e) {\r\n\t\treturn L.DomEvent\r\n\t\t\t.preventDefault(e)\r\n\t\t\t.stopPropagation(e);\r\n\t},\r\n\r\n\tgetMousePosition: function (e, container) {\r\n\t\tif (!container) {\r\n\t\t\treturn new L.Point(e.clientX, e.clientY);\r\n\t\t}\r\n\r\n\t\tvar rect = container.getBoundingClientRect();\r\n\r\n\t\treturn new L.Point(\r\n\t\t\te.clientX - rect.left - container.clientLeft,\r\n\t\t\te.clientY - rect.top - container.clientTop);\r\n\t},\r\n\r\n\tgetWheelDelta: function (e) {\r\n\r\n\t\tvar delta = 0;\r\n\r\n\t\tif (e.wheelDelta) {\r\n\t\t\tdelta = e.wheelDelta / 120;\r\n\t\t}\r\n\t\tif (e.detail) {\r\n\t\t\tdelta = -e.detail / 3;\r\n\t\t}\r\n\t\treturn delta;\r\n\t},\r\n\r\n\t_skipEvents: {},\r\n\r\n\t_fakeStop: function (e) {\r\n\t\t// fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)\r\n\t\tL.DomEvent._skipEvents[e.type] = true;\r\n\t},\r\n\r\n\t_skipped: function (e) {\r\n\t\tvar skipped = this._skipEvents[e.type];\r\n\t\t// reset when checking, as it's only used in map container and propagates outside of the map\r\n\t\tthis._skipEvents[e.type] = false;\r\n\t\treturn skipped;\r\n\t},\r\n\r\n\t// check if element really left/entered the event target (for mouseenter/mouseleave)\r\n\t_checkMouse: function (el, e) {\r\n\r\n\t\tvar related = e.relatedTarget;\r\n\r\n\t\tif (!related) { return true; }\r\n\r\n\t\ttry {\r\n\t\t\twhile (related && (related !== el)) {\r\n\t\t\t\trelated = related.parentNode;\r\n\t\t\t}\r\n\t\t} catch (err) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn (related !== el);\r\n\t},\r\n\r\n\t_getEvent: function () { // evil magic for IE\r\n\t\t/*jshint noarg:false */\r\n\t\tvar e = window.event;\r\n\t\tif (!e) {\r\n\t\t\tvar caller = arguments.callee.caller;\r\n\t\t\twhile (caller) {\r\n\t\t\t\te = caller['arguments'][0];\r\n\t\t\t\tif (e && window.Event === e.constructor) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcaller = caller.caller;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn e;\r\n\t},\r\n\r\n\t// this is a horrible workaround for a bug in Android where a single touch triggers two click events\r\n\t_filterClick: function (e, handler) {\r\n\t\tvar timeStamp = (e.timeStamp || e.originalEvent.timeStamp),\r\n\t\t\telapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);\r\n\r\n\t\t// are they closer together than 500ms yet more than 100ms?\r\n\t\t// Android typically triggers them ~300ms apart while multiple listeners\r\n\t\t// on the same event should be triggered far faster;\r\n\t\t// or check if click is simulated on the element, and if it is, reject any non-simulated events\r\n\r\n\t\tif ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {\r\n\t\t\tL.DomEvent.stop(e);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tL.DomEvent._lastClick = timeStamp;\r\n\r\n\t\treturn handler(e);\r\n\t}\r\n};\r\n\r\nL.DomEvent.on = L.DomEvent.addListener;\r\nL.DomEvent.off = L.DomEvent.removeListener;\r\n\n\n/*\r\n * L.Draggable allows you to add dragging capabilities to any element. Supports mobile devices too.\r\n */\r\n\r\nL.Draggable = L.Class.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\tstatics: {\r\n\t\tSTART: L.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],\r\n\t\tEND: {\r\n\t\t\tmousedown: 'mouseup',\r\n\t\t\ttouchstart: 'touchend',\r\n\t\t\tpointerdown: 'touchend',\r\n\t\t\tMSPointerDown: 'touchend'\r\n\t\t},\r\n\t\tMOVE: {\r\n\t\t\tmousedown: 'mousemove',\r\n\t\t\ttouchstart: 'touchmove',\r\n\t\t\tpointerdown: 'touchmove',\r\n\t\t\tMSPointerDown: 'touchmove'\r\n\t\t}\r\n\t},\r\n\r\n\tinitialize: function (element, dragStartTarget) {\r\n\t\tthis._element = element;\r\n\t\tthis._dragStartTarget = dragStartTarget || element;\r\n\t},\r\n\r\n\tenable: function () {\r\n\t\tif (this._enabled) { return; }\r\n\r\n\t\tfor (var i = L.Draggable.START.length - 1; i >= 0; i--) {\r\n\t\t\tL.DomEvent.on(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);\r\n\t\t}\r\n\r\n\t\tthis._enabled = true;\r\n\t},\r\n\r\n\tdisable: function () {\r\n\t\tif (!this._enabled) { return; }\r\n\r\n\t\tfor (var i = L.Draggable.START.length - 1; i >= 0; i--) {\r\n\t\t\tL.DomEvent.off(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);\r\n\t\t}\r\n\r\n\t\tthis._enabled = false;\r\n\t\tthis._moved = false;\r\n\t},\r\n\r\n\t_onDown: function (e) {\r\n\t\tthis._moved = false;\r\n\r\n\t\tif (e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }\r\n\r\n\t\tL.DomEvent.stopPropagation(e);\r\n\r\n\t\tif (L.Draggable._disabled) { return; }\r\n\r\n\t\tL.DomUtil.disableImageDrag();\r\n\t\tL.DomUtil.disableTextSelection();\r\n\r\n\t\tif (this._moving) { return; }\r\n\r\n\t\tvar first = e.touches ? e.touches[0] : e;\r\n\r\n\t\tthis._startPoint = new L.Point(first.clientX, first.clientY);\r\n\t\tthis._startPos = this._newPos = L.DomUtil.getPosition(this._element);\r\n\r\n\t\tL.DomEvent\r\n\t\t    .on(document, L.Draggable.MOVE[e.type], this._onMove, this)\r\n\t\t    .on(document, L.Draggable.END[e.type], this._onUp, this);\r\n\t},\r\n\r\n\t_onMove: function (e) {\r\n\t\tif (e.touches && e.touches.length > 1) {\r\n\t\t\tthis._moved = true;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),\r\n\t\t    newPoint = new L.Point(first.clientX, first.clientY),\r\n\t\t    offset = newPoint.subtract(this._startPoint);\r\n\r\n\t\tif (!offset.x && !offset.y) { return; }\r\n\t\tif (L.Browser.touch && Math.abs(offset.x) + Math.abs(offset.y) < 3) { return; }\r\n\r\n\t\tL.DomEvent.preventDefault(e);\r\n\r\n\t\tif (!this._moved) {\r\n\t\t\tthis.fire('dragstart');\r\n\r\n\t\t\tthis._moved = true;\r\n\t\t\tthis._startPos = L.DomUtil.getPosition(this._element).subtract(offset);\r\n\r\n\t\t\tL.DomUtil.addClass(document.body, 'leaflet-dragging');\r\n\t\t\tthis._lastTarget = e.target || e.srcElement;\r\n\t\t\tL.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');\r\n\t\t}\r\n\r\n\t\tthis._newPos = this._startPos.add(offset);\r\n\t\tthis._moving = true;\r\n\r\n\t\tL.Util.cancelAnimFrame(this._animRequest);\r\n\t\tthis._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true, this._dragStartTarget);\r\n\t},\r\n\r\n\t_updatePosition: function () {\r\n\t\tthis.fire('predrag');\r\n\t\tL.DomUtil.setPosition(this._element, this._newPos);\r\n\t\tthis.fire('drag');\r\n\t},\r\n\r\n\t_onUp: function () {\r\n\t\tL.DomUtil.removeClass(document.body, 'leaflet-dragging');\r\n\r\n\t\tif (this._lastTarget) {\r\n\t\t\tL.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');\r\n\t\t\tthis._lastTarget = null;\r\n\t\t}\r\n\r\n\t\tfor (var i in L.Draggable.MOVE) {\r\n\t\t\tL.DomEvent\r\n\t\t\t    .off(document, L.Draggable.MOVE[i], this._onMove)\r\n\t\t\t    .off(document, L.Draggable.END[i], this._onUp);\r\n\t\t}\r\n\r\n\t\tL.DomUtil.enableImageDrag();\r\n\t\tL.DomUtil.enableTextSelection();\r\n\r\n\t\tif (this._moved && this._moving) {\r\n\t\t\t// ensure drag is not fired after dragend\r\n\t\t\tL.Util.cancelAnimFrame(this._animRequest);\r\n\r\n\t\t\tthis.fire('dragend', {\r\n\t\t\t\tdistance: this._newPos.distanceTo(this._startPos)\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tthis._moving = false;\r\n\t}\r\n});\r\n\n\n/*\n\tL.Handler is a base class for handler classes that are used internally to inject\n\tinteraction features like dragging to classes like Map and Marker.\n*/\n\nL.Handler = L.Class.extend({\n\tinitialize: function (map) {\n\t\tthis._map = map;\n\t},\n\n\tenable: function () {\n\t\tif (this._enabled) { return; }\n\n\t\tthis._enabled = true;\n\t\tthis.addHooks();\n\t},\n\n\tdisable: function () {\n\t\tif (!this._enabled) { return; }\n\n\t\tthis._enabled = false;\n\t\tthis.removeHooks();\n\t},\n\n\tenabled: function () {\n\t\treturn !!this._enabled;\n\t}\n});\n\n\n/*\n * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.\n */\n\nL.Map.mergeOptions({\n\tdragging: true,\n\n\tinertia: !L.Browser.android23,\n\tinertiaDeceleration: 3400, // px/s^2\n\tinertiaMaxSpeed: Infinity, // px/s\n\tinertiaThreshold: L.Browser.touch ? 32 : 18, // ms\n\teaseLinearity: 0.25,\n\n\t// TODO refactor, move to CRS\n\tworldCopyJump: false\n});\n\nL.Map.Drag = L.Handler.extend({\n\taddHooks: function () {\n\t\tif (!this._draggable) {\n\t\t\tvar map = this._map;\n\n\t\t\tthis._draggable = new L.Draggable(map._mapPane, map._container);\n\n\t\t\tthis._draggable.on({\n\t\t\t\t'dragstart': this._onDragStart,\n\t\t\t\t'drag': this._onDrag,\n\t\t\t\t'dragend': this._onDragEnd\n\t\t\t}, this);\n\n\t\t\tif (map.options.worldCopyJump) {\n\t\t\t\tthis._draggable.on('predrag', this._onPreDrag, this);\n\t\t\t\tmap.on('viewreset', this._onViewReset, this);\n\n\t\t\t\tmap.whenReady(this._onViewReset, this);\n\t\t\t}\n\t\t}\n\t\tthis._draggable.enable();\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._draggable.disable();\n\t},\n\n\tmoved: function () {\n\t\treturn this._draggable && this._draggable._moved;\n\t},\n\n\t_onDragStart: function () {\n\t\tvar map = this._map;\n\n\t\tif (map._panAnim) {\n\t\t\tmap._panAnim.stop();\n\t\t}\n\n\t\tmap\n\t\t    .fire('movestart')\n\t\t    .fire('dragstart');\n\n\t\tif (map.options.inertia) {\n\t\t\tthis._positions = [];\n\t\t\tthis._times = [];\n\t\t}\n\t},\n\n\t_onDrag: function () {\n\t\tif (this._map.options.inertia) {\n\t\t\tvar time = this._lastTime = +new Date(),\n\t\t\t    pos = this._lastPos = this._draggable._newPos;\n\n\t\t\tthis._positions.push(pos);\n\t\t\tthis._times.push(time);\n\n\t\t\tif (time - this._times[0] > 200) {\n\t\t\t\tthis._positions.shift();\n\t\t\t\tthis._times.shift();\n\t\t\t}\n\t\t}\n\n\t\tthis._map\n\t\t    .fire('move')\n\t\t    .fire('drag');\n\t},\n\n\t_onViewReset: function () {\n\t\t// TODO fix hardcoded Earth values\n\t\tvar pxCenter = this._map.getSize()._divideBy(2),\n\t\t    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);\n\n\t\tthis._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;\n\t\tthis._worldWidth = this._map.project([0, 180]).x;\n\t},\n\n\t_onPreDrag: function () {\n\t\t// TODO refactor to be able to adjust map pane position after zoom\n\t\tvar worldWidth = this._worldWidth,\n\t\t    halfWidth = Math.round(worldWidth / 2),\n\t\t    dx = this._initialWorldOffset,\n\t\t    x = this._draggable._newPos.x,\n\t\t    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,\n\t\t    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,\n\t\t    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;\n\n\t\tthis._draggable._newPos.x = newX;\n\t},\n\n\t_onDragEnd: function (e) {\n\t\tvar map = this._map,\n\t\t    options = map.options,\n\t\t    delay = +new Date() - this._lastTime,\n\n\t\t    noInertia = !options.inertia || delay > options.inertiaThreshold || !this._positions[0];\n\n\t\tmap.fire('dragend', e);\n\n\t\tif (noInertia) {\n\t\t\tmap.fire('moveend');\n\n\t\t} else {\n\n\t\t\tvar direction = this._lastPos.subtract(this._positions[0]),\n\t\t\t    duration = (this._lastTime + delay - this._times[0]) / 1000,\n\t\t\t    ease = options.easeLinearity,\n\n\t\t\t    speedVector = direction.multiplyBy(ease / duration),\n\t\t\t    speed = speedVector.distanceTo([0, 0]),\n\n\t\t\t    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),\n\t\t\t    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),\n\n\t\t\t    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),\n\t\t\t    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();\n\n\t\t\tif (!offset.x || !offset.y) {\n\t\t\t\tmap.fire('moveend');\n\n\t\t\t} else {\n\t\t\t\toffset = map._limitOffset(offset, map.options.maxBounds);\n\n\t\t\t\tL.Util.requestAnimFrame(function () {\n\t\t\t\t\tmap.panBy(offset, {\n\t\t\t\t\t\tduration: decelerationDuration,\n\t\t\t\t\t\teaseLinearity: ease,\n\t\t\t\t\t\tnoMoveStart: true\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'dragging', L.Map.Drag);\n\n\n/*\n * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.\n */\n\nL.Map.mergeOptions({\n\tdoubleClickZoom: true\n});\n\nL.Map.DoubleClickZoom = L.Handler.extend({\n\taddHooks: function () {\n\t\tthis._map.on('dblclick', this._onDoubleClick, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._map.off('dblclick', this._onDoubleClick, this);\n\t},\n\n\t_onDoubleClick: function (e) {\n\t\tvar map = this._map,\n\t\t    zoom = map.getZoom() + (e.originalEvent.shiftKey ? -1 : 1);\n\n\t\tif (map.options.doubleClickZoom === 'center') {\n\t\t\tmap.setZoom(zoom);\n\t\t} else {\n\t\t\tmap.setZoomAround(e.containerPoint, zoom);\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'doubleClickZoom', L.Map.DoubleClickZoom);\n\n\n/*\n * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.\n */\n\nL.Map.mergeOptions({\n\tscrollWheelZoom: true\n});\n\nL.Map.ScrollWheelZoom = L.Handler.extend({\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._map._container, 'mousewheel', this._onWheelScroll, this);\n\t\tL.DomEvent.on(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);\n\t\tthis._delta = 0;\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._map._container, 'mousewheel', this._onWheelScroll);\n\t\tL.DomEvent.off(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);\n\t},\n\n\t_onWheelScroll: function (e) {\n\t\tvar delta = L.DomEvent.getWheelDelta(e);\n\n\t\tthis._delta += delta;\n\t\tthis._lastMousePos = this._map.mouseEventToContainerPoint(e);\n\n\t\tif (!this._startTime) {\n\t\t\tthis._startTime = +new Date();\n\t\t}\n\n\t\tvar left = Math.max(40 - (+new Date() - this._startTime), 0);\n\n\t\tclearTimeout(this._timer);\n\t\tthis._timer = setTimeout(L.bind(this._performZoom, this), left);\n\n\t\tL.DomEvent.preventDefault(e);\n\t\tL.DomEvent.stopPropagation(e);\n\t},\n\n\t_performZoom: function () {\n\t\tvar map = this._map,\n\t\t    delta = this._delta,\n\t\t    zoom = map.getZoom();\n\n\t\tdelta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);\n\t\tdelta = Math.max(Math.min(delta, 4), -4);\n\t\tdelta = map._limitZoom(zoom + delta) - zoom;\n\n\t\tthis._delta = 0;\n\t\tthis._startTime = null;\n\n\t\tif (!delta) { return; }\n\n\t\tif (map.options.scrollWheelZoom === 'center') {\n\t\t\tmap.setZoom(zoom + delta);\n\t\t} else {\n\t\t\tmap.setZoomAround(this._lastMousePos, zoom + delta);\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'scrollWheelZoom', L.Map.ScrollWheelZoom);\n\n\n/*\r\n * Extends the event handling code with double tap support for mobile browsers.\r\n */\r\n\r\nL.extend(L.DomEvent, {\r\n\r\n\t_touchstart: L.Browser.msPointer ? 'MSPointerDown' : L.Browser.pointer ? 'pointerdown' : 'touchstart',\r\n\t_touchend: L.Browser.msPointer ? 'MSPointerUp' : L.Browser.pointer ? 'pointerup' : 'touchend',\r\n\r\n\t// inspired by Zepto touch code by Thomas Fuchs\r\n\taddDoubleTapListener: function (obj, handler, id) {\r\n\t\tvar last,\r\n\t\t    doubleTap = false,\r\n\t\t    delay = 250,\r\n\t\t    touch,\r\n\t\t    pre = '_leaflet_',\r\n\t\t    touchstart = this._touchstart,\r\n\t\t    touchend = this._touchend,\r\n\t\t    trackedTouches = [];\r\n\r\n\t\tfunction onTouchStart(e) {\r\n\t\t\tvar count;\r\n\r\n\t\t\tif (L.Browser.pointer) {\r\n\t\t\t\ttrackedTouches.push(e.pointerId);\r\n\t\t\t\tcount = trackedTouches.length;\r\n\t\t\t} else {\r\n\t\t\t\tcount = e.touches.length;\r\n\t\t\t}\r\n\t\t\tif (count > 1) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar now = Date.now(),\r\n\t\t\t\tdelta = now - (last || now);\r\n\r\n\t\t\ttouch = e.touches ? e.touches[0] : e;\r\n\t\t\tdoubleTap = (delta > 0 && delta <= delay);\r\n\t\t\tlast = now;\r\n\t\t}\r\n\r\n\t\tfunction onTouchEnd(e) {\r\n\t\t\tif (L.Browser.pointer) {\r\n\t\t\t\tvar idx = trackedTouches.indexOf(e.pointerId);\r\n\t\t\t\tif (idx === -1) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\ttrackedTouches.splice(idx, 1);\r\n\t\t\t}\r\n\r\n\t\t\tif (doubleTap) {\r\n\t\t\t\tif (L.Browser.pointer) {\r\n\t\t\t\t\t// work around .type being readonly with MSPointer* events\r\n\t\t\t\t\tvar newTouch = { },\r\n\t\t\t\t\t\tprop;\r\n\r\n\t\t\t\t\t// jshint forin:false\r\n\t\t\t\t\tfor (var i in touch) {\r\n\t\t\t\t\t\tprop = touch[i];\r\n\t\t\t\t\t\tif (typeof prop === 'function') {\r\n\t\t\t\t\t\t\tnewTouch[i] = prop.bind(touch);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tnewTouch[i] = prop;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttouch = newTouch;\r\n\t\t\t\t}\r\n\t\t\t\ttouch.type = 'dblclick';\r\n\t\t\t\thandler(touch);\r\n\t\t\t\tlast = null;\r\n\t\t\t}\r\n\t\t}\r\n\t\tobj[pre + touchstart + id] = onTouchStart;\r\n\t\tobj[pre + touchend + id] = onTouchEnd;\r\n\r\n\t\t// on pointer we need to listen on the document, otherwise a drag starting on the map and moving off screen\r\n\t\t// will not come through to us, so we will lose track of how many touches are ongoing\r\n\t\tvar endElement = L.Browser.pointer ? document.documentElement : obj;\r\n\r\n\t\tobj.addEventListener(touchstart, onTouchStart, false);\r\n\t\tendElement.addEventListener(touchend, onTouchEnd, false);\r\n\r\n\t\tif (L.Browser.pointer) {\r\n\t\t\tendElement.addEventListener(L.DomEvent.POINTER_CANCEL, onTouchEnd, false);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveDoubleTapListener: function (obj, id) {\r\n\t\tvar pre = '_leaflet_';\r\n\r\n\t\tobj.removeEventListener(this._touchstart, obj[pre + this._touchstart + id], false);\r\n\t\t(L.Browser.pointer ? document.documentElement : obj).removeEventListener(\r\n\t\t        this._touchend, obj[pre + this._touchend + id], false);\r\n\r\n\t\tif (L.Browser.pointer) {\r\n\t\t\tdocument.documentElement.removeEventListener(L.DomEvent.POINTER_CANCEL, obj[pre + this._touchend + id],\r\n\t\t\t\tfalse);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n});\r\n\n\n/*\n * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.\n */\n\nL.extend(L.DomEvent, {\n\n\t//static\n\tPOINTER_DOWN: L.Browser.msPointer ? 'MSPointerDown' : 'pointerdown',\n\tPOINTER_MOVE: L.Browser.msPointer ? 'MSPointerMove' : 'pointermove',\n\tPOINTER_UP: L.Browser.msPointer ? 'MSPointerUp' : 'pointerup',\n\tPOINTER_CANCEL: L.Browser.msPointer ? 'MSPointerCancel' : 'pointercancel',\n\n\t_pointers: [],\n\t_pointerDocumentListener: false,\n\n\t// Provides a touch events wrapper for (ms)pointer events.\n\t// Based on changes by veproza https://github.com/CloudMade/Leaflet/pull/1019\n\t//ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890\n\n\taddPointerListener: function (obj, type, handler, id) {\n\n\t\tswitch (type) {\n\t\tcase 'touchstart':\n\t\t\treturn this.addPointerListenerStart(obj, type, handler, id);\n\t\tcase 'touchend':\n\t\t\treturn this.addPointerListenerEnd(obj, type, handler, id);\n\t\tcase 'touchmove':\n\t\t\treturn this.addPointerListenerMove(obj, type, handler, id);\n\t\tdefault:\n\t\t\tthrow 'Unknown touch event type';\n\t\t}\n\t},\n\n\taddPointerListenerStart: function (obj, type, handler, id) {\n\t\tvar pre = '_leaflet_',\n\t\t    pointers = this._pointers;\n\n\t\tvar cb = function (e) {\n\t\t\tif (e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {\n\t\t\t\tL.DomEvent.preventDefault(e);\n\t\t\t}\n\n\t\t\tvar alreadyInArray = false;\n\t\t\tfor (var i = 0; i < pointers.length; i++) {\n\t\t\t\tif (pointers[i].pointerId === e.pointerId) {\n\t\t\t\t\talreadyInArray = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!alreadyInArray) {\n\t\t\t\tpointers.push(e);\n\t\t\t}\n\n\t\t\te.touches = pointers.slice();\n\t\t\te.changedTouches = [e];\n\n\t\t\thandler(e);\n\t\t};\n\n\t\tobj[pre + 'touchstart' + id] = cb;\n\t\tobj.addEventListener(this.POINTER_DOWN, cb, false);\n\n\t\t// need to also listen for end events to keep the _pointers list accurate\n\t\t// this needs to be on the body and never go away\n\t\tif (!this._pointerDocumentListener) {\n\t\t\tvar internalCb = function (e) {\n\t\t\t\tfor (var i = 0; i < pointers.length; i++) {\n\t\t\t\t\tif (pointers[i].pointerId === e.pointerId) {\n\t\t\t\t\t\tpointers.splice(i, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\t//We listen on the documentElement as any drags that end by moving the touch off the screen get fired there\n\t\t\tdocument.documentElement.addEventListener(this.POINTER_UP, internalCb, false);\n\t\t\tdocument.documentElement.addEventListener(this.POINTER_CANCEL, internalCb, false);\n\n\t\t\tthis._pointerDocumentListener = true;\n\t\t}\n\n\t\treturn this;\n\t},\n\n\taddPointerListenerMove: function (obj, type, handler, id) {\n\t\tvar pre = '_leaflet_',\n\t\t    touches = this._pointers;\n\n\t\tfunction cb(e) {\n\n\t\t\t// don't fire touch moves when mouse isn't down\n\t\t\tif ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }\n\n\t\t\tfor (var i = 0; i < touches.length; i++) {\n\t\t\t\tif (touches[i].pointerId === e.pointerId) {\n\t\t\t\t\ttouches[i] = e;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\te.touches = touches.slice();\n\t\t\te.changedTouches = [e];\n\n\t\t\thandler(e);\n\t\t}\n\n\t\tobj[pre + 'touchmove' + id] = cb;\n\t\tobj.addEventListener(this.POINTER_MOVE, cb, false);\n\n\t\treturn this;\n\t},\n\n\taddPointerListenerEnd: function (obj, type, handler, id) {\n\t\tvar pre = '_leaflet_',\n\t\t    touches = this._pointers;\n\n\t\tvar cb = function (e) {\n\t\t\tfor (var i = 0; i < touches.length; i++) {\n\t\t\t\tif (touches[i].pointerId === e.pointerId) {\n\t\t\t\t\ttouches.splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\te.touches = touches.slice();\n\t\t\te.changedTouches = [e];\n\n\t\t\thandler(e);\n\t\t};\n\n\t\tobj[pre + 'touchend' + id] = cb;\n\t\tobj.addEventListener(this.POINTER_UP, cb, false);\n\t\tobj.addEventListener(this.POINTER_CANCEL, cb, false);\n\n\t\treturn this;\n\t},\n\n\tremovePointerListener: function (obj, type, id) {\n\t\tvar pre = '_leaflet_',\n\t\t    cb = obj[pre + type + id];\n\n\t\tswitch (type) {\n\t\tcase 'touchstart':\n\t\t\tobj.removeEventListener(this.POINTER_DOWN, cb, false);\n\t\t\tbreak;\n\t\tcase 'touchmove':\n\t\t\tobj.removeEventListener(this.POINTER_MOVE, cb, false);\n\t\t\tbreak;\n\t\tcase 'touchend':\n\t\t\tobj.removeEventListener(this.POINTER_UP, cb, false);\n\t\t\tobj.removeEventListener(this.POINTER_CANCEL, cb, false);\n\t\t\tbreak;\n\t\t}\n\n\t\treturn this;\n\t}\n});\n\n\n/*\n * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.\n */\n\nL.Map.mergeOptions({\n\ttouchZoom: L.Browser.touch && !L.Browser.android23,\n\tbounceAtZoomLimits: true\n});\n\nL.Map.TouchZoom = L.Handler.extend({\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);\n\t},\n\n\t_onTouchStart: function (e) {\n\t\tvar map = this._map;\n\n\t\tif (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }\n\n\t\tvar p1 = map.mouseEventToLayerPoint(e.touches[0]),\n\t\t    p2 = map.mouseEventToLayerPoint(e.touches[1]),\n\t\t    viewCenter = map._getCenterLayerPoint();\n\n\t\tthis._startCenter = p1.add(p2)._divideBy(2);\n\t\tthis._startDist = p1.distanceTo(p2);\n\n\t\tthis._moved = false;\n\t\tthis._zooming = true;\n\n\t\tthis._centerOffset = viewCenter.subtract(this._startCenter);\n\n\t\tif (map._panAnim) {\n\t\t\tmap._panAnim.stop();\n\t\t}\n\n\t\tL.DomEvent\n\t\t    .on(document, 'touchmove', this._onTouchMove, this)\n\t\t    .on(document, 'touchend', this._onTouchEnd, this);\n\n\t\tL.DomEvent.preventDefault(e);\n\t},\n\n\t_onTouchMove: function (e) {\n\t\tvar map = this._map;\n\n\t\tif (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }\n\n\t\tvar p1 = map.mouseEventToLayerPoint(e.touches[0]),\n\t\t    p2 = map.mouseEventToLayerPoint(e.touches[1]);\n\n\t\tthis._scale = p1.distanceTo(p2) / this._startDist;\n\t\tthis._delta = p1._add(p2)._divideBy(2)._subtract(this._startCenter);\n\n\t\tif (this._scale === 1) { return; }\n\n\t\tif (!map.options.bounceAtZoomLimits) {\n\t\t\tif ((map.getZoom() === map.getMinZoom() && this._scale < 1) ||\n\t\t\t    (map.getZoom() === map.getMaxZoom() && this._scale > 1)) { return; }\n\t\t}\n\n\t\tif (!this._moved) {\n\t\t\tL.DomUtil.addClass(map._mapPane, 'leaflet-touching');\n\n\t\t\tmap\n\t\t\t    .fire('movestart')\n\t\t\t    .fire('zoomstart');\n\n\t\t\tthis._moved = true;\n\t\t}\n\n\t\tL.Util.cancelAnimFrame(this._animRequest);\n\t\tthis._animRequest = L.Util.requestAnimFrame(\n\t\t        this._updateOnMove, this, true, this._map._container);\n\n\t\tL.DomEvent.preventDefault(e);\n\t},\n\n\t_updateOnMove: function () {\n\t\tvar map = this._map,\n\t\t    origin = this._getScaleOrigin(),\n\t\t    center = map.layerPointToLatLng(origin),\n\t\t    zoom = map.getScaleZoom(this._scale);\n\n\t\tmap._animateZoom(center, zoom, this._startCenter, this._scale, this._delta, false, true);\n\t},\n\n\t_onTouchEnd: function () {\n\t\tif (!this._moved || !this._zooming) {\n\t\t\tthis._zooming = false;\n\t\t\treturn;\n\t\t}\n\n\t\tvar map = this._map;\n\n\t\tthis._zooming = false;\n\t\tL.DomUtil.removeClass(map._mapPane, 'leaflet-touching');\n\t\tL.Util.cancelAnimFrame(this._animRequest);\n\n\t\tL.DomEvent\n\t\t    .off(document, 'touchmove', this._onTouchMove)\n\t\t    .off(document, 'touchend', this._onTouchEnd);\n\n\t\tvar origin = this._getScaleOrigin(),\n\t\t    center = map.layerPointToLatLng(origin),\n\n\t\t    oldZoom = map.getZoom(),\n\t\t    floatZoomDelta = map.getScaleZoom(this._scale) - oldZoom,\n\t\t    roundZoomDelta = (floatZoomDelta > 0 ?\n\t\t            Math.ceil(floatZoomDelta) : Math.floor(floatZoomDelta)),\n\n\t\t    zoom = map._limitZoom(oldZoom + roundZoomDelta),\n\t\t    scale = map.getZoomScale(zoom) / this._scale;\n\n\t\tmap._animateZoom(center, zoom, origin, scale);\n\t},\n\n\t_getScaleOrigin: function () {\n\t\tvar centerOffset = this._centerOffset.subtract(this._delta).divideBy(this._scale);\n\t\treturn this._startCenter.add(centerOffset);\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);\n\n\n/*\n * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.\n */\n\nL.Map.mergeOptions({\n\ttap: true,\n\ttapTolerance: 15\n});\n\nL.Map.Tap = L.Handler.extend({\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._map._container, 'touchstart', this._onDown, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._map._container, 'touchstart', this._onDown, this);\n\t},\n\n\t_onDown: function (e) {\n\t\tif (!e.touches) { return; }\n\n\t\tL.DomEvent.preventDefault(e);\n\n\t\tthis._fireClick = true;\n\n\t\t// don't simulate click or track longpress if more than 1 touch\n\t\tif (e.touches.length > 1) {\n\t\t\tthis._fireClick = false;\n\t\t\tclearTimeout(this._holdTimeout);\n\t\t\treturn;\n\t\t}\n\n\t\tvar first = e.touches[0],\n\t\t    el = first.target;\n\n\t\tthis._startPos = this._newPos = new L.Point(first.clientX, first.clientY);\n\n\t\t// if touching a link, highlight it\n\t\tif (el.tagName && el.tagName.toLowerCase() === 'a') {\n\t\t\tL.DomUtil.addClass(el, 'leaflet-active');\n\t\t}\n\n\t\t// simulate long hold but setting a timeout\n\t\tthis._holdTimeout = setTimeout(L.bind(function () {\n\t\t\tif (this._isTapValid()) {\n\t\t\t\tthis._fireClick = false;\n\t\t\t\tthis._onUp();\n\t\t\t\tthis._simulateEvent('contextmenu', first);\n\t\t\t}\n\t\t}, this), 1000);\n\n\t\tL.DomEvent\n\t\t\t.on(document, 'touchmove', this._onMove, this)\n\t\t\t.on(document, 'touchend', this._onUp, this);\n\t},\n\n\t_onUp: function (e) {\n\t\tclearTimeout(this._holdTimeout);\n\n\t\tL.DomEvent\n\t\t\t.off(document, 'touchmove', this._onMove, this)\n\t\t\t.off(document, 'touchend', this._onUp, this);\n\n\t\tif (this._fireClick && e && e.changedTouches) {\n\n\t\t\tvar first = e.changedTouches[0],\n\t\t\t    el = first.target;\n\n\t\t\tif (el && el.tagName && el.tagName.toLowerCase() === 'a') {\n\t\t\t\tL.DomUtil.removeClass(el, 'leaflet-active');\n\t\t\t}\n\n\t\t\t// simulate click if the touch didn't move too much\n\t\t\tif (this._isTapValid()) {\n\t\t\t\tthis._simulateEvent('click', first);\n\t\t\t}\n\t\t}\n\t},\n\n\t_isTapValid: function () {\n\t\treturn this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;\n\t},\n\n\t_onMove: function (e) {\n\t\tvar first = e.touches[0];\n\t\tthis._newPos = new L.Point(first.clientX, first.clientY);\n\t},\n\n\t_simulateEvent: function (type, e) {\n\t\tvar simulatedEvent = document.createEvent('MouseEvents');\n\n\t\tsimulatedEvent._simulated = true;\n\t\te.target._simulatedClick = true;\n\n\t\tsimulatedEvent.initMouseEvent(\n\t\t        type, true, true, window, 1,\n\t\t        e.screenX, e.screenY,\n\t\t        e.clientX, e.clientY,\n\t\t        false, false, false, false, 0, null);\n\n\t\te.target.dispatchEvent(simulatedEvent);\n\t}\n});\n\nif (L.Browser.touch && !L.Browser.pointer) {\n\tL.Map.addInitHook('addHandler', 'tap', L.Map.Tap);\n}\n\n\n/*\n * L.Handler.ShiftDragZoom is used to add shift-drag zoom interaction to the map\n  * (zoom to a selected bounding box), enabled by default.\n */\n\nL.Map.mergeOptions({\n\tboxZoom: true\n});\n\nL.Map.BoxZoom = L.Handler.extend({\n\tinitialize: function (map) {\n\t\tthis._map = map;\n\t\tthis._container = map._container;\n\t\tthis._pane = map._panes.overlayPane;\n\t\tthis._moved = false;\n\t},\n\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._container, 'mousedown', this._onMouseDown);\n\t\tthis._moved = false;\n\t},\n\n\tmoved: function () {\n\t\treturn this._moved;\n\t},\n\n\t_onMouseDown: function (e) {\n\t\tthis._moved = false;\n\n\t\tif (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }\n\n\t\tL.DomUtil.disableTextSelection();\n\t\tL.DomUtil.disableImageDrag();\n\n\t\tthis._startLayerPoint = this._map.mouseEventToLayerPoint(e);\n\n\t\tL.DomEvent\n\t\t    .on(document, 'mousemove', this._onMouseMove, this)\n\t\t    .on(document, 'mouseup', this._onMouseUp, this)\n\t\t    .on(document, 'keydown', this._onKeyDown, this);\n\t},\n\n\t_onMouseMove: function (e) {\n\t\tif (!this._moved) {\n\t\t\tthis._box = L.DomUtil.create('div', 'leaflet-zoom-box', this._pane);\n\t\t\tL.DomUtil.setPosition(this._box, this._startLayerPoint);\n\n\t\t\t//TODO refactor: move cursor to styles\n\t\t\tthis._container.style.cursor = 'crosshair';\n\t\t\tthis._map.fire('boxzoomstart');\n\t\t}\n\n\t\tvar startPoint = this._startLayerPoint,\n\t\t    box = this._box,\n\n\t\t    layerPoint = this._map.mouseEventToLayerPoint(e),\n\t\t    offset = layerPoint.subtract(startPoint),\n\n\t\t    newPos = new L.Point(\n\t\t        Math.min(layerPoint.x, startPoint.x),\n\t\t        Math.min(layerPoint.y, startPoint.y));\n\n\t\tL.DomUtil.setPosition(box, newPos);\n\n\t\tthis._moved = true;\n\n\t\t// TODO refactor: remove hardcoded 4 pixels\n\t\tbox.style.width  = (Math.max(0, Math.abs(offset.x) - 4)) + 'px';\n\t\tbox.style.height = (Math.max(0, Math.abs(offset.y) - 4)) + 'px';\n\t},\n\n\t_finish: function () {\n\t\tif (this._moved) {\n\t\t\tthis._pane.removeChild(this._box);\n\t\t\tthis._container.style.cursor = '';\n\t\t}\n\n\t\tL.DomUtil.enableTextSelection();\n\t\tL.DomUtil.enableImageDrag();\n\n\t\tL.DomEvent\n\t\t    .off(document, 'mousemove', this._onMouseMove)\n\t\t    .off(document, 'mouseup', this._onMouseUp)\n\t\t    .off(document, 'keydown', this._onKeyDown);\n\t},\n\n\t_onMouseUp: function (e) {\n\n\t\tthis._finish();\n\n\t\tvar map = this._map,\n\t\t    layerPoint = map.mouseEventToLayerPoint(e);\n\n\t\tif (this._startLayerPoint.equals(layerPoint)) { return; }\n\n\t\tvar bounds = new L.LatLngBounds(\n\t\t        map.layerPointToLatLng(this._startLayerPoint),\n\t\t        map.layerPointToLatLng(layerPoint));\n\n\t\tmap.fitBounds(bounds);\n\n\t\tmap.fire('boxzoomend', {\n\t\t\tboxZoomBounds: bounds\n\t\t});\n\t},\n\n\t_onKeyDown: function (e) {\n\t\tif (e.keyCode === 27) {\n\t\t\tthis._finish();\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'boxZoom', L.Map.BoxZoom);\n\n\n/*\n * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.\n */\n\nL.Map.mergeOptions({\n\tkeyboard: true,\n\tkeyboardPanOffset: 80,\n\tkeyboardZoomOffset: 1\n});\n\nL.Map.Keyboard = L.Handler.extend({\n\n\tkeyCodes: {\n\t\tleft:    [37],\n\t\tright:   [39],\n\t\tdown:    [40],\n\t\tup:      [38],\n\t\tzoomIn:  [187, 107, 61, 171],\n\t\tzoomOut: [189, 109, 173]\n\t},\n\n\tinitialize: function (map) {\n\t\tthis._map = map;\n\n\t\tthis._setPanOffset(map.options.keyboardPanOffset);\n\t\tthis._setZoomOffset(map.options.keyboardZoomOffset);\n\t},\n\n\taddHooks: function () {\n\t\tvar container = this._map._container;\n\n\t\t// make the container focusable by tabbing\n\t\tif (container.tabIndex === -1) {\n\t\t\tcontainer.tabIndex = '0';\n\t\t}\n\n\t\tL.DomEvent\n\t\t    .on(container, 'focus', this._onFocus, this)\n\t\t    .on(container, 'blur', this._onBlur, this)\n\t\t    .on(container, 'mousedown', this._onMouseDown, this);\n\n\t\tthis._map\n\t\t    .on('focus', this._addHooks, this)\n\t\t    .on('blur', this._removeHooks, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._removeHooks();\n\n\t\tvar container = this._map._container;\n\n\t\tL.DomEvent\n\t\t    .off(container, 'focus', this._onFocus, this)\n\t\t    .off(container, 'blur', this._onBlur, this)\n\t\t    .off(container, 'mousedown', this._onMouseDown, this);\n\n\t\tthis._map\n\t\t    .off('focus', this._addHooks, this)\n\t\t    .off('blur', this._removeHooks, this);\n\t},\n\n\t_onMouseDown: function () {\n\t\tif (this._focused) { return; }\n\n\t\tvar body = document.body,\n\t\t    docEl = document.documentElement,\n\t\t    top = body.scrollTop || docEl.scrollTop,\n\t\t    left = body.scrollLeft || docEl.scrollLeft;\n\n\t\tthis._map._container.focus();\n\n\t\twindow.scrollTo(left, top);\n\t},\n\n\t_onFocus: function () {\n\t\tthis._focused = true;\n\t\tthis._map.fire('focus');\n\t},\n\n\t_onBlur: function () {\n\t\tthis._focused = false;\n\t\tthis._map.fire('blur');\n\t},\n\n\t_setPanOffset: function (pan) {\n\t\tvar keys = this._panKeys = {},\n\t\t    codes = this.keyCodes,\n\t\t    i, len;\n\n\t\tfor (i = 0, len = codes.left.length; i < len; i++) {\n\t\t\tkeys[codes.left[i]] = [-1 * pan, 0];\n\t\t}\n\t\tfor (i = 0, len = codes.right.length; i < len; i++) {\n\t\t\tkeys[codes.right[i]] = [pan, 0];\n\t\t}\n\t\tfor (i = 0, len = codes.down.length; i < len; i++) {\n\t\t\tkeys[codes.down[i]] = [0, pan];\n\t\t}\n\t\tfor (i = 0, len = codes.up.length; i < len; i++) {\n\t\t\tkeys[codes.up[i]] = [0, -1 * pan];\n\t\t}\n\t},\n\n\t_setZoomOffset: function (zoom) {\n\t\tvar keys = this._zoomKeys = {},\n\t\t    codes = this.keyCodes,\n\t\t    i, len;\n\n\t\tfor (i = 0, len = codes.zoomIn.length; i < len; i++) {\n\t\t\tkeys[codes.zoomIn[i]] = zoom;\n\t\t}\n\t\tfor (i = 0, len = codes.zoomOut.length; i < len; i++) {\n\t\t\tkeys[codes.zoomOut[i]] = -zoom;\n\t\t}\n\t},\n\n\t_addHooks: function () {\n\t\tL.DomEvent.on(document, 'keydown', this._onKeyDown, this);\n\t},\n\n\t_removeHooks: function () {\n\t\tL.DomEvent.off(document, 'keydown', this._onKeyDown, this);\n\t},\n\n\t_onKeyDown: function (e) {\n\t\tvar key = e.keyCode,\n\t\t    map = this._map;\n\n\t\tif (key in this._panKeys) {\n\n\t\t\tif (map._panAnim && map._panAnim._inProgress) { return; }\n\n\t\t\tmap.panBy(this._panKeys[key]);\n\n\t\t\tif (map.options.maxBounds) {\n\t\t\t\tmap.panInsideBounds(map.options.maxBounds);\n\t\t\t}\n\n\t\t} else if (key in this._zoomKeys) {\n\t\t\tmap.setZoom(map.getZoom() + this._zoomKeys[key]);\n\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\n\t\tL.DomEvent.stop(e);\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'keyboard', L.Map.Keyboard);\n\n\n/*\n * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.\n */\n\nL.Handler.MarkerDrag = L.Handler.extend({\n\tinitialize: function (marker) {\n\t\tthis._marker = marker;\n\t},\n\n\taddHooks: function () {\n\t\tvar icon = this._marker._icon;\n\t\tif (!this._draggable) {\n\t\t\tthis._draggable = new L.Draggable(icon, icon);\n\t\t}\n\n\t\tthis._draggable\n\t\t\t.on('dragstart', this._onDragStart, this)\n\t\t\t.on('drag', this._onDrag, this)\n\t\t\t.on('dragend', this._onDragEnd, this);\n\t\tthis._draggable.enable();\n\t\tL.DomUtil.addClass(this._marker._icon, 'leaflet-marker-draggable');\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._draggable\n\t\t\t.off('dragstart', this._onDragStart, this)\n\t\t\t.off('drag', this._onDrag, this)\n\t\t\t.off('dragend', this._onDragEnd, this);\n\n\t\tthis._draggable.disable();\n\t\tL.DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');\n\t},\n\n\tmoved: function () {\n\t\treturn this._draggable && this._draggable._moved;\n\t},\n\n\t_onDragStart: function () {\n\t\tthis._marker\n\t\t    .closePopup()\n\t\t    .fire('movestart')\n\t\t    .fire('dragstart');\n\t},\n\n\t_onDrag: function () {\n\t\tvar marker = this._marker,\n\t\t    shadow = marker._shadow,\n\t\t    iconPos = L.DomUtil.getPosition(marker._icon),\n\t\t    latlng = marker._map.layerPointToLatLng(iconPos);\n\n\t\t// update shadow position\n\t\tif (shadow) {\n\t\t\tL.DomUtil.setPosition(shadow, iconPos);\n\t\t}\n\n\t\tmarker._latlng = latlng;\n\n\t\tmarker\n\t\t    .fire('move', {latlng: latlng})\n\t\t    .fire('drag');\n\t},\n\n\t_onDragEnd: function (e) {\n\t\tthis._marker\n\t\t    .fire('moveend')\n\t\t    .fire('dragend', e);\n\t}\n});\n\n\n/*\r\n * L.Control is a base class for implementing map controls. Handles positioning.\r\n * All other controls extend from this class.\r\n */\r\n\r\nL.Control = L.Class.extend({\r\n\toptions: {\r\n\t\tposition: 'topright'\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tgetPosition: function () {\r\n\t\treturn this.options.position;\r\n\t},\r\n\r\n\tsetPosition: function (position) {\r\n\t\tvar map = this._map;\r\n\r\n\t\tif (map) {\r\n\t\t\tmap.removeControl(this);\r\n\t\t}\r\n\r\n\t\tthis.options.position = position;\r\n\r\n\t\tif (map) {\r\n\t\t\tmap.addControl(this);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetContainer: function () {\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tvar container = this._container = this.onAdd(map),\r\n\t\t    pos = this.getPosition(),\r\n\t\t    corner = map._controlCorners[pos];\r\n\r\n\t\tL.DomUtil.addClass(container, 'leaflet-control');\r\n\r\n\t\tif (pos.indexOf('bottom') !== -1) {\r\n\t\t\tcorner.insertBefore(container, corner.firstChild);\r\n\t\t} else {\r\n\t\t\tcorner.appendChild(container);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveFrom: function (map) {\r\n\t\tvar pos = this.getPosition(),\r\n\t\t    corner = map._controlCorners[pos];\r\n\r\n\t\tcorner.removeChild(this._container);\r\n\t\tthis._map = null;\r\n\r\n\t\tif (this.onRemove) {\r\n\t\t\tthis.onRemove(map);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_refocusOnMap: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._map.getContainer().focus();\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.control = function (options) {\r\n\treturn new L.Control(options);\r\n};\r\n\r\n\r\n// adds control-related methods to L.Map\r\n\r\nL.Map.include({\r\n\taddControl: function (control) {\r\n\t\tcontrol.addTo(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveControl: function (control) {\r\n\t\tcontrol.removeFrom(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_initControlPos: function () {\r\n\t\tvar corners = this._controlCorners = {},\r\n\t\t    l = 'leaflet-',\r\n\t\t    container = this._controlContainer =\r\n\t\t            L.DomUtil.create('div', l + 'control-container', this._container);\r\n\r\n\t\tfunction createCorner(vSide, hSide) {\r\n\t\t\tvar className = l + vSide + ' ' + l + hSide;\r\n\r\n\t\t\tcorners[vSide + hSide] = L.DomUtil.create('div', className, container);\r\n\t\t}\r\n\r\n\t\tcreateCorner('top', 'left');\r\n\t\tcreateCorner('top', 'right');\r\n\t\tcreateCorner('bottom', 'left');\r\n\t\tcreateCorner('bottom', 'right');\r\n\t},\r\n\r\n\t_clearControlPos: function () {\r\n\t\tthis._container.removeChild(this._controlContainer);\r\n\t}\r\n});\r\n\n\n/*\r\n * L.Control.Zoom is used for the default zoom buttons on the map.\r\n */\r\n\r\nL.Control.Zoom = L.Control.extend({\r\n\toptions: {\r\n\t\tposition: 'topleft',\r\n\t\tzoomInText: '+',\r\n\t\tzoomInTitle: 'Zoom in',\r\n\t\tzoomOutText: '-',\r\n\t\tzoomOutTitle: 'Zoom out'\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tvar zoomName = 'leaflet-control-zoom',\r\n\t\t    container = L.DomUtil.create('div', zoomName + ' leaflet-bar');\r\n\r\n\t\tthis._map = map;\r\n\r\n\t\tthis._zoomInButton  = this._createButton(\r\n\t\t        this.options.zoomInText, this.options.zoomInTitle,\r\n\t\t        zoomName + '-in',  container, this._zoomIn,  this);\r\n\t\tthis._zoomOutButton = this._createButton(\r\n\t\t        this.options.zoomOutText, this.options.zoomOutTitle,\r\n\t\t        zoomName + '-out', container, this._zoomOut, this);\r\n\r\n\t\tthis._updateDisabled();\r\n\t\tmap.on('zoomend zoomlevelschange', this._updateDisabled, this);\r\n\r\n\t\treturn container;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap.off('zoomend zoomlevelschange', this._updateDisabled, this);\r\n\t},\r\n\r\n\t_zoomIn: function (e) {\r\n\t\tthis._map.zoomIn(e.shiftKey ? 3 : 1);\r\n\t},\r\n\r\n\t_zoomOut: function (e) {\r\n\t\tthis._map.zoomOut(e.shiftKey ? 3 : 1);\r\n\t},\r\n\r\n\t_createButton: function (html, title, className, container, fn, context) {\r\n\t\tvar link = L.DomUtil.create('a', className, container);\r\n\t\tlink.innerHTML = html;\r\n\t\tlink.href = '#';\r\n\t\tlink.title = title;\r\n\r\n\t\tvar stop = L.DomEvent.stopPropagation;\r\n\r\n\t\tL.DomEvent\r\n\t\t    .on(link, 'click', stop)\r\n\t\t    .on(link, 'mousedown', stop)\r\n\t\t    .on(link, 'dblclick', stop)\r\n\t\t    .on(link, 'click', L.DomEvent.preventDefault)\r\n\t\t    .on(link, 'click', fn, context)\r\n\t\t    .on(link, 'click', this._refocusOnMap, context);\r\n\r\n\t\treturn link;\r\n\t},\r\n\r\n\t_updateDisabled: function () {\r\n\t\tvar map = this._map,\r\n\t\t\tclassName = 'leaflet-disabled';\r\n\r\n\t\tL.DomUtil.removeClass(this._zoomInButton, className);\r\n\t\tL.DomUtil.removeClass(this._zoomOutButton, className);\r\n\r\n\t\tif (map._zoom === map.getMinZoom()) {\r\n\t\t\tL.DomUtil.addClass(this._zoomOutButton, className);\r\n\t\t}\r\n\t\tif (map._zoom === map.getMaxZoom()) {\r\n\t\t\tL.DomUtil.addClass(this._zoomInButton, className);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Map.mergeOptions({\r\n\tzoomControl: true\r\n});\r\n\r\nL.Map.addInitHook(function () {\r\n\tif (this.options.zoomControl) {\r\n\t\tthis.zoomControl = new L.Control.Zoom();\r\n\t\tthis.addControl(this.zoomControl);\r\n\t}\r\n});\r\n\r\nL.control.zoom = function (options) {\r\n\treturn new L.Control.Zoom(options);\r\n};\r\n\r\n\n\n/*\r\n * L.Control.Attribution is used for displaying attribution on the map (added by default).\r\n */\r\n\r\nL.Control.Attribution = L.Control.extend({\r\n\toptions: {\r\n\t\tposition: 'bottomright',\r\n\t\tprefix: '<a href=\"http://leafletjs.com\" title=\"A JS library for interactive maps\">Leaflet</a>'\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._attributions = {};\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._container = L.DomUtil.create('div', 'leaflet-control-attribution');\r\n\t\tL.DomEvent.disableClickPropagation(this._container);\r\n\r\n\t\tfor (var i in map._layers) {\r\n\t\t\tif (map._layers[i].getAttribution) {\r\n\t\t\t\tthis.addAttribution(map._layers[i].getAttribution());\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tmap\r\n\t\t    .on('layeradd', this._onLayerAdd, this)\r\n\t\t    .on('layerremove', this._onLayerRemove, this);\r\n\r\n\t\tthis._update();\r\n\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap\r\n\t\t    .off('layeradd', this._onLayerAdd)\r\n\t\t    .off('layerremove', this._onLayerRemove);\r\n\r\n\t},\r\n\r\n\tsetPrefix: function (prefix) {\r\n\t\tthis.options.prefix = prefix;\r\n\t\tthis._update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\taddAttribution: function (text) {\r\n\t\tif (!text) { return; }\r\n\r\n\t\tif (!this._attributions[text]) {\r\n\t\t\tthis._attributions[text] = 0;\r\n\t\t}\r\n\t\tthis._attributions[text]++;\r\n\r\n\t\tthis._update();\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveAttribution: function (text) {\r\n\t\tif (!text) { return; }\r\n\r\n\t\tif (this._attributions[text]) {\r\n\t\t\tthis._attributions[text]--;\r\n\t\t\tthis._update();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_update: function () {\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tvar attribs = [];\r\n\r\n\t\tfor (var i in this._attributions) {\r\n\t\t\tif (this._attributions[i]) {\r\n\t\t\t\tattribs.push(i);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar prefixAndAttribs = [];\r\n\r\n\t\tif (this.options.prefix) {\r\n\t\t\tprefixAndAttribs.push(this.options.prefix);\r\n\t\t}\r\n\t\tif (attribs.length) {\r\n\t\t\tprefixAndAttribs.push(attribs.join(', '));\r\n\t\t}\r\n\r\n\t\tthis._container.innerHTML = prefixAndAttribs.join(' | ');\r\n\t},\r\n\r\n\t_onLayerAdd: function (e) {\r\n\t\tif (e.layer.getAttribution) {\r\n\t\t\tthis.addAttribution(e.layer.getAttribution());\r\n\t\t}\r\n\t},\r\n\r\n\t_onLayerRemove: function (e) {\r\n\t\tif (e.layer.getAttribution) {\r\n\t\t\tthis.removeAttribution(e.layer.getAttribution());\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Map.mergeOptions({\r\n\tattributionControl: true\r\n});\r\n\r\nL.Map.addInitHook(function () {\r\n\tif (this.options.attributionControl) {\r\n\t\tthis.attributionControl = (new L.Control.Attribution()).addTo(this);\r\n\t}\r\n});\r\n\r\nL.control.attribution = function (options) {\r\n\treturn new L.Control.Attribution(options);\r\n};\r\n\n\n/*\n * L.Control.Scale is used for displaying metric/imperial scale on the map.\n */\n\nL.Control.Scale = L.Control.extend({\n\toptions: {\n\t\tposition: 'bottomleft',\n\t\tmaxWidth: 100,\n\t\tmetric: true,\n\t\timperial: true,\n\t\tupdateWhenIdle: false\n\t},\n\n\tonAdd: function (map) {\n\t\tthis._map = map;\n\n\t\tvar className = 'leaflet-control-scale',\n\t\t    container = L.DomUtil.create('div', className),\n\t\t    options = this.options;\n\n\t\tthis._addScales(options, className, container);\n\n\t\tmap.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n\t\tmap.whenReady(this._update, this);\n\n\t\treturn container;\n\t},\n\n\tonRemove: function (map) {\n\t\tmap.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n\t},\n\n\t_addScales: function (options, className, container) {\n\t\tif (options.metric) {\n\t\t\tthis._mScale = L.DomUtil.create('div', className + '-line', container);\n\t\t}\n\t\tif (options.imperial) {\n\t\t\tthis._iScale = L.DomUtil.create('div', className + '-line', container);\n\t\t}\n\t},\n\n\t_update: function () {\n\t\tvar bounds = this._map.getBounds(),\n\t\t    centerLat = bounds.getCenter().lat,\n\t\t    halfWorldMeters = 6378137 * Math.PI * Math.cos(centerLat * Math.PI / 180),\n\t\t    dist = halfWorldMeters * (bounds.getNorthEast().lng - bounds.getSouthWest().lng) / 180,\n\n\t\t    size = this._map.getSize(),\n\t\t    options = this.options,\n\t\t    maxMeters = 0;\n\n\t\tif (size.x > 0) {\n\t\t\tmaxMeters = dist * (options.maxWidth / size.x);\n\t\t}\n\n\t\tthis._updateScales(options, maxMeters);\n\t},\n\n\t_updateScales: function (options, maxMeters) {\n\t\tif (options.metric && maxMeters) {\n\t\t\tthis._updateMetric(maxMeters);\n\t\t}\n\n\t\tif (options.imperial && maxMeters) {\n\t\t\tthis._updateImperial(maxMeters);\n\t\t}\n\t},\n\n\t_updateMetric: function (maxMeters) {\n\t\tvar meters = this._getRoundNum(maxMeters);\n\n\t\tthis._mScale.style.width = this._getScaleWidth(meters / maxMeters) + 'px';\n\t\tthis._mScale.innerHTML = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';\n\t},\n\n\t_updateImperial: function (maxMeters) {\n\t\tvar maxFeet = maxMeters * 3.2808399,\n\t\t    scale = this._iScale,\n\t\t    maxMiles, miles, feet;\n\n\t\tif (maxFeet > 5280) {\n\t\t\tmaxMiles = maxFeet / 5280;\n\t\t\tmiles = this._getRoundNum(maxMiles);\n\n\t\t\tscale.style.width = this._getScaleWidth(miles / maxMiles) + 'px';\n\t\t\tscale.innerHTML = miles + ' mi';\n\n\t\t} else {\n\t\t\tfeet = this._getRoundNum(maxFeet);\n\n\t\t\tscale.style.width = this._getScaleWidth(feet / maxFeet) + 'px';\n\t\t\tscale.innerHTML = feet + ' ft';\n\t\t}\n\t},\n\n\t_getScaleWidth: function (ratio) {\n\t\treturn Math.round(this.options.maxWidth * ratio) - 10;\n\t},\n\n\t_getRoundNum: function (num) {\n\t\tvar pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),\n\t\t    d = num / pow10;\n\n\t\td = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;\n\n\t\treturn pow10 * d;\n\t}\n});\n\nL.control.scale = function (options) {\n\treturn new L.Control.Scale(options);\n};\n\n\n/*\r\n * L.Control.Layers is a control to allow users to switch between different layers on the map.\r\n */\r\n\r\nL.Control.Layers = L.Control.extend({\r\n\toptions: {\r\n\t\tcollapsed: true,\r\n\t\tposition: 'topright',\r\n\t\tautoZIndex: true\r\n\t},\r\n\r\n\tinitialize: function (baseLayers, overlays, options) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._layers = {};\r\n\t\tthis._lastZIndex = 0;\r\n\t\tthis._handlingClick = false;\r\n\r\n\t\tfor (var i in baseLayers) {\r\n\t\t\tthis._addLayer(baseLayers[i], i);\r\n\t\t}\r\n\r\n\t\tfor (i in overlays) {\r\n\t\t\tthis._addLayer(overlays[i], i, true);\r\n\t\t}\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._initLayout();\r\n\t\tthis._update();\r\n\r\n\t\tmap\r\n\t\t    .on('layeradd', this._onLayerChange, this)\r\n\t\t    .on('layerremove', this._onLayerChange, this);\r\n\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap\r\n\t\t    .off('layeradd', this._onLayerChange, this)\r\n\t\t    .off('layerremove', this._onLayerChange, this);\r\n\t},\r\n\r\n\taddBaseLayer: function (layer, name) {\r\n\t\tthis._addLayer(layer, name);\r\n\t\tthis._update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\taddOverlay: function (layer, name) {\r\n\t\tthis._addLayer(layer, name, true);\r\n\t\tthis._update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\t\tvar id = L.stamp(layer);\r\n\t\tdelete this._layers[id];\r\n\t\tthis._update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_initLayout: function () {\r\n\t\tvar className = 'leaflet-control-layers',\r\n\t\t    container = this._container = L.DomUtil.create('div', className);\r\n\r\n\t\t//Makes this work on IE10 Touch devices by stopping it from firing a mouseout event when the touch is released\r\n\t\tcontainer.setAttribute('aria-haspopup', true);\r\n\r\n\t\tif (!L.Browser.touch) {\r\n\t\t\tL.DomEvent\r\n\t\t\t\t.disableClickPropagation(container)\r\n\t\t\t\t.disableScrollPropagation(container);\r\n\t\t} else {\r\n\t\t\tL.DomEvent.on(container, 'click', L.DomEvent.stopPropagation);\r\n\t\t}\r\n\r\n\t\tvar form = this._form = L.DomUtil.create('form', className + '-list');\r\n\r\n\t\tif (this.options.collapsed) {\r\n\t\t\tif (!L.Browser.android) {\r\n\t\t\t\tL.DomEvent\r\n\t\t\t\t    .on(container, 'mouseover', this._expand, this)\r\n\t\t\t\t    .on(container, 'mouseout', this._collapse, this);\r\n\t\t\t}\r\n\t\t\tvar link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);\r\n\t\t\tlink.href = '#';\r\n\t\t\tlink.title = 'Layers';\r\n\r\n\t\t\tif (L.Browser.touch) {\r\n\t\t\t\tL.DomEvent\r\n\t\t\t\t    .on(link, 'click', L.DomEvent.stop)\r\n\t\t\t\t    .on(link, 'click', this._expand, this);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tL.DomEvent.on(link, 'focus', this._expand, this);\r\n\t\t\t}\r\n\t\t\t//Work around for Firefox android issue https://github.com/Leaflet/Leaflet/issues/2033\r\n\t\t\tL.DomEvent.on(form, 'click', function () {\r\n\t\t\t\tsetTimeout(L.bind(this._onInputClick, this), 0);\r\n\t\t\t}, this);\r\n\r\n\t\t\tthis._map.on('click', this._collapse, this);\r\n\t\t\t// TODO keyboard accessibility\r\n\t\t} else {\r\n\t\t\tthis._expand();\r\n\t\t}\r\n\r\n\t\tthis._baseLayersList = L.DomUtil.create('div', className + '-base', form);\r\n\t\tthis._separator = L.DomUtil.create('div', className + '-separator', form);\r\n\t\tthis._overlaysList = L.DomUtil.create('div', className + '-overlays', form);\r\n\r\n\t\tcontainer.appendChild(form);\r\n\t},\r\n\r\n\t_addLayer: function (layer, name, overlay) {\r\n\t\tvar id = L.stamp(layer);\r\n\r\n\t\tthis._layers[id] = {\r\n\t\t\tlayer: layer,\r\n\t\t\tname: name,\r\n\t\t\toverlay: overlay\r\n\t\t};\r\n\r\n\t\tif (this.options.autoZIndex && layer.setZIndex) {\r\n\t\t\tthis._lastZIndex++;\r\n\t\t\tlayer.setZIndex(this._lastZIndex);\r\n\t\t}\r\n\t},\r\n\r\n\t_update: function () {\r\n\t\tif (!this._container) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._baseLayersList.innerHTML = '';\r\n\t\tthis._overlaysList.innerHTML = '';\r\n\r\n\t\tvar baseLayersPresent = false,\r\n\t\t    overlaysPresent = false,\r\n\t\t    i, obj;\r\n\r\n\t\tfor (i in this._layers) {\r\n\t\t\tobj = this._layers[i];\r\n\t\t\tthis._addItem(obj);\r\n\t\t\toverlaysPresent = overlaysPresent || obj.overlay;\r\n\t\t\tbaseLayersPresent = baseLayersPresent || !obj.overlay;\r\n\t\t}\r\n\r\n\t\tthis._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';\r\n\t},\r\n\r\n\t_onLayerChange: function (e) {\r\n\t\tvar obj = this._layers[L.stamp(e.layer)];\r\n\r\n\t\tif (!obj) { return; }\r\n\r\n\t\tif (!this._handlingClick) {\r\n\t\t\tthis._update();\r\n\t\t}\r\n\r\n\t\tvar type = obj.overlay ?\r\n\t\t\t(e.type === 'layeradd' ? 'overlayadd' : 'overlayremove') :\r\n\t\t\t(e.type === 'layeradd' ? 'baselayerchange' : null);\r\n\r\n\t\tif (type) {\r\n\t\t\tthis._map.fire(type, obj);\r\n\t\t}\r\n\t},\r\n\r\n\t// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)\r\n\t_createRadioElement: function (name, checked) {\r\n\r\n\t\tvar radioHtml = '<input type=\"radio\" class=\"leaflet-control-layers-selector\" name=\"' + name + '\"';\r\n\t\tif (checked) {\r\n\t\t\tradioHtml += ' checked=\"checked\"';\r\n\t\t}\r\n\t\tradioHtml += '/>';\r\n\r\n\t\tvar radioFragment = document.createElement('div');\r\n\t\tradioFragment.innerHTML = radioHtml;\r\n\r\n\t\treturn radioFragment.firstChild;\r\n\t},\r\n\r\n\t_addItem: function (obj) {\r\n\t\tvar label = document.createElement('label'),\r\n\t\t    input,\r\n\t\t    checked = this._map.hasLayer(obj.layer);\r\n\r\n\t\tif (obj.overlay) {\r\n\t\t\tinput = document.createElement('input');\r\n\t\t\tinput.type = 'checkbox';\r\n\t\t\tinput.className = 'leaflet-control-layers-selector';\r\n\t\t\tinput.defaultChecked = checked;\r\n\t\t} else {\r\n\t\t\tinput = this._createRadioElement('leaflet-base-layers', checked);\r\n\t\t}\r\n\r\n\t\tinput.layerId = L.stamp(obj.layer);\r\n\r\n\t\tL.DomEvent.on(input, 'click', this._onInputClick, this);\r\n\r\n\t\tvar name = document.createElement('span');\r\n\t\tname.innerHTML = ' ' + obj.name;\r\n\r\n\t\tlabel.appendChild(input);\r\n\t\tlabel.appendChild(name);\r\n\r\n\t\tvar container = obj.overlay ? this._overlaysList : this._baseLayersList;\r\n\t\tcontainer.appendChild(label);\r\n\r\n\t\treturn label;\r\n\t},\r\n\r\n\t_onInputClick: function () {\r\n\t\tvar i, input, obj,\r\n\t\t    inputs = this._form.getElementsByTagName('input'),\r\n\t\t    inputsLen = inputs.length;\r\n\r\n\t\tthis._handlingClick = true;\r\n\r\n\t\tfor (i = 0; i < inputsLen; i++) {\r\n\t\t\tinput = inputs[i];\r\n\t\t\tobj = this._layers[input.layerId];\r\n\r\n\t\t\tif (input.checked && !this._map.hasLayer(obj.layer)) {\r\n\t\t\t\tthis._map.addLayer(obj.layer);\r\n\r\n\t\t\t} else if (!input.checked && this._map.hasLayer(obj.layer)) {\r\n\t\t\t\tthis._map.removeLayer(obj.layer);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._handlingClick = false;\r\n\r\n\t\tthis._refocusOnMap();\r\n\t},\r\n\r\n\t_expand: function () {\r\n\t\tL.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');\r\n\t},\r\n\r\n\t_collapse: function () {\r\n\t\tthis._container.className = this._container.className.replace(' leaflet-control-layers-expanded', '');\r\n\t}\r\n});\r\n\r\nL.control.layers = function (baseLayers, overlays, options) {\r\n\treturn new L.Control.Layers(baseLayers, overlays, options);\r\n};\r\n\n\n/*\n * L.PosAnimation is used by Leaflet internally for pan animations.\n */\n\nL.PosAnimation = L.Class.extend({\n\tincludes: L.Mixin.Events,\n\n\trun: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])\n\t\tthis.stop();\n\n\t\tthis._el = el;\n\t\tthis._inProgress = true;\n\t\tthis._newPos = newPos;\n\n\t\tthis.fire('start');\n\n\t\tel.style[L.DomUtil.TRANSITION] = 'all ' + (duration || 0.25) +\n\t\t        's cubic-bezier(0,0,' + (easeLinearity || 0.5) + ',1)';\n\n\t\tL.DomEvent.on(el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);\n\t\tL.DomUtil.setPosition(el, newPos);\n\n\t\t// toggle reflow, Chrome flickers for some reason if you don't do this\n\t\tL.Util.falseFn(el.offsetWidth);\n\n\t\t// there's no native way to track value updates of transitioned properties, so we imitate this\n\t\tthis._stepTimer = setInterval(L.bind(this._onStep, this), 50);\n\t},\n\n\tstop: function () {\n\t\tif (!this._inProgress) { return; }\n\n\t\t// if we just removed the transition property, the element would jump to its final position,\n\t\t// so we need to make it stay at the current position\n\n\t\tL.DomUtil.setPosition(this._el, this._getPos());\n\t\tthis._onTransitionEnd();\n\t\tL.Util.falseFn(this._el.offsetWidth); // force reflow in case we are about to start a new animation\n\t},\n\n\t_onStep: function () {\n\t\tvar stepPos = this._getPos();\n\t\tif (!stepPos) {\n\t\t\tthis._onTransitionEnd();\n\t\t\treturn;\n\t\t}\n\t\t// jshint camelcase: false\n\t\t// make L.DomUtil.getPosition return intermediate position value during animation\n\t\tthis._el._leaflet_pos = stepPos;\n\n\t\tthis.fire('step');\n\t},\n\n\t// you can't easily get intermediate values of properties animated with CSS3 Transitions,\n\t// we need to parse computed style (in case of transform it returns matrix string)\n\n\t_transformRe: /([-+]?(?:\\d*\\.)?\\d+)\\D*, ([-+]?(?:\\d*\\.)?\\d+)\\D*\\)/,\n\n\t_getPos: function () {\n\t\tvar left, top, matches,\n\t\t    el = this._el,\n\t\t    style = window.getComputedStyle(el);\n\n\t\tif (L.Browser.any3d) {\n\t\t\tmatches = style[L.DomUtil.TRANSFORM].match(this._transformRe);\n\t\t\tif (!matches) { return; }\n\t\t\tleft = parseFloat(matches[1]);\n\t\t\ttop  = parseFloat(matches[2]);\n\t\t} else {\n\t\t\tleft = parseFloat(style.left);\n\t\t\ttop  = parseFloat(style.top);\n\t\t}\n\n\t\treturn new L.Point(left, top, true);\n\t},\n\n\t_onTransitionEnd: function () {\n\t\tL.DomEvent.off(this._el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);\n\n\t\tif (!this._inProgress) { return; }\n\t\tthis._inProgress = false;\n\n\t\tthis._el.style[L.DomUtil.TRANSITION] = '';\n\n\t\t// jshint camelcase: false\n\t\t// make sure L.DomUtil.getPosition returns the final position value after animation\n\t\tthis._el._leaflet_pos = this._newPos;\n\n\t\tclearInterval(this._stepTimer);\n\n\t\tthis.fire('step').fire('end');\n\t}\n\n});\n\n\n/*\n * Extends L.Map to handle panning animations.\n */\n\nL.Map.include({\n\n\tsetView: function (center, zoom, options) {\n\n\t\tzoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);\n\t\tcenter = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);\n\t\toptions = options || {};\n\n\t\tif (this._panAnim) {\n\t\t\tthis._panAnim.stop();\n\t\t}\n\n\t\tif (this._loaded && !options.reset && options !== true) {\n\n\t\t\tif (options.animate !== undefined) {\n\t\t\t\toptions.zoom = L.extend({animate: options.animate}, options.zoom);\n\t\t\t\toptions.pan = L.extend({animate: options.animate}, options.pan);\n\t\t\t}\n\n\t\t\t// try animating pan or zoom\n\t\t\tvar animated = (this._zoom !== zoom) ?\n\t\t\t\tthis._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :\n\t\t\t\tthis._tryAnimatedPan(center, options.pan);\n\n\t\t\tif (animated) {\n\t\t\t\t// prevent resize handler call, the view will refresh after animation anyway\n\t\t\t\tclearTimeout(this._sizeTimer);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\n\t\t// animation didn't start, just reset the map view\n\t\tthis._resetView(center, zoom);\n\n\t\treturn this;\n\t},\n\n\tpanBy: function (offset, options) {\n\t\toffset = L.point(offset).round();\n\t\toptions = options || {};\n\n\t\tif (!offset.x && !offset.y) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif (!this._panAnim) {\n\t\t\tthis._panAnim = new L.PosAnimation();\n\n\t\t\tthis._panAnim.on({\n\t\t\t\t'step': this._onPanTransitionStep,\n\t\t\t\t'end': this._onPanTransitionEnd\n\t\t\t}, this);\n\t\t}\n\n\t\t// don't fire movestart if animating inertia\n\t\tif (!options.noMoveStart) {\n\t\t\tthis.fire('movestart');\n\t\t}\n\n\t\t// animate pan unless animate: false specified\n\t\tif (options.animate !== false) {\n\t\t\tL.DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');\n\n\t\t\tvar newPos = this._getMapPanePos().subtract(offset);\n\t\t\tthis._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);\n\t\t} else {\n\t\t\tthis._rawPanBy(offset);\n\t\t\tthis.fire('move').fire('moveend');\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t_onPanTransitionStep: function () {\n\t\tthis.fire('move');\n\t},\n\n\t_onPanTransitionEnd: function () {\n\t\tL.DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');\n\t\tthis.fire('moveend');\n\t},\n\n\t_tryAnimatedPan: function (center, options) {\n\t\t// difference between the new and current centers in pixels\n\t\tvar offset = this._getCenterOffset(center)._floor();\n\n\t\t// don't animate too far unless animate: true specified in options\n\t\tif ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }\n\n\t\tthis.panBy(offset, options);\n\n\t\treturn true;\n\t}\n});\n\n\n/*\n * L.PosAnimation fallback implementation that powers Leaflet pan animations\n * in browsers that don't support CSS3 Transitions.\n */\n\nL.PosAnimation = L.DomUtil.TRANSITION ? L.PosAnimation : L.PosAnimation.extend({\n\n\trun: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])\n\t\tthis.stop();\n\n\t\tthis._el = el;\n\t\tthis._inProgress = true;\n\t\tthis._duration = duration || 0.25;\n\t\tthis._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);\n\n\t\tthis._startPos = L.DomUtil.getPosition(el);\n\t\tthis._offset = newPos.subtract(this._startPos);\n\t\tthis._startTime = +new Date();\n\n\t\tthis.fire('start');\n\n\t\tthis._animate();\n\t},\n\n\tstop: function () {\n\t\tif (!this._inProgress) { return; }\n\n\t\tthis._step();\n\t\tthis._complete();\n\t},\n\n\t_animate: function () {\n\t\t// animation loop\n\t\tthis._animId = L.Util.requestAnimFrame(this._animate, this);\n\t\tthis._step();\n\t},\n\n\t_step: function () {\n\t\tvar elapsed = (+new Date()) - this._startTime,\n\t\t    duration = this._duration * 1000;\n\n\t\tif (elapsed < duration) {\n\t\t\tthis._runFrame(this._easeOut(elapsed / duration));\n\t\t} else {\n\t\t\tthis._runFrame(1);\n\t\t\tthis._complete();\n\t\t}\n\t},\n\n\t_runFrame: function (progress) {\n\t\tvar pos = this._startPos.add(this._offset.multiplyBy(progress));\n\t\tL.DomUtil.setPosition(this._el, pos);\n\n\t\tthis.fire('step');\n\t},\n\n\t_complete: function () {\n\t\tL.Util.cancelAnimFrame(this._animId);\n\n\t\tthis._inProgress = false;\n\t\tthis.fire('end');\n\t},\n\n\t_easeOut: function (t) {\n\t\treturn 1 - Math.pow(1 - t, this._easeOutPower);\n\t}\n});\n\n\n/*\n * Extends L.Map to handle zoom animations.\n */\n\nL.Map.mergeOptions({\n\tzoomAnimation: true,\n\tzoomAnimationThreshold: 4\n});\n\nif (L.DomUtil.TRANSITION) {\n\n\tL.Map.addInitHook(function () {\n\t\t// don't animate on browsers without hardware-accelerated transitions or old Android/Opera\n\t\tthis._zoomAnimated = this.options.zoomAnimation && L.DomUtil.TRANSITION &&\n\t\t\t\tL.Browser.any3d && !L.Browser.android23 && !L.Browser.mobileOpera;\n\n\t\t// zoom transitions run with the same duration for all layers, so if one of transitionend events\n\t\t// happens after starting zoom animation (propagating to the map pane), we know that it ended globally\n\t\tif (this._zoomAnimated) {\n\t\t\tL.DomEvent.on(this._mapPane, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);\n\t\t}\n\t});\n}\n\nL.Map.include(!L.DomUtil.TRANSITION ? {} : {\n\n\t_catchTransitionEnd: function (e) {\n\t\tif (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {\n\t\t\tthis._onZoomTransitionEnd();\n\t\t}\n\t},\n\n\t_nothingToAnimate: function () {\n\t\treturn !this._container.getElementsByClassName('leaflet-zoom-animated').length;\n\t},\n\n\t_tryAnimatedZoom: function (center, zoom, options) {\n\n\t\tif (this._animatingZoom) { return true; }\n\n\t\toptions = options || {};\n\n\t\t// don't animate if disabled, not supported or zoom difference is too large\n\t\tif (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||\n\t\t        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }\n\n\t\t// offset is the pixel coords of the zoom origin relative to the current center\n\t\tvar scale = this.getZoomScale(zoom),\n\t\t    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale),\n\t\t\torigin = this._getCenterLayerPoint()._add(offset);\n\n\t\t// don't animate if the zoom origin isn't within one screen from the current center, unless forced\n\t\tif (options.animate !== true && !this.getSize().contains(offset)) { return false; }\n\n\t\tthis\n\t\t    .fire('movestart')\n\t\t    .fire('zoomstart');\n\n\t\tthis._animateZoom(center, zoom, origin, scale, null, true);\n\n\t\treturn true;\n\t},\n\n\t_animateZoom: function (center, zoom, origin, scale, delta, backwards, forTouchZoom) {\n\n\t\tif (!forTouchZoom) {\n\t\t\tthis._animatingZoom = true;\n\t\t}\n\n\t\t// put transform transition on all layers with leaflet-zoom-animated class\n\t\tL.DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');\n\n\t\t// remember what center/zoom to set after animation\n\t\tthis._animateToCenter = center;\n\t\tthis._animateToZoom = zoom;\n\n\t\t// disable any dragging during animation\n\t\tif (L.Draggable) {\n\t\t\tL.Draggable._disabled = true;\n\t\t}\n\n\t\tL.Util.requestAnimFrame(function () {\n\t\t\tthis.fire('zoomanim', {\n\t\t\t\tcenter: center,\n\t\t\t\tzoom: zoom,\n\t\t\t\torigin: origin,\n\t\t\t\tscale: scale,\n\t\t\t\tdelta: delta,\n\t\t\t\tbackwards: backwards\n\t\t\t});\n\t\t\t// horrible hack to work around a Chrome bug https://github.com/Leaflet/Leaflet/issues/3689\n\t\t\tsetTimeout(L.bind(this._onZoomTransitionEnd, this), 250);\n\t\t}, this);\n\t},\n\n\t_onZoomTransitionEnd: function () {\n\t\tif (!this._animatingZoom) { return; }\n\n\t\tthis._animatingZoom = false;\n\n\t\tL.DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');\n\n\t\tL.Util.requestAnimFrame(function () {\n\t\t\tthis._resetView(this._animateToCenter, this._animateToZoom, true, true);\n\n\t\t\tif (L.Draggable) {\n\t\t\t\tL.Draggable._disabled = false;\n\t\t\t}\n\t\t}, this);\n\t}\n});\n\n\n/*\n\tZoom animation logic for L.TileLayer.\n*/\n\nL.TileLayer.include({\n\t_animateZoom: function (e) {\n\t\tif (!this._animating) {\n\t\t\tthis._animating = true;\n\t\t\tthis._prepareBgBuffer();\n\t\t}\n\n\t\tvar bg = this._bgBuffer,\n\t\t    transform = L.DomUtil.TRANSFORM,\n\t\t    initialTransform = e.delta ? L.DomUtil.getTranslateString(e.delta) : bg.style[transform],\n\t\t    scaleStr = L.DomUtil.getScaleString(e.scale, e.origin);\n\n\t\tbg.style[transform] = e.backwards ?\n\t\t\t\tscaleStr + ' ' + initialTransform :\n\t\t\t\tinitialTransform + ' ' + scaleStr;\n\t},\n\n\t_endZoomAnim: function () {\n\t\tvar front = this._tileContainer,\n\t\t    bg = this._bgBuffer;\n\n\t\tfront.style.visibility = '';\n\t\tfront.parentNode.appendChild(front); // Bring to fore\n\n\t\t// force reflow\n\t\tL.Util.falseFn(bg.offsetWidth);\n\n\t\tvar zoom = this._map.getZoom();\n\t\tif (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\n\t\t\tthis._clearBgBuffer();\n\t\t}\n\n\t\tthis._animating = false;\n\t},\n\n\t_clearBgBuffer: function () {\n\t\tvar map = this._map;\n\n\t\tif (map && !map._animatingZoom && !map.touchZoom._zooming) {\n\t\t\tthis._bgBuffer.innerHTML = '';\n\t\t\tthis._bgBuffer.style[L.DomUtil.TRANSFORM] = '';\n\t\t}\n\t},\n\n\t_prepareBgBuffer: function () {\n\n\t\tvar front = this._tileContainer,\n\t\t    bg = this._bgBuffer;\n\n\t\t// if foreground layer doesn't have many tiles but bg layer does,\n\t\t// keep the existing bg layer and just zoom it some more\n\n\t\tvar bgLoaded = this._getLoadedTilesPercentage(bg),\n\t\t    frontLoaded = this._getLoadedTilesPercentage(front);\n\n\t\tif (bg && bgLoaded > 0.5 && frontLoaded < 0.5) {\n\n\t\t\tfront.style.visibility = 'hidden';\n\t\t\tthis._stopLoadingImages(front);\n\t\t\treturn;\n\t\t}\n\n\t\t// prepare the buffer to become the front tile pane\n\t\tbg.style.visibility = 'hidden';\n\t\tbg.style[L.DomUtil.TRANSFORM] = '';\n\n\t\t// switch out the current layer to be the new bg layer (and vice-versa)\n\t\tthis._tileContainer = bg;\n\t\tbg = this._bgBuffer = front;\n\n\t\tthis._stopLoadingImages(bg);\n\n\t\t//prevent bg buffer from clearing right after zoom\n\t\tclearTimeout(this._clearBgBufferTimer);\n\t},\n\n\t_getLoadedTilesPercentage: function (container) {\n\t\tvar tiles = container.getElementsByTagName('img'),\n\t\t    i, len, count = 0;\n\n\t\tfor (i = 0, len = tiles.length; i < len; i++) {\n\t\t\tif (tiles[i].complete) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count / len;\n\t},\n\n\t// stops loading all tiles in the background layer\n\t_stopLoadingImages: function (container) {\n\t\tvar tiles = Array.prototype.slice.call(container.getElementsByTagName('img')),\n\t\t    i, len, tile;\n\n\t\tfor (i = 0, len = tiles.length; i < len; i++) {\n\t\t\ttile = tiles[i];\n\n\t\t\tif (!tile.complete) {\n\t\t\t\ttile.onload = L.Util.falseFn;\n\t\t\t\ttile.onerror = L.Util.falseFn;\n\t\t\t\ttile.src = L.Util.emptyImageUrl;\n\n\t\t\t\ttile.parentNode.removeChild(tile);\n\t\t\t}\n\t\t}\n\t}\n});\n\n\n/*\r\n * Provides L.Map with convenient shortcuts for using browser geolocation features.\r\n */\r\n\r\nL.Map.include({\r\n\t_defaultLocateOptions: {\r\n\t\twatch: false,\r\n\t\tsetView: false,\r\n\t\tmaxZoom: Infinity,\r\n\t\ttimeout: 10000,\r\n\t\tmaximumAge: 0,\r\n\t\tenableHighAccuracy: false\r\n\t},\r\n\r\n\tlocate: function (/*Object*/ options) {\r\n\r\n\t\toptions = this._locateOptions = L.extend(this._defaultLocateOptions, options);\r\n\r\n\t\tif (!navigator.geolocation) {\r\n\t\t\tthis._handleGeolocationError({\r\n\t\t\t\tcode: 0,\r\n\t\t\t\tmessage: 'Geolocation not supported.'\r\n\t\t\t});\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tvar onResponse = L.bind(this._handleGeolocationResponse, this),\r\n\t\t\tonError = L.bind(this._handleGeolocationError, this);\r\n\r\n\t\tif (options.watch) {\r\n\t\t\tthis._locationWatchId =\r\n\t\t\t        navigator.geolocation.watchPosition(onResponse, onError, options);\r\n\t\t} else {\r\n\t\t\tnavigator.geolocation.getCurrentPosition(onResponse, onError, options);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tstopLocate: function () {\r\n\t\tif (navigator.geolocation) {\r\n\t\t\tnavigator.geolocation.clearWatch(this._locationWatchId);\r\n\t\t}\r\n\t\tif (this._locateOptions) {\r\n\t\t\tthis._locateOptions.setView = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_handleGeolocationError: function (error) {\r\n\t\tvar c = error.code,\r\n\t\t    message = error.message ||\r\n\t\t            (c === 1 ? 'permission denied' :\r\n\t\t            (c === 2 ? 'position unavailable' : 'timeout'));\r\n\r\n\t\tif (this._locateOptions.setView && !this._loaded) {\r\n\t\t\tthis.fitWorld();\r\n\t\t}\r\n\r\n\t\tthis.fire('locationerror', {\r\n\t\t\tcode: c,\r\n\t\t\tmessage: 'Geolocation error: ' + message + '.'\r\n\t\t});\r\n\t},\r\n\r\n\t_handleGeolocationResponse: function (pos) {\r\n\t\tvar lat = pos.coords.latitude,\r\n\t\t    lng = pos.coords.longitude,\r\n\t\t    latlng = new L.LatLng(lat, lng),\r\n\r\n\t\t    latAccuracy = 180 * pos.coords.accuracy / 40075017,\r\n\t\t    lngAccuracy = latAccuracy / Math.cos(L.LatLng.DEG_TO_RAD * lat),\r\n\r\n\t\t    bounds = L.latLngBounds(\r\n\t\t            [lat - latAccuracy, lng - lngAccuracy],\r\n\t\t            [lat + latAccuracy, lng + lngAccuracy]),\r\n\r\n\t\t    options = this._locateOptions;\r\n\r\n\t\tif (options.setView) {\r\n\t\t\tvar zoom = Math.min(this.getBoundsZoom(bounds), options.maxZoom);\r\n\t\t\tthis.setView(latlng, zoom);\r\n\t\t}\r\n\r\n\t\tvar data = {\r\n\t\t\tlatlng: latlng,\r\n\t\t\tbounds: bounds,\r\n\t\t\ttimestamp: pos.timestamp\r\n\t\t};\r\n\r\n\t\tfor (var i in pos.coords) {\r\n\t\t\tif (typeof pos.coords[i] === 'number') {\r\n\t\t\t\tdata[i] = pos.coords[i];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.fire('locationfound', data);\r\n\t}\r\n});\r\n\n\n}(window, document));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/leaflet/dist/leaflet-src.js\n ** module id = 14\n ** module chunks = 0\n **/","// vim:ts=4:sts=4:sw=4:\n/*!\n *\n * Copyright 2009-2012 Kris Kowal under the terms of the MIT\n * license found at http://github.com/kriskowal/q/raw/master/LICENSE\n *\n * With parts by Tyler Close\n * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found\n * at http://www.opensource.org/licenses/mit-license.html\n * Forked at ref_send.js version: 2009-05-11\n *\n * With parts by Mark Miller\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n(function (definition) {\n    \"use strict\";\n\n    // This file will function properly as a <script> tag, or a module\n    // using CommonJS and NodeJS or RequireJS module formats.  In\n    // Common/Node/RequireJS, the module exports the Q API and when\n    // executed as a simple <script>, it creates a Q global instead.\n\n    // Montage Require\n    if (typeof bootstrap === \"function\") {\n        bootstrap(\"promise\", definition);\n\n    // CommonJS\n    } else if (typeof exports === \"object\" && typeof module === \"object\") {\n        module.exports = definition();\n\n    // RequireJS\n    } else if (typeof define === \"function\" && define.amd) {\n        define(definition);\n\n    // SES (Secure EcmaScript)\n    } else if (typeof ses !== \"undefined\") {\n        if (!ses.ok()) {\n            return;\n        } else {\n            ses.makeQ = definition;\n        }\n\n    // <script>\n    } else if (typeof window !== \"undefined\" || typeof self !== \"undefined\") {\n        // Prefer window over self for add-on scripts. Use self for\n        // non-windowed contexts.\n        var global = typeof window !== \"undefined\" ? window : self;\n\n        // Get the `window` object, save the previous Q global\n        // and initialize Q as a global.\n        var previousQ = global.Q;\n        global.Q = definition();\n\n        // Add a noConflict function so Q can be removed from the\n        // global namespace.\n        global.Q.noConflict = function () {\n            global.Q = previousQ;\n            return this;\n        };\n\n    } else {\n        throw new Error(\"This environment was not anticipated by Q. Please file a bug.\");\n    }\n\n})(function () {\n\"use strict\";\n\nvar hasStacks = false;\ntry {\n    throw new Error();\n} catch (e) {\n    hasStacks = !!e.stack;\n}\n\n// All code after this point will be filtered from stack traces reported\n// by Q.\nvar qStartingLine = captureLine();\nvar qFileName;\n\n// shims\n\n// used for fallback in \"allResolved\"\nvar noop = function () {};\n\n// Use the fastest possible means to execute a task in a future turn\n// of the event loop.\nvar nextTick =(function () {\n    // linked list of tasks (single, with head node)\n    var head = {task: void 0, next: null};\n    var tail = head;\n    var flushing = false;\n    var requestTick = void 0;\n    var isNodeJS = false;\n    // queue for late tasks, used by unhandled rejection tracking\n    var laterQueue = [];\n\n    function flush() {\n        /* jshint loopfunc: true */\n        var task, domain;\n\n        while (head.next) {\n            head = head.next;\n            task = head.task;\n            head.task = void 0;\n            domain = head.domain;\n\n            if (domain) {\n                head.domain = void 0;\n                domain.enter();\n            }\n            runSingle(task, domain);\n\n        }\n        while (laterQueue.length) {\n            task = laterQueue.pop();\n            runSingle(task);\n        }\n        flushing = false;\n    }\n    // runs a single function in the async queue\n    function runSingle(task, domain) {\n        try {\n            task();\n\n        } catch (e) {\n            if (isNodeJS) {\n                // In node, uncaught exceptions are considered fatal errors.\n                // Re-throw them synchronously to interrupt flushing!\n\n                // Ensure continuation if the uncaught exception is suppressed\n                // listening \"uncaughtException\" events (as domains does).\n                // Continue in next event to avoid tick recursion.\n                if (domain) {\n                    domain.exit();\n                }\n                setTimeout(flush, 0);\n                if (domain) {\n                    domain.enter();\n                }\n\n                throw e;\n\n            } else {\n                // In browsers, uncaught exceptions are not fatal.\n                // Re-throw them asynchronously to avoid slow-downs.\n                setTimeout(function () {\n                    throw e;\n                }, 0);\n            }\n        }\n\n        if (domain) {\n            domain.exit();\n        }\n    }\n\n    nextTick = function (task) {\n        tail = tail.next = {\n            task: task,\n            domain: isNodeJS && process.domain,\n            next: null\n        };\n\n        if (!flushing) {\n            flushing = true;\n            requestTick();\n        }\n    };\n\n    if (typeof process === \"object\" &&\n        process.toString() === \"[object process]\" && process.nextTick) {\n        // Ensure Q is in a real Node environment, with a `process.nextTick`.\n        // To see through fake Node environments:\n        // * Mocha test runner - exposes a `process` global without a `nextTick`\n        // * Browserify - exposes a `process.nexTick` function that uses\n        //   `setTimeout`. In this case `setImmediate` is preferred because\n        //    it is faster. Browserify's `process.toString()` yields\n        //   \"[object Object]\", while in a real Node environment\n        //   `process.nextTick()` yields \"[object process]\".\n        isNodeJS = true;\n\n        requestTick = function () {\n            process.nextTick(flush);\n        };\n\n    } else if (typeof setImmediate === \"function\") {\n        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\n        if (typeof window !== \"undefined\") {\n            requestTick = setImmediate.bind(window, flush);\n        } else {\n            requestTick = function () {\n                setImmediate(flush);\n            };\n        }\n\n    } else if (typeof MessageChannel !== \"undefined\") {\n        // modern browsers\n        // http://www.nonblocking.io/2011/06/windownexttick.html\n        var channel = new MessageChannel();\n        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create\n        // working message ports the first time a page loads.\n        channel.port1.onmessage = function () {\n            requestTick = requestPortTick;\n            channel.port1.onmessage = flush;\n            flush();\n        };\n        var requestPortTick = function () {\n            // Opera requires us to provide a message payload, regardless of\n            // whether we use it.\n            channel.port2.postMessage(0);\n        };\n        requestTick = function () {\n            setTimeout(flush, 0);\n            requestPortTick();\n        };\n\n    } else {\n        // old browsers\n        requestTick = function () {\n            setTimeout(flush, 0);\n        };\n    }\n    // runs a task after all other tasks have been run\n    // this is useful for unhandled rejection tracking that needs to happen\n    // after all `then`d tasks have been run.\n    nextTick.runAfter = function (task) {\n        laterQueue.push(task);\n        if (!flushing) {\n            flushing = true;\n            requestTick();\n        }\n    };\n    return nextTick;\n})();\n\n// Attempt to make generics safe in the face of downstream\n// modifications.\n// There is no situation where this is necessary.\n// If you need a security guarantee, these primordials need to be\n// deeply frozen anyway, and if you don’t need a security guarantee,\n// this is just plain paranoid.\n// However, this **might** have the nice side-effect of reducing the size of\n// the minified code by reducing x.call() to merely x()\n// See Mark Miller’s explanation of what this does.\n// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\nvar call = Function.call;\nfunction uncurryThis(f) {\n    return function () {\n        return call.apply(f, arguments);\n    };\n}\n// This is equivalent, but slower:\n// uncurryThis = Function_bind.bind(Function_bind.call);\n// http://jsperf.com/uncurrythis\n\nvar array_slice = uncurryThis(Array.prototype.slice);\n\nvar array_reduce = uncurryThis(\n    Array.prototype.reduce || function (callback, basis) {\n        var index = 0,\n            length = this.length;\n        // concerning the initial value, if one is not provided\n        if (arguments.length === 1) {\n            // seek to the first value in the array, accounting\n            // for the possibility that is is a sparse array\n            do {\n                if (index in this) {\n                    basis = this[index++];\n                    break;\n                }\n                if (++index >= length) {\n                    throw new TypeError();\n                }\n            } while (1);\n        }\n        // reduce\n        for (; index < length; index++) {\n            // account for the possibility that the array is sparse\n            if (index in this) {\n                basis = callback(basis, this[index], index);\n            }\n        }\n        return basis;\n    }\n);\n\nvar array_indexOf = uncurryThis(\n    Array.prototype.indexOf || function (value) {\n        // not a very good shim, but good enough for our one use of it\n        for (var i = 0; i < this.length; i++) {\n            if (this[i] === value) {\n                return i;\n            }\n        }\n        return -1;\n    }\n);\n\nvar array_map = uncurryThis(\n    Array.prototype.map || function (callback, thisp) {\n        var self = this;\n        var collect = [];\n        array_reduce(self, function (undefined, value, index) {\n            collect.push(callback.call(thisp, value, index, self));\n        }, void 0);\n        return collect;\n    }\n);\n\nvar object_create = Object.create || function (prototype) {\n    function Type() { }\n    Type.prototype = prototype;\n    return new Type();\n};\n\nvar object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\n\nvar object_keys = Object.keys || function (object) {\n    var keys = [];\n    for (var key in object) {\n        if (object_hasOwnProperty(object, key)) {\n            keys.push(key);\n        }\n    }\n    return keys;\n};\n\nvar object_toString = uncurryThis(Object.prototype.toString);\n\nfunction isObject(value) {\n    return value === Object(value);\n}\n\n// generator related shims\n\n// FIXME: Remove this function once ES6 generators are in SpiderMonkey.\nfunction isStopIteration(exception) {\n    return (\n        object_toString(exception) === \"[object StopIteration]\" ||\n        exception instanceof QReturnValue\n    );\n}\n\n// FIXME: Remove this helper and Q.return once ES6 generators are in\n// SpiderMonkey.\nvar QReturnValue;\nif (typeof ReturnValue !== \"undefined\") {\n    QReturnValue = ReturnValue;\n} else {\n    QReturnValue = function (value) {\n        this.value = value;\n    };\n}\n\n// long stack traces\n\nvar STACK_JUMP_SEPARATOR = \"From previous event:\";\n\nfunction makeStackTraceLong(error, promise) {\n    // If possible, transform the error stack trace by removing Node and Q\n    // cruft, then concatenating with the stack trace of `promise`. See #57.\n    if (hasStacks &&\n        promise.stack &&\n        typeof error === \"object\" &&\n        error !== null &&\n        error.stack &&\n        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1\n    ) {\n        var stacks = [];\n        for (var p = promise; !!p; p = p.source) {\n            if (p.stack) {\n                stacks.unshift(p.stack);\n            }\n        }\n        stacks.unshift(error.stack);\n\n        var concatedStacks = stacks.join(\"\\n\" + STACK_JUMP_SEPARATOR + \"\\n\");\n        error.stack = filterStackString(concatedStacks);\n    }\n}\n\nfunction filterStackString(stackString) {\n    var lines = stackString.split(\"\\n\");\n    var desiredLines = [];\n    for (var i = 0; i < lines.length; ++i) {\n        var line = lines[i];\n\n        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {\n            desiredLines.push(line);\n        }\n    }\n    return desiredLines.join(\"\\n\");\n}\n\nfunction isNodeFrame(stackLine) {\n    return stackLine.indexOf(\"(module.js:\") !== -1 ||\n           stackLine.indexOf(\"(node.js:\") !== -1;\n}\n\nfunction getFileNameAndLineNumber(stackLine) {\n    // Named functions: \"at functionName (filename:lineNumber:columnNumber)\"\n    // In IE10 function name can have spaces (\"Anonymous function\") O_o\n    var attempt1 = /at .+ \\((.+):(\\d+):(?:\\d+)\\)$/.exec(stackLine);\n    if (attempt1) {\n        return [attempt1[1], Number(attempt1[2])];\n    }\n\n    // Anonymous functions: \"at filename:lineNumber:columnNumber\"\n    var attempt2 = /at ([^ ]+):(\\d+):(?:\\d+)$/.exec(stackLine);\n    if (attempt2) {\n        return [attempt2[1], Number(attempt2[2])];\n    }\n\n    // Firefox style: \"function@filename:lineNumber or @filename:lineNumber\"\n    var attempt3 = /.*@(.+):(\\d+)$/.exec(stackLine);\n    if (attempt3) {\n        return [attempt3[1], Number(attempt3[2])];\n    }\n}\n\nfunction isInternalFrame(stackLine) {\n    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);\n\n    if (!fileNameAndLineNumber) {\n        return false;\n    }\n\n    var fileName = fileNameAndLineNumber[0];\n    var lineNumber = fileNameAndLineNumber[1];\n\n    return fileName === qFileName &&\n        lineNumber >= qStartingLine &&\n        lineNumber <= qEndingLine;\n}\n\n// discover own file name and line number range for filtering stack\n// traces\nfunction captureLine() {\n    if (!hasStacks) {\n        return;\n    }\n\n    try {\n        throw new Error();\n    } catch (e) {\n        var lines = e.stack.split(\"\\n\");\n        var firstLine = lines[0].indexOf(\"@\") > 0 ? lines[1] : lines[2];\n        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);\n        if (!fileNameAndLineNumber) {\n            return;\n        }\n\n        qFileName = fileNameAndLineNumber[0];\n        return fileNameAndLineNumber[1];\n    }\n}\n\nfunction deprecate(callback, name, alternative) {\n    return function () {\n        if (typeof console !== \"undefined\" &&\n            typeof console.warn === \"function\") {\n            console.warn(name + \" is deprecated, use \" + alternative +\n                         \" instead.\", new Error(\"\").stack);\n        }\n        return callback.apply(callback, arguments);\n    };\n}\n\n// end of shims\n// beginning of real work\n\n/**\n * Constructs a promise for an immediate reference, passes promises through, or\n * coerces promises from different systems.\n * @param value immediate reference or promise\n */\nfunction Q(value) {\n    // If the object is already a Promise, return it directly.  This enables\n    // the resolve function to both be used to created references from objects,\n    // but to tolerably coerce non-promises to promises.\n    if (value instanceof Promise) {\n        return value;\n    }\n\n    // assimilate thenables\n    if (isPromiseAlike(value)) {\n        return coerce(value);\n    } else {\n        return fulfill(value);\n    }\n}\nQ.resolve = Q;\n\n/**\n * Performs a task in a future turn of the event loop.\n * @param {Function} task\n */\nQ.nextTick = nextTick;\n\n/**\n * Controls whether or not long stack traces will be on\n */\nQ.longStackSupport = false;\n\n// enable long stacks if Q_DEBUG is set\nif (typeof process === \"object\" && process && process.env && process.env.Q_DEBUG) {\n    Q.longStackSupport = true;\n}\n\n/**\n * Constructs a {promise, resolve, reject} object.\n *\n * `resolve` is a callback to invoke with a more resolved value for the\n * promise. To fulfill the promise, invoke `resolve` with any value that is\n * not a thenable. To reject the promise, invoke `resolve` with a rejected\n * thenable, or invoke `reject` with the reason directly. To resolve the\n * promise to another thenable, thus putting it in the same state, invoke\n * `resolve` with that other thenable.\n */\nQ.defer = defer;\nfunction defer() {\n    // if \"messages\" is an \"Array\", that indicates that the promise has not yet\n    // been resolved.  If it is \"undefined\", it has been resolved.  Each\n    // element of the messages array is itself an array of complete arguments to\n    // forward to the resolved promise.  We coerce the resolution value to a\n    // promise using the `resolve` function because it handles both fully\n    // non-thenable values and other thenables gracefully.\n    var messages = [], progressListeners = [], resolvedPromise;\n\n    var deferred = object_create(defer.prototype);\n    var promise = object_create(Promise.prototype);\n\n    promise.promiseDispatch = function (resolve, op, operands) {\n        var args = array_slice(arguments);\n        if (messages) {\n            messages.push(args);\n            if (op === \"when\" && operands[1]) { // progress operand\n                progressListeners.push(operands[1]);\n            }\n        } else {\n            Q.nextTick(function () {\n                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);\n            });\n        }\n    };\n\n    // XXX deprecated\n    promise.valueOf = function () {\n        if (messages) {\n            return promise;\n        }\n        var nearerValue = nearer(resolvedPromise);\n        if (isPromise(nearerValue)) {\n            resolvedPromise = nearerValue; // shorten chain\n        }\n        return nearerValue;\n    };\n\n    promise.inspect = function () {\n        if (!resolvedPromise) {\n            return { state: \"pending\" };\n        }\n        return resolvedPromise.inspect();\n    };\n\n    if (Q.longStackSupport && hasStacks) {\n        try {\n            throw new Error();\n        } catch (e) {\n            // NOTE: don't try to use `Error.captureStackTrace` or transfer the\n            // accessor around; that causes memory leaks as per GH-111. Just\n            // reify the stack trace as a string ASAP.\n            //\n            // At the same time, cut off the first line; it's always just\n            // \"[object Promise]\\n\", as per the `toString`.\n            promise.stack = e.stack.substring(e.stack.indexOf(\"\\n\") + 1);\n        }\n    }\n\n    // NOTE: we do the checks for `resolvedPromise` in each method, instead of\n    // consolidating them into `become`, since otherwise we'd create new\n    // promises with the lines `become(whatever(value))`. See e.g. GH-252.\n\n    function become(newPromise) {\n        resolvedPromise = newPromise;\n        promise.source = newPromise;\n\n        array_reduce(messages, function (undefined, message) {\n            Q.nextTick(function () {\n                newPromise.promiseDispatch.apply(newPromise, message);\n            });\n        }, void 0);\n\n        messages = void 0;\n        progressListeners = void 0;\n    }\n\n    deferred.promise = promise;\n    deferred.resolve = function (value) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(Q(value));\n    };\n\n    deferred.fulfill = function (value) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(fulfill(value));\n    };\n    deferred.reject = function (reason) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(reject(reason));\n    };\n    deferred.notify = function (progress) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        array_reduce(progressListeners, function (undefined, progressListener) {\n            Q.nextTick(function () {\n                progressListener(progress);\n            });\n        }, void 0);\n    };\n\n    return deferred;\n}\n\n/**\n * Creates a Node-style callback that will resolve or reject the deferred\n * promise.\n * @returns a nodeback\n */\ndefer.prototype.makeNodeResolver = function () {\n    var self = this;\n    return function (error, value) {\n        if (error) {\n            self.reject(error);\n        } else if (arguments.length > 2) {\n            self.resolve(array_slice(arguments, 1));\n        } else {\n            self.resolve(value);\n        }\n    };\n};\n\n/**\n * @param resolver {Function} a function that returns nothing and accepts\n * the resolve, reject, and notify functions for a deferred.\n * @returns a promise that may be resolved with the given resolve and reject\n * functions, or rejected by a thrown exception in resolver\n */\nQ.Promise = promise; // ES6\nQ.promise = promise;\nfunction promise(resolver) {\n    if (typeof resolver !== \"function\") {\n        throw new TypeError(\"resolver must be a function.\");\n    }\n    var deferred = defer();\n    try {\n        resolver(deferred.resolve, deferred.reject, deferred.notify);\n    } catch (reason) {\n        deferred.reject(reason);\n    }\n    return deferred.promise;\n}\n\npromise.race = race; // ES6\npromise.all = all; // ES6\npromise.reject = reject; // ES6\npromise.resolve = Q; // ES6\n\n// XXX experimental.  This method is a way to denote that a local value is\n// serializable and should be immediately dispatched to a remote upon request,\n// instead of passing a reference.\nQ.passByCopy = function (object) {\n    //freeze(object);\n    //passByCopies.set(object, true);\n    return object;\n};\n\nPromise.prototype.passByCopy = function () {\n    //freeze(object);\n    //passByCopies.set(object, true);\n    return this;\n};\n\n/**\n * If two promises eventually fulfill to the same value, promises that value,\n * but otherwise rejects.\n * @param x {Any*}\n * @param y {Any*}\n * @returns {Any*} a promise for x and y if they are the same, but a rejection\n * otherwise.\n *\n */\nQ.join = function (x, y) {\n    return Q(x).join(y);\n};\n\nPromise.prototype.join = function (that) {\n    return Q([this, that]).spread(function (x, y) {\n        if (x === y) {\n            // TODO: \"===\" should be Object.is or equiv\n            return x;\n        } else {\n            throw new Error(\"Can't join: not the same: \" + x + \" \" + y);\n        }\n    });\n};\n\n/**\n * Returns a promise for the first of an array of promises to become settled.\n * @param answers {Array[Any*]} promises to race\n * @returns {Any*} the first promise to be settled\n */\nQ.race = race;\nfunction race(answerPs) {\n    return promise(function (resolve, reject) {\n        // Switch to this once we can assume at least ES5\n        // answerPs.forEach(function (answerP) {\n        //     Q(answerP).then(resolve, reject);\n        // });\n        // Use this in the meantime\n        for (var i = 0, len = answerPs.length; i < len; i++) {\n            Q(answerPs[i]).then(resolve, reject);\n        }\n    });\n}\n\nPromise.prototype.race = function () {\n    return this.then(Q.race);\n};\n\n/**\n * Constructs a Promise with a promise descriptor object and optional fallback\n * function.  The descriptor contains methods like when(rejected), get(name),\n * set(name, value), post(name, args), and delete(name), which all\n * return either a value, a promise for a value, or a rejection.  The fallback\n * accepts the operation name, a resolver, and any further arguments that would\n * have been forwarded to the appropriate method above had a method been\n * provided with the proper name.  The API makes no guarantees about the nature\n * of the returned object, apart from that it is usable whereever promises are\n * bought and sold.\n */\nQ.makePromise = Promise;\nfunction Promise(descriptor, fallback, inspect) {\n    if (fallback === void 0) {\n        fallback = function (op) {\n            return reject(new Error(\n                \"Promise does not support operation: \" + op\n            ));\n        };\n    }\n    if (inspect === void 0) {\n        inspect = function () {\n            return {state: \"unknown\"};\n        };\n    }\n\n    var promise = object_create(Promise.prototype);\n\n    promise.promiseDispatch = function (resolve, op, args) {\n        var result;\n        try {\n            if (descriptor[op]) {\n                result = descriptor[op].apply(promise, args);\n            } else {\n                result = fallback.call(promise, op, args);\n            }\n        } catch (exception) {\n            result = reject(exception);\n        }\n        if (resolve) {\n            resolve(result);\n        }\n    };\n\n    promise.inspect = inspect;\n\n    // XXX deprecated `valueOf` and `exception` support\n    if (inspect) {\n        var inspected = inspect();\n        if (inspected.state === \"rejected\") {\n            promise.exception = inspected.reason;\n        }\n\n        promise.valueOf = function () {\n            var inspected = inspect();\n            if (inspected.state === \"pending\" ||\n                inspected.state === \"rejected\") {\n                return promise;\n            }\n            return inspected.value;\n        };\n    }\n\n    return promise;\n}\n\nPromise.prototype.toString = function () {\n    return \"[object Promise]\";\n};\n\nPromise.prototype.then = function (fulfilled, rejected, progressed) {\n    var self = this;\n    var deferred = defer();\n    var done = false;   // ensure the untrusted promise makes at most a\n                        // single call to one of the callbacks\n\n    function _fulfilled(value) {\n        try {\n            return typeof fulfilled === \"function\" ? fulfilled(value) : value;\n        } catch (exception) {\n            return reject(exception);\n        }\n    }\n\n    function _rejected(exception) {\n        if (typeof rejected === \"function\") {\n            makeStackTraceLong(exception, self);\n            try {\n                return rejected(exception);\n            } catch (newException) {\n                return reject(newException);\n            }\n        }\n        return reject(exception);\n    }\n\n    function _progressed(value) {\n        return typeof progressed === \"function\" ? progressed(value) : value;\n    }\n\n    Q.nextTick(function () {\n        self.promiseDispatch(function (value) {\n            if (done) {\n                return;\n            }\n            done = true;\n\n            deferred.resolve(_fulfilled(value));\n        }, \"when\", [function (exception) {\n            if (done) {\n                return;\n            }\n            done = true;\n\n            deferred.resolve(_rejected(exception));\n        }]);\n    });\n\n    // Progress propagator need to be attached in the current tick.\n    self.promiseDispatch(void 0, \"when\", [void 0, function (value) {\n        var newValue;\n        var threw = false;\n        try {\n            newValue = _progressed(value);\n        } catch (e) {\n            threw = true;\n            if (Q.onerror) {\n                Q.onerror(e);\n            } else {\n                throw e;\n            }\n        }\n\n        if (!threw) {\n            deferred.notify(newValue);\n        }\n    }]);\n\n    return deferred.promise;\n};\n\nQ.tap = function (promise, callback) {\n    return Q(promise).tap(callback);\n};\n\n/**\n * Works almost like \"finally\", but not called for rejections.\n * Original resolution value is passed through callback unaffected.\n * Callback may return a promise that will be awaited for.\n * @param {Function} callback\n * @returns {Q.Promise}\n * @example\n * doSomething()\n *   .then(...)\n *   .tap(console.log)\n *   .then(...);\n */\nPromise.prototype.tap = function (callback) {\n    callback = Q(callback);\n\n    return this.then(function (value) {\n        return callback.fcall(value).thenResolve(value);\n    });\n};\n\n/**\n * Registers an observer on a promise.\n *\n * Guarantees:\n *\n * 1. that fulfilled and rejected will be called only once.\n * 2. that either the fulfilled callback or the rejected callback will be\n *    called, but not both.\n * 3. that fulfilled and rejected will not be called in this turn.\n *\n * @param value      promise or immediate reference to observe\n * @param fulfilled  function to be called with the fulfilled value\n * @param rejected   function to be called with the rejection exception\n * @param progressed function to be called on any progress notifications\n * @return promise for the return value from the invoked callback\n */\nQ.when = when;\nfunction when(value, fulfilled, rejected, progressed) {\n    return Q(value).then(fulfilled, rejected, progressed);\n}\n\nPromise.prototype.thenResolve = function (value) {\n    return this.then(function () { return value; });\n};\n\nQ.thenResolve = function (promise, value) {\n    return Q(promise).thenResolve(value);\n};\n\nPromise.prototype.thenReject = function (reason) {\n    return this.then(function () { throw reason; });\n};\n\nQ.thenReject = function (promise, reason) {\n    return Q(promise).thenReject(reason);\n};\n\n/**\n * If an object is not a promise, it is as \"near\" as possible.\n * If a promise is rejected, it is as \"near\" as possible too.\n * If it’s a fulfilled promise, the fulfillment value is nearer.\n * If it’s a deferred promise and the deferred has been resolved, the\n * resolution is \"nearer\".\n * @param object\n * @returns most resolved (nearest) form of the object\n */\n\n// XXX should we re-do this?\nQ.nearer = nearer;\nfunction nearer(value) {\n    if (isPromise(value)) {\n        var inspected = value.inspect();\n        if (inspected.state === \"fulfilled\") {\n            return inspected.value;\n        }\n    }\n    return value;\n}\n\n/**\n * @returns whether the given object is a promise.\n * Otherwise it is a fulfilled value.\n */\nQ.isPromise = isPromise;\nfunction isPromise(object) {\n    return object instanceof Promise;\n}\n\nQ.isPromiseAlike = isPromiseAlike;\nfunction isPromiseAlike(object) {\n    return isObject(object) && typeof object.then === \"function\";\n}\n\n/**\n * @returns whether the given object is a pending promise, meaning not\n * fulfilled or rejected.\n */\nQ.isPending = isPending;\nfunction isPending(object) {\n    return isPromise(object) && object.inspect().state === \"pending\";\n}\n\nPromise.prototype.isPending = function () {\n    return this.inspect().state === \"pending\";\n};\n\n/**\n * @returns whether the given object is a value or fulfilled\n * promise.\n */\nQ.isFulfilled = isFulfilled;\nfunction isFulfilled(object) {\n    return !isPromise(object) || object.inspect().state === \"fulfilled\";\n}\n\nPromise.prototype.isFulfilled = function () {\n    return this.inspect().state === \"fulfilled\";\n};\n\n/**\n * @returns whether the given object is a rejected promise.\n */\nQ.isRejected = isRejected;\nfunction isRejected(object) {\n    return isPromise(object) && object.inspect().state === \"rejected\";\n}\n\nPromise.prototype.isRejected = function () {\n    return this.inspect().state === \"rejected\";\n};\n\n//// BEGIN UNHANDLED REJECTION TRACKING\n\n// This promise library consumes exceptions thrown in handlers so they can be\n// handled by a subsequent promise.  The exceptions get added to this array when\n// they are created, and removed when they are handled.  Note that in ES6 or\n// shimmed environments, this would naturally be a `Set`.\nvar unhandledReasons = [];\nvar unhandledRejections = [];\nvar reportedUnhandledRejections = [];\nvar trackUnhandledRejections = true;\n\nfunction resetUnhandledRejections() {\n    unhandledReasons.length = 0;\n    unhandledRejections.length = 0;\n\n    if (!trackUnhandledRejections) {\n        trackUnhandledRejections = true;\n    }\n}\n\nfunction trackRejection(promise, reason) {\n    if (!trackUnhandledRejections) {\n        return;\n    }\n    if (typeof process === \"object\" && typeof process.emit === \"function\") {\n        Q.nextTick.runAfter(function () {\n            if (array_indexOf(unhandledRejections, promise) !== -1) {\n                process.emit(\"unhandledRejection\", reason, promise);\n                reportedUnhandledRejections.push(promise);\n            }\n        });\n    }\n\n    unhandledRejections.push(promise);\n    if (reason && typeof reason.stack !== \"undefined\") {\n        unhandledReasons.push(reason.stack);\n    } else {\n        unhandledReasons.push(\"(no stack) \" + reason);\n    }\n}\n\nfunction untrackRejection(promise) {\n    if (!trackUnhandledRejections) {\n        return;\n    }\n\n    var at = array_indexOf(unhandledRejections, promise);\n    if (at !== -1) {\n        if (typeof process === \"object\" && typeof process.emit === \"function\") {\n            Q.nextTick.runAfter(function () {\n                var atReport = array_indexOf(reportedUnhandledRejections, promise);\n                if (atReport !== -1) {\n                    process.emit(\"rejectionHandled\", unhandledReasons[at], promise);\n                    reportedUnhandledRejections.splice(atReport, 1);\n                }\n            });\n        }\n        unhandledRejections.splice(at, 1);\n        unhandledReasons.splice(at, 1);\n    }\n}\n\nQ.resetUnhandledRejections = resetUnhandledRejections;\n\nQ.getUnhandledReasons = function () {\n    // Make a copy so that consumers can't interfere with our internal state.\n    return unhandledReasons.slice();\n};\n\nQ.stopUnhandledRejectionTracking = function () {\n    resetUnhandledRejections();\n    trackUnhandledRejections = false;\n};\n\nresetUnhandledRejections();\n\n//// END UNHANDLED REJECTION TRACKING\n\n/**\n * Constructs a rejected promise.\n * @param reason value describing the failure\n */\nQ.reject = reject;\nfunction reject(reason) {\n    var rejection = Promise({\n        \"when\": function (rejected) {\n            // note that the error has been handled\n            if (rejected) {\n                untrackRejection(this);\n            }\n            return rejected ? rejected(reason) : this;\n        }\n    }, function fallback() {\n        return this;\n    }, function inspect() {\n        return { state: \"rejected\", reason: reason };\n    });\n\n    // Note that the reason has not been handled.\n    trackRejection(rejection, reason);\n\n    return rejection;\n}\n\n/**\n * Constructs a fulfilled promise for an immediate reference.\n * @param value immediate reference\n */\nQ.fulfill = fulfill;\nfunction fulfill(value) {\n    return Promise({\n        \"when\": function () {\n            return value;\n        },\n        \"get\": function (name) {\n            return value[name];\n        },\n        \"set\": function (name, rhs) {\n            value[name] = rhs;\n        },\n        \"delete\": function (name) {\n            delete value[name];\n        },\n        \"post\": function (name, args) {\n            // Mark Miller proposes that post with no name should apply a\n            // promised function.\n            if (name === null || name === void 0) {\n                return value.apply(void 0, args);\n            } else {\n                return value[name].apply(value, args);\n            }\n        },\n        \"apply\": function (thisp, args) {\n            return value.apply(thisp, args);\n        },\n        \"keys\": function () {\n            return object_keys(value);\n        }\n    }, void 0, function inspect() {\n        return { state: \"fulfilled\", value: value };\n    });\n}\n\n/**\n * Converts thenables to Q promises.\n * @param promise thenable promise\n * @returns a Q promise\n */\nfunction coerce(promise) {\n    var deferred = defer();\n    Q.nextTick(function () {\n        try {\n            promise.then(deferred.resolve, deferred.reject, deferred.notify);\n        } catch (exception) {\n            deferred.reject(exception);\n        }\n    });\n    return deferred.promise;\n}\n\n/**\n * Annotates an object such that it will never be\n * transferred away from this process over any promise\n * communication channel.\n * @param object\n * @returns promise a wrapping of that object that\n * additionally responds to the \"isDef\" message\n * without a rejection.\n */\nQ.master = master;\nfunction master(object) {\n    return Promise({\n        \"isDef\": function () {}\n    }, function fallback(op, args) {\n        return dispatch(object, op, args);\n    }, function () {\n        return Q(object).inspect();\n    });\n}\n\n/**\n * Spreads the values of a promised array of arguments into the\n * fulfillment callback.\n * @param fulfilled callback that receives variadic arguments from the\n * promised array\n * @param rejected callback that receives the exception if the promise\n * is rejected.\n * @returns a promise for the return value or thrown exception of\n * either callback.\n */\nQ.spread = spread;\nfunction spread(value, fulfilled, rejected) {\n    return Q(value).spread(fulfilled, rejected);\n}\n\nPromise.prototype.spread = function (fulfilled, rejected) {\n    return this.all().then(function (array) {\n        return fulfilled.apply(void 0, array);\n    }, rejected);\n};\n\n/**\n * The async function is a decorator for generator functions, turning\n * them into asynchronous generators.  Although generators are only part\n * of the newest ECMAScript 6 drafts, this code does not cause syntax\n * errors in older engines.  This code should continue to work and will\n * in fact improve over time as the language improves.\n *\n * ES6 generators are currently part of V8 version 3.19 with the\n * --harmony-generators runtime flag enabled.  SpiderMonkey has had them\n * for longer, but under an older Python-inspired form.  This function\n * works on both kinds of generators.\n *\n * Decorates a generator function such that:\n *  - it may yield promises\n *  - execution will continue when that promise is fulfilled\n *  - the value of the yield expression will be the fulfilled value\n *  - it returns a promise for the return value (when the generator\n *    stops iterating)\n *  - the decorated function returns a promise for the return value\n *    of the generator or the first rejected promise among those\n *    yielded.\n *  - if an error is thrown in the generator, it propagates through\n *    every following yield until it is caught, or until it escapes\n *    the generator function altogether, and is translated into a\n *    rejection for the promise returned by the decorated generator.\n */\nQ.async = async;\nfunction async(makeGenerator) {\n    return function () {\n        // when verb is \"send\", arg is a value\n        // when verb is \"throw\", arg is an exception\n        function continuer(verb, arg) {\n            var result;\n\n            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only\n            // engine that has a deployed base of browsers that support generators.\n            // However, SM's generators use the Python-inspired semantics of\n            // outdated ES6 drafts.  We would like to support ES6, but we'd also\n            // like to make it possible to use generators in deployed browsers, so\n            // we also support Python-style generators.  At some point we can remove\n            // this block.\n\n            if (typeof StopIteration === \"undefined\") {\n                // ES6 Generators\n                try {\n                    result = generator[verb](arg);\n                } catch (exception) {\n                    return reject(exception);\n                }\n                if (result.done) {\n                    return Q(result.value);\n                } else {\n                    return when(result.value, callback, errback);\n                }\n            } else {\n                // SpiderMonkey Generators\n                // FIXME: Remove this case when SM does ES6 generators.\n                try {\n                    result = generator[verb](arg);\n                } catch (exception) {\n                    if (isStopIteration(exception)) {\n                        return Q(exception.value);\n                    } else {\n                        return reject(exception);\n                    }\n                }\n                return when(result, callback, errback);\n            }\n        }\n        var generator = makeGenerator.apply(this, arguments);\n        var callback = continuer.bind(continuer, \"next\");\n        var errback = continuer.bind(continuer, \"throw\");\n        return callback();\n    };\n}\n\n/**\n * The spawn function is a small wrapper around async that immediately\n * calls the generator and also ends the promise chain, so that any\n * unhandled errors are thrown instead of forwarded to the error\n * handler. This is useful because it's extremely common to run\n * generators at the top-level to work with libraries.\n */\nQ.spawn = spawn;\nfunction spawn(makeGenerator) {\n    Q.done(Q.async(makeGenerator)());\n}\n\n// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.\n/**\n * Throws a ReturnValue exception to stop an asynchronous generator.\n *\n * This interface is a stop-gap measure to support generator return\n * values in older Firefox/SpiderMonkey.  In browsers that support ES6\n * generators like Chromium 29, just use \"return\" in your generator\n * functions.\n *\n * @param value the return value for the surrounding generator\n * @throws ReturnValue exception with the value.\n * @example\n * // ES6 style\n * Q.async(function* () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      return foo + bar;\n * })\n * // Older SpiderMonkey style\n * Q.async(function () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      Q.return(foo + bar);\n * })\n */\nQ[\"return\"] = _return;\nfunction _return(value) {\n    throw new QReturnValue(value);\n}\n\n/**\n * The promised function decorator ensures that any promise arguments\n * are settled and passed as values (`this` is also settled and passed\n * as a value).  It will also ensure that the result of a function is\n * always a promise.\n *\n * @example\n * var add = Q.promised(function (a, b) {\n *     return a + b;\n * });\n * add(Q(a), Q(B));\n *\n * @param {function} callback The function to decorate\n * @returns {function} a function that has been decorated.\n */\nQ.promised = promised;\nfunction promised(callback) {\n    return function () {\n        return spread([this, all(arguments)], function (self, args) {\n            return callback.apply(self, args);\n        });\n    };\n}\n\n/**\n * sends a message to a value in a future turn\n * @param object* the recipient\n * @param op the name of the message operation, e.g., \"when\",\n * @param args further arguments to be forwarded to the operation\n * @returns result {Promise} a promise for the result of the operation\n */\nQ.dispatch = dispatch;\nfunction dispatch(object, op, args) {\n    return Q(object).dispatch(op, args);\n}\n\nPromise.prototype.dispatch = function (op, args) {\n    var self = this;\n    var deferred = defer();\n    Q.nextTick(function () {\n        self.promiseDispatch(deferred.resolve, op, args);\n    });\n    return deferred.promise;\n};\n\n/**\n * Gets the value of a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to get\n * @return promise for the property value\n */\nQ.get = function (object, key) {\n    return Q(object).dispatch(\"get\", [key]);\n};\n\nPromise.prototype.get = function (key) {\n    return this.dispatch(\"get\", [key]);\n};\n\n/**\n * Sets the value of a property in a future turn.\n * @param object    promise or immediate reference for object object\n * @param name      name of property to set\n * @param value     new value of property\n * @return promise for the return value\n */\nQ.set = function (object, key, value) {\n    return Q(object).dispatch(\"set\", [key, value]);\n};\n\nPromise.prototype.set = function (key, value) {\n    return this.dispatch(\"set\", [key, value]);\n};\n\n/**\n * Deletes a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to delete\n * @return promise for the return value\n */\nQ.del = // XXX legacy\nQ[\"delete\"] = function (object, key) {\n    return Q(object).dispatch(\"delete\", [key]);\n};\n\nPromise.prototype.del = // XXX legacy\nPromise.prototype[\"delete\"] = function (key) {\n    return this.dispatch(\"delete\", [key]);\n};\n\n/**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param value     a value to post, typically an array of\n *                  invocation arguments for promises that\n *                  are ultimately backed with `resolve` values,\n *                  as opposed to those backed with URLs\n *                  wherein the posted value can be any\n *                  JSON serializable object.\n * @return promise for the return value\n */\n// bound locally because it is used by other methods\nQ.mapply = // XXX As proposed by \"Redsandro\"\nQ.post = function (object, name, args) {\n    return Q(object).dispatch(\"post\", [name, args]);\n};\n\nPromise.prototype.mapply = // XXX As proposed by \"Redsandro\"\nPromise.prototype.post = function (name, args) {\n    return this.dispatch(\"post\", [name, args]);\n};\n\n/**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param ...args   array of invocation arguments\n * @return promise for the return value\n */\nQ.send = // XXX Mark Miller's proposed parlance\nQ.mcall = // XXX As proposed by \"Redsandro\"\nQ.invoke = function (object, name /*...args*/) {\n    return Q(object).dispatch(\"post\", [name, array_slice(arguments, 2)]);\n};\n\nPromise.prototype.send = // XXX Mark Miller's proposed parlance\nPromise.prototype.mcall = // XXX As proposed by \"Redsandro\"\nPromise.prototype.invoke = function (name /*...args*/) {\n    return this.dispatch(\"post\", [name, array_slice(arguments, 1)]);\n};\n\n/**\n * Applies the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param args      array of application arguments\n */\nQ.fapply = function (object, args) {\n    return Q(object).dispatch(\"apply\", [void 0, args]);\n};\n\nPromise.prototype.fapply = function (args) {\n    return this.dispatch(\"apply\", [void 0, args]);\n};\n\n/**\n * Calls the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\nQ[\"try\"] =\nQ.fcall = function (object /* ...args*/) {\n    return Q(object).dispatch(\"apply\", [void 0, array_slice(arguments, 1)]);\n};\n\nPromise.prototype.fcall = function (/*...args*/) {\n    return this.dispatch(\"apply\", [void 0, array_slice(arguments)]);\n};\n\n/**\n * Binds the promised function, transforming return values into a fulfilled\n * promise and thrown errors into a rejected one.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\nQ.fbind = function (object /*...args*/) {\n    var promise = Q(object);\n    var args = array_slice(arguments, 1);\n    return function fbound() {\n        return promise.dispatch(\"apply\", [\n            this,\n            args.concat(array_slice(arguments))\n        ]);\n    };\n};\nPromise.prototype.fbind = function (/*...args*/) {\n    var promise = this;\n    var args = array_slice(arguments);\n    return function fbound() {\n        return promise.dispatch(\"apply\", [\n            this,\n            args.concat(array_slice(arguments))\n        ]);\n    };\n};\n\n/**\n * Requests the names of the owned properties of a promised\n * object in a future turn.\n * @param object    promise or immediate reference for target object\n * @return promise for the keys of the eventually settled object\n */\nQ.keys = function (object) {\n    return Q(object).dispatch(\"keys\", []);\n};\n\nPromise.prototype.keys = function () {\n    return this.dispatch(\"keys\", []);\n};\n\n/**\n * Turns an array of promises into a promise for an array.  If any of\n * the promises gets rejected, the whole array is rejected immediately.\n * @param {Array*} an array (or promise for an array) of values (or\n * promises for values)\n * @returns a promise for an array of the corresponding values\n */\n// By Mark Miller\n// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled\nQ.all = all;\nfunction all(promises) {\n    return when(promises, function (promises) {\n        var pendingCount = 0;\n        var deferred = defer();\n        array_reduce(promises, function (undefined, promise, index) {\n            var snapshot;\n            if (\n                isPromise(promise) &&\n                (snapshot = promise.inspect()).state === \"fulfilled\"\n            ) {\n                promises[index] = snapshot.value;\n            } else {\n                ++pendingCount;\n                when(\n                    promise,\n                    function (value) {\n                        promises[index] = value;\n                        if (--pendingCount === 0) {\n                            deferred.resolve(promises);\n                        }\n                    },\n                    deferred.reject,\n                    function (progress) {\n                        deferred.notify({ index: index, value: progress });\n                    }\n                );\n            }\n        }, void 0);\n        if (pendingCount === 0) {\n            deferred.resolve(promises);\n        }\n        return deferred.promise;\n    });\n}\n\nPromise.prototype.all = function () {\n    return all(this);\n};\n\n/**\n * Returns the first resolved promise of an array. Prior rejected promises are\n * ignored.  Rejects only if all promises are rejected.\n * @param {Array*} an array containing values or promises for values\n * @returns a promise fulfilled with the value of the first resolved promise,\n * or a rejected promise if all promises are rejected.\n */\nQ.any = any;\n\nfunction any(promises) {\n    if (promises.length === 0) {\n        return Q.resolve();\n    }\n\n    var deferred = Q.defer();\n    var pendingCount = 0;\n    array_reduce(promises, function (prev, current, index) {\n        var promise = promises[index];\n\n        pendingCount++;\n\n        when(promise, onFulfilled, onRejected, onProgress);\n        function onFulfilled(result) {\n            deferred.resolve(result);\n        }\n        function onRejected() {\n            pendingCount--;\n            if (pendingCount === 0) {\n                deferred.reject(new Error(\n                    \"Can't get fulfillment value from any promise, all \" +\n                    \"promises were rejected.\"\n                ));\n            }\n        }\n        function onProgress(progress) {\n            deferred.notify({\n                index: index,\n                value: progress\n            });\n        }\n    }, undefined);\n\n    return deferred.promise;\n}\n\nPromise.prototype.any = function () {\n    return any(this);\n};\n\n/**\n * Waits for all promises to be settled, either fulfilled or\n * rejected.  This is distinct from `all` since that would stop\n * waiting at the first rejection.  The promise returned by\n * `allResolved` will never be rejected.\n * @param promises a promise for an array (or an array) of promises\n * (or values)\n * @return a promise for an array of promises\n */\nQ.allResolved = deprecate(allResolved, \"allResolved\", \"allSettled\");\nfunction allResolved(promises) {\n    return when(promises, function (promises) {\n        promises = array_map(promises, Q);\n        return when(all(array_map(promises, function (promise) {\n            return when(promise, noop, noop);\n        })), function () {\n            return promises;\n        });\n    });\n}\n\nPromise.prototype.allResolved = function () {\n    return allResolved(this);\n};\n\n/**\n * @see Promise#allSettled\n */\nQ.allSettled = allSettled;\nfunction allSettled(promises) {\n    return Q(promises).allSettled();\n}\n\n/**\n * Turns an array of promises into a promise for an array of their states (as\n * returned by `inspect`) when they have all settled.\n * @param {Array[Any*]} values an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Array[State]} an array of states for the respective values.\n */\nPromise.prototype.allSettled = function () {\n    return this.then(function (promises) {\n        return all(array_map(promises, function (promise) {\n            promise = Q(promise);\n            function regardless() {\n                return promise.inspect();\n            }\n            return promise.then(regardless, regardless);\n        }));\n    });\n};\n\n/**\n * Captures the failure of a promise, giving an oportunity to recover\n * with a callback.  If the given promise is fulfilled, the returned\n * promise is fulfilled.\n * @param {Any*} promise for something\n * @param {Function} callback to fulfill the returned promise if the\n * given promise is rejected\n * @returns a promise for the return value of the callback\n */\nQ.fail = // XXX legacy\nQ[\"catch\"] = function (object, rejected) {\n    return Q(object).then(void 0, rejected);\n};\n\nPromise.prototype.fail = // XXX legacy\nPromise.prototype[\"catch\"] = function (rejected) {\n    return this.then(void 0, rejected);\n};\n\n/**\n * Attaches a listener that can respond to progress notifications from a\n * promise's originating deferred. This listener receives the exact arguments\n * passed to ``deferred.notify``.\n * @param {Any*} promise for something\n * @param {Function} callback to receive any progress notifications\n * @returns the given promise, unchanged\n */\nQ.progress = progress;\nfunction progress(object, progressed) {\n    return Q(object).then(void 0, void 0, progressed);\n}\n\nPromise.prototype.progress = function (progressed) {\n    return this.then(void 0, void 0, progressed);\n};\n\n/**\n * Provides an opportunity to observe the settling of a promise,\n * regardless of whether the promise is fulfilled or rejected.  Forwards\n * the resolution to the returned promise when the callback is done.\n * The callback can return a promise to defer completion.\n * @param {Any*} promise\n * @param {Function} callback to observe the resolution of the given\n * promise, takes no arguments.\n * @returns a promise for the resolution of the given promise when\n * ``fin`` is done.\n */\nQ.fin = // XXX legacy\nQ[\"finally\"] = function (object, callback) {\n    return Q(object)[\"finally\"](callback);\n};\n\nPromise.prototype.fin = // XXX legacy\nPromise.prototype[\"finally\"] = function (callback) {\n    callback = Q(callback);\n    return this.then(function (value) {\n        return callback.fcall().then(function () {\n            return value;\n        });\n    }, function (reason) {\n        // TODO attempt to recycle the rejection with \"this\".\n        return callback.fcall().then(function () {\n            throw reason;\n        });\n    });\n};\n\n/**\n * Terminates a chain of promises, forcing rejections to be\n * thrown as exceptions.\n * @param {Any*} promise at the end of a chain of promises\n * @returns nothing\n */\nQ.done = function (object, fulfilled, rejected, progress) {\n    return Q(object).done(fulfilled, rejected, progress);\n};\n\nPromise.prototype.done = function (fulfilled, rejected, progress) {\n    var onUnhandledError = function (error) {\n        // forward to a future turn so that ``when``\n        // does not catch it and turn it into a rejection.\n        Q.nextTick(function () {\n            makeStackTraceLong(error, promise);\n            if (Q.onerror) {\n                Q.onerror(error);\n            } else {\n                throw error;\n            }\n        });\n    };\n\n    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.\n    var promise = fulfilled || rejected || progress ?\n        this.then(fulfilled, rejected, progress) :\n        this;\n\n    if (typeof process === \"object\" && process && process.domain) {\n        onUnhandledError = process.domain.bind(onUnhandledError);\n    }\n\n    promise.then(void 0, onUnhandledError);\n};\n\n/**\n * Causes a promise to be rejected if it does not get fulfilled before\n * some milliseconds time out.\n * @param {Any*} promise\n * @param {Number} milliseconds timeout\n * @param {Any*} custom error message or Error object (optional)\n * @returns a promise for the resolution of the given promise if it is\n * fulfilled before the timeout, otherwise rejected.\n */\nQ.timeout = function (object, ms, error) {\n    return Q(object).timeout(ms, error);\n};\n\nPromise.prototype.timeout = function (ms, error) {\n    var deferred = defer();\n    var timeoutId = setTimeout(function () {\n        if (!error || \"string\" === typeof error) {\n            error = new Error(error || \"Timed out after \" + ms + \" ms\");\n            error.code = \"ETIMEDOUT\";\n        }\n        deferred.reject(error);\n    }, ms);\n\n    this.then(function (value) {\n        clearTimeout(timeoutId);\n        deferred.resolve(value);\n    }, function (exception) {\n        clearTimeout(timeoutId);\n        deferred.reject(exception);\n    }, deferred.notify);\n\n    return deferred.promise;\n};\n\n/**\n * Returns a promise for the given value (or promised value), some\n * milliseconds after it resolved. Passes rejections immediately.\n * @param {Any*} promise\n * @param {Number} milliseconds\n * @returns a promise for the resolution of the given promise after milliseconds\n * time has elapsed since the resolution of the given promise.\n * If the given promise rejects, that is passed immediately.\n */\nQ.delay = function (object, timeout) {\n    if (timeout === void 0) {\n        timeout = object;\n        object = void 0;\n    }\n    return Q(object).delay(timeout);\n};\n\nPromise.prototype.delay = function (timeout) {\n    return this.then(function (value) {\n        var deferred = defer();\n        setTimeout(function () {\n            deferred.resolve(value);\n        }, timeout);\n        return deferred.promise;\n    });\n};\n\n/**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided as an array, and returns a promise.\n *\n *      Q.nfapply(FS.readFile, [__filename])\n *      .then(function (content) {\n *      })\n *\n */\nQ.nfapply = function (callback, args) {\n    return Q(callback).nfapply(args);\n};\n\nPromise.prototype.nfapply = function (args) {\n    var deferred = defer();\n    var nodeArgs = array_slice(args);\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.fapply(nodeArgs).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided individually, and returns a promise.\n * @example\n * Q.nfcall(FS.readFile, __filename)\n * .then(function (content) {\n * })\n *\n */\nQ.nfcall = function (callback /*...args*/) {\n    var args = array_slice(arguments, 1);\n    return Q(callback).nfapply(args);\n};\n\nPromise.prototype.nfcall = function (/*...args*/) {\n    var nodeArgs = array_slice(arguments);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.fapply(nodeArgs).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Wraps a NodeJS continuation passing function and returns an equivalent\n * version that returns a promise.\n * @example\n * Q.nfbind(FS.readFile, __filename)(\"utf-8\")\n * .then(console.log)\n * .done()\n */\nQ.nfbind =\nQ.denodeify = function (callback /*...args*/) {\n    var baseArgs = array_slice(arguments, 1);\n    return function () {\n        var nodeArgs = baseArgs.concat(array_slice(arguments));\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        Q(callback).fapply(nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n};\n\nPromise.prototype.nfbind =\nPromise.prototype.denodeify = function (/*...args*/) {\n    var args = array_slice(arguments);\n    args.unshift(this);\n    return Q.denodeify.apply(void 0, args);\n};\n\nQ.nbind = function (callback, thisp /*...args*/) {\n    var baseArgs = array_slice(arguments, 2);\n    return function () {\n        var nodeArgs = baseArgs.concat(array_slice(arguments));\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        function bound() {\n            return callback.apply(thisp, arguments);\n        }\n        Q(bound).fapply(nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n};\n\nPromise.prototype.nbind = function (/*thisp, ...args*/) {\n    var args = array_slice(arguments, 0);\n    args.unshift(this);\n    return Q.nbind.apply(void 0, args);\n};\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback with a given array of arguments, plus a provided callback.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param {Array} args arguments to pass to the method; the callback\n * will be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\nQ.nmapply = // XXX As proposed by \"Redsandro\"\nQ.npost = function (object, name, args) {\n    return Q(object).npost(name, args);\n};\n\nPromise.prototype.nmapply = // XXX As proposed by \"Redsandro\"\nPromise.prototype.npost = function (name, args) {\n    var nodeArgs = array_slice(args || []);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback, forwarding the given variadic arguments, plus a provided\n * callback argument.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param ...args arguments to pass to the method; the callback will\n * be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\nQ.nsend = // XXX Based on Mark Miller's proposed \"send\"\nQ.nmcall = // XXX Based on \"Redsandro's\" proposal\nQ.ninvoke = function (object, name /*...args*/) {\n    var nodeArgs = array_slice(arguments, 2);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    Q(object).dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\nPromise.prototype.nsend = // XXX Based on Mark Miller's proposed \"send\"\nPromise.prototype.nmcall = // XXX Based on \"Redsandro's\" proposal\nPromise.prototype.ninvoke = function (name /*...args*/) {\n    var nodeArgs = array_slice(arguments, 1);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * If a function would like to support both Node continuation-passing-style and\n * promise-returning-style, it can end its internal promise chain with\n * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user\n * elects to use a nodeback, the result will be sent there.  If they do not\n * pass a nodeback, they will receive the result promise.\n * @param object a result (or a promise for a result)\n * @param {Function} nodeback a Node.js-style callback\n * @returns either the promise or nothing\n */\nQ.nodeify = nodeify;\nfunction nodeify(object, nodeback) {\n    return Q(object).nodeify(nodeback);\n}\n\nPromise.prototype.nodeify = function (nodeback) {\n    if (nodeback) {\n        this.then(function (value) {\n            Q.nextTick(function () {\n                nodeback(null, value);\n            });\n        }, function (error) {\n            Q.nextTick(function () {\n                nodeback(error);\n            });\n        });\n    } else {\n        return this;\n    }\n};\n\nQ.noConflict = function() {\n    throw new Error(\"Q.noConflict only works when Q is used as a global\");\n};\n\n// All code before this point will be filtered from stack traces.\nvar qEndingLine = captureLine();\n\nreturn Q;\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/q/q.js\n ** module id = 15\n ** module chunks = 0\n **/","/*!\n * Vue.js v1.0.21\n * (c) 2016 Evan You\n * Released under the MIT License.\n */\n'use strict';\n\nfunction set(obj, key, val) {\n  if (hasOwn(obj, key)) {\n    obj[key] = val;\n    return;\n  }\n  if (obj._isVue) {\n    set(obj._data, key, val);\n    return;\n  }\n  var ob = obj.__ob__;\n  if (!ob) {\n    obj[key] = val;\n    return;\n  }\n  ob.convert(key, val);\n  ob.dep.notify();\n  if (ob.vms) {\n    var i = ob.vms.length;\n    while (i--) {\n      var vm = ob.vms[i];\n      vm._proxy(key);\n      vm._digest();\n    }\n  }\n  return val;\n}\n\n/**\n * Delete a property and trigger change if necessary.\n *\n * @param {Object} obj\n * @param {String} key\n */\n\nfunction del(obj, key) {\n  if (!hasOwn(obj, key)) {\n    return;\n  }\n  delete obj[key];\n  var ob = obj.__ob__;\n  if (!ob) {\n    return;\n  }\n  ob.dep.notify();\n  if (ob.vms) {\n    var i = ob.vms.length;\n    while (i--) {\n      var vm = ob.vms[i];\n      vm._unproxy(key);\n      vm._digest();\n    }\n  }\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * Check whether the object has the property.\n *\n * @param {Object} obj\n * @param {String} key\n * @return {Boolean}\n */\n\nfunction hasOwn(obj, key) {\n  return hasOwnProperty.call(obj, key);\n}\n\n/**\n * Check if an expression is a literal value.\n *\n * @param {String} exp\n * @return {Boolean}\n */\n\nvar literalValueRE = /^\\s?(true|false|-?[\\d\\.]+|'[^']*'|\"[^\"]*\")\\s?$/;\n\nfunction isLiteral(exp) {\n  return literalValueRE.test(exp);\n}\n\n/**\n * Check if a string starts with $ or _\n *\n * @param {String} str\n * @return {Boolean}\n */\n\nfunction isReserved(str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F;\n}\n\n/**\n * Guard text output, make sure undefined outputs\n * empty string\n *\n * @param {*} value\n * @return {String}\n */\n\nfunction _toString(value) {\n  return value == null ? '' : value.toString();\n}\n\n/**\n * Check and convert possible numeric strings to numbers\n * before setting back to data\n *\n * @param {*} value\n * @return {*|Number}\n */\n\nfunction toNumber(value) {\n  if (typeof value !== 'string') {\n    return value;\n  } else {\n    var parsed = Number(value);\n    return isNaN(parsed) ? value : parsed;\n  }\n}\n\n/**\n * Convert string boolean literals into real booleans.\n *\n * @param {*} value\n * @return {*|Boolean}\n */\n\nfunction toBoolean(value) {\n  return value === 'true' ? true : value === 'false' ? false : value;\n}\n\n/**\n * Strip quotes from a string\n *\n * @param {String} str\n * @return {String | false}\n */\n\nfunction stripQuotes(str) {\n  var a = str.charCodeAt(0);\n  var b = str.charCodeAt(str.length - 1);\n  return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;\n}\n\n/**\n * Camelize a hyphen-delmited string.\n *\n * @param {String} str\n * @return {String}\n */\n\nvar camelizeRE = /-(\\w)/g;\n\nfunction camelize(str) {\n  return str.replace(camelizeRE, toUpper);\n}\n\nfunction toUpper(_, c) {\n  return c ? c.toUpperCase() : '';\n}\n\n/**\n * Hyphenate a camelCase string.\n *\n * @param {String} str\n * @return {String}\n */\n\nvar hyphenateRE = /([a-z\\d])([A-Z])/g;\n\nfunction hyphenate(str) {\n  return str.replace(hyphenateRE, '$1-$2').toLowerCase();\n}\n\n/**\n * Converts hyphen/underscore/slash delimitered names into\n * camelized classNames.\n *\n * e.g. my-component => MyComponent\n *      some_else    => SomeElse\n *      some/comp    => SomeComp\n *\n * @param {String} str\n * @return {String}\n */\n\nvar classifyRE = /(?:^|[-_\\/])(\\w)/g;\n\nfunction classify(str) {\n  return str.replace(classifyRE, toUpper);\n}\n\n/**\n * Simple bind, faster than native\n *\n * @param {Function} fn\n * @param {Object} ctx\n * @return {Function}\n */\n\nfunction bind(fn, ctx) {\n  return function (a) {\n    var l = arguments.length;\n    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n  };\n}\n\n/**\n * Convert an Array-like object to a real Array.\n *\n * @param {Array-like} list\n * @param {Number} [start] - start index\n * @return {Array}\n */\n\nfunction toArray(list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret;\n}\n\n/**\n * Mix properties into target object.\n *\n * @param {Object} to\n * @param {Object} from\n */\n\nfunction extend(to, from) {\n  var keys = Object.keys(from);\n  var i = keys.length;\n  while (i--) {\n    to[keys[i]] = from[keys[i]];\n  }\n  return to;\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n *\n * @param {*} obj\n * @return {Boolean}\n */\n\nfunction isObject(obj) {\n  return obj !== null && typeof obj === 'object';\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n *\n * @param {*} obj\n * @return {Boolean}\n */\n\nvar toString = Object.prototype.toString;\nvar OBJECT_STRING = '[object Object]';\n\nfunction isPlainObject(obj) {\n  return toString.call(obj) === OBJECT_STRING;\n}\n\n/**\n * Array type check.\n *\n * @param {*} obj\n * @return {Boolean}\n */\n\nvar isArray = Array.isArray;\n\n/**\n * Define a property.\n *\n * @param {Object} obj\n * @param {String} key\n * @param {*} val\n * @param {Boolean} [enumerable]\n */\n\nfunction def(obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Debounce a function so it only gets called after the\n * input stops arriving after the given wait period.\n *\n * @param {Function} func\n * @param {Number} wait\n * @return {Function} - the debounced function\n */\n\nfunction _debounce(func, wait) {\n  var timeout, args, context, timestamp, result;\n  var later = function later() {\n    var last = Date.now() - timestamp;\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    }\n  };\n  return function () {\n    context = this;\n    args = arguments;\n    timestamp = Date.now();\n    if (!timeout) {\n      timeout = setTimeout(later, wait);\n    }\n    return result;\n  };\n}\n\n/**\n * Manual indexOf because it's slightly faster than\n * native.\n *\n * @param {Array} arr\n * @param {*} obj\n */\n\nfunction indexOf(arr, obj) {\n  var i = arr.length;\n  while (i--) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n}\n\n/**\n * Make a cancellable version of an async callback.\n *\n * @param {Function} fn\n * @return {Function}\n */\n\nfunction cancellable(fn) {\n  var cb = function cb() {\n    if (!cb.cancelled) {\n      return fn.apply(this, arguments);\n    }\n  };\n  cb.cancel = function () {\n    cb.cancelled = true;\n  };\n  return cb;\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n *\n * @param {*} a\n * @param {*} b\n * @return {Boolean}\n */\n\nfunction looseEqual(a, b) {\n  /* eslint-disable eqeqeq */\n  return a == b || (isObject(a) && isObject(b) ? JSON.stringify(a) === JSON.stringify(b) : false);\n  /* eslint-enable eqeqeq */\n}\n\nvar hasProto = ('__proto__' in {});\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined' && Object.prototype.toString.call(window) !== '[object Object]';\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n// UA sniffing for working around browser-specific quirks\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0;\n\nvar transitionProp = undefined;\nvar transitionEndEvent = undefined;\nvar animationProp = undefined;\nvar animationEndEvent = undefined;\n\n// Transition property/event sniffing\nif (inBrowser && !isIE9) {\n  var isWebkitTrans = window.ontransitionend === undefined && window.onwebkittransitionend !== undefined;\n  var isWebkitAnim = window.onanimationend === undefined && window.onwebkitanimationend !== undefined;\n  transitionProp = isWebkitTrans ? 'WebkitTransition' : 'transition';\n  transitionEndEvent = isWebkitTrans ? 'webkitTransitionEnd' : 'transitionend';\n  animationProp = isWebkitAnim ? 'WebkitAnimation' : 'animation';\n  animationEndEvent = isWebkitAnim ? 'webkitAnimationEnd' : 'animationend';\n}\n\n/**\n * Defer a task to execute it asynchronously. Ideally this\n * should be executed as a microtask, so we leverage\n * MutationObserver if it's available, and fallback to\n * setTimeout(0).\n *\n * @param {Function} cb\n * @param {Object} ctx\n */\n\nvar nextTick = (function () {\n  var callbacks = [];\n  var pending = false;\n  var timerFunc;\n  function nextTickHandler() {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks = [];\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  /* istanbul ignore if */\n  if (typeof MutationObserver !== 'undefined') {\n    var counter = 1;\n    var observer = new MutationObserver(nextTickHandler);\n    var textNode = document.createTextNode(counter);\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = counter;\n    };\n  } else {\n    // webpack attempts to inject a shim for setImmediate\n    // if it is used as a global, so we have to work around that to\n    // avoid bundling unnecessary code.\n    var context = inBrowser ? window : typeof global !== 'undefined' ? global : {};\n    timerFunc = context.setImmediate || setTimeout;\n  }\n  return function (cb, ctx) {\n    var func = ctx ? function () {\n      cb.call(ctx);\n    } : cb;\n    callbacks.push(func);\n    if (pending) return;\n    pending = true;\n    timerFunc(nextTickHandler, 0);\n  };\n})();\n\nfunction Cache(limit) {\n  this.size = 0;\n  this.limit = limit;\n  this.head = this.tail = undefined;\n  this._keymap = Object.create(null);\n}\n\nvar p = Cache.prototype;\n\n/**\n * Put <value> into the cache associated with <key>.\n * Returns the entry which was removed to make room for\n * the new entry. Otherwise undefined is returned.\n * (i.e. if there was enough room already).\n *\n * @param {String} key\n * @param {*} value\n * @return {Entry|undefined}\n */\n\np.put = function (key, value) {\n  var removed;\n  if (this.size === this.limit) {\n    removed = this.shift();\n  }\n\n  var entry = this.get(key, true);\n  if (!entry) {\n    entry = {\n      key: key\n    };\n    this._keymap[key] = entry;\n    if (this.tail) {\n      this.tail.newer = entry;\n      entry.older = this.tail;\n    } else {\n      this.head = entry;\n    }\n    this.tail = entry;\n    this.size++;\n  }\n  entry.value = value;\n\n  return removed;\n};\n\n/**\n * Purge the least recently used (oldest) entry from the\n * cache. Returns the removed entry or undefined if the\n * cache was empty.\n */\n\np.shift = function () {\n  var entry = this.head;\n  if (entry) {\n    this.head = this.head.newer;\n    this.head.older = undefined;\n    entry.newer = entry.older = undefined;\n    this._keymap[entry.key] = undefined;\n    this.size--;\n  }\n  return entry;\n};\n\n/**\n * Get and register recent use of <key>. Returns the value\n * associated with <key> or undefined if not in cache.\n *\n * @param {String} key\n * @param {Boolean} returnEntry\n * @return {Entry|*}\n */\n\np.get = function (key, returnEntry) {\n  var entry = this._keymap[key];\n  if (entry === undefined) return;\n  if (entry === this.tail) {\n    return returnEntry ? entry : entry.value;\n  }\n  // HEAD--------------TAIL\n  //   <.older   .newer>\n  //  <--- add direction --\n  //   A  B  C  <D>  E\n  if (entry.newer) {\n    if (entry === this.head) {\n      this.head = entry.newer;\n    }\n    entry.newer.older = entry.older; // C <-- E.\n  }\n  if (entry.older) {\n    entry.older.newer = entry.newer; // C. --> E\n  }\n  entry.newer = undefined; // D --x\n  entry.older = this.tail; // D. --> E\n  if (this.tail) {\n    this.tail.newer = entry; // E. <-- D\n  }\n  this.tail = entry;\n  return returnEntry ? entry : entry.value;\n};\n\nvar cache$1 = new Cache(1000);\nvar filterTokenRE = /[^\\s'\"]+|'[^']*'|\"[^\"]*\"/g;\nvar reservedArgRE = /^in$|^-?\\d+/;\n\n/**\n * Parser state\n */\n\nvar str;\nvar dir;\nvar c;\nvar prev;\nvar i;\nvar l;\nvar lastFilterIndex;\nvar inSingle;\nvar inDouble;\nvar curly;\nvar square;\nvar paren;\n/**\n * Push a filter to the current directive object\n */\n\nfunction pushFilter() {\n  var exp = str.slice(lastFilterIndex, i).trim();\n  var filter;\n  if (exp) {\n    filter = {};\n    var tokens = exp.match(filterTokenRE);\n    filter.name = tokens[0];\n    if (tokens.length > 1) {\n      filter.args = tokens.slice(1).map(processFilterArg);\n    }\n  }\n  if (filter) {\n    (dir.filters = dir.filters || []).push(filter);\n  }\n  lastFilterIndex = i + 1;\n}\n\n/**\n * Check if an argument is dynamic and strip quotes.\n *\n * @param {String} arg\n * @return {Object}\n */\n\nfunction processFilterArg(arg) {\n  if (reservedArgRE.test(arg)) {\n    return {\n      value: toNumber(arg),\n      dynamic: false\n    };\n  } else {\n    var stripped = stripQuotes(arg);\n    var dynamic = stripped === arg;\n    return {\n      value: dynamic ? arg : stripped,\n      dynamic: dynamic\n    };\n  }\n}\n\n/**\n * Parse a directive value and extract the expression\n * and its filters into a descriptor.\n *\n * Example:\n *\n * \"a + 1 | uppercase\" will yield:\n * {\n *   expression: 'a + 1',\n *   filters: [\n *     { name: 'uppercase', args: null }\n *   ]\n * }\n *\n * @param {String} s\n * @return {Object}\n */\n\nfunction parseDirective(s) {\n  var hit = cache$1.get(s);\n  if (hit) {\n    return hit;\n  }\n\n  // reset parser state\n  str = s;\n  inSingle = inDouble = false;\n  curly = square = paren = 0;\n  lastFilterIndex = 0;\n  dir = {};\n\n  for (i = 0, l = str.length; i < l; i++) {\n    prev = c;\n    c = str.charCodeAt(i);\n    if (inSingle) {\n      // check single quote\n      if (c === 0x27 && prev !== 0x5C) inSingle = !inSingle;\n    } else if (inDouble) {\n      // check double quote\n      if (c === 0x22 && prev !== 0x5C) inDouble = !inDouble;\n    } else if (c === 0x7C && // pipe\n    str.charCodeAt(i + 1) !== 0x7C && str.charCodeAt(i - 1) !== 0x7C) {\n      if (dir.expression == null) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        dir.expression = str.slice(0, i).trim();\n      } else {\n        // already has filter\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22:\n          inDouble = true;break; // \"\n        case 0x27:\n          inSingle = true;break; // '\n        case 0x28:\n          paren++;break; // (\n        case 0x29:\n          paren--;break; // )\n        case 0x5B:\n          square++;break; // [\n        case 0x5D:\n          square--;break; // ]\n        case 0x7B:\n          curly++;break; // {\n        case 0x7D:\n          curly--;break; // }\n      }\n    }\n  }\n\n  if (dir.expression == null) {\n    dir.expression = str.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  cache$1.put(s, dir);\n  return dir;\n}\n\nvar directive = Object.freeze({\n  parseDirective: parseDirective\n});\n\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\nvar cache = undefined;\nvar tagRE = undefined;\nvar htmlRE = undefined;\n/**\n * Escape a string so it can be used in a RegExp\n * constructor.\n *\n * @param {String} str\n */\n\nfunction escapeRegex(str) {\n  return str.replace(regexEscapeRE, '\\\\$&');\n}\n\nfunction compileRegex() {\n  var open = escapeRegex(config.delimiters[0]);\n  var close = escapeRegex(config.delimiters[1]);\n  var unsafeOpen = escapeRegex(config.unsafeDelimiters[0]);\n  var unsafeClose = escapeRegex(config.unsafeDelimiters[1]);\n  tagRE = new RegExp(unsafeOpen + '((?:.|\\\\n)+?)' + unsafeClose + '|' + open + '((?:.|\\\\n)+?)' + close, 'g');\n  htmlRE = new RegExp('^' + unsafeOpen + '.*' + unsafeClose + '$');\n  // reset cache\n  cache = new Cache(1000);\n}\n\n/**\n * Parse a template text string into an array of tokens.\n *\n * @param {String} text\n * @return {Array<Object> | null}\n *               - {String} type\n *               - {String} value\n *               - {Boolean} [html]\n *               - {Boolean} [oneTime]\n */\n\nfunction parseText(text) {\n  if (!cache) {\n    compileRegex();\n  }\n  var hit = cache.get(text);\n  if (hit) {\n    return hit;\n  }\n  if (!tagRE.test(text)) {\n    return null;\n  }\n  var tokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index, html, value, first, oneTime;\n  /* eslint-disable no-cond-assign */\n  while (match = tagRE.exec(text)) {\n    /* eslint-enable no-cond-assign */\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      tokens.push({\n        value: text.slice(lastIndex, index)\n      });\n    }\n    // tag token\n    html = htmlRE.test(match[0]);\n    value = html ? match[1] : match[2];\n    first = value.charCodeAt(0);\n    oneTime = first === 42; // *\n    value = oneTime ? value.slice(1) : value;\n    tokens.push({\n      tag: true,\n      value: value.trim(),\n      html: html,\n      oneTime: oneTime\n    });\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    tokens.push({\n      value: text.slice(lastIndex)\n    });\n  }\n  cache.put(text, tokens);\n  return tokens;\n}\n\n/**\n * Format a list of tokens into an expression.\n * e.g. tokens parsed from 'a {{b}} c' can be serialized\n * into one single expression as '\"a \" + b + \" c\"'.\n *\n * @param {Array} tokens\n * @param {Vue} [vm]\n * @return {String}\n */\n\nfunction tokensToExp(tokens, vm) {\n  if (tokens.length > 1) {\n    return tokens.map(function (token) {\n      return formatToken(token, vm);\n    }).join('+');\n  } else {\n    return formatToken(tokens[0], vm, true);\n  }\n}\n\n/**\n * Format a single token.\n *\n * @param {Object} token\n * @param {Vue} [vm]\n * @param {Boolean} [single]\n * @return {String}\n */\n\nfunction formatToken(token, vm, single) {\n  return token.tag ? token.oneTime && vm ? '\"' + vm.$eval(token.value) + '\"' : inlineFilters(token.value, single) : '\"' + token.value + '\"';\n}\n\n/**\n * For an attribute with multiple interpolation tags,\n * e.g. attr=\"some-{{thing | filter}}\", in order to combine\n * the whole thing into a single watchable expression, we\n * have to inline those filters. This function does exactly\n * that. This is a bit hacky but it avoids heavy changes\n * to directive parser and watcher mechanism.\n *\n * @param {String} exp\n * @param {Boolean} single\n * @return {String}\n */\n\nvar filterRE = /[^|]\\|[^|]/;\nfunction inlineFilters(exp, single) {\n  if (!filterRE.test(exp)) {\n    return single ? exp : '(' + exp + ')';\n  } else {\n    var dir = parseDirective(exp);\n    if (!dir.filters) {\n      return '(' + exp + ')';\n    } else {\n      return 'this._applyFilters(' + dir.expression + // value\n      ',null,' + // oldValue (null for read)\n      JSON.stringify(dir.filters) + // filter descriptors\n      ',false)'; // write?\n    }\n  }\n}\n\nvar text = Object.freeze({\n  compileRegex: compileRegex,\n  parseText: parseText,\n  tokensToExp: tokensToExp\n});\n\nvar delimiters = ['{{', '}}'];\nvar unsafeDelimiters = ['{{{', '}}}'];\n\nvar config = Object.defineProperties({\n\n  /**\n   * Whether to print debug messages.\n   * Also enables stack trace for warnings.\n   *\n   * @type {Boolean}\n   */\n\n  debug: false,\n\n  /**\n   * Whether to suppress warnings.\n   *\n   * @type {Boolean}\n   */\n\n  silent: false,\n\n  /**\n   * Whether to use async rendering.\n   */\n\n  async: true,\n\n  /**\n   * Whether to warn against errors caught when evaluating\n   * expressions.\n   */\n\n  warnExpressionErrors: true,\n\n  /**\n   * Whether to allow devtools inspection.\n   * Disabled by default in production builds.\n   */\n\n  devtools: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Internal flag to indicate the delimiters have been\n   * changed.\n   *\n   * @type {Boolean}\n   */\n\n  _delimitersChanged: true,\n\n  /**\n   * List of asset types that a component can own.\n   *\n   * @type {Array}\n   */\n\n  _assetTypes: ['component', 'directive', 'elementDirective', 'filter', 'transition', 'partial'],\n\n  /**\n   * prop binding modes\n   */\n\n  _propBindingModes: {\n    ONE_WAY: 0,\n    TWO_WAY: 1,\n    ONE_TIME: 2\n  },\n\n  /**\n   * Max circular updates allowed in a batcher flush cycle.\n   */\n\n  _maxUpdateCount: 100\n\n}, {\n  delimiters: { /**\n                 * Interpolation delimiters. Changing these would trigger\n                 * the text parser to re-compile the regular expressions.\n                 *\n                 * @type {Array<String>}\n                 */\n\n    get: function get() {\n      return delimiters;\n    },\n    set: function set(val) {\n      delimiters = val;\n      compileRegex();\n    },\n    configurable: true,\n    enumerable: true\n  },\n  unsafeDelimiters: {\n    get: function get() {\n      return unsafeDelimiters;\n    },\n    set: function set(val) {\n      unsafeDelimiters = val;\n      compileRegex();\n    },\n    configurable: true,\n    enumerable: true\n  }\n});\n\nvar warn = undefined;\nvar formatComponentName = undefined;\n\nif (process.env.NODE_ENV !== 'production') {\n  (function () {\n    var hasConsole = typeof console !== 'undefined';\n\n    warn = function (msg, vm) {\n      if (hasConsole && !config.silent) {\n        console.error('[Vue warn]: ' + msg + (vm ? formatComponentName(vm) : ''));\n      }\n    };\n\n    formatComponentName = function (vm) {\n      var name = vm._isVue ? vm.$options.name : vm.name;\n      return name ? ' (found in component: <' + hyphenate(name) + '>)' : '';\n    };\n  })();\n}\n\n/**\n * Append with transition.\n *\n * @param {Element} el\n * @param {Element} target\n * @param {Vue} vm\n * @param {Function} [cb]\n */\n\nfunction appendWithTransition(el, target, vm, cb) {\n  applyTransition(el, 1, function () {\n    target.appendChild(el);\n  }, vm, cb);\n}\n\n/**\n * InsertBefore with transition.\n *\n * @param {Element} el\n * @param {Element} target\n * @param {Vue} vm\n * @param {Function} [cb]\n */\n\nfunction beforeWithTransition(el, target, vm, cb) {\n  applyTransition(el, 1, function () {\n    before(el, target);\n  }, vm, cb);\n}\n\n/**\n * Remove with transition.\n *\n * @param {Element} el\n * @param {Vue} vm\n * @param {Function} [cb]\n */\n\nfunction removeWithTransition(el, vm, cb) {\n  applyTransition(el, -1, function () {\n    remove(el);\n  }, vm, cb);\n}\n\n/**\n * Apply transitions with an operation callback.\n *\n * @param {Element} el\n * @param {Number} direction\n *                  1: enter\n *                 -1: leave\n * @param {Function} op - the actual DOM operation\n * @param {Vue} vm\n * @param {Function} [cb]\n */\n\nfunction applyTransition(el, direction, op, vm, cb) {\n  var transition = el.__v_trans;\n  if (!transition ||\n  // skip if there are no js hooks and CSS transition is\n  // not supported\n  !transition.hooks && !transitionEndEvent ||\n  // skip transitions for initial compile\n  !vm._isCompiled ||\n  // if the vm is being manipulated by a parent directive\n  // during the parent's compilation phase, skip the\n  // animation.\n  vm.$parent && !vm.$parent._isCompiled) {\n    op();\n    if (cb) cb();\n    return;\n  }\n  var action = direction > 0 ? 'enter' : 'leave';\n  transition[action](op, cb);\n}\n\nvar transition = Object.freeze({\n  appendWithTransition: appendWithTransition,\n  beforeWithTransition: beforeWithTransition,\n  removeWithTransition: removeWithTransition,\n  applyTransition: applyTransition\n});\n\n/**\n * Query an element selector if it's not an element already.\n *\n * @param {String|Element} el\n * @return {Element}\n */\n\nfunction query(el) {\n  if (typeof el === 'string') {\n    var selector = el;\n    el = document.querySelector(el);\n    if (!el) {\n      process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + selector);\n    }\n  }\n  return el;\n}\n\n/**\n * Check if a node is in the document.\n * Note: document.documentElement.contains should work here\n * but always returns false for comment nodes in phantomjs,\n * making unit tests difficult. This is fixed by doing the\n * contains() check on the node's parentNode instead of\n * the node itself.\n *\n * @param {Node} node\n * @return {Boolean}\n */\n\nfunction inDoc(node) {\n  var doc = document.documentElement;\n  var parent = node && node.parentNode;\n  return doc === node || doc === parent || !!(parent && parent.nodeType === 1 && doc.contains(parent));\n}\n\n/**\n * Get and remove an attribute from a node.\n *\n * @param {Node} node\n * @param {String} _attr\n */\n\nfunction getAttr(node, _attr) {\n  var val = node.getAttribute(_attr);\n  if (val !== null) {\n    node.removeAttribute(_attr);\n  }\n  return val;\n}\n\n/**\n * Get an attribute with colon or v-bind: prefix.\n *\n * @param {Node} node\n * @param {String} name\n * @return {String|null}\n */\n\nfunction getBindAttr(node, name) {\n  var val = getAttr(node, ':' + name);\n  if (val === null) {\n    val = getAttr(node, 'v-bind:' + name);\n  }\n  return val;\n}\n\n/**\n * Check the presence of a bind attribute.\n *\n * @param {Node} node\n * @param {String} name\n * @return {Boolean}\n */\n\nfunction hasBindAttr(node, name) {\n  return node.hasAttribute(name) || node.hasAttribute(':' + name) || node.hasAttribute('v-bind:' + name);\n}\n\n/**\n * Insert el before target\n *\n * @param {Element} el\n * @param {Element} target\n */\n\nfunction before(el, target) {\n  target.parentNode.insertBefore(el, target);\n}\n\n/**\n * Insert el after target\n *\n * @param {Element} el\n * @param {Element} target\n */\n\nfunction after(el, target) {\n  if (target.nextSibling) {\n    before(el, target.nextSibling);\n  } else {\n    target.parentNode.appendChild(el);\n  }\n}\n\n/**\n * Remove el from DOM\n *\n * @param {Element} el\n */\n\nfunction remove(el) {\n  el.parentNode.removeChild(el);\n}\n\n/**\n * Prepend el to target\n *\n * @param {Element} el\n * @param {Element} target\n */\n\nfunction prepend(el, target) {\n  if (target.firstChild) {\n    before(el, target.firstChild);\n  } else {\n    target.appendChild(el);\n  }\n}\n\n/**\n * Replace target with el\n *\n * @param {Element} target\n * @param {Element} el\n */\n\nfunction replace(target, el) {\n  var parent = target.parentNode;\n  if (parent) {\n    parent.replaceChild(el, target);\n  }\n}\n\n/**\n * Add event listener shorthand.\n *\n * @param {Element} el\n * @param {String} event\n * @param {Function} cb\n * @param {Boolean} [useCapture]\n */\n\nfunction on(el, event, cb, useCapture) {\n  el.addEventListener(event, cb, useCapture);\n}\n\n/**\n * Remove event listener shorthand.\n *\n * @param {Element} el\n * @param {String} event\n * @param {Function} cb\n */\n\nfunction off(el, event, cb) {\n  el.removeEventListener(event, cb);\n}\n\n/**\n * For IE9 compat: when both class and :class are present\n * getAttribute('class') returns wrong value...\n *\n * @param {Element} el\n * @return {String}\n */\n\nfunction getClass(el) {\n  var classname = el.className;\n  if (typeof classname === 'object') {\n    classname = classname.baseVal || '';\n  }\n  return classname;\n}\n\n/**\n * In IE9, setAttribute('class') will result in empty class\n * if the element also has the :class attribute; However in\n * PhantomJS, setting `className` does not work on SVG elements...\n * So we have to do a conditional check here.\n *\n * @param {Element} el\n * @param {String} cls\n */\n\nfunction setClass(el, cls) {\n  /* istanbul ignore if */\n  if (isIE9 && !/svg$/.test(el.namespaceURI)) {\n    el.className = cls;\n  } else {\n    el.setAttribute('class', cls);\n  }\n}\n\n/**\n * Add class with compatibility for IE & SVG\n *\n * @param {Element} el\n * @param {String} cls\n */\n\nfunction addClass(el, cls) {\n  if (el.classList) {\n    el.classList.add(cls);\n  } else {\n    var cur = ' ' + getClass(el) + ' ';\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      setClass(el, (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for IE & SVG\n *\n * @param {Element} el\n * @param {String} cls\n */\n\nfunction removeClass(el, cls) {\n  if (el.classList) {\n    el.classList.remove(cls);\n  } else {\n    var cur = ' ' + getClass(el) + ' ';\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    setClass(el, cur.trim());\n  }\n  if (!el.className) {\n    el.removeAttribute('class');\n  }\n}\n\n/**\n * Extract raw content inside an element into a temporary\n * container div\n *\n * @param {Element} el\n * @param {Boolean} asFragment\n * @return {Element|DocumentFragment}\n */\n\nfunction extractContent(el, asFragment) {\n  var child;\n  var rawContent;\n  /* istanbul ignore if */\n  if (isTemplate(el) && isFragment(el.content)) {\n    el = el.content;\n  }\n  if (el.hasChildNodes()) {\n    trimNode(el);\n    rawContent = asFragment ? document.createDocumentFragment() : document.createElement('div');\n    /* eslint-disable no-cond-assign */\n    while (child = el.firstChild) {\n      /* eslint-enable no-cond-assign */\n      rawContent.appendChild(child);\n    }\n  }\n  return rawContent;\n}\n\n/**\n * Trim possible empty head/tail text and comment\n * nodes inside a parent.\n *\n * @param {Node} node\n */\n\nfunction trimNode(node) {\n  var child;\n  /* eslint-disable no-sequences */\n  while ((child = node.firstChild, isTrimmable(child))) {\n    node.removeChild(child);\n  }\n  while ((child = node.lastChild, isTrimmable(child))) {\n    node.removeChild(child);\n  }\n  /* eslint-enable no-sequences */\n}\n\nfunction isTrimmable(node) {\n  return node && (node.nodeType === 3 && !node.data.trim() || node.nodeType === 8);\n}\n\n/**\n * Check if an element is a template tag.\n * Note if the template appears inside an SVG its tagName\n * will be in lowercase.\n *\n * @param {Element} el\n */\n\nfunction isTemplate(el) {\n  return el.tagName && el.tagName.toLowerCase() === 'template';\n}\n\n/**\n * Create an \"anchor\" for performing dom insertion/removals.\n * This is used in a number of scenarios:\n * - fragment instance\n * - v-html\n * - v-if\n * - v-for\n * - component\n *\n * @param {String} content\n * @param {Boolean} persist - IE trashes empty textNodes on\n *                            cloneNode(true), so in certain\n *                            cases the anchor needs to be\n *                            non-empty to be persisted in\n *                            templates.\n * @return {Comment|Text}\n */\n\nfunction createAnchor(content, persist) {\n  var anchor = config.debug ? document.createComment(content) : document.createTextNode(persist ? ' ' : '');\n  anchor.__v_anchor = true;\n  return anchor;\n}\n\n/**\n * Find a component ref attribute that starts with $.\n *\n * @param {Element} node\n * @return {String|undefined}\n */\n\nvar refRE = /^v-ref:/;\n\nfunction findRef(node) {\n  if (node.hasAttributes()) {\n    var attrs = node.attributes;\n    for (var i = 0, l = attrs.length; i < l; i++) {\n      var name = attrs[i].name;\n      if (refRE.test(name)) {\n        return camelize(name.replace(refRE, ''));\n      }\n    }\n  }\n}\n\n/**\n * Map a function to a range of nodes .\n *\n * @param {Node} node\n * @param {Node} end\n * @param {Function} op\n */\n\nfunction mapNodeRange(node, end, op) {\n  var next;\n  while (node !== end) {\n    next = node.nextSibling;\n    op(node);\n    node = next;\n  }\n  op(end);\n}\n\n/**\n * Remove a range of nodes with transition, store\n * the nodes in a fragment with correct ordering,\n * and call callback when done.\n *\n * @param {Node} start\n * @param {Node} end\n * @param {Vue} vm\n * @param {DocumentFragment} frag\n * @param {Function} cb\n */\n\nfunction removeNodeRange(start, end, vm, frag, cb) {\n  var done = false;\n  var removed = 0;\n  var nodes = [];\n  mapNodeRange(start, end, function (node) {\n    if (node === end) done = true;\n    nodes.push(node);\n    removeWithTransition(node, vm, onRemoved);\n  });\n  function onRemoved() {\n    removed++;\n    if (done && removed >= nodes.length) {\n      for (var i = 0; i < nodes.length; i++) {\n        frag.appendChild(nodes[i]);\n      }\n      cb && cb();\n    }\n  }\n}\n\n/**\n * Check if a node is a DocumentFragment.\n *\n * @param {Node} node\n * @return {Boolean}\n */\n\nfunction isFragment(node) {\n  return node && node.nodeType === 11;\n}\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n *\n * @param {Element} el\n * @return {String}\n */\n\nfunction getOuterHTML(el) {\n  if (el.outerHTML) {\n    return el.outerHTML;\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML;\n  }\n}\n\nvar commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/i;\nvar reservedTagRE = /^(slot|partial|component)$/i;\n\nvar isUnknownElement = undefined;\nif (process.env.NODE_ENV !== 'production') {\n  isUnknownElement = function (el, tag) {\n    if (tag.indexOf('-') > -1) {\n      // http://stackoverflow.com/a/28210364/1070244\n      return el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;\n    } else {\n      return (/HTMLUnknownElement/.test(el.toString()) &&\n        // Chrome returns unknown for several HTML5 elements.\n        // https://code.google.com/p/chromium/issues/detail?id=540526\n        !/^(data|time|rtc|rb)$/.test(tag)\n      );\n    }\n  };\n}\n\n/**\n * Check if an element is a component, if yes return its\n * component id.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Object|undefined}\n */\n\nfunction checkComponentAttr(el, options) {\n  var tag = el.tagName.toLowerCase();\n  var hasAttrs = el.hasAttributes();\n  if (!commonTagRE.test(tag) && !reservedTagRE.test(tag)) {\n    if (resolveAsset(options, 'components', tag)) {\n      return { id: tag };\n    } else {\n      var is = hasAttrs && getIsBinding(el);\n      if (is) {\n        return is;\n      } else if (process.env.NODE_ENV !== 'production') {\n        var expectedTag = options._componentNameMap && options._componentNameMap[tag];\n        if (expectedTag) {\n          warn('Unknown custom element: <' + tag + '> - ' + 'did you mean <' + expectedTag + '>? ' + 'HTML is case-insensitive, remember to use kebab-case in templates.');\n        } else if (isUnknownElement(el, tag)) {\n          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the \"name\" option.');\n        }\n      }\n    }\n  } else if (hasAttrs) {\n    return getIsBinding(el);\n  }\n}\n\n/**\n * Get \"is\" binding from an element.\n *\n * @param {Element} el\n * @return {Object|undefined}\n */\n\nfunction getIsBinding(el) {\n  // dynamic syntax\n  var exp = getAttr(el, 'is');\n  if (exp != null) {\n    return { id: exp };\n  } else {\n    exp = getBindAttr(el, 'is');\n    if (exp != null) {\n      return { id: exp, dynamic: true };\n    }\n  }\n}\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n *\n * All strategy functions follow the same signature:\n *\n * @param {*} parentVal\n * @param {*} childVal\n * @param {Vue} [vm]\n */\n\nvar strats = config.optionMergeStrategies = Object.create(null);\n\n/**\n * Helper that recursively merges two data objects together.\n */\n\nfunction mergeData(to, from) {\n  var key, toVal, fromVal;\n  for (key in from) {\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (isObject(toVal) && isObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to;\n}\n\n/**\n * Data\n */\n\nstrats.data = function (parentVal, childVal, vm) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal;\n    }\n    if (typeof childVal !== 'function') {\n      process.env.NODE_ENV !== 'production' && warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n      return parentVal;\n    }\n    if (!parentVal) {\n      return childVal;\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn() {\n      return mergeData(childVal.call(this), parentVal.call(this));\n    };\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn() {\n      // instance merge\n      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;\n      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData);\n      } else {\n        return defaultData;\n      }\n    };\n  }\n};\n\n/**\n * El\n */\n\nstrats.el = function (parentVal, childVal, vm) {\n  if (!vm && childVal && typeof childVal !== 'function') {\n    process.env.NODE_ENV !== 'production' && warn('The \"el\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n    return;\n  }\n  var ret = childVal || parentVal;\n  // invoke the element factory if this is instance merge\n  return vm && typeof ret === 'function' ? ret.call(vm) : ret;\n};\n\n/**\n * Hooks and param attributes are merged as arrays.\n */\n\nstrats.init = strats.created = strats.ready = strats.attached = strats.detached = strats.beforeCompile = strats.compiled = strats.beforeDestroy = strats.destroyed = strats.activate = function (parentVal, childVal) {\n  return childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;\n};\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\n\nfunction mergeAssets(parentVal, childVal) {\n  var res = Object.create(parentVal);\n  return childVal ? extend(res, guardArrayAssets(childVal)) : res;\n}\n\nconfig._assetTypes.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Events & Watchers.\n *\n * Events & watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\n\nstrats.watch = strats.events = function (parentVal, childVal) {\n  if (!childVal) return parentVal;\n  if (!parentVal) return childVal;\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key in childVal) {\n    var parent = ret[key];\n    var child = childVal[key];\n    if (parent && !isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key] = parent ? parent.concat(child) : [child];\n  }\n  return ret;\n};\n\n/**\n * Other object hashes.\n */\n\nstrats.props = strats.methods = strats.computed = function (parentVal, childVal) {\n  if (!childVal) return parentVal;\n  if (!parentVal) return childVal;\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  extend(ret, childVal);\n  return ret;\n};\n\n/**\n * Default strategy.\n */\n\nvar defaultStrat = function defaultStrat(parentVal, childVal) {\n  return childVal === undefined ? parentVal : childVal;\n};\n\n/**\n * Make sure component options get converted to actual\n * constructors.\n *\n * @param {Object} options\n */\n\nfunction guardComponents(options) {\n  if (options.components) {\n    var components = options.components = guardArrayAssets(options.components);\n    var ids = Object.keys(components);\n    var def;\n    if (process.env.NODE_ENV !== 'production') {\n      var map = options._componentNameMap = {};\n    }\n    for (var i = 0, l = ids.length; i < l; i++) {\n      var key = ids[i];\n      if (commonTagRE.test(key) || reservedTagRE.test(key)) {\n        process.env.NODE_ENV !== 'production' && warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);\n        continue;\n      }\n      // record a all lowercase <-> kebab-case mapping for\n      // possible custom element case error warning\n      if (process.env.NODE_ENV !== 'production') {\n        map[key.replace(/-/g, '').toLowerCase()] = hyphenate(key);\n      }\n      def = components[key];\n      if (isPlainObject(def)) {\n        components[key] = Vue.extend(def);\n      }\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n *\n * @param {Object} options\n */\n\nfunction guardProps(options) {\n  var props = options.props;\n  var i, val;\n  if (isArray(props)) {\n    options.props = {};\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        options.props[val] = null;\n      } else if (val.name) {\n        options.props[val.name] = val;\n      }\n    }\n  } else if (isPlainObject(props)) {\n    var keys = Object.keys(props);\n    i = keys.length;\n    while (i--) {\n      val = props[keys[i]];\n      if (typeof val === 'function') {\n        props[keys[i]] = { type: val };\n      }\n    }\n  }\n}\n\n/**\n * Guard an Array-format assets option and converted it\n * into the key-value Object format.\n *\n * @param {Object|Array} assets\n * @return {Object}\n */\n\nfunction guardArrayAssets(assets) {\n  if (isArray(assets)) {\n    var res = {};\n    var i = assets.length;\n    var asset;\n    while (i--) {\n      asset = assets[i];\n      var id = typeof asset === 'function' ? asset.options && asset.options.name || asset.id : asset.name || asset.id;\n      if (!id) {\n        process.env.NODE_ENV !== 'production' && warn('Array-syntax assets must provide a \"name\" or \"id\" field.');\n      } else {\n        res[id] = asset;\n      }\n    }\n    return res;\n  }\n  return assets;\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n *\n * @param {Object} parent\n * @param {Object} child\n * @param {Vue} [vm] - if vm is present, indicates this is\n *                     an instantiation merge.\n */\n\nfunction mergeOptions(parent, child, vm) {\n  guardComponents(child);\n  guardProps(child);\n  var options = {};\n  var key;\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      parent = mergeOptions(parent, child.mixins[i], vm);\n    }\n  }\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField(key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options;\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n *\n * @param {Object} options\n * @param {String} type\n * @param {String} id\n * @param {Boolean} warnMissing\n * @return {Object|Function}\n */\n\nfunction resolveAsset(options, type, id, warnMissing) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return;\n  }\n  var assets = options[type];\n  var camelizedId;\n  var res = assets[id] ||\n  // camelCase ID\n  assets[camelizedId = camelize(id)] ||\n  // Pascal Case ID\n  assets[camelizedId.charAt(0).toUpperCase() + camelizedId.slice(1)];\n  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\n    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);\n  }\n  return res;\n}\n\nvar uid$1 = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n *\n * @constructor\n */\nfunction Dep() {\n  this.id = uid$1++;\n  this.subs = [];\n}\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\n\n/**\n * Add a directive subscriber.\n *\n * @param {Directive} sub\n */\n\nDep.prototype.addSub = function (sub) {\n  this.subs.push(sub);\n};\n\n/**\n * Remove a directive subscriber.\n *\n * @param {Directive} sub\n */\n\nDep.prototype.removeSub = function (sub) {\n  this.subs.$remove(sub);\n};\n\n/**\n * Add self as a dependency to the target watcher.\n */\n\nDep.prototype.depend = function () {\n  Dep.target.addDep(this);\n};\n\n/**\n * Notify all subscribers of a new value.\n */\n\nDep.prototype.notify = function () {\n  // stablize the subscriber list first\n  var subs = toArray(this.subs);\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto)\n\n/**\n * Intercept mutating methods and emit events\n */\n\n;['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator() {\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length;\n    var args = new Array(i);\n    while (i--) {\n      args[i] = arguments[i];\n    }\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n        inserted = args;\n        break;\n      case 'unshift':\n        inserted = args;\n        break;\n      case 'splice':\n        inserted = args.slice(2);\n        break;\n    }\n    if (inserted) ob.observeArray(inserted);\n    // notify change\n    ob.dep.notify();\n    return result;\n  });\n});\n\n/**\n * Swap the element at the given index with a new value\n * and emits corresponding event.\n *\n * @param {Number} index\n * @param {*} val\n * @return {*} - replaced element\n */\n\ndef(arrayProto, '$set', function $set(index, val) {\n  if (index >= this.length) {\n    this.length = Number(index) + 1;\n  }\n  return this.splice(index, 1, val)[0];\n});\n\n/**\n * Convenience method to remove the element at given index or target element reference.\n *\n * @param {*} item\n */\n\ndef(arrayProto, '$remove', function $remove(item) {\n  /* istanbul ignore if */\n  if (!this.length) return;\n  var index = indexOf(this, item);\n  if (index > -1) {\n    return this.splice(index, 1);\n  }\n});\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However in certain cases, e.g.\n * v-for scope alias and props, we don't want to force conversion\n * because the value may be a nested value under a frozen data structure.\n *\n * So whenever we want to set a reactive property without forcing\n * conversion on the new value, we wrap that call inside this function.\n */\n\nvar shouldConvert = true;\n\nfunction withoutConversion(fn) {\n  shouldConvert = false;\n  fn();\n  shouldConvert = true;\n}\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n *\n * @param {Array|Object} value\n * @constructor\n */\n\nfunction Observer(value) {\n  this.value = value;\n  this.dep = new Dep();\n  def(value, '__ob__', this);\n  if (isArray(value)) {\n    var augment = hasProto ? protoAugment : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n}\n\n// Instance methods\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n *\n * @param {Object} obj\n */\n\nObserver.prototype.walk = function (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0, l = keys.length; i < l; i++) {\n    this.convert(keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n *\n * @param {Array} items\n */\n\nObserver.prototype.observeArray = function (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n/**\n * Convert a property into getter/setter so we can emit\n * the events when the property is accessed/changed.\n *\n * @param {String} key\n * @param {*} val\n */\n\nObserver.prototype.convert = function (key, val) {\n  defineReactive(this.value, key, val);\n};\n\n/**\n * Add an owner vm, so that when $set/$delete mutations\n * happen we can notify owner vms to proxy the keys and\n * digest the watchers. This is only called when the object\n * is observed as an instance's root $data.\n *\n * @param {Vue} vm\n */\n\nObserver.prototype.addVm = function (vm) {\n  (this.vms || (this.vms = [])).push(vm);\n};\n\n/**\n * Remove an owner vm. This is called when the object is\n * swapped out as an instance's $data object.\n *\n * @param {Vue} vm\n */\n\nObserver.prototype.removeVm = function (vm) {\n  this.vms.$remove(vm);\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n *\n * @param {Object|Array} target\n * @param {Object} src\n */\n\nfunction protoAugment(target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n *\n * @param {Object|Array} target\n * @param {Object} proto\n */\n\nfunction copyAugment(target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n *\n * @param {*} value\n * @param {Vue} [vm]\n * @return {Observer|undefined}\n * @static\n */\n\nfunction observe(value, vm) {\n  if (!value || typeof value !== 'object') {\n    return;\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (shouldConvert && (isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {\n    ob = new Observer(value);\n  }\n  if (ob && vm) {\n    ob.addVm(vm);\n  }\n  return ob;\n}\n\n/**\n * Define a reactive property on an Object.\n *\n * @param {Object} obj\n * @param {String} key\n * @param {*} val\n */\n\nfunction defineReactive(obj, key, val) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return;\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter() {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n        }\n        if (isArray(value)) {\n          for (var e, i = 0, l = value.length; i < l; i++) {\n            e = value[i];\n            e && e.__ob__ && e.__ob__.dep.depend();\n          }\n        }\n      }\n      return value;\n    },\n    set: function reactiveSetter(newVal) {\n      var value = getter ? getter.call(obj) : val;\n      if (newVal === value) {\n        return;\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n\n\nvar util = Object.freeze({\n\tdefineReactive: defineReactive,\n\tset: set,\n\tdel: del,\n\thasOwn: hasOwn,\n\tisLiteral: isLiteral,\n\tisReserved: isReserved,\n\t_toString: _toString,\n\ttoNumber: toNumber,\n\ttoBoolean: toBoolean,\n\tstripQuotes: stripQuotes,\n\tcamelize: camelize,\n\thyphenate: hyphenate,\n\tclassify: classify,\n\tbind: bind,\n\ttoArray: toArray,\n\textend: extend,\n\tisObject: isObject,\n\tisPlainObject: isPlainObject,\n\tdef: def,\n\tdebounce: _debounce,\n\tindexOf: indexOf,\n\tcancellable: cancellable,\n\tlooseEqual: looseEqual,\n\tisArray: isArray,\n\thasProto: hasProto,\n\tinBrowser: inBrowser,\n\tdevtools: devtools,\n\tisIE9: isIE9,\n\tisAndroid: isAndroid,\n\tget transitionProp () { return transitionProp; },\n\tget transitionEndEvent () { return transitionEndEvent; },\n\tget animationProp () { return animationProp; },\n\tget animationEndEvent () { return animationEndEvent; },\n\tnextTick: nextTick,\n\tquery: query,\n\tinDoc: inDoc,\n\tgetAttr: getAttr,\n\tgetBindAttr: getBindAttr,\n\thasBindAttr: hasBindAttr,\n\tbefore: before,\n\tafter: after,\n\tremove: remove,\n\tprepend: prepend,\n\treplace: replace,\n\ton: on,\n\toff: off,\n\tsetClass: setClass,\n\taddClass: addClass,\n\tremoveClass: removeClass,\n\textractContent: extractContent,\n\ttrimNode: trimNode,\n\tisTemplate: isTemplate,\n\tcreateAnchor: createAnchor,\n\tfindRef: findRef,\n\tmapNodeRange: mapNodeRange,\n\tremoveNodeRange: removeNodeRange,\n\tisFragment: isFragment,\n\tgetOuterHTML: getOuterHTML,\n\tmergeOptions: mergeOptions,\n\tresolveAsset: resolveAsset,\n\tcheckComponentAttr: checkComponentAttr,\n\tcommonTagRE: commonTagRE,\n\treservedTagRE: reservedTagRE,\n\tget warn () { return warn; }\n});\n\nvar uid = 0;\n\nfunction initMixin (Vue) {\n  /**\n   * The main init sequence. This is called for every\n   * instance, including ones that are created from extended\n   * constructors.\n   *\n   * @param {Object} options - this options object should be\n   *                           the result of merging class\n   *                           options and the options passed\n   *                           in to the constructor.\n   */\n\n  Vue.prototype._init = function (options) {\n    options = options || {};\n\n    this.$el = null;\n    this.$parent = options.parent;\n    this.$root = this.$parent ? this.$parent.$root : this;\n    this.$children = [];\n    this.$refs = {}; // child vm references\n    this.$els = {}; // element references\n    this._watchers = []; // all watchers as an array\n    this._directives = []; // all directives\n\n    // a uid\n    this._uid = uid++;\n\n    // a flag to avoid this being observed\n    this._isVue = true;\n\n    // events bookkeeping\n    this._events = {}; // registered callbacks\n    this._eventsCount = {}; // for $broadcast optimization\n\n    // fragment instance properties\n    this._isFragment = false;\n    this._fragment = // @type {DocumentFragment}\n    this._fragmentStart = // @type {Text|Comment}\n    this._fragmentEnd = null; // @type {Text|Comment}\n\n    // lifecycle state\n    this._isCompiled = this._isDestroyed = this._isReady = this._isAttached = this._isBeingDestroyed = this._vForRemoving = false;\n    this._unlinkFn = null;\n\n    // context:\n    // if this is a transcluded component, context\n    // will be the common parent vm of this instance\n    // and its host.\n    this._context = options._context || this.$parent;\n\n    // scope:\n    // if this is inside an inline v-for, the scope\n    // will be the intermediate scope created for this\n    // repeat fragment. this is used for linking props\n    // and container directives.\n    this._scope = options._scope;\n\n    // fragment:\n    // if this instance is compiled inside a Fragment, it\n    // needs to reigster itself as a child of that fragment\n    // for attach/detach to work properly.\n    this._frag = options._frag;\n    if (this._frag) {\n      this._frag.children.push(this);\n    }\n\n    // push self into parent / transclusion host\n    if (this.$parent) {\n      this.$parent.$children.push(this);\n    }\n\n    // merge options.\n    options = this.$options = mergeOptions(this.constructor.options, options, this);\n\n    // set ref\n    this._updateRef();\n\n    // initialize data as empty object.\n    // it will be filled up in _initScope().\n    this._data = {};\n\n    // save raw constructor data before merge\n    // so that we know which properties are provided at\n    // instantiation.\n    this._runtimeData = options.data;\n\n    // call init hook\n    this._callHook('init');\n\n    // initialize data observation and scope inheritance.\n    this._initState();\n\n    // setup event system and option events.\n    this._initEvents();\n\n    // call created hook\n    this._callHook('created');\n\n    // if `el` option is passed, start compilation.\n    if (options.el) {\n      this.$mount(options.el);\n    }\n  };\n}\n\nvar pathCache = new Cache(1000);\n\n// actions\nvar APPEND = 0;\nvar PUSH = 1;\nvar INC_SUB_PATH_DEPTH = 2;\nvar PUSH_SUB_PATH = 3;\n\n// states\nvar BEFORE_PATH = 0;\nvar IN_PATH = 1;\nvar BEFORE_IDENT = 2;\nvar IN_IDENT = 3;\nvar IN_SUB_PATH = 4;\nvar IN_SINGLE_QUOTE = 5;\nvar IN_DOUBLE_QUOTE = 6;\nvar AFTER_PATH = 7;\nvar ERROR = 8;\n\nvar pathStateMachine = [];\n\npathStateMachine[BEFORE_PATH] = {\n  'ws': [BEFORE_PATH],\n  'ident': [IN_IDENT, APPEND],\n  '[': [IN_SUB_PATH],\n  'eof': [AFTER_PATH]\n};\n\npathStateMachine[IN_PATH] = {\n  'ws': [IN_PATH],\n  '.': [BEFORE_IDENT],\n  '[': [IN_SUB_PATH],\n  'eof': [AFTER_PATH]\n};\n\npathStateMachine[BEFORE_IDENT] = {\n  'ws': [BEFORE_IDENT],\n  'ident': [IN_IDENT, APPEND]\n};\n\npathStateMachine[IN_IDENT] = {\n  'ident': [IN_IDENT, APPEND],\n  '0': [IN_IDENT, APPEND],\n  'number': [IN_IDENT, APPEND],\n  'ws': [IN_PATH, PUSH],\n  '.': [BEFORE_IDENT, PUSH],\n  '[': [IN_SUB_PATH, PUSH],\n  'eof': [AFTER_PATH, PUSH]\n};\n\npathStateMachine[IN_SUB_PATH] = {\n  \"'\": [IN_SINGLE_QUOTE, APPEND],\n  '\"': [IN_DOUBLE_QUOTE, APPEND],\n  '[': [IN_SUB_PATH, INC_SUB_PATH_DEPTH],\n  ']': [IN_PATH, PUSH_SUB_PATH],\n  'eof': ERROR,\n  'else': [IN_SUB_PATH, APPEND]\n};\n\npathStateMachine[IN_SINGLE_QUOTE] = {\n  \"'\": [IN_SUB_PATH, APPEND],\n  'eof': ERROR,\n  'else': [IN_SINGLE_QUOTE, APPEND]\n};\n\npathStateMachine[IN_DOUBLE_QUOTE] = {\n  '\"': [IN_SUB_PATH, APPEND],\n  'eof': ERROR,\n  'else': [IN_DOUBLE_QUOTE, APPEND]\n};\n\n/**\n * Determine the type of a character in a keypath.\n *\n * @param {Char} ch\n * @return {String} type\n */\n\nfunction getPathCharType(ch) {\n  if (ch === undefined) {\n    return 'eof';\n  }\n\n  var code = ch.charCodeAt(0);\n\n  switch (code) {\n    case 0x5B: // [\n    case 0x5D: // ]\n    case 0x2E: // .\n    case 0x22: // \"\n    case 0x27: // '\n    case 0x30:\n      // 0\n      return ch;\n\n    case 0x5F: // _\n    case 0x24:\n      // $\n      return 'ident';\n\n    case 0x20: // Space\n    case 0x09: // Tab\n    case 0x0A: // Newline\n    case 0x0D: // Return\n    case 0xA0: // No-break space\n    case 0xFEFF: // Byte Order Mark\n    case 0x2028: // Line Separator\n    case 0x2029:\n      // Paragraph Separator\n      return 'ws';\n  }\n\n  // a-z, A-Z\n  if (code >= 0x61 && code <= 0x7A || code >= 0x41 && code <= 0x5A) {\n    return 'ident';\n  }\n\n  // 1-9\n  if (code >= 0x31 && code <= 0x39) {\n    return 'number';\n  }\n\n  return 'else';\n}\n\n/**\n * Format a subPath, return its plain form if it is\n * a literal string or number. Otherwise prepend the\n * dynamic indicator (*).\n *\n * @param {String} path\n * @return {String}\n */\n\nfunction formatSubPath(path) {\n  var trimmed = path.trim();\n  // invalid leading 0\n  if (path.charAt(0) === '0' && isNaN(path)) {\n    return false;\n  }\n  return isLiteral(trimmed) ? stripQuotes(trimmed) : '*' + trimmed;\n}\n\n/**\n * Parse a string path into an array of segments\n *\n * @param {String} path\n * @return {Array|undefined}\n */\n\nfunction parse(path) {\n  var keys = [];\n  var index = -1;\n  var mode = BEFORE_PATH;\n  var subPathDepth = 0;\n  var c, newChar, key, type, transition, action, typeMap;\n\n  var actions = [];\n\n  actions[PUSH] = function () {\n    if (key !== undefined) {\n      keys.push(key);\n      key = undefined;\n    }\n  };\n\n  actions[APPEND] = function () {\n    if (key === undefined) {\n      key = newChar;\n    } else {\n      key += newChar;\n    }\n  };\n\n  actions[INC_SUB_PATH_DEPTH] = function () {\n    actions[APPEND]();\n    subPathDepth++;\n  };\n\n  actions[PUSH_SUB_PATH] = function () {\n    if (subPathDepth > 0) {\n      subPathDepth--;\n      mode = IN_SUB_PATH;\n      actions[APPEND]();\n    } else {\n      subPathDepth = 0;\n      key = formatSubPath(key);\n      if (key === false) {\n        return false;\n      } else {\n        actions[PUSH]();\n      }\n    }\n  };\n\n  function maybeUnescapeQuote() {\n    var nextChar = path[index + 1];\n    if (mode === IN_SINGLE_QUOTE && nextChar === \"'\" || mode === IN_DOUBLE_QUOTE && nextChar === '\"') {\n      index++;\n      newChar = '\\\\' + nextChar;\n      actions[APPEND]();\n      return true;\n    }\n  }\n\n  while (mode != null) {\n    index++;\n    c = path[index];\n\n    if (c === '\\\\' && maybeUnescapeQuote()) {\n      continue;\n    }\n\n    type = getPathCharType(c);\n    typeMap = pathStateMachine[mode];\n    transition = typeMap[type] || typeMap['else'] || ERROR;\n\n    if (transition === ERROR) {\n      return; // parse error\n    }\n\n    mode = transition[0];\n    action = actions[transition[1]];\n    if (action) {\n      newChar = transition[2];\n      newChar = newChar === undefined ? c : newChar;\n      if (action() === false) {\n        return;\n      }\n    }\n\n    if (mode === AFTER_PATH) {\n      keys.raw = path;\n      return keys;\n    }\n  }\n}\n\n/**\n * External parse that check for a cache hit first\n *\n * @param {String} path\n * @return {Array|undefined}\n */\n\nfunction parsePath(path) {\n  var hit = pathCache.get(path);\n  if (!hit) {\n    hit = parse(path);\n    if (hit) {\n      pathCache.put(path, hit);\n    }\n  }\n  return hit;\n}\n\n/**\n * Get from an object from a path string\n *\n * @param {Object} obj\n * @param {String} path\n */\n\nfunction getPath(obj, path) {\n  return parseExpression(path).get(obj);\n}\n\n/**\n * Warn against setting non-existent root path on a vm.\n */\n\nvar warnNonExistent;\nif (process.env.NODE_ENV !== 'production') {\n  warnNonExistent = function (path, vm) {\n    warn('You are setting a non-existent path \"' + path.raw + '\" ' + 'on a vm instance. Consider pre-initializing the property ' + 'with the \"data\" option for more reliable reactivity ' + 'and better performance.', vm);\n  };\n}\n\n/**\n * Set on an object from a path\n *\n * @param {Object} obj\n * @param {String | Array} path\n * @param {*} val\n */\n\nfunction setPath(obj, path, val) {\n  var original = obj;\n  if (typeof path === 'string') {\n    path = parse(path);\n  }\n  if (!path || !isObject(obj)) {\n    return false;\n  }\n  var last, key;\n  for (var i = 0, l = path.length; i < l; i++) {\n    last = obj;\n    key = path[i];\n    if (key.charAt(0) === '*') {\n      key = parseExpression(key.slice(1)).get.call(original, original);\n    }\n    if (i < l - 1) {\n      obj = obj[key];\n      if (!isObject(obj)) {\n        obj = {};\n        if (process.env.NODE_ENV !== 'production' && last._isVue) {\n          warnNonExistent(path, last);\n        }\n        set(last, key, obj);\n      }\n    } else {\n      if (isArray(obj)) {\n        obj.$set(key, val);\n      } else if (key in obj) {\n        obj[key] = val;\n      } else {\n        if (process.env.NODE_ENV !== 'production' && obj._isVue) {\n          warnNonExistent(path, obj);\n        }\n        set(obj, key, val);\n      }\n    }\n  }\n  return true;\n}\n\nvar path = Object.freeze({\n  parsePath: parsePath,\n  getPath: getPath,\n  setPath: setPath\n});\n\nvar expressionCache = new Cache(1000);\n\nvar allowedKeywords = 'Math,Date,this,true,false,null,undefined,Infinity,NaN,' + 'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,' + 'encodeURIComponent,parseInt,parseFloat';\nvar allowedKeywordsRE = new RegExp('^(' + allowedKeywords.replace(/,/g, '\\\\b|') + '\\\\b)');\n\n// keywords that don't make sense inside expressions\nvar improperKeywords = 'break,case,class,catch,const,continue,debugger,default,' + 'delete,do,else,export,extends,finally,for,function,if,' + 'import,in,instanceof,let,return,super,switch,throw,try,' + 'var,while,with,yield,enum,await,implements,package,' + 'protected,static,interface,private,public';\nvar improperKeywordsRE = new RegExp('^(' + improperKeywords.replace(/,/g, '\\\\b|') + '\\\\b)');\n\nvar wsRE = /\\s/g;\nvar newlineRE = /\\n/g;\nvar saveRE = /[\\{,]\\s*[\\w\\$_]+\\s*:|('(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`)|new |typeof |void /g;\nvar restoreRE = /\"(\\d+)\"/g;\nvar pathTestRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?'\\]|\\[\".*?\"\\]|\\[\\d+\\]|\\[[A-Za-z_$][\\w$]*\\])*$/;\nvar identRE = /[^\\w$\\.](?:[A-Za-z_$][\\w$]*)/g;\nvar booleanLiteralRE = /^(?:true|false)$/;\n\n/**\n * Save / Rewrite / Restore\n *\n * When rewriting paths found in an expression, it is\n * possible for the same letter sequences to be found in\n * strings and Object literal property keys. Therefore we\n * remove and store these parts in a temporary array, and\n * restore them after the path rewrite.\n */\n\nvar saved = [];\n\n/**\n * Save replacer\n *\n * The save regex can match two possible cases:\n * 1. An opening object literal\n * 2. A string\n * If matched as a plain string, we need to escape its\n * newlines, since the string needs to be preserved when\n * generating the function body.\n *\n * @param {String} str\n * @param {String} isString - str if matched as a string\n * @return {String} - placeholder with index\n */\n\nfunction save(str, isString) {\n  var i = saved.length;\n  saved[i] = isString ? str.replace(newlineRE, '\\\\n') : str;\n  return '\"' + i + '\"';\n}\n\n/**\n * Path rewrite replacer\n *\n * @param {String} raw\n * @return {String}\n */\n\nfunction rewrite(raw) {\n  var c = raw.charAt(0);\n  var path = raw.slice(1);\n  if (allowedKeywordsRE.test(path)) {\n    return raw;\n  } else {\n    path = path.indexOf('\"') > -1 ? path.replace(restoreRE, restore) : path;\n    return c + 'scope.' + path;\n  }\n}\n\n/**\n * Restore replacer\n *\n * @param {String} str\n * @param {String} i - matched save index\n * @return {String}\n */\n\nfunction restore(str, i) {\n  return saved[i];\n}\n\n/**\n * Rewrite an expression, prefixing all path accessors with\n * `scope.` and generate getter/setter functions.\n *\n * @param {String} exp\n * @return {Function}\n */\n\nfunction compileGetter(exp) {\n  if (improperKeywordsRE.test(exp)) {\n    process.env.NODE_ENV !== 'production' && warn('Avoid using reserved keywords in expression: ' + exp);\n  }\n  // reset state\n  saved.length = 0;\n  // save strings and object literal keys\n  var body = exp.replace(saveRE, save).replace(wsRE, '');\n  // rewrite all paths\n  // pad 1 space here becaue the regex matches 1 extra char\n  body = (' ' + body).replace(identRE, rewrite).replace(restoreRE, restore);\n  return makeGetterFn(body);\n}\n\n/**\n * Build a getter function. Requires eval.\n *\n * We isolate the try/catch so it doesn't affect the\n * optimization of the parse function when it is not called.\n *\n * @param {String} body\n * @return {Function|undefined}\n */\n\nfunction makeGetterFn(body) {\n  try {\n    /* eslint-disable no-new-func */\n    return new Function('scope', 'return ' + body + ';');\n    /* eslint-enable no-new-func */\n  } catch (e) {\n    process.env.NODE_ENV !== 'production' && warn('Invalid expression. ' + 'Generated function body: ' + body);\n  }\n}\n\n/**\n * Compile a setter function for the expression.\n *\n * @param {String} exp\n * @return {Function|undefined}\n */\n\nfunction compileSetter(exp) {\n  var path = parsePath(exp);\n  if (path) {\n    return function (scope, val) {\n      setPath(scope, path, val);\n    };\n  } else {\n    process.env.NODE_ENV !== 'production' && warn('Invalid setter expression: ' + exp);\n  }\n}\n\n/**\n * Parse an expression into re-written getter/setters.\n *\n * @param {String} exp\n * @param {Boolean} needSet\n * @return {Function}\n */\n\nfunction parseExpression(exp, needSet) {\n  exp = exp.trim();\n  // try cache\n  var hit = expressionCache.get(exp);\n  if (hit) {\n    if (needSet && !hit.set) {\n      hit.set = compileSetter(hit.exp);\n    }\n    return hit;\n  }\n  var res = { exp: exp };\n  res.get = isSimplePath(exp) && exp.indexOf('[') < 0\n  // optimized super simple getter\n  ? makeGetterFn('scope.' + exp)\n  // dynamic getter\n  : compileGetter(exp);\n  if (needSet) {\n    res.set = compileSetter(exp);\n  }\n  expressionCache.put(exp, res);\n  return res;\n}\n\n/**\n * Check if an expression is a simple path.\n *\n * @param {String} exp\n * @return {Boolean}\n */\n\nfunction isSimplePath(exp) {\n  return pathTestRE.test(exp) &&\n  // don't treat true/false as paths\n  !booleanLiteralRE.test(exp) &&\n  // Math constants e.g. Math.PI, Math.E etc.\n  exp.slice(0, 5) !== 'Math.';\n}\n\nvar expression = Object.freeze({\n  parseExpression: parseExpression,\n  isSimplePath: isSimplePath\n});\n\n// we have two separate queues: one for directive updates\n// and one for user watcher registered via $watch().\n// we want to guarantee directive updates to be called\n// before user watchers so that when user watchers are\n// triggered, the DOM would have already been in updated\n// state.\n\nvar queueIndex;\nvar queue = [];\nvar userQueue = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar internalQueueDepleted = false;\n\n/**\n * Reset the batcher's state.\n */\n\nfunction resetBatcherState() {\n  queue = [];\n  userQueue = [];\n  has = {};\n  circular = {};\n  waiting = internalQueueDepleted = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\n\nfunction flushBatcherQueue() {\n  runBatcherQueue(queue);\n  internalQueueDepleted = true;\n  runBatcherQueue(userQueue);\n  // dev tool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n  resetBatcherState();\n}\n\n/**\n * Run the watchers in a single queue.\n *\n * @param {Array} queue\n */\n\nfunction runBatcherQueue(queue) {\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (queueIndex = 0; queueIndex < queue.length; queueIndex++) {\n    var watcher = queue[queueIndex];\n    var id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > config._maxUpdateCount) {\n        warn('You may have an infinite update loop for watcher ' + 'with expression \"' + watcher.expression + '\"', watcher.vm);\n        break;\n      }\n    }\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n *\n * @param {Watcher} watcher\n *   properties:\n *   - {Number} id\n *   - {Function} run\n */\n\nfunction pushWatcher(watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    if (internalQueueDepleted && !watcher.user) {\n      // an internal watcher triggered by a user watcher...\n      // let's run it immediately after current user watcher is done.\n      userQueue.splice(queueIndex + 1, 0, watcher);\n    } else {\n      // push watcher into appropriate queue\n      var q = watcher.user ? userQueue : queue;\n      has[id] = q.length;\n      q.push(watcher);\n      // queue the flush\n      if (!waiting) {\n        waiting = true;\n        nextTick(flushBatcherQueue);\n      }\n    }\n  }\n}\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n *\n * @param {Vue} vm\n * @param {String|Function} expOrFn\n * @param {Function} cb\n * @param {Object} options\n *                 - {Array} filters\n *                 - {Boolean} twoWay\n *                 - {Boolean} deep\n *                 - {Boolean} user\n *                 - {Boolean} sync\n *                 - {Boolean} lazy\n *                 - {Function} [preProcess]\n *                 - {Function} [postProcess]\n * @constructor\n */\nfunction Watcher(vm, expOrFn, cb, options) {\n  // mix in options\n  if (options) {\n    extend(this, options);\n  }\n  var isFn = typeof expOrFn === 'function';\n  this.vm = vm;\n  vm._watchers.push(this);\n  this.expression = expOrFn;\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = Object.create(null);\n  this.newDepIds = null;\n  this.prevError = null; // for async error stacks\n  // parse expression for getter/setter\n  if (isFn) {\n    this.getter = expOrFn;\n    this.setter = undefined;\n  } else {\n    var res = parseExpression(expOrFn, this.twoWay);\n    this.getter = res.get;\n    this.setter = res.set;\n  }\n  this.value = this.lazy ? undefined : this.get();\n  // state for avoiding false triggers for deep and Array\n  // watchers during vm._digest()\n  this.queued = this.shallow = false;\n}\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\n\nWatcher.prototype.get = function () {\n  this.beforeGet();\n  var scope = this.scope || this.vm;\n  var value;\n  try {\n    value = this.getter.call(scope, scope);\n  } catch (e) {\n    if (process.env.NODE_ENV !== 'production' && config.warnExpressionErrors) {\n      warn('Error when evaluating expression ' + '\"' + this.expression + '\": ' + e.toString(), this.vm);\n    }\n  }\n  // \"touch\" every property so they are all tracked as\n  // dependencies for deep watching\n  if (this.deep) {\n    traverse(value);\n  }\n  if (this.preProcess) {\n    value = this.preProcess(value);\n  }\n  if (this.filters) {\n    value = scope._applyFilters(value, null, this.filters, false);\n  }\n  if (this.postProcess) {\n    value = this.postProcess(value);\n  }\n  this.afterGet();\n  return value;\n};\n\n/**\n * Set the corresponding value with the setter.\n *\n * @param {*} value\n */\n\nWatcher.prototype.set = function (value) {\n  var scope = this.scope || this.vm;\n  if (this.filters) {\n    value = scope._applyFilters(value, this.value, this.filters, true);\n  }\n  try {\n    this.setter.call(scope, scope, value);\n  } catch (e) {\n    if (process.env.NODE_ENV !== 'production' && config.warnExpressionErrors) {\n      warn('Error when evaluating setter ' + '\"' + this.expression + '\": ' + e.toString(), this.vm);\n    }\n  }\n  // two-way sync for v-for alias\n  var forContext = scope.$forContext;\n  if (forContext && forContext.alias === this.expression) {\n    if (forContext.filters) {\n      process.env.NODE_ENV !== 'production' && warn('It seems you are using two-way binding on ' + 'a v-for alias (' + this.expression + '), and the ' + 'v-for has filters. This will not work properly. ' + 'Either remove the filters or use an array of ' + 'objects and bind to object properties instead.', this.vm);\n      return;\n    }\n    forContext._withLock(function () {\n      if (scope.$key) {\n        // original is an object\n        forContext.rawValue[scope.$key] = value;\n      } else {\n        forContext.rawValue.$set(scope.$index, value);\n      }\n    });\n  }\n};\n\n/**\n * Prepare for dependency collection.\n */\n\nWatcher.prototype.beforeGet = function () {\n  Dep.target = this;\n  this.newDepIds = Object.create(null);\n  this.newDeps.length = 0;\n};\n\n/**\n * Add a dependency to this directive.\n *\n * @param {Dep} dep\n */\n\nWatcher.prototype.addDep = function (dep) {\n  var id = dep.id;\n  if (!this.newDepIds[id]) {\n    this.newDepIds[id] = true;\n    this.newDeps.push(dep);\n    if (!this.depIds[id]) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\n\nWatcher.prototype.afterGet = function () {\n  Dep.target = null;\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this.deps[i];\n    if (!this.newDepIds[dep.id]) {\n      dep.removeSub(this);\n    }\n  }\n  this.depIds = this.newDepIds;\n  var tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n *\n * @param {Boolean} shallow\n */\n\nWatcher.prototype.update = function (shallow) {\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync || !config.async) {\n    this.run();\n  } else {\n    // if queued, only overwrite shallow with non-shallow,\n    // but not the other way around.\n    this.shallow = this.queued ? shallow ? this.shallow : false : !!shallow;\n    this.queued = true;\n    // record before-push error stack in debug mode\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.debug) {\n      this.prevError = new Error('[vue] async stack trace');\n    }\n    pushWatcher(this);\n  }\n};\n\n/**\n * Batcher job interface.\n * Will be called by the batcher.\n */\n\nWatcher.prototype.run = function () {\n  if (this.active) {\n    var value = this.get();\n    if (value !== this.value ||\n    // Deep watchers and watchers on Object/Arrays should fire even\n    // when the value is the same, because the value may\n    // have mutated; but only do so if this is a\n    // non-shallow update (caused by a vm digest).\n    (isObject(value) || this.deep) && !this.shallow) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      // in debug + async mode, when a watcher callbacks\n      // throws, we also throw the saved before-push error\n      // so the full cross-tick stack trace is available.\n      var prevError = this.prevError;\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.debug && prevError) {\n        this.prevError = null;\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          nextTick(function () {\n            throw prevError;\n          }, 0);\n          throw e;\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n    this.queued = this.shallow = false;\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\n\nWatcher.prototype.evaluate = function () {\n  // avoid overwriting another watcher that is being\n  // collected.\n  var current = Dep.target;\n  this.value = this.get();\n  this.dirty = false;\n  Dep.target = current;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\n\nWatcher.prototype.depend = function () {\n  var i = this.deps.length;\n  while (i--) {\n    this.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subcriber list.\n */\n\nWatcher.prototype.teardown = function () {\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed or is performing a v-for\n    // re-render (the watcher list is then filtered by v-for).\n    if (!this.vm._isBeingDestroyed && !this.vm._vForRemoving) {\n      this.vm._watchers.$remove(this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this.deps[i].removeSub(this);\n    }\n    this.active = false;\n    this.vm = this.cb = this.value = null;\n  }\n};\n\n/**\n * Recrusively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n *\n * @param {*} val\n */\n\nfunction traverse(val) {\n  var i, keys;\n  if (isArray(val)) {\n    i = val.length;\n    while (i--) traverse(val[i]);\n  } else if (isObject(val)) {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) traverse(val[keys[i]]);\n  }\n}\n\nvar text$1 = {\n\n  bind: function bind() {\n    this.attr = this.el.nodeType === 3 ? 'data' : 'textContent';\n  },\n\n  update: function update(value) {\n    this.el[this.attr] = _toString(value);\n  }\n};\n\nvar templateCache = new Cache(1000);\nvar idSelectorCache = new Cache(1000);\n\nvar map = {\n  efault: [0, '', ''],\n  legend: [1, '<fieldset>', '</fieldset>'],\n  tr: [2, '<table><tbody>', '</tbody></table>'],\n  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>']\n};\n\nmap.td = map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];\n\nmap.option = map.optgroup = [1, '<select multiple=\"multiple\">', '</select>'];\n\nmap.thead = map.tbody = map.colgroup = map.caption = map.tfoot = [1, '<table>', '</table>'];\n\nmap.g = map.defs = map.symbol = map.use = map.image = map.text = map.circle = map.ellipse = map.line = map.path = map.polygon = map.polyline = map.rect = [1, '<svg ' + 'xmlns=\"http://www.w3.org/2000/svg\" ' + 'xmlns:xlink=\"http://www.w3.org/1999/xlink\" ' + 'xmlns:ev=\"http://www.w3.org/2001/xml-events\"' + 'version=\"1.1\">', '</svg>'];\n\n/**\n * Check if a node is a supported template node with a\n * DocumentFragment content.\n *\n * @param {Node} node\n * @return {Boolean}\n */\n\nfunction isRealTemplate(node) {\n  return isTemplate(node) && isFragment(node.content);\n}\n\nvar tagRE$1 = /<([\\w:-]+)/;\nvar entityRE = /&#?\\w+?;/;\n\n/**\n * Convert a string template to a DocumentFragment.\n * Determines correct wrapping by tag types. Wrapping\n * strategy found in jQuery & component/domify.\n *\n * @param {String} templateString\n * @param {Boolean} raw\n * @return {DocumentFragment}\n */\n\nfunction stringToFragment(templateString, raw) {\n  // try a cache hit first\n  var cacheKey = raw ? templateString : templateString.trim();\n  var hit = templateCache.get(cacheKey);\n  if (hit) {\n    return hit;\n  }\n\n  var frag = document.createDocumentFragment();\n  var tagMatch = templateString.match(tagRE$1);\n  var entityMatch = entityRE.test(templateString);\n\n  if (!tagMatch && !entityMatch) {\n    // text only, return a single text node.\n    frag.appendChild(document.createTextNode(templateString));\n  } else {\n    var tag = tagMatch && tagMatch[1];\n    var wrap = map[tag] || map.efault;\n    var depth = wrap[0];\n    var prefix = wrap[1];\n    var suffix = wrap[2];\n    var node = document.createElement('div');\n\n    node.innerHTML = prefix + templateString + suffix;\n    while (depth--) {\n      node = node.lastChild;\n    }\n\n    var child;\n    /* eslint-disable no-cond-assign */\n    while (child = node.firstChild) {\n      /* eslint-enable no-cond-assign */\n      frag.appendChild(child);\n    }\n  }\n  if (!raw) {\n    trimNode(frag);\n  }\n  templateCache.put(cacheKey, frag);\n  return frag;\n}\n\n/**\n * Convert a template node to a DocumentFragment.\n *\n * @param {Node} node\n * @return {DocumentFragment}\n */\n\nfunction nodeToFragment(node) {\n  // if its a template tag and the browser supports it,\n  // its content is already a document fragment.\n  if (isRealTemplate(node)) {\n    trimNode(node.content);\n    return node.content;\n  }\n  // script template\n  if (node.tagName === 'SCRIPT') {\n    return stringToFragment(node.textContent);\n  }\n  // normal node, clone it to avoid mutating the original\n  var clonedNode = cloneNode(node);\n  var frag = document.createDocumentFragment();\n  var child;\n  /* eslint-disable no-cond-assign */\n  while (child = clonedNode.firstChild) {\n    /* eslint-enable no-cond-assign */\n    frag.appendChild(child);\n  }\n  trimNode(frag);\n  return frag;\n}\n\n// Test for the presence of the Safari template cloning bug\n// https://bugs.webkit.org/showug.cgi?id=137755\nvar hasBrokenTemplate = (function () {\n  /* istanbul ignore else */\n  if (inBrowser) {\n    var a = document.createElement('div');\n    a.innerHTML = '<template>1</template>';\n    return !a.cloneNode(true).firstChild.innerHTML;\n  } else {\n    return false;\n  }\n})();\n\n// Test for IE10/11 textarea placeholder clone bug\nvar hasTextareaCloneBug = (function () {\n  /* istanbul ignore else */\n  if (inBrowser) {\n    var t = document.createElement('textarea');\n    t.placeholder = 't';\n    return t.cloneNode(true).value === 't';\n  } else {\n    return false;\n  }\n})();\n\n/**\n * 1. Deal with Safari cloning nested <template> bug by\n *    manually cloning all template instances.\n * 2. Deal with IE10/11 textarea placeholder bug by setting\n *    the correct value after cloning.\n *\n * @param {Element|DocumentFragment} node\n * @return {Element|DocumentFragment}\n */\n\nfunction cloneNode(node) {\n  /* istanbul ignore if */\n  if (!node.querySelectorAll) {\n    return node.cloneNode();\n  }\n  var res = node.cloneNode(true);\n  var i, original, cloned;\n  /* istanbul ignore if */\n  if (hasBrokenTemplate) {\n    var tempClone = res;\n    if (isRealTemplate(node)) {\n      node = node.content;\n      tempClone = res.content;\n    }\n    original = node.querySelectorAll('template');\n    if (original.length) {\n      cloned = tempClone.querySelectorAll('template');\n      i = cloned.length;\n      while (i--) {\n        cloned[i].parentNode.replaceChild(cloneNode(original[i]), cloned[i]);\n      }\n    }\n  }\n  /* istanbul ignore if */\n  if (hasTextareaCloneBug) {\n    if (node.tagName === 'TEXTAREA') {\n      res.value = node.value;\n    } else {\n      original = node.querySelectorAll('textarea');\n      if (original.length) {\n        cloned = res.querySelectorAll('textarea');\n        i = cloned.length;\n        while (i--) {\n          cloned[i].value = original[i].value;\n        }\n      }\n    }\n  }\n  return res;\n}\n\n/**\n * Process the template option and normalizes it into a\n * a DocumentFragment that can be used as a partial or a\n * instance template.\n *\n * @param {*} template\n *        Possible values include:\n *        - DocumentFragment object\n *        - Node object of type Template\n *        - id selector: '#some-template-id'\n *        - template string: '<div><span>{{msg}}</span></div>'\n * @param {Boolean} shouldClone\n * @param {Boolean} raw\n *        inline HTML interpolation. Do not check for id\n *        selector and keep whitespace in the string.\n * @return {DocumentFragment|undefined}\n */\n\nfunction parseTemplate(template, shouldClone, raw) {\n  var node, frag;\n\n  // if the template is already a document fragment,\n  // do nothing\n  if (isFragment(template)) {\n    trimNode(template);\n    return shouldClone ? cloneNode(template) : template;\n  }\n\n  if (typeof template === 'string') {\n    // id selector\n    if (!raw && template.charAt(0) === '#') {\n      // id selector can be cached too\n      frag = idSelectorCache.get(template);\n      if (!frag) {\n        node = document.getElementById(template.slice(1));\n        if (node) {\n          frag = nodeToFragment(node);\n          // save selector to cache\n          idSelectorCache.put(template, frag);\n        }\n      }\n    } else {\n      // normal string template\n      frag = stringToFragment(template, raw);\n    }\n  } else if (template.nodeType) {\n    // a direct node\n    frag = nodeToFragment(template);\n  }\n\n  return frag && shouldClone ? cloneNode(frag) : frag;\n}\n\nvar template = Object.freeze({\n  cloneNode: cloneNode,\n  parseTemplate: parseTemplate\n});\n\nvar html = {\n\n  bind: function bind() {\n    // a comment node means this is a binding for\n    // {{{ inline unescaped html }}}\n    if (this.el.nodeType === 8) {\n      // hold nodes\n      this.nodes = [];\n      // replace the placeholder with proper anchor\n      this.anchor = createAnchor('v-html');\n      replace(this.el, this.anchor);\n    }\n  },\n\n  update: function update(value) {\n    value = _toString(value);\n    if (this.nodes) {\n      this.swap(value);\n    } else {\n      this.el.innerHTML = value;\n    }\n  },\n\n  swap: function swap(value) {\n    // remove old nodes\n    var i = this.nodes.length;\n    while (i--) {\n      remove(this.nodes[i]);\n    }\n    // convert new value to a fragment\n    // do not attempt to retrieve from id selector\n    var frag = parseTemplate(value, true, true);\n    // save a reference to these nodes so we can remove later\n    this.nodes = toArray(frag.childNodes);\n    before(frag, this.anchor);\n  }\n};\n\n/**\n * Abstraction for a partially-compiled fragment.\n * Can optionally compile content with a child scope.\n *\n * @param {Function} linker\n * @param {Vue} vm\n * @param {DocumentFragment} frag\n * @param {Vue} [host]\n * @param {Object} [scope]\n * @param {Fragment} [parentFrag]\n */\nfunction Fragment(linker, vm, frag, host, scope, parentFrag) {\n  this.children = [];\n  this.childFrags = [];\n  this.vm = vm;\n  this.scope = scope;\n  this.inserted = false;\n  this.parentFrag = parentFrag;\n  if (parentFrag) {\n    parentFrag.childFrags.push(this);\n  }\n  this.unlink = linker(vm, frag, host, scope, this);\n  var single = this.single = frag.childNodes.length === 1 &&\n  // do not go single mode if the only node is an anchor\n  !frag.childNodes[0].__v_anchor;\n  if (single) {\n    this.node = frag.childNodes[0];\n    this.before = singleBefore;\n    this.remove = singleRemove;\n  } else {\n    this.node = createAnchor('fragment-start');\n    this.end = createAnchor('fragment-end');\n    this.frag = frag;\n    prepend(this.node, frag);\n    frag.appendChild(this.end);\n    this.before = multiBefore;\n    this.remove = multiRemove;\n  }\n  this.node.__v_frag = this;\n}\n\n/**\n * Call attach/detach for all components contained within\n * this fragment. Also do so recursively for all child\n * fragments.\n *\n * @param {Function} hook\n */\n\nFragment.prototype.callHook = function (hook) {\n  var i, l;\n  for (i = 0, l = this.childFrags.length; i < l; i++) {\n    this.childFrags[i].callHook(hook);\n  }\n  for (i = 0, l = this.children.length; i < l; i++) {\n    hook(this.children[i]);\n  }\n};\n\n/**\n * Insert fragment before target, single node version\n *\n * @param {Node} target\n * @param {Boolean} withTransition\n */\n\nfunction singleBefore(target, withTransition) {\n  this.inserted = true;\n  var method = withTransition !== false ? beforeWithTransition : before;\n  method(this.node, target, this.vm);\n  if (inDoc(this.node)) {\n    this.callHook(attach);\n  }\n}\n\n/**\n * Remove fragment, single node version\n */\n\nfunction singleRemove() {\n  this.inserted = false;\n  var shouldCallRemove = inDoc(this.node);\n  var self = this;\n  this.beforeRemove();\n  removeWithTransition(this.node, this.vm, function () {\n    if (shouldCallRemove) {\n      self.callHook(detach);\n    }\n    self.destroy();\n  });\n}\n\n/**\n * Insert fragment before target, multi-nodes version\n *\n * @param {Node} target\n * @param {Boolean} withTransition\n */\n\nfunction multiBefore(target, withTransition) {\n  this.inserted = true;\n  var vm = this.vm;\n  var method = withTransition !== false ? beforeWithTransition : before;\n  mapNodeRange(this.node, this.end, function (node) {\n    method(node, target, vm);\n  });\n  if (inDoc(this.node)) {\n    this.callHook(attach);\n  }\n}\n\n/**\n * Remove fragment, multi-nodes version\n */\n\nfunction multiRemove() {\n  this.inserted = false;\n  var self = this;\n  var shouldCallRemove = inDoc(this.node);\n  this.beforeRemove();\n  removeNodeRange(this.node, this.end, this.vm, this.frag, function () {\n    if (shouldCallRemove) {\n      self.callHook(detach);\n    }\n    self.destroy();\n  });\n}\n\n/**\n * Prepare the fragment for removal.\n */\n\nFragment.prototype.beforeRemove = function () {\n  var i, l;\n  for (i = 0, l = this.childFrags.length; i < l; i++) {\n    // call the same method recursively on child\n    // fragments, depth-first\n    this.childFrags[i].beforeRemove(false);\n  }\n  for (i = 0, l = this.children.length; i < l; i++) {\n    // Call destroy for all contained instances,\n    // with remove:false and defer:true.\n    // Defer is necessary because we need to\n    // keep the children to call detach hooks\n    // on them.\n    this.children[i].$destroy(false, true);\n  }\n  var dirs = this.unlink.dirs;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    // disable the watchers on all the directives\n    // so that the rendered content stays the same\n    // during removal.\n    dirs[i]._watcher && dirs[i]._watcher.teardown();\n  }\n};\n\n/**\n * Destroy the fragment.\n */\n\nFragment.prototype.destroy = function () {\n  if (this.parentFrag) {\n    this.parentFrag.childFrags.$remove(this);\n  }\n  this.node.__v_frag = null;\n  this.unlink();\n};\n\n/**\n * Call attach hook for a Vue instance.\n *\n * @param {Vue} child\n */\n\nfunction attach(child) {\n  if (!child._isAttached && inDoc(child.$el)) {\n    child._callHook('attached');\n  }\n}\n\n/**\n * Call detach hook for a Vue instance.\n *\n * @param {Vue} child\n */\n\nfunction detach(child) {\n  if (child._isAttached && !inDoc(child.$el)) {\n    child._callHook('detached');\n  }\n}\n\nvar linkerCache = new Cache(5000);\n\n/**\n * A factory that can be used to create instances of a\n * fragment. Caches the compiled linker if possible.\n *\n * @param {Vue} vm\n * @param {Element|String} el\n */\nfunction FragmentFactory(vm, el) {\n  this.vm = vm;\n  var template;\n  var isString = typeof el === 'string';\n  if (isString || isTemplate(el)) {\n    template = parseTemplate(el, true);\n  } else {\n    template = document.createDocumentFragment();\n    template.appendChild(el);\n  }\n  this.template = template;\n  // linker can be cached, but only for components\n  var linker;\n  var cid = vm.constructor.cid;\n  if (cid > 0) {\n    var cacheId = cid + (isString ? el : getOuterHTML(el));\n    linker = linkerCache.get(cacheId);\n    if (!linker) {\n      linker = compile(template, vm.$options, true);\n      linkerCache.put(cacheId, linker);\n    }\n  } else {\n    linker = compile(template, vm.$options, true);\n  }\n  this.linker = linker;\n}\n\n/**\n * Create a fragment instance with given host and scope.\n *\n * @param {Vue} host\n * @param {Object} scope\n * @param {Fragment} parentFrag\n */\n\nFragmentFactory.prototype.create = function (host, scope, parentFrag) {\n  var frag = cloneNode(this.template);\n  return new Fragment(this.linker, this.vm, frag, host, scope, parentFrag);\n};\n\nvar ON = 700;\nvar MODEL = 800;\nvar BIND = 850;\nvar TRANSITION = 1100;\nvar EL = 1500;\nvar COMPONENT = 1500;\nvar PARTIAL = 1750;\nvar IF = 2100;\nvar FOR = 2200;\nvar SLOT = 2300;\n\nvar uid$3 = 0;\n\nvar vFor = {\n\n  priority: FOR,\n  terminal: true,\n\n  params: ['track-by', 'stagger', 'enter-stagger', 'leave-stagger'],\n\n  bind: function bind() {\n    // support \"item in/of items\" syntax\n    var inMatch = this.expression.match(/(.*) (?:in|of) (.*)/);\n    if (inMatch) {\n      var itMatch = inMatch[1].match(/\\((.*),(.*)\\)/);\n      if (itMatch) {\n        this.iterator = itMatch[1].trim();\n        this.alias = itMatch[2].trim();\n      } else {\n        this.alias = inMatch[1].trim();\n      }\n      this.expression = inMatch[2];\n    }\n\n    if (!this.alias) {\n      process.env.NODE_ENV !== 'production' && warn('Invalid v-for expression \"' + this.descriptor.raw + '\": ' + 'alias is required.', this.vm);\n      return;\n    }\n\n    // uid as a cache identifier\n    this.id = '__v-for__' + ++uid$3;\n\n    // check if this is an option list,\n    // so that we know if we need to update the <select>'s\n    // v-model when the option list has changed.\n    // because v-model has a lower priority than v-for,\n    // the v-model is not bound here yet, so we have to\n    // retrive it in the actual updateModel() function.\n    var tag = this.el.tagName;\n    this.isOption = (tag === 'OPTION' || tag === 'OPTGROUP') && this.el.parentNode.tagName === 'SELECT';\n\n    // setup anchor nodes\n    this.start = createAnchor('v-for-start');\n    this.end = createAnchor('v-for-end');\n    replace(this.el, this.end);\n    before(this.start, this.end);\n\n    // cache\n    this.cache = Object.create(null);\n\n    // fragment factory\n    this.factory = new FragmentFactory(this.vm, this.el);\n  },\n\n  update: function update(data) {\n    this.diff(data);\n    this.updateRef();\n    this.updateModel();\n  },\n\n  /**\n   * Diff, based on new data and old data, determine the\n   * minimum amount of DOM manipulations needed to make the\n   * DOM reflect the new data Array.\n   *\n   * The algorithm diffs the new data Array by storing a\n   * hidden reference to an owner vm instance on previously\n   * seen data. This allows us to achieve O(n) which is\n   * better than a levenshtein distance based algorithm,\n   * which is O(m * n).\n   *\n   * @param {Array} data\n   */\n\n  diff: function diff(data) {\n    // check if the Array was converted from an Object\n    var item = data[0];\n    var convertedFromObject = this.fromObject = isObject(item) && hasOwn(item, '$key') && hasOwn(item, '$value');\n\n    var trackByKey = this.params.trackBy;\n    var oldFrags = this.frags;\n    var frags = this.frags = new Array(data.length);\n    var alias = this.alias;\n    var iterator = this.iterator;\n    var start = this.start;\n    var end = this.end;\n    var inDocument = inDoc(start);\n    var init = !oldFrags;\n    var i, l, frag, key, value, primitive;\n\n    // First pass, go through the new Array and fill up\n    // the new frags array. If a piece of data has a cached\n    // instance for it, we reuse it. Otherwise build a new\n    // instance.\n    for (i = 0, l = data.length; i < l; i++) {\n      item = data[i];\n      key = convertedFromObject ? item.$key : null;\n      value = convertedFromObject ? item.$value : item;\n      primitive = !isObject(value);\n      frag = !init && this.getCachedFrag(value, i, key);\n      if (frag) {\n        // reusable fragment\n        frag.reused = true;\n        // update $index\n        frag.scope.$index = i;\n        // update $key\n        if (key) {\n          frag.scope.$key = key;\n        }\n        // update iterator\n        if (iterator) {\n          frag.scope[iterator] = key !== null ? key : i;\n        }\n        // update data for track-by, object repeat &\n        // primitive values.\n        if (trackByKey || convertedFromObject || primitive) {\n          withoutConversion(function () {\n            frag.scope[alias] = value;\n          });\n        }\n      } else {\n        // new isntance\n        frag = this.create(value, alias, i, key);\n        frag.fresh = !init;\n      }\n      frags[i] = frag;\n      if (init) {\n        frag.before(end);\n      }\n    }\n\n    // we're done for the initial render.\n    if (init) {\n      return;\n    }\n\n    // Second pass, go through the old fragments and\n    // destroy those who are not reused (and remove them\n    // from cache)\n    var removalIndex = 0;\n    var totalRemoved = oldFrags.length - frags.length;\n    // when removing a large number of fragments, watcher removal\n    // turns out to be a perf bottleneck, so we batch the watcher\n    // removals into a single filter call!\n    this.vm._vForRemoving = true;\n    for (i = 0, l = oldFrags.length; i < l; i++) {\n      frag = oldFrags[i];\n      if (!frag.reused) {\n        this.deleteCachedFrag(frag);\n        this.remove(frag, removalIndex++, totalRemoved, inDocument);\n      }\n    }\n    this.vm._vForRemoving = false;\n    if (removalIndex) {\n      this.vm._watchers = this.vm._watchers.filter(function (w) {\n        return w.active;\n      });\n    }\n\n    // Final pass, move/insert new fragments into the\n    // right place.\n    var targetPrev, prevEl, currentPrev;\n    var insertionIndex = 0;\n    for (i = 0, l = frags.length; i < l; i++) {\n      frag = frags[i];\n      // this is the frag that we should be after\n      targetPrev = frags[i - 1];\n      prevEl = targetPrev ? targetPrev.staggerCb ? targetPrev.staggerAnchor : targetPrev.end || targetPrev.node : start;\n      if (frag.reused && !frag.staggerCb) {\n        currentPrev = findPrevFrag(frag, start, this.id);\n        if (currentPrev !== targetPrev && (!currentPrev ||\n        // optimization for moving a single item.\n        // thanks to suggestions by @livoras in #1807\n        findPrevFrag(currentPrev, start, this.id) !== targetPrev)) {\n          this.move(frag, prevEl);\n        }\n      } else {\n        // new instance, or still in stagger.\n        // insert with updated stagger index.\n        this.insert(frag, insertionIndex++, prevEl, inDocument);\n      }\n      frag.reused = frag.fresh = false;\n    }\n  },\n\n  /**\n   * Create a new fragment instance.\n   *\n   * @param {*} value\n   * @param {String} alias\n   * @param {Number} index\n   * @param {String} [key]\n   * @return {Fragment}\n   */\n\n  create: function create(value, alias, index, key) {\n    var host = this._host;\n    // create iteration scope\n    var parentScope = this._scope || this.vm;\n    var scope = Object.create(parentScope);\n    // ref holder for the scope\n    scope.$refs = Object.create(parentScope.$refs);\n    scope.$els = Object.create(parentScope.$els);\n    // make sure point $parent to parent scope\n    scope.$parent = parentScope;\n    // for two-way binding on alias\n    scope.$forContext = this;\n    // define scope properties\n    // important: define the scope alias without forced conversion\n    // so that frozen data structures remain non-reactive.\n    withoutConversion(function () {\n      defineReactive(scope, alias, value);\n    });\n    defineReactive(scope, '$index', index);\n    if (key) {\n      defineReactive(scope, '$key', key);\n    } else if (scope.$key) {\n      // avoid accidental fallback\n      def(scope, '$key', null);\n    }\n    if (this.iterator) {\n      defineReactive(scope, this.iterator, key !== null ? key : index);\n    }\n    var frag = this.factory.create(host, scope, this._frag);\n    frag.forId = this.id;\n    this.cacheFrag(value, frag, index, key);\n    return frag;\n  },\n\n  /**\n   * Update the v-ref on owner vm.\n   */\n\n  updateRef: function updateRef() {\n    var ref = this.descriptor.ref;\n    if (!ref) return;\n    var hash = (this._scope || this.vm).$refs;\n    var refs;\n    if (!this.fromObject) {\n      refs = this.frags.map(findVmFromFrag);\n    } else {\n      refs = {};\n      this.frags.forEach(function (frag) {\n        refs[frag.scope.$key] = findVmFromFrag(frag);\n      });\n    }\n    hash[ref] = refs;\n  },\n\n  /**\n   * For option lists, update the containing v-model on\n   * parent <select>.\n   */\n\n  updateModel: function updateModel() {\n    if (this.isOption) {\n      var parent = this.start.parentNode;\n      var model = parent && parent.__v_model;\n      if (model) {\n        model.forceUpdate();\n      }\n    }\n  },\n\n  /**\n   * Insert a fragment. Handles staggering.\n   *\n   * @param {Fragment} frag\n   * @param {Number} index\n   * @param {Node} prevEl\n   * @param {Boolean} inDocument\n   */\n\n  insert: function insert(frag, index, prevEl, inDocument) {\n    if (frag.staggerCb) {\n      frag.staggerCb.cancel();\n      frag.staggerCb = null;\n    }\n    var staggerAmount = this.getStagger(frag, index, null, 'enter');\n    if (inDocument && staggerAmount) {\n      // create an anchor and insert it synchronously,\n      // so that we can resolve the correct order without\n      // worrying about some elements not inserted yet\n      var anchor = frag.staggerAnchor;\n      if (!anchor) {\n        anchor = frag.staggerAnchor = createAnchor('stagger-anchor');\n        anchor.__v_frag = frag;\n      }\n      after(anchor, prevEl);\n      var op = frag.staggerCb = cancellable(function () {\n        frag.staggerCb = null;\n        frag.before(anchor);\n        remove(anchor);\n      });\n      setTimeout(op, staggerAmount);\n    } else {\n      frag.before(prevEl.nextSibling);\n    }\n  },\n\n  /**\n   * Remove a fragment. Handles staggering.\n   *\n   * @param {Fragment} frag\n   * @param {Number} index\n   * @param {Number} total\n   * @param {Boolean} inDocument\n   */\n\n  remove: function remove(frag, index, total, inDocument) {\n    if (frag.staggerCb) {\n      frag.staggerCb.cancel();\n      frag.staggerCb = null;\n      // it's not possible for the same frag to be removed\n      // twice, so if we have a pending stagger callback,\n      // it means this frag is queued for enter but removed\n      // before its transition started. Since it is already\n      // destroyed, we can just leave it in detached state.\n      return;\n    }\n    var staggerAmount = this.getStagger(frag, index, total, 'leave');\n    if (inDocument && staggerAmount) {\n      var op = frag.staggerCb = cancellable(function () {\n        frag.staggerCb = null;\n        frag.remove();\n      });\n      setTimeout(op, staggerAmount);\n    } else {\n      frag.remove();\n    }\n  },\n\n  /**\n   * Move a fragment to a new position.\n   * Force no transition.\n   *\n   * @param {Fragment} frag\n   * @param {Node} prevEl\n   */\n\n  move: function move(frag, prevEl) {\n    // fix a common issue with Sortable:\n    // if prevEl doesn't have nextSibling, this means it's\n    // been dragged after the end anchor. Just re-position\n    // the end anchor to the end of the container.\n    /* istanbul ignore if */\n    if (!prevEl.nextSibling) {\n      this.end.parentNode.appendChild(this.end);\n    }\n    frag.before(prevEl.nextSibling, false);\n  },\n\n  /**\n   * Cache a fragment using track-by or the object key.\n   *\n   * @param {*} value\n   * @param {Fragment} frag\n   * @param {Number} index\n   * @param {String} [key]\n   */\n\n  cacheFrag: function cacheFrag(value, frag, index, key) {\n    var trackByKey = this.params.trackBy;\n    var cache = this.cache;\n    var primitive = !isObject(value);\n    var id;\n    if (key || trackByKey || primitive) {\n      id = trackByKey ? trackByKey === '$index' ? index : getPath(value, trackByKey) : key || value;\n      if (!cache[id]) {\n        cache[id] = frag;\n      } else if (trackByKey !== '$index') {\n        process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);\n      }\n    } else {\n      id = this.id;\n      if (hasOwn(value, id)) {\n        if (value[id] === null) {\n          value[id] = frag;\n        } else {\n          process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);\n        }\n      } else {\n        def(value, id, frag);\n      }\n    }\n    frag.raw = value;\n  },\n\n  /**\n   * Get a cached fragment from the value/index/key\n   *\n   * @param {*} value\n   * @param {Number} index\n   * @param {String} key\n   * @return {Fragment}\n   */\n\n  getCachedFrag: function getCachedFrag(value, index, key) {\n    var trackByKey = this.params.trackBy;\n    var primitive = !isObject(value);\n    var frag;\n    if (key || trackByKey || primitive) {\n      var id = trackByKey ? trackByKey === '$index' ? index : getPath(value, trackByKey) : key || value;\n      frag = this.cache[id];\n    } else {\n      frag = value[this.id];\n    }\n    if (frag && (frag.reused || frag.fresh)) {\n      process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);\n    }\n    return frag;\n  },\n\n  /**\n   * Delete a fragment from cache.\n   *\n   * @param {Fragment} frag\n   */\n\n  deleteCachedFrag: function deleteCachedFrag(frag) {\n    var value = frag.raw;\n    var trackByKey = this.params.trackBy;\n    var scope = frag.scope;\n    var index = scope.$index;\n    // fix #948: avoid accidentally fall through to\n    // a parent repeater which happens to have $key.\n    var key = hasOwn(scope, '$key') && scope.$key;\n    var primitive = !isObject(value);\n    if (trackByKey || key || primitive) {\n      var id = trackByKey ? trackByKey === '$index' ? index : getPath(value, trackByKey) : key || value;\n      this.cache[id] = null;\n    } else {\n      value[this.id] = null;\n      frag.raw = null;\n    }\n  },\n\n  /**\n   * Get the stagger amount for an insertion/removal.\n   *\n   * @param {Fragment} frag\n   * @param {Number} index\n   * @param {Number} total\n   * @param {String} type\n   */\n\n  getStagger: function getStagger(frag, index, total, type) {\n    type = type + 'Stagger';\n    var trans = frag.node.__v_trans;\n    var hooks = trans && trans.hooks;\n    var hook = hooks && (hooks[type] || hooks.stagger);\n    return hook ? hook.call(frag, index, total) : index * parseInt(this.params[type] || this.params.stagger, 10);\n  },\n\n  /**\n   * Pre-process the value before piping it through the\n   * filters. This is passed to and called by the watcher.\n   */\n\n  _preProcess: function _preProcess(value) {\n    // regardless of type, store the un-filtered raw value.\n    this.rawValue = value;\n    return value;\n  },\n\n  /**\n   * Post-process the value after it has been piped through\n   * the filters. This is passed to and called by the watcher.\n   *\n   * It is necessary for this to be called during the\n   * wathcer's dependency collection phase because we want\n   * the v-for to update when the source Object is mutated.\n   */\n\n  _postProcess: function _postProcess(value) {\n    if (isArray(value)) {\n      return value;\n    } else if (isPlainObject(value)) {\n      // convert plain object to array.\n      var keys = Object.keys(value);\n      var i = keys.length;\n      var res = new Array(i);\n      var key;\n      while (i--) {\n        key = keys[i];\n        res[i] = {\n          $key: key,\n          $value: value[key]\n        };\n      }\n      return res;\n    } else {\n      if (typeof value === 'number' && !isNaN(value)) {\n        value = range(value);\n      }\n      return value || [];\n    }\n  },\n\n  unbind: function unbind() {\n    if (this.descriptor.ref) {\n      (this._scope || this.vm).$refs[this.descriptor.ref] = null;\n    }\n    if (this.frags) {\n      var i = this.frags.length;\n      var frag;\n      while (i--) {\n        frag = this.frags[i];\n        this.deleteCachedFrag(frag);\n        frag.destroy();\n      }\n    }\n  }\n};\n\n/**\n * Helper to find the previous element that is a fragment\n * anchor. This is necessary because a destroyed frag's\n * element could still be lingering in the DOM before its\n * leaving transition finishes, but its inserted flag\n * should have been set to false so we can skip them.\n *\n * If this is a block repeat, we want to make sure we only\n * return frag that is bound to this v-for. (see #929)\n *\n * @param {Fragment} frag\n * @param {Comment|Text} anchor\n * @param {String} id\n * @return {Fragment}\n */\n\nfunction findPrevFrag(frag, anchor, id) {\n  var el = frag.node.previousSibling;\n  /* istanbul ignore if */\n  if (!el) return;\n  frag = el.__v_frag;\n  while ((!frag || frag.forId !== id || !frag.inserted) && el !== anchor) {\n    el = el.previousSibling;\n    /* istanbul ignore if */\n    if (!el) return;\n    frag = el.__v_frag;\n  }\n  return frag;\n}\n\n/**\n * Find a vm from a fragment.\n *\n * @param {Fragment} frag\n * @return {Vue|undefined}\n */\n\nfunction findVmFromFrag(frag) {\n  var node = frag.node;\n  // handle multi-node frag\n  if (frag.end) {\n    while (!node.__vue__ && node !== frag.end && node.nextSibling) {\n      node = node.nextSibling;\n    }\n  }\n  return node.__vue__;\n}\n\n/**\n * Create a range array from given number.\n *\n * @param {Number} n\n * @return {Array}\n */\n\nfunction range(n) {\n  var i = -1;\n  var ret = new Array(Math.floor(n));\n  while (++i < n) {\n    ret[i] = i;\n  }\n  return ret;\n}\n\nif (process.env.NODE_ENV !== 'production') {\n  vFor.warnDuplicate = function (value) {\n    warn('Duplicate value found in v-for=\"' + this.descriptor.raw + '\": ' + JSON.stringify(value) + '. Use track-by=\"$index\" if ' + 'you are expecting duplicate values.', this.vm);\n  };\n}\n\nvar vIf = {\n\n  priority: IF,\n  terminal: true,\n\n  bind: function bind() {\n    var el = this.el;\n    if (!el.__vue__) {\n      // check else block\n      var next = el.nextElementSibling;\n      if (next && getAttr(next, 'v-else') !== null) {\n        remove(next);\n        this.elseEl = next;\n      }\n      // check main block\n      this.anchor = createAnchor('v-if');\n      replace(el, this.anchor);\n    } else {\n      process.env.NODE_ENV !== 'production' && warn('v-if=\"' + this.expression + '\" cannot be ' + 'used on an instance root element.', this.vm);\n      this.invalid = true;\n    }\n  },\n\n  update: function update(value) {\n    if (this.invalid) return;\n    if (value) {\n      if (!this.frag) {\n        this.insert();\n      }\n    } else {\n      this.remove();\n    }\n  },\n\n  insert: function insert() {\n    if (this.elseFrag) {\n      this.elseFrag.remove();\n      this.elseFrag = null;\n    }\n    // lazy init factory\n    if (!this.factory) {\n      this.factory = new FragmentFactory(this.vm, this.el);\n    }\n    this.frag = this.factory.create(this._host, this._scope, this._frag);\n    this.frag.before(this.anchor);\n  },\n\n  remove: function remove() {\n    if (this.frag) {\n      this.frag.remove();\n      this.frag = null;\n    }\n    if (this.elseEl && !this.elseFrag) {\n      if (!this.elseFactory) {\n        this.elseFactory = new FragmentFactory(this.elseEl._context || this.vm, this.elseEl);\n      }\n      this.elseFrag = this.elseFactory.create(this._host, this._scope, this._frag);\n      this.elseFrag.before(this.anchor);\n    }\n  },\n\n  unbind: function unbind() {\n    if (this.frag) {\n      this.frag.destroy();\n    }\n    if (this.elseFrag) {\n      this.elseFrag.destroy();\n    }\n  }\n};\n\nvar show = {\n\n  bind: function bind() {\n    // check else block\n    var next = this.el.nextElementSibling;\n    if (next && getAttr(next, 'v-else') !== null) {\n      this.elseEl = next;\n    }\n  },\n\n  update: function update(value) {\n    this.apply(this.el, value);\n    if (this.elseEl) {\n      this.apply(this.elseEl, !value);\n    }\n  },\n\n  apply: function apply(el, value) {\n    if (inDoc(el)) {\n      applyTransition(el, value ? 1 : -1, toggle, this.vm);\n    } else {\n      toggle();\n    }\n    function toggle() {\n      el.style.display = value ? '' : 'none';\n    }\n  }\n};\n\nvar text$2 = {\n\n  bind: function bind() {\n    var self = this;\n    var el = this.el;\n    var isRange = el.type === 'range';\n    var lazy = this.params.lazy;\n    var number = this.params.number;\n    var debounce = this.params.debounce;\n\n    // handle composition events.\n    //   http://blog.evanyou.me/2014/01/03/composition-event/\n    // skip this for Android because it handles composition\n    // events quite differently. Android doesn't trigger\n    // composition events for language input methods e.g.\n    // Chinese, but instead triggers them for spelling\n    // suggestions... (see Discussion/#162)\n    var composing = false;\n    if (!isAndroid && !isRange) {\n      this.on('compositionstart', function () {\n        composing = true;\n      });\n      this.on('compositionend', function () {\n        composing = false;\n        // in IE11 the \"compositionend\" event fires AFTER\n        // the \"input\" event, so the input handler is blocked\n        // at the end... have to call it here.\n        //\n        // #1327: in lazy mode this is unecessary.\n        if (!lazy) {\n          self.listener();\n        }\n      });\n    }\n\n    // prevent messing with the input when user is typing,\n    // and force update on blur.\n    this.focused = false;\n    if (!isRange && !lazy) {\n      this.on('focus', function () {\n        self.focused = true;\n      });\n      this.on('blur', function () {\n        self.focused = false;\n        // do not sync value after fragment removal (#2017)\n        if (!self._frag || self._frag.inserted) {\n          self.rawListener();\n        }\n      });\n    }\n\n    // Now attach the main listener\n    this.listener = this.rawListener = function () {\n      if (composing || !self._bound) {\n        return;\n      }\n      var val = number || isRange ? toNumber(el.value) : el.value;\n      self.set(val);\n      // force update on next tick to avoid lock & same value\n      // also only update when user is not typing\n      nextTick(function () {\n        if (self._bound && !self.focused) {\n          self.update(self._watcher.value);\n        }\n      });\n    };\n\n    // apply debounce\n    if (debounce) {\n      this.listener = _debounce(this.listener, debounce);\n    }\n\n    // Support jQuery events, since jQuery.trigger() doesn't\n    // trigger native events in some cases and some plugins\n    // rely on $.trigger()\n    //\n    // We want to make sure if a listener is attached using\n    // jQuery, it is also removed with jQuery, that's why\n    // we do the check for each directive instance and\n    // store that check result on itself. This also allows\n    // easier test coverage control by unsetting the global\n    // jQuery variable in tests.\n    this.hasjQuery = typeof jQuery === 'function';\n    if (this.hasjQuery) {\n      var method = jQuery.fn.on ? 'on' : 'bind';\n      jQuery(el)[method]('change', this.rawListener);\n      if (!lazy) {\n        jQuery(el)[method]('input', this.listener);\n      }\n    } else {\n      this.on('change', this.rawListener);\n      if (!lazy) {\n        this.on('input', this.listener);\n      }\n    }\n\n    // IE9 doesn't fire input event on backspace/del/cut\n    if (!lazy && isIE9) {\n      this.on('cut', function () {\n        nextTick(self.listener);\n      });\n      this.on('keyup', function (e) {\n        if (e.keyCode === 46 || e.keyCode === 8) {\n          self.listener();\n        }\n      });\n    }\n\n    // set initial value if present\n    if (el.hasAttribute('value') || el.tagName === 'TEXTAREA' && el.value.trim()) {\n      this.afterBind = this.listener;\n    }\n  },\n\n  update: function update(value) {\n    this.el.value = _toString(value);\n  },\n\n  unbind: function unbind() {\n    var el = this.el;\n    if (this.hasjQuery) {\n      var method = jQuery.fn.off ? 'off' : 'unbind';\n      jQuery(el)[method]('change', this.listener);\n      jQuery(el)[method]('input', this.listener);\n    }\n  }\n};\n\nvar radio = {\n\n  bind: function bind() {\n    var self = this;\n    var el = this.el;\n\n    this.getValue = function () {\n      // value overwrite via v-bind:value\n      if (el.hasOwnProperty('_value')) {\n        return el._value;\n      }\n      var val = el.value;\n      if (self.params.number) {\n        val = toNumber(val);\n      }\n      return val;\n    };\n\n    this.listener = function () {\n      self.set(self.getValue());\n    };\n    this.on('change', this.listener);\n\n    if (el.hasAttribute('checked')) {\n      this.afterBind = this.listener;\n    }\n  },\n\n  update: function update(value) {\n    this.el.checked = looseEqual(value, this.getValue());\n  }\n};\n\nvar select = {\n\n  bind: function bind() {\n    var self = this;\n    var el = this.el;\n\n    // method to force update DOM using latest value.\n    this.forceUpdate = function () {\n      if (self._watcher) {\n        self.update(self._watcher.get());\n      }\n    };\n\n    // check if this is a multiple select\n    var multiple = this.multiple = el.hasAttribute('multiple');\n\n    // attach listener\n    this.listener = function () {\n      var value = getValue(el, multiple);\n      value = self.params.number ? isArray(value) ? value.map(toNumber) : toNumber(value) : value;\n      self.set(value);\n    };\n    this.on('change', this.listener);\n\n    // if has initial value, set afterBind\n    var initValue = getValue(el, multiple, true);\n    if (multiple && initValue.length || !multiple && initValue !== null) {\n      this.afterBind = this.listener;\n    }\n\n    // All major browsers except Firefox resets\n    // selectedIndex with value -1 to 0 when the element\n    // is appended to a new parent, therefore we have to\n    // force a DOM update whenever that happens...\n    this.vm.$on('hook:attached', this.forceUpdate);\n  },\n\n  update: function update(value) {\n    var el = this.el;\n    el.selectedIndex = -1;\n    var multi = this.multiple && isArray(value);\n    var options = el.options;\n    var i = options.length;\n    var op, val;\n    while (i--) {\n      op = options[i];\n      val = op.hasOwnProperty('_value') ? op._value : op.value;\n      /* eslint-disable eqeqeq */\n      op.selected = multi ? indexOf$1(value, val) > -1 : looseEqual(value, val);\n      /* eslint-enable eqeqeq */\n    }\n  },\n\n  unbind: function unbind() {\n    /* istanbul ignore next */\n    this.vm.$off('hook:attached', this.forceUpdate);\n  }\n};\n\n/**\n * Get select value\n *\n * @param {SelectElement} el\n * @param {Boolean} multi\n * @param {Boolean} init\n * @return {Array|*}\n */\n\nfunction getValue(el, multi, init) {\n  var res = multi ? [] : null;\n  var op, val, selected;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    op = el.options[i];\n    selected = init ? op.hasAttribute('selected') : op.selected;\n    if (selected) {\n      val = op.hasOwnProperty('_value') ? op._value : op.value;\n      if (multi) {\n        res.push(val);\n      } else {\n        return val;\n      }\n    }\n  }\n  return res;\n}\n\n/**\n * Native Array.indexOf uses strict equal, but in this\n * case we need to match string/numbers with custom equal.\n *\n * @param {Array} arr\n * @param {*} val\n */\n\nfunction indexOf$1(arr, val) {\n  var i = arr.length;\n  while (i--) {\n    if (looseEqual(arr[i], val)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nvar checkbox = {\n\n  bind: function bind() {\n    var self = this;\n    var el = this.el;\n\n    this.getValue = function () {\n      return el.hasOwnProperty('_value') ? el._value : self.params.number ? toNumber(el.value) : el.value;\n    };\n\n    function getBooleanValue() {\n      var val = el.checked;\n      if (val && el.hasOwnProperty('_trueValue')) {\n        return el._trueValue;\n      }\n      if (!val && el.hasOwnProperty('_falseValue')) {\n        return el._falseValue;\n      }\n      return val;\n    }\n\n    this.listener = function () {\n      var model = self._watcher.value;\n      if (isArray(model)) {\n        var val = self.getValue();\n        if (el.checked) {\n          if (indexOf(model, val) < 0) {\n            model.push(val);\n          }\n        } else {\n          model.$remove(val);\n        }\n      } else {\n        self.set(getBooleanValue());\n      }\n    };\n\n    this.on('change', this.listener);\n    if (el.hasAttribute('checked')) {\n      this.afterBind = this.listener;\n    }\n  },\n\n  update: function update(value) {\n    var el = this.el;\n    if (isArray(value)) {\n      el.checked = indexOf(value, this.getValue()) > -1;\n    } else {\n      if (el.hasOwnProperty('_trueValue')) {\n        el.checked = looseEqual(value, el._trueValue);\n      } else {\n        el.checked = !!value;\n      }\n    }\n  }\n};\n\nvar handlers = {\n  text: text$2,\n  radio: radio,\n  select: select,\n  checkbox: checkbox\n};\n\nvar model = {\n\n  priority: MODEL,\n  twoWay: true,\n  handlers: handlers,\n  params: ['lazy', 'number', 'debounce'],\n\n  /**\n   * Possible elements:\n   *   <select>\n   *   <textarea>\n   *   <input type=\"*\">\n   *     - text\n   *     - checkbox\n   *     - radio\n   *     - number\n   */\n\n  bind: function bind() {\n    // friendly warning...\n    this.checkFilters();\n    if (this.hasRead && !this.hasWrite) {\n      process.env.NODE_ENV !== 'production' && warn('It seems you are using a read-only filter with ' + 'v-model=\"' + this.descriptor.raw + '\". ' + 'You might want to use a two-way filter to ensure correct behavior.', this.vm);\n    }\n    var el = this.el;\n    var tag = el.tagName;\n    var handler;\n    if (tag === 'INPUT') {\n      handler = handlers[el.type] || handlers.text;\n    } else if (tag === 'SELECT') {\n      handler = handlers.select;\n    } else if (tag === 'TEXTAREA') {\n      handler = handlers.text;\n    } else {\n      process.env.NODE_ENV !== 'production' && warn('v-model does not support element type: ' + tag, this.vm);\n      return;\n    }\n    el.__v_model = this;\n    handler.bind.call(this);\n    this.update = handler.update;\n    this._unbind = handler.unbind;\n  },\n\n  /**\n   * Check read/write filter stats.\n   */\n\n  checkFilters: function checkFilters() {\n    var filters = this.filters;\n    if (!filters) return;\n    var i = filters.length;\n    while (i--) {\n      var filter = resolveAsset(this.vm.$options, 'filters', filters[i].name);\n      if (typeof filter === 'function' || filter.read) {\n        this.hasRead = true;\n      }\n      if (filter.write) {\n        this.hasWrite = true;\n      }\n    }\n  },\n\n  unbind: function unbind() {\n    this.el.__v_model = null;\n    this._unbind && this._unbind();\n  }\n};\n\n// keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  'delete': [8, 46],\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40\n};\n\nfunction keyFilter(handler, keys) {\n  var codes = keys.map(function (key) {\n    var charCode = key.charCodeAt(0);\n    if (charCode > 47 && charCode < 58) {\n      return parseInt(key, 10);\n    }\n    if (key.length === 1) {\n      charCode = key.toUpperCase().charCodeAt(0);\n      if (charCode > 64 && charCode < 91) {\n        return charCode;\n      }\n    }\n    return keyCodes[key];\n  });\n  codes = [].concat.apply([], codes);\n  return function keyHandler(e) {\n    if (codes.indexOf(e.keyCode) > -1) {\n      return handler.call(this, e);\n    }\n  };\n}\n\nfunction stopFilter(handler) {\n  return function stopHandler(e) {\n    e.stopPropagation();\n    return handler.call(this, e);\n  };\n}\n\nfunction preventFilter(handler) {\n  return function preventHandler(e) {\n    e.preventDefault();\n    return handler.call(this, e);\n  };\n}\n\nfunction selfFilter(handler) {\n  return function selfHandler(e) {\n    if (e.target === e.currentTarget) {\n      return handler.call(this, e);\n    }\n  };\n}\n\nvar on$1 = {\n\n  priority: ON,\n  acceptStatement: true,\n  keyCodes: keyCodes,\n\n  bind: function bind() {\n    // deal with iframes\n    if (this.el.tagName === 'IFRAME' && this.arg !== 'load') {\n      var self = this;\n      this.iframeBind = function () {\n        on(self.el.contentWindow, self.arg, self.handler, self.modifiers.capture);\n      };\n      this.on('load', this.iframeBind);\n    }\n  },\n\n  update: function update(handler) {\n    // stub a noop for v-on with no value,\n    // e.g. @mousedown.prevent\n    if (!this.descriptor.raw) {\n      handler = function () {};\n    }\n\n    if (typeof handler !== 'function') {\n      process.env.NODE_ENV !== 'production' && warn('v-on:' + this.arg + '=\"' + this.expression + '\" expects a function value, ' + 'got ' + handler, this.vm);\n      return;\n    }\n\n    // apply modifiers\n    if (this.modifiers.stop) {\n      handler = stopFilter(handler);\n    }\n    if (this.modifiers.prevent) {\n      handler = preventFilter(handler);\n    }\n    if (this.modifiers.self) {\n      handler = selfFilter(handler);\n    }\n    // key filter\n    var keys = Object.keys(this.modifiers).filter(function (key) {\n      return key !== 'stop' && key !== 'prevent' && key !== 'self';\n    });\n    if (keys.length) {\n      handler = keyFilter(handler, keys);\n    }\n\n    this.reset();\n    this.handler = handler;\n\n    if (this.iframeBind) {\n      this.iframeBind();\n    } else {\n      on(this.el, this.arg, this.handler, this.modifiers.capture);\n    }\n  },\n\n  reset: function reset() {\n    var el = this.iframeBind ? this.el.contentWindow : this.el;\n    if (this.handler) {\n      off(el, this.arg, this.handler);\n    }\n  },\n\n  unbind: function unbind() {\n    this.reset();\n  }\n};\n\nvar prefixes = ['-webkit-', '-moz-', '-ms-'];\nvar camelPrefixes = ['Webkit', 'Moz', 'ms'];\nvar importantRE = /!important;?$/;\nvar propCache = Object.create(null);\n\nvar testEl = null;\n\nvar style = {\n\n  deep: true,\n\n  update: function update(value) {\n    if (typeof value === 'string') {\n      this.el.style.cssText = value;\n    } else if (isArray(value)) {\n      this.handleObject(value.reduce(extend, {}));\n    } else {\n      this.handleObject(value || {});\n    }\n  },\n\n  handleObject: function handleObject(value) {\n    // cache object styles so that only changed props\n    // are actually updated.\n    var cache = this.cache || (this.cache = {});\n    var name, val;\n    for (name in cache) {\n      if (!(name in value)) {\n        this.handleSingle(name, null);\n        delete cache[name];\n      }\n    }\n    for (name in value) {\n      val = value[name];\n      if (val !== cache[name]) {\n        cache[name] = val;\n        this.handleSingle(name, val);\n      }\n    }\n  },\n\n  handleSingle: function handleSingle(prop, value) {\n    prop = normalize(prop);\n    if (!prop) return; // unsupported prop\n    // cast possible numbers/booleans into strings\n    if (value != null) value += '';\n    if (value) {\n      var isImportant = importantRE.test(value) ? 'important' : '';\n      if (isImportant) {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production') {\n          warn('It\\'s probably a bad idea to use !important with inline rules. ' + 'This feature will be deprecated in a future version of Vue.');\n        }\n        value = value.replace(importantRE, '').trim();\n        this.el.style.setProperty(prop.kebab, value, isImportant);\n      } else {\n        this.el.style[prop.camel] = value;\n      }\n    } else {\n      this.el.style[prop.camel] = '';\n    }\n  }\n\n};\n\n/**\n * Normalize a CSS property name.\n * - cache result\n * - auto prefix\n * - camelCase -> dash-case\n *\n * @param {String} prop\n * @return {String}\n */\n\nfunction normalize(prop) {\n  if (propCache[prop]) {\n    return propCache[prop];\n  }\n  var res = prefix(prop);\n  propCache[prop] = propCache[res] = res;\n  return res;\n}\n\n/**\n * Auto detect the appropriate prefix for a CSS property.\n * https://gist.github.com/paulirish/523692\n *\n * @param {String} prop\n * @return {String}\n */\n\nfunction prefix(prop) {\n  prop = hyphenate(prop);\n  var camel = camelize(prop);\n  var upper = camel.charAt(0).toUpperCase() + camel.slice(1);\n  if (!testEl) {\n    testEl = document.createElement('div');\n  }\n  var i = prefixes.length;\n  var prefixed;\n  while (i--) {\n    prefixed = camelPrefixes[i] + upper;\n    if (prefixed in testEl.style) {\n      return {\n        kebab: prefixes[i] + prop,\n        camel: prefixed\n      };\n    }\n  }\n  if (camel in testEl.style) {\n    return {\n      kebab: prop,\n      camel: camel\n    };\n  }\n}\n\n// xlink\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\nvar xlinkRE = /^xlink:/;\n\n// check for attributes that prohibit interpolations\nvar disallowedInterpAttrRE = /^v-|^:|^@|^(?:is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/;\n// these attributes should also set their corresponding properties\n// because they only affect the initial state of the element\nvar attrWithPropsRE = /^(?:value|checked|selected|muted)$/;\n// these attributes expect enumrated values of \"true\" or \"false\"\n// but are not boolean attributes\nvar enumeratedAttrRE = /^(?:draggable|contenteditable|spellcheck)$/;\n\n// these attributes should set a hidden property for\n// binding v-model to object values\nvar modelProps = {\n  value: '_value',\n  'true-value': '_trueValue',\n  'false-value': '_falseValue'\n};\n\nvar bind$1 = {\n\n  priority: BIND,\n\n  bind: function bind() {\n    var attr = this.arg;\n    var tag = this.el.tagName;\n    // should be deep watch on object mode\n    if (!attr) {\n      this.deep = true;\n    }\n    // handle interpolation bindings\n    var descriptor = this.descriptor;\n    var tokens = descriptor.interp;\n    if (tokens) {\n      // handle interpolations with one-time tokens\n      if (descriptor.hasOneTime) {\n        this.expression = tokensToExp(tokens, this._scope || this.vm);\n      }\n\n      // only allow binding on native attributes\n      if (disallowedInterpAttrRE.test(attr) || attr === 'name' && (tag === 'PARTIAL' || tag === 'SLOT')) {\n        process.env.NODE_ENV !== 'production' && warn(attr + '=\"' + descriptor.raw + '\": ' + 'attribute interpolation is not allowed in Vue.js ' + 'directives and special attributes.', this.vm);\n        this.el.removeAttribute(attr);\n        this.invalid = true;\n      }\n\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production') {\n        var raw = attr + '=\"' + descriptor.raw + '\": ';\n        // warn src\n        if (attr === 'src') {\n          warn(raw + 'interpolation in \"src\" attribute will cause ' + 'a 404 request. Use v-bind:src instead.', this.vm);\n        }\n\n        // warn style\n        if (attr === 'style') {\n          warn(raw + 'interpolation in \"style\" attribute will cause ' + 'the attribute to be discarded in Internet Explorer. ' + 'Use v-bind:style instead.', this.vm);\n        }\n      }\n    }\n  },\n\n  update: function update(value) {\n    if (this.invalid) {\n      return;\n    }\n    var attr = this.arg;\n    if (this.arg) {\n      this.handleSingle(attr, value);\n    } else {\n      this.handleObject(value || {});\n    }\n  },\n\n  // share object handler with v-bind:class\n  handleObject: style.handleObject,\n\n  handleSingle: function handleSingle(attr, value) {\n    var el = this.el;\n    var interp = this.descriptor.interp;\n    if (this.modifiers.camel) {\n      attr = camelize(attr);\n    }\n    if (!interp && attrWithPropsRE.test(attr) && attr in el) {\n      el[attr] = attr === 'value' ? value == null // IE9 will set input.value to \"null\" for null...\n      ? '' : value : value;\n    }\n    // set model props\n    var modelProp = modelProps[attr];\n    if (!interp && modelProp) {\n      el[modelProp] = value;\n      // update v-model if present\n      var model = el.__v_model;\n      if (model) {\n        model.listener();\n      }\n    }\n    // do not set value attribute for textarea\n    if (attr === 'value' && el.tagName === 'TEXTAREA') {\n      el.removeAttribute(attr);\n      return;\n    }\n    // update attribute\n    if (enumeratedAttrRE.test(attr)) {\n      el.setAttribute(attr, value ? 'true' : 'false');\n    } else if (value != null && value !== false) {\n      if (attr === 'class') {\n        // handle edge case #1960:\n        // class interpolation should not overwrite Vue transition class\n        if (el.__v_trans) {\n          value += ' ' + el.__v_trans.id + '-transition';\n        }\n        setClass(el, value);\n      } else if (xlinkRE.test(attr)) {\n        el.setAttributeNS(xlinkNS, attr, value === true ? '' : value);\n      } else {\n        el.setAttribute(attr, value === true ? '' : value);\n      }\n    } else {\n      el.removeAttribute(attr);\n    }\n  }\n};\n\nvar el = {\n\n  priority: EL,\n\n  bind: function bind() {\n    /* istanbul ignore if */\n    if (!this.arg) {\n      return;\n    }\n    var id = this.id = camelize(this.arg);\n    var refs = (this._scope || this.vm).$els;\n    if (hasOwn(refs, id)) {\n      refs[id] = this.el;\n    } else {\n      defineReactive(refs, id, this.el);\n    }\n  },\n\n  unbind: function unbind() {\n    var refs = (this._scope || this.vm).$els;\n    if (refs[this.id] === this.el) {\n      refs[this.id] = null;\n    }\n  }\n};\n\nvar ref = {\n  bind: function bind() {\n    process.env.NODE_ENV !== 'production' && warn('v-ref:' + this.arg + ' must be used on a child ' + 'component. Found on <' + this.el.tagName.toLowerCase() + '>.', this.vm);\n  }\n};\n\nvar cloak = {\n  bind: function bind() {\n    var el = this.el;\n    this.vm.$once('pre-hook:compiled', function () {\n      el.removeAttribute('v-cloak');\n    });\n  }\n};\n\n// must export plain object\nvar directives = {\n  text: text$1,\n  html: html,\n  'for': vFor,\n  'if': vIf,\n  show: show,\n  model: model,\n  on: on$1,\n  bind: bind$1,\n  el: el,\n  ref: ref,\n  cloak: cloak\n};\n\nvar vClass = {\n\n  deep: true,\n\n  update: function update(value) {\n    if (value && typeof value === 'string') {\n      this.handleObject(stringToObject(value));\n    } else if (isPlainObject(value)) {\n      this.handleObject(value);\n    } else if (isArray(value)) {\n      this.handleArray(value);\n    } else {\n      this.cleanup();\n    }\n  },\n\n  handleObject: function handleObject(value) {\n    this.cleanup(value);\n    this.prevKeys = Object.keys(value);\n    setObjectClasses(this.el, value);\n  },\n\n  handleArray: function handleArray(value) {\n    this.cleanup(value);\n    for (var i = 0, l = value.length; i < l; i++) {\n      var val = value[i];\n      if (val && isPlainObject(val)) {\n        setObjectClasses(this.el, val);\n      } else if (val && typeof val === 'string') {\n        addClass(this.el, val);\n      }\n    }\n    this.prevKeys = value.slice();\n  },\n\n  cleanup: function cleanup(value) {\n    if (!this.prevKeys) return;\n\n    var i = this.prevKeys.length;\n    while (i--) {\n      var key = this.prevKeys[i];\n      if (!key) continue;\n\n      var keys = isPlainObject(key) ? Object.keys(key) : [key];\n      for (var j = 0, l = keys.length; j < l; j++) {\n        toggleClasses(this.el, keys[j], removeClass);\n      }\n    }\n  }\n};\n\nfunction setObjectClasses(el, obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    if (!obj[key]) continue;\n    toggleClasses(el, key, addClass);\n  }\n}\n\nfunction stringToObject(value) {\n  var res = {};\n  var keys = value.trim().split(/\\s+/);\n  for (var i = 0, l = keys.length; i < l; i++) {\n    res[keys[i]] = true;\n  }\n  return res;\n}\n\n/**\n * Add or remove a class/classes on an element\n *\n * @param {Element} el\n * @param {String} key The class name. This may or may not\n *                     contain a space character, in such a\n *                     case we'll deal with multiple class\n *                     names at once.\n * @param {Function} fn\n */\n\nfunction toggleClasses(el, key, fn) {\n  key = key.trim();\n\n  if (key.indexOf(' ') === -1) {\n    fn(el, key);\n    return;\n  }\n\n  // The key contains one or more space characters.\n  // Since a class name doesn't accept such characters, we\n  // treat it as multiple classes.\n  var keys = key.split(/\\s+/);\n  for (var i = 0, l = keys.length; i < l; i++) {\n    fn(el, keys[i]);\n  }\n}\n\nvar component = {\n\n  priority: COMPONENT,\n\n  params: ['keep-alive', 'transition-mode', 'inline-template'],\n\n  /**\n   * Setup. Two possible usages:\n   *\n   * - static:\n   *   <comp> or <div v-component=\"comp\">\n   *\n   * - dynamic:\n   *   <component :is=\"view\">\n   */\n\n  bind: function bind() {\n    if (!this.el.__vue__) {\n      // keep-alive cache\n      this.keepAlive = this.params.keepAlive;\n      if (this.keepAlive) {\n        this.cache = {};\n      }\n      // check inline-template\n      if (this.params.inlineTemplate) {\n        // extract inline template as a DocumentFragment\n        this.inlineTemplate = extractContent(this.el, true);\n      }\n      // component resolution related state\n      this.pendingComponentCb = this.Component = null;\n      // transition related state\n      this.pendingRemovals = 0;\n      this.pendingRemovalCb = null;\n      // create a ref anchor\n      this.anchor = createAnchor('v-component');\n      replace(this.el, this.anchor);\n      // remove is attribute.\n      // this is removed during compilation, but because compilation is\n      // cached, when the component is used elsewhere this attribute\n      // will remain at link time.\n      this.el.removeAttribute('is');\n      // remove ref, same as above\n      if (this.descriptor.ref) {\n        this.el.removeAttribute('v-ref:' + hyphenate(this.descriptor.ref));\n      }\n      // if static, build right now.\n      if (this.literal) {\n        this.setComponent(this.expression);\n      }\n    } else {\n      process.env.NODE_ENV !== 'production' && warn('cannot mount component \"' + this.expression + '\" ' + 'on already mounted element: ' + this.el);\n    }\n  },\n\n  /**\n   * Public update, called by the watcher in the dynamic\n   * literal scenario, e.g. <component :is=\"view\">\n   */\n\n  update: function update(value) {\n    if (!this.literal) {\n      this.setComponent(value);\n    }\n  },\n\n  /**\n   * Switch dynamic components. May resolve the component\n   * asynchronously, and perform transition based on\n   * specified transition mode. Accepts a few additional\n   * arguments specifically for vue-router.\n   *\n   * The callback is called when the full transition is\n   * finished.\n   *\n   * @param {String} value\n   * @param {Function} [cb]\n   */\n\n  setComponent: function setComponent(value, cb) {\n    this.invalidatePending();\n    if (!value) {\n      // just remove current\n      this.unbuild(true);\n      this.remove(this.childVM, cb);\n      this.childVM = null;\n    } else {\n      var self = this;\n      this.resolveComponent(value, function () {\n        self.mountComponent(cb);\n      });\n    }\n  },\n\n  /**\n   * Resolve the component constructor to use when creating\n   * the child vm.\n   *\n   * @param {String|Function} value\n   * @param {Function} cb\n   */\n\n  resolveComponent: function resolveComponent(value, cb) {\n    var self = this;\n    this.pendingComponentCb = cancellable(function (Component) {\n      self.ComponentName = Component.options.name || (typeof value === 'string' ? value : null);\n      self.Component = Component;\n      cb();\n    });\n    this.vm._resolveComponent(value, this.pendingComponentCb);\n  },\n\n  /**\n   * Create a new instance using the current constructor and\n   * replace the existing instance. This method doesn't care\n   * whether the new component and the old one are actually\n   * the same.\n   *\n   * @param {Function} [cb]\n   */\n\n  mountComponent: function mountComponent(cb) {\n    // actual mount\n    this.unbuild(true);\n    var self = this;\n    var activateHooks = this.Component.options.activate;\n    var cached = this.getCached();\n    var newComponent = this.build();\n    if (activateHooks && !cached) {\n      this.waitingFor = newComponent;\n      callActivateHooks(activateHooks, newComponent, function () {\n        if (self.waitingFor !== newComponent) {\n          return;\n        }\n        self.waitingFor = null;\n        self.transition(newComponent, cb);\n      });\n    } else {\n      // update ref for kept-alive component\n      if (cached) {\n        newComponent._updateRef();\n      }\n      this.transition(newComponent, cb);\n    }\n  },\n\n  /**\n   * When the component changes or unbinds before an async\n   * constructor is resolved, we need to invalidate its\n   * pending callback.\n   */\n\n  invalidatePending: function invalidatePending() {\n    if (this.pendingComponentCb) {\n      this.pendingComponentCb.cancel();\n      this.pendingComponentCb = null;\n    }\n  },\n\n  /**\n   * Instantiate/insert a new child vm.\n   * If keep alive and has cached instance, insert that\n   * instance; otherwise build a new one and cache it.\n   *\n   * @param {Object} [extraOptions]\n   * @return {Vue} - the created instance\n   */\n\n  build: function build(extraOptions) {\n    var cached = this.getCached();\n    if (cached) {\n      return cached;\n    }\n    if (this.Component) {\n      // default options\n      var options = {\n        name: this.ComponentName,\n        el: cloneNode(this.el),\n        template: this.inlineTemplate,\n        // make sure to add the child with correct parent\n        // if this is a transcluded component, its parent\n        // should be the transclusion host.\n        parent: this._host || this.vm,\n        // if no inline-template, then the compiled\n        // linker can be cached for better performance.\n        _linkerCachable: !this.inlineTemplate,\n        _ref: this.descriptor.ref,\n        _asComponent: true,\n        _isRouterView: this._isRouterView,\n        // if this is a transcluded component, context\n        // will be the common parent vm of this instance\n        // and its host.\n        _context: this.vm,\n        // if this is inside an inline v-for, the scope\n        // will be the intermediate scope created for this\n        // repeat fragment. this is used for linking props\n        // and container directives.\n        _scope: this._scope,\n        // pass in the owner fragment of this component.\n        // this is necessary so that the fragment can keep\n        // track of its contained components in order to\n        // call attach/detach hooks for them.\n        _frag: this._frag\n      };\n      // extra options\n      // in 1.0.0 this is used by vue-router only\n      /* istanbul ignore if */\n      if (extraOptions) {\n        extend(options, extraOptions);\n      }\n      var child = new this.Component(options);\n      if (this.keepAlive) {\n        this.cache[this.Component.cid] = child;\n      }\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && this.el.hasAttribute('transition') && child._isFragment) {\n        warn('Transitions will not work on a fragment instance. ' + 'Template: ' + child.$options.template, child);\n      }\n      return child;\n    }\n  },\n\n  /**\n   * Try to get a cached instance of the current component.\n   *\n   * @return {Vue|undefined}\n   */\n\n  getCached: function getCached() {\n    return this.keepAlive && this.cache[this.Component.cid];\n  },\n\n  /**\n   * Teardown the current child, but defers cleanup so\n   * that we can separate the destroy and removal steps.\n   *\n   * @param {Boolean} defer\n   */\n\n  unbuild: function unbuild(defer) {\n    if (this.waitingFor) {\n      if (!this.keepAlive) {\n        this.waitingFor.$destroy();\n      }\n      this.waitingFor = null;\n    }\n    var child = this.childVM;\n    if (!child || this.keepAlive) {\n      if (child) {\n        // remove ref\n        child._inactive = true;\n        child._updateRef(true);\n      }\n      return;\n    }\n    // the sole purpose of `deferCleanup` is so that we can\n    // \"deactivate\" the vm right now and perform DOM removal\n    // later.\n    child.$destroy(false, defer);\n  },\n\n  /**\n   * Remove current destroyed child and manually do\n   * the cleanup after removal.\n   *\n   * @param {Function} cb\n   */\n\n  remove: function remove(child, cb) {\n    var keepAlive = this.keepAlive;\n    if (child) {\n      // we may have a component switch when a previous\n      // component is still being transitioned out.\n      // we want to trigger only one lastest insertion cb\n      // when the existing transition finishes. (#1119)\n      this.pendingRemovals++;\n      this.pendingRemovalCb = cb;\n      var self = this;\n      child.$remove(function () {\n        self.pendingRemovals--;\n        if (!keepAlive) child._cleanup();\n        if (!self.pendingRemovals && self.pendingRemovalCb) {\n          self.pendingRemovalCb();\n          self.pendingRemovalCb = null;\n        }\n      });\n    } else if (cb) {\n      cb();\n    }\n  },\n\n  /**\n   * Actually swap the components, depending on the\n   * transition mode. Defaults to simultaneous.\n   *\n   * @param {Vue} target\n   * @param {Function} [cb]\n   */\n\n  transition: function transition(target, cb) {\n    var self = this;\n    var current = this.childVM;\n    // for devtool inspection\n    if (current) current._inactive = true;\n    target._inactive = false;\n    this.childVM = target;\n    switch (self.params.transitionMode) {\n      case 'in-out':\n        target.$before(self.anchor, function () {\n          self.remove(current, cb);\n        });\n        break;\n      case 'out-in':\n        self.remove(current, function () {\n          target.$before(self.anchor, cb);\n        });\n        break;\n      default:\n        self.remove(current);\n        target.$before(self.anchor, cb);\n    }\n  },\n\n  /**\n   * Unbind.\n   */\n\n  unbind: function unbind() {\n    this.invalidatePending();\n    // Do not defer cleanup when unbinding\n    this.unbuild();\n    // destroy all keep-alive cached instances\n    if (this.cache) {\n      for (var key in this.cache) {\n        this.cache[key].$destroy();\n      }\n      this.cache = null;\n    }\n  }\n};\n\n/**\n * Call activate hooks in order (asynchronous)\n *\n * @param {Array} hooks\n * @param {Vue} vm\n * @param {Function} cb\n */\n\nfunction callActivateHooks(hooks, vm, cb) {\n  var total = hooks.length;\n  var called = 0;\n  hooks[0].call(vm, next);\n  function next() {\n    if (++called >= total) {\n      cb();\n    } else {\n      hooks[called].call(vm, next);\n    }\n  }\n}\n\nvar propBindingModes = config._propBindingModes;\nvar empty = {};\n\n// regexes\nvar identRE$1 = /^[$_a-zA-Z]+[\\w$]*$/;\nvar settablePathRE = /^[A-Za-z_$][\\w$]*(\\.[A-Za-z_$][\\w$]*|\\[[^\\[\\]]+\\])*$/;\n\n/**\n * Compile props on a root element and return\n * a props link function.\n *\n * @param {Element|DocumentFragment} el\n * @param {Array} propOptions\n * @param {Vue} vm\n * @return {Function} propsLinkFn\n */\n\nfunction compileProps(el, propOptions, vm) {\n  var props = [];\n  var names = Object.keys(propOptions);\n  var i = names.length;\n  var options, name, attr, value, path, parsed, prop;\n  while (i--) {\n    name = names[i];\n    options = propOptions[name] || empty;\n\n    if (process.env.NODE_ENV !== 'production' && name === '$data') {\n      warn('Do not use $data as prop.', vm);\n      continue;\n    }\n\n    // props could contain dashes, which will be\n    // interpreted as minus calculations by the parser\n    // so we need to camelize the path here\n    path = camelize(name);\n    if (!identRE$1.test(path)) {\n      process.env.NODE_ENV !== 'production' && warn('Invalid prop key: \"' + name + '\". Prop keys ' + 'must be valid identifiers.', vm);\n      continue;\n    }\n\n    prop = {\n      name: name,\n      path: path,\n      options: options,\n      mode: propBindingModes.ONE_WAY,\n      raw: null\n    };\n\n    attr = hyphenate(name);\n    // first check dynamic version\n    if ((value = getBindAttr(el, attr)) === null) {\n      if ((value = getBindAttr(el, attr + '.sync')) !== null) {\n        prop.mode = propBindingModes.TWO_WAY;\n      } else if ((value = getBindAttr(el, attr + '.once')) !== null) {\n        prop.mode = propBindingModes.ONE_TIME;\n      }\n    }\n    if (value !== null) {\n      // has dynamic binding!\n      prop.raw = value;\n      parsed = parseDirective(value);\n      value = parsed.expression;\n      prop.filters = parsed.filters;\n      // check binding type\n      if (isLiteral(value) && !parsed.filters) {\n        // for expressions containing literal numbers and\n        // booleans, there's no need to setup a prop binding,\n        // so we can optimize them as a one-time set.\n        prop.optimizedLiteral = true;\n      } else {\n        prop.dynamic = true;\n        // check non-settable path for two-way bindings\n        if (process.env.NODE_ENV !== 'production' && prop.mode === propBindingModes.TWO_WAY && !settablePathRE.test(value)) {\n          prop.mode = propBindingModes.ONE_WAY;\n          warn('Cannot bind two-way prop with non-settable ' + 'parent path: ' + value, vm);\n        }\n      }\n      prop.parentPath = value;\n\n      // warn required two-way\n      if (process.env.NODE_ENV !== 'production' && options.twoWay && prop.mode !== propBindingModes.TWO_WAY) {\n        warn('Prop \"' + name + '\" expects a two-way binding type.', vm);\n      }\n    } else if ((value = getAttr(el, attr)) !== null) {\n      // has literal binding!\n      prop.raw = value;\n    } else if (process.env.NODE_ENV !== 'production') {\n      // check possible camelCase prop usage\n      var lowerCaseName = path.toLowerCase();\n      value = /[A-Z\\-]/.test(name) && (el.getAttribute(lowerCaseName) || el.getAttribute(':' + lowerCaseName) || el.getAttribute('v-bind:' + lowerCaseName) || el.getAttribute(':' + lowerCaseName + '.once') || el.getAttribute('v-bind:' + lowerCaseName + '.once') || el.getAttribute(':' + lowerCaseName + '.sync') || el.getAttribute('v-bind:' + lowerCaseName + '.sync'));\n      if (value) {\n        warn('Possible usage error for prop `' + lowerCaseName + '` - ' + 'did you mean `' + attr + '`? HTML is case-insensitive, remember to use ' + 'kebab-case for props in templates.', vm);\n      } else if (options.required) {\n        // warn missing required\n        warn('Missing required prop: ' + name, vm);\n      }\n    }\n    // push prop\n    props.push(prop);\n  }\n  return makePropsLinkFn(props);\n}\n\n/**\n * Build a function that applies props to a vm.\n *\n * @param {Array} props\n * @return {Function} propsLinkFn\n */\n\nfunction makePropsLinkFn(props) {\n  return function propsLinkFn(vm, scope) {\n    // store resolved props info\n    vm._props = {};\n    var i = props.length;\n    var prop, path, options, value, raw;\n    while (i--) {\n      prop = props[i];\n      raw = prop.raw;\n      path = prop.path;\n      options = prop.options;\n      vm._props[path] = prop;\n      if (raw === null) {\n        // initialize absent prop\n        initProp(vm, prop, undefined);\n      } else if (prop.dynamic) {\n        // dynamic prop\n        if (prop.mode === propBindingModes.ONE_TIME) {\n          // one time binding\n          value = (scope || vm._context || vm).$get(prop.parentPath);\n          initProp(vm, prop, value);\n        } else {\n          if (vm._context) {\n            // dynamic binding\n            vm._bindDir({\n              name: 'prop',\n              def: propDef,\n              prop: prop\n            }, null, null, scope); // el, host, scope\n          } else {\n              // root instance\n              initProp(vm, prop, vm.$get(prop.parentPath));\n            }\n        }\n      } else if (prop.optimizedLiteral) {\n        // optimized literal, cast it and just set once\n        var stripped = stripQuotes(raw);\n        value = stripped === raw ? toBoolean(toNumber(raw)) : stripped;\n        initProp(vm, prop, value);\n      } else {\n        // string literal, but we need to cater for\n        // Boolean props with no value, or with same\n        // literal value (e.g. disabled=\"disabled\")\n        // see https://github.com/vuejs/vue-loader/issues/182\n        value = options.type === Boolean && (raw === '' || raw === hyphenate(prop.name)) ? true : raw;\n        initProp(vm, prop, value);\n      }\n    }\n  };\n}\n\n/**\n * Process a prop with a rawValue, applying necessary coersions,\n * default values & assertions and call the given callback with\n * processed value.\n *\n * @param {Vue} vm\n * @param {Object} prop\n * @param {*} rawValue\n * @param {Function} fn\n */\n\nfunction processPropValue(vm, prop, rawValue, fn) {\n  var isSimple = prop.dynamic && isSimplePath(prop.parentPath);\n  var value = rawValue;\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop);\n  }\n  value = coerceProp(prop, value);\n  var coerced = value !== rawValue;\n  if (!assertProp(prop, value, vm)) {\n    value = undefined;\n  }\n  if (isSimple && !coerced) {\n    withoutConversion(function () {\n      fn(value);\n    });\n  } else {\n    fn(value);\n  }\n}\n\n/**\n * Set a prop's initial value on a vm and its data object.\n *\n * @param {Vue} vm\n * @param {Object} prop\n * @param {*} value\n */\n\nfunction initProp(vm, prop, value) {\n  processPropValue(vm, prop, value, function (value) {\n    defineReactive(vm, prop.path, value);\n  });\n}\n\n/**\n * Update a prop's value on a vm.\n *\n * @param {Vue} vm\n * @param {Object} prop\n * @param {*} value\n */\n\nfunction updateProp(vm, prop, value) {\n  processPropValue(vm, prop, value, function (value) {\n    vm[prop.path] = value;\n  });\n}\n\n/**\n * Get the default value of a prop.\n *\n * @param {Vue} vm\n * @param {Object} prop\n * @return {*}\n */\n\nfunction getPropDefaultValue(vm, prop) {\n  // no default, return undefined\n  var options = prop.options;\n  if (!hasOwn(options, 'default')) {\n    // absent boolean value defaults to false\n    return options.type === Boolean ? false : undefined;\n  }\n  var def = options['default'];\n  // warn against non-factory defaults for Object & Array\n  if (isObject(def)) {\n    process.env.NODE_ENV !== 'production' && warn('Invalid default value for prop \"' + prop.name + '\": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);\n  }\n  // call factory function for non-Function types\n  return typeof def === 'function' && options.type !== Function ? def.call(vm) : def;\n}\n\n/**\n * Assert whether a prop is valid.\n *\n * @param {Object} prop\n * @param {*} value\n * @param {Vue} vm\n */\n\nfunction assertProp(prop, value, vm) {\n  if (!prop.options.required && ( // non-required\n  prop.raw === null || // abscent\n  value == null) // null or undefined\n  ) {\n      return true;\n    }\n  var options = prop.options;\n  var type = options.type;\n  var valid = !type;\n  var expectedTypes = [];\n  if (type) {\n    if (!isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType);\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    if (process.env.NODE_ENV !== 'production') {\n      warn('Invalid prop: type check failed for prop \"' + prop.name + '\".' + ' Expected ' + expectedTypes.map(formatType).join(', ') + ', got ' + formatValue(value) + '.', vm);\n    }\n    return false;\n  }\n  var validator = options.validator;\n  if (validator) {\n    if (!validator(value)) {\n      process.env.NODE_ENV !== 'production' && warn('Invalid prop: custom validator check failed for prop \"' + prop.name + '\".', vm);\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Force parsing value with coerce option.\n *\n * @param {*} value\n * @param {Object} options\n * @return {*}\n */\n\nfunction coerceProp(prop, value) {\n  var coerce = prop.options.coerce;\n  if (!coerce) {\n    return value;\n  }\n  // coerce is a function\n  return coerce(value);\n}\n\n/**\n * Assert the type of a value\n *\n * @param {*} value\n * @param {Function} type\n * @return {Object}\n */\n\nfunction assertType(value, type) {\n  var valid;\n  var expectedType;\n  if (type === String) {\n    expectedType = 'string';\n    valid = typeof value === expectedType;\n  } else if (type === Number) {\n    expectedType = 'number';\n    valid = typeof value === expectedType;\n  } else if (type === Boolean) {\n    expectedType = 'boolean';\n    valid = typeof value === expectedType;\n  } else if (type === Function) {\n    expectedType = 'function';\n    valid = typeof value === expectedType;\n  } else if (type === Object) {\n    expectedType = 'object';\n    valid = isPlainObject(value);\n  } else if (type === Array) {\n    expectedType = 'array';\n    valid = isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  };\n}\n\n/**\n * Format type for output\n *\n * @param {String} type\n * @return {String}\n */\n\nfunction formatType(type) {\n  return type ? type.charAt(0).toUpperCase() + type.slice(1) : 'custom type';\n}\n\n/**\n * Format value\n *\n * @param {*} value\n * @return {String}\n */\n\nfunction formatValue(val) {\n  return Object.prototype.toString.call(val).slice(8, -1);\n}\n\nvar bindingModes = config._propBindingModes;\n\nvar propDef = {\n\n  bind: function bind() {\n    var child = this.vm;\n    var parent = child._context;\n    // passed in from compiler directly\n    var prop = this.descriptor.prop;\n    var childKey = prop.path;\n    var parentKey = prop.parentPath;\n    var twoWay = prop.mode === bindingModes.TWO_WAY;\n\n    var parentWatcher = this.parentWatcher = new Watcher(parent, parentKey, function (val) {\n      updateProp(child, prop, val);\n    }, {\n      twoWay: twoWay,\n      filters: prop.filters,\n      // important: props need to be observed on the\n      // v-for scope if present\n      scope: this._scope\n    });\n\n    // set the child initial value.\n    initProp(child, prop, parentWatcher.value);\n\n    // setup two-way binding\n    if (twoWay) {\n      // important: defer the child watcher creation until\n      // the created hook (after data observation)\n      var self = this;\n      child.$once('pre-hook:created', function () {\n        self.childWatcher = new Watcher(child, childKey, function (val) {\n          parentWatcher.set(val);\n        }, {\n          // ensure sync upward before parent sync down.\n          // this is necessary in cases e.g. the child\n          // mutates a prop array, then replaces it. (#1683)\n          sync: true\n        });\n      });\n    }\n  },\n\n  unbind: function unbind() {\n    this.parentWatcher.teardown();\n    if (this.childWatcher) {\n      this.childWatcher.teardown();\n    }\n  }\n};\n\nvar queue$1 = [];\nvar queued = false;\n\n/**\n * Push a job into the queue.\n *\n * @param {Function} job\n */\n\nfunction pushJob(job) {\n  queue$1.push(job);\n  if (!queued) {\n    queued = true;\n    nextTick(flush);\n  }\n}\n\n/**\n * Flush the queue, and do one forced reflow before\n * triggering transitions.\n */\n\nfunction flush() {\n  // Force layout\n  var f = document.documentElement.offsetHeight;\n  for (var i = 0; i < queue$1.length; i++) {\n    queue$1[i]();\n  }\n  queue$1 = [];\n  queued = false;\n  // dummy return, so js linters don't complain about\n  // unused variable f\n  return f;\n}\n\nvar TYPE_TRANSITION = 'transition';\nvar TYPE_ANIMATION = 'animation';\nvar transDurationProp = transitionProp + 'Duration';\nvar animDurationProp = animationProp + 'Duration';\n\n/**\n * If a just-entered element is applied the\n * leave class while its enter transition hasn't started yet,\n * and the transitioned property has the same value for both\n * enter/leave, then the leave transition will be skipped and\n * the transitionend event never fires. This function ensures\n * its callback to be called after a transition has started\n * by waiting for double raf.\n *\n * It falls back to setTimeout on devices that support CSS\n * transitions but not raf (e.g. Android 4.2 browser) - since\n * these environments are usually slow, we are giving it a\n * relatively large timeout.\n */\n\nvar raf = inBrowser && window.requestAnimationFrame;\nvar waitForTransitionStart = raf\n/* istanbul ignore next */\n? function (fn) {\n  raf(function () {\n    raf(fn);\n  });\n} : function (fn) {\n  setTimeout(fn, 50);\n};\n\n/**\n * A Transition object that encapsulates the state and logic\n * of the transition.\n *\n * @param {Element} el\n * @param {String} id\n * @param {Object} hooks\n * @param {Vue} vm\n */\nfunction Transition(el, id, hooks, vm) {\n  this.id = id;\n  this.el = el;\n  this.enterClass = hooks && hooks.enterClass || id + '-enter';\n  this.leaveClass = hooks && hooks.leaveClass || id + '-leave';\n  this.hooks = hooks;\n  this.vm = vm;\n  // async state\n  this.pendingCssEvent = this.pendingCssCb = this.cancel = this.pendingJsCb = this.op = this.cb = null;\n  this.justEntered = false;\n  this.entered = this.left = false;\n  this.typeCache = {};\n  // check css transition type\n  this.type = hooks && hooks.type;\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production') {\n    if (this.type && this.type !== TYPE_TRANSITION && this.type !== TYPE_ANIMATION) {\n      warn('invalid CSS transition type for transition=\"' + this.id + '\": ' + this.type, vm);\n    }\n  }\n  // bind\n  var self = this;['enterNextTick', 'enterDone', 'leaveNextTick', 'leaveDone'].forEach(function (m) {\n    self[m] = bind(self[m], self);\n  });\n}\n\nvar p$1 = Transition.prototype;\n\n/**\n * Start an entering transition.\n *\n * 1. enter transition triggered\n * 2. call beforeEnter hook\n * 3. add enter class\n * 4. insert/show element\n * 5. call enter hook (with possible explicit js callback)\n * 6. reflow\n * 7. based on transition type:\n *    - transition:\n *        remove class now, wait for transitionend,\n *        then done if there's no explicit js callback.\n *    - animation:\n *        wait for animationend, remove class,\n *        then done if there's no explicit js callback.\n *    - no css transition:\n *        done now if there's no explicit js callback.\n * 8. wait for either done or js callback, then call\n *    afterEnter hook.\n *\n * @param {Function} op - insert/show the element\n * @param {Function} [cb]\n */\n\np$1.enter = function (op, cb) {\n  this.cancelPending();\n  this.callHook('beforeEnter');\n  this.cb = cb;\n  addClass(this.el, this.enterClass);\n  op();\n  this.entered = false;\n  this.callHookWithCb('enter');\n  if (this.entered) {\n    return; // user called done synchronously.\n  }\n  this.cancel = this.hooks && this.hooks.enterCancelled;\n  pushJob(this.enterNextTick);\n};\n\n/**\n * The \"nextTick\" phase of an entering transition, which is\n * to be pushed into a queue and executed after a reflow so\n * that removing the class can trigger a CSS transition.\n */\n\np$1.enterNextTick = function () {\n  var _this = this;\n\n  // prevent transition skipping\n  this.justEntered = true;\n  waitForTransitionStart(function () {\n    _this.justEntered = false;\n  });\n  var enterDone = this.enterDone;\n  var type = this.getCssTransitionType(this.enterClass);\n  if (!this.pendingJsCb) {\n    if (type === TYPE_TRANSITION) {\n      // trigger transition by removing enter class now\n      removeClass(this.el, this.enterClass);\n      this.setupCssCb(transitionEndEvent, enterDone);\n    } else if (type === TYPE_ANIMATION) {\n      this.setupCssCb(animationEndEvent, enterDone);\n    } else {\n      enterDone();\n    }\n  } else if (type === TYPE_TRANSITION) {\n    removeClass(this.el, this.enterClass);\n  }\n};\n\n/**\n * The \"cleanup\" phase of an entering transition.\n */\n\np$1.enterDone = function () {\n  this.entered = true;\n  this.cancel = this.pendingJsCb = null;\n  removeClass(this.el, this.enterClass);\n  this.callHook('afterEnter');\n  if (this.cb) this.cb();\n};\n\n/**\n * Start a leaving transition.\n *\n * 1. leave transition triggered.\n * 2. call beforeLeave hook\n * 3. add leave class (trigger css transition)\n * 4. call leave hook (with possible explicit js callback)\n * 5. reflow if no explicit js callback is provided\n * 6. based on transition type:\n *    - transition or animation:\n *        wait for end event, remove class, then done if\n *        there's no explicit js callback.\n *    - no css transition:\n *        done if there's no explicit js callback.\n * 7. wait for either done or js callback, then call\n *    afterLeave hook.\n *\n * @param {Function} op - remove/hide the element\n * @param {Function} [cb]\n */\n\np$1.leave = function (op, cb) {\n  this.cancelPending();\n  this.callHook('beforeLeave');\n  this.op = op;\n  this.cb = cb;\n  addClass(this.el, this.leaveClass);\n  this.left = false;\n  this.callHookWithCb('leave');\n  if (this.left) {\n    return; // user called done synchronously.\n  }\n  this.cancel = this.hooks && this.hooks.leaveCancelled;\n  // only need to handle leaveDone if\n  // 1. the transition is already done (synchronously called\n  //    by the user, which causes this.op set to null)\n  // 2. there's no explicit js callback\n  if (this.op && !this.pendingJsCb) {\n    // if a CSS transition leaves immediately after enter,\n    // the transitionend event never fires. therefore we\n    // detect such cases and end the leave immediately.\n    if (this.justEntered) {\n      this.leaveDone();\n    } else {\n      pushJob(this.leaveNextTick);\n    }\n  }\n};\n\n/**\n * The \"nextTick\" phase of a leaving transition.\n */\n\np$1.leaveNextTick = function () {\n  var type = this.getCssTransitionType(this.leaveClass);\n  if (type) {\n    var event = type === TYPE_TRANSITION ? transitionEndEvent : animationEndEvent;\n    this.setupCssCb(event, this.leaveDone);\n  } else {\n    this.leaveDone();\n  }\n};\n\n/**\n * The \"cleanup\" phase of a leaving transition.\n */\n\np$1.leaveDone = function () {\n  this.left = true;\n  this.cancel = this.pendingJsCb = null;\n  this.op();\n  removeClass(this.el, this.leaveClass);\n  this.callHook('afterLeave');\n  if (this.cb) this.cb();\n  this.op = null;\n};\n\n/**\n * Cancel any pending callbacks from a previously running\n * but not finished transition.\n */\n\np$1.cancelPending = function () {\n  this.op = this.cb = null;\n  var hasPending = false;\n  if (this.pendingCssCb) {\n    hasPending = true;\n    off(this.el, this.pendingCssEvent, this.pendingCssCb);\n    this.pendingCssEvent = this.pendingCssCb = null;\n  }\n  if (this.pendingJsCb) {\n    hasPending = true;\n    this.pendingJsCb.cancel();\n    this.pendingJsCb = null;\n  }\n  if (hasPending) {\n    removeClass(this.el, this.enterClass);\n    removeClass(this.el, this.leaveClass);\n  }\n  if (this.cancel) {\n    this.cancel.call(this.vm, this.el);\n    this.cancel = null;\n  }\n};\n\n/**\n * Call a user-provided synchronous hook function.\n *\n * @param {String} type\n */\n\np$1.callHook = function (type) {\n  if (this.hooks && this.hooks[type]) {\n    this.hooks[type].call(this.vm, this.el);\n  }\n};\n\n/**\n * Call a user-provided, potentially-async hook function.\n * We check for the length of arguments to see if the hook\n * expects a `done` callback. If true, the transition's end\n * will be determined by when the user calls that callback;\n * otherwise, the end is determined by the CSS transition or\n * animation.\n *\n * @param {String} type\n */\n\np$1.callHookWithCb = function (type) {\n  var hook = this.hooks && this.hooks[type];\n  if (hook) {\n    if (hook.length > 1) {\n      this.pendingJsCb = cancellable(this[type + 'Done']);\n    }\n    hook.call(this.vm, this.el, this.pendingJsCb);\n  }\n};\n\n/**\n * Get an element's transition type based on the\n * calculated styles.\n *\n * @param {String} className\n * @return {Number}\n */\n\np$1.getCssTransitionType = function (className) {\n  /* istanbul ignore if */\n  if (!transitionEndEvent ||\n  // skip CSS transitions if page is not visible -\n  // this solves the issue of transitionend events not\n  // firing until the page is visible again.\n  // pageVisibility API is supported in IE10+, same as\n  // CSS transitions.\n  document.hidden ||\n  // explicit js-only transition\n  this.hooks && this.hooks.css === false ||\n  // element is hidden\n  isHidden(this.el)) {\n    return;\n  }\n  var type = this.type || this.typeCache[className];\n  if (type) return type;\n  var inlineStyles = this.el.style;\n  var computedStyles = window.getComputedStyle(this.el);\n  var transDuration = inlineStyles[transDurationProp] || computedStyles[transDurationProp];\n  if (transDuration && transDuration !== '0s') {\n    type = TYPE_TRANSITION;\n  } else {\n    var animDuration = inlineStyles[animDurationProp] || computedStyles[animDurationProp];\n    if (animDuration && animDuration !== '0s') {\n      type = TYPE_ANIMATION;\n    }\n  }\n  if (type) {\n    this.typeCache[className] = type;\n  }\n  return type;\n};\n\n/**\n * Setup a CSS transitionend/animationend callback.\n *\n * @param {String} event\n * @param {Function} cb\n */\n\np$1.setupCssCb = function (event, cb) {\n  this.pendingCssEvent = event;\n  var self = this;\n  var el = this.el;\n  var onEnd = this.pendingCssCb = function (e) {\n    if (e.target === el) {\n      off(el, event, onEnd);\n      self.pendingCssEvent = self.pendingCssCb = null;\n      if (!self.pendingJsCb && cb) {\n        cb();\n      }\n    }\n  };\n  on(el, event, onEnd);\n};\n\n/**\n * Check if an element is hidden - in that case we can just\n * skip the transition alltogether.\n *\n * @param {Element} el\n * @return {Boolean}\n */\n\nfunction isHidden(el) {\n  if (/svg$/.test(el.namespaceURI)) {\n    // SVG elements do not have offset(Width|Height)\n    // so we need to check the client rect\n    var rect = el.getBoundingClientRect();\n    return !(rect.width || rect.height);\n  } else {\n    return !(el.offsetWidth || el.offsetHeight || el.getClientRects().length);\n  }\n}\n\nvar transition$1 = {\n\n  priority: TRANSITION,\n\n  update: function update(id, oldId) {\n    var el = this.el;\n    // resolve on owner vm\n    var hooks = resolveAsset(this.vm.$options, 'transitions', id);\n    id = id || 'v';\n    el.__v_trans = new Transition(el, id, hooks, this.vm);\n    if (oldId) {\n      removeClass(el, oldId + '-transition');\n    }\n    addClass(el, id + '-transition');\n  }\n};\n\nvar internalDirectives = {\n  style: style,\n  'class': vClass,\n  component: component,\n  prop: propDef,\n  transition: transition$1\n};\n\n// special binding prefixes\nvar bindRE = /^v-bind:|^:/;\nvar onRE = /^v-on:|^@/;\nvar dirAttrRE = /^v-([^:]+)(?:$|:(.*)$)/;\nvar modifierRE = /\\.[^\\.]+/g;\nvar transitionRE = /^(v-bind:|:)?transition$/;\n\n// default directive priority\nvar DEFAULT_PRIORITY = 1000;\nvar DEFAULT_TERMINAL_PRIORITY = 2000;\n\n/**\n * Compile a template and return a reusable composite link\n * function, which recursively contains more link functions\n * inside. This top level compile function would normally\n * be called on instance root nodes, but can also be used\n * for partial compilation if the partial argument is true.\n *\n * The returned composite link function, when called, will\n * return an unlink function that tearsdown all directives\n * created during the linking phase.\n *\n * @param {Element|DocumentFragment} el\n * @param {Object} options\n * @param {Boolean} partial\n * @return {Function}\n */\n\nfunction compile(el, options, partial) {\n  // link function for the node itself.\n  var nodeLinkFn = partial || !options._asComponent ? compileNode(el, options) : null;\n  // link function for the childNodes\n  var childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && el.tagName !== 'SCRIPT' && el.hasChildNodes() ? compileNodeList(el.childNodes, options) : null;\n\n  /**\n   * A composite linker function to be called on a already\n   * compiled piece of DOM, which instantiates all directive\n   * instances.\n   *\n   * @param {Vue} vm\n   * @param {Element|DocumentFragment} el\n   * @param {Vue} [host] - host vm of transcluded content\n   * @param {Object} [scope] - v-for scope\n   * @param {Fragment} [frag] - link context fragment\n   * @return {Function|undefined}\n   */\n\n  return function compositeLinkFn(vm, el, host, scope, frag) {\n    // cache childNodes before linking parent, fix #657\n    var childNodes = toArray(el.childNodes);\n    // link\n    var dirs = linkAndCapture(function compositeLinkCapturer() {\n      if (nodeLinkFn) nodeLinkFn(vm, el, host, scope, frag);\n      if (childLinkFn) childLinkFn(vm, childNodes, host, scope, frag);\n    }, vm);\n    return makeUnlinkFn(vm, dirs);\n  };\n}\n\n/**\n * Apply a linker to a vm/element pair and capture the\n * directives created during the process.\n *\n * @param {Function} linker\n * @param {Vue} vm\n */\n\nfunction linkAndCapture(linker, vm) {\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV === 'production') {\n    // reset directives before every capture in production\n    // mode, so that when unlinking we don't need to splice\n    // them out (which turns out to be a perf hit).\n    // they are kept in development mode because they are\n    // useful for Vue's own tests.\n    vm._directives = [];\n  }\n  var originalDirCount = vm._directives.length;\n  linker();\n  var dirs = vm._directives.slice(originalDirCount);\n  dirs.sort(directiveComparator);\n  for (var i = 0, l = dirs.length; i < l; i++) {\n    dirs[i]._bind();\n  }\n  return dirs;\n}\n\n/**\n * Directive priority sort comparator\n *\n * @param {Object} a\n * @param {Object} b\n */\n\nfunction directiveComparator(a, b) {\n  a = a.descriptor.def.priority || DEFAULT_PRIORITY;\n  b = b.descriptor.def.priority || DEFAULT_PRIORITY;\n  return a > b ? -1 : a === b ? 0 : 1;\n}\n\n/**\n * Linker functions return an unlink function that\n * tearsdown all directives instances generated during\n * the process.\n *\n * We create unlink functions with only the necessary\n * information to avoid retaining additional closures.\n *\n * @param {Vue} vm\n * @param {Array} dirs\n * @param {Vue} [context]\n * @param {Array} [contextDirs]\n * @return {Function}\n */\n\nfunction makeUnlinkFn(vm, dirs, context, contextDirs) {\n  function unlink(destroying) {\n    teardownDirs(vm, dirs, destroying);\n    if (context && contextDirs) {\n      teardownDirs(context, contextDirs);\n    }\n  }\n  // expose linked directives\n  unlink.dirs = dirs;\n  return unlink;\n}\n\n/**\n * Teardown partial linked directives.\n *\n * @param {Vue} vm\n * @param {Array} dirs\n * @param {Boolean} destroying\n */\n\nfunction teardownDirs(vm, dirs, destroying) {\n  var i = dirs.length;\n  while (i--) {\n    dirs[i]._teardown();\n    if (process.env.NODE_ENV !== 'production' && !destroying) {\n      vm._directives.$remove(dirs[i]);\n    }\n  }\n}\n\n/**\n * Compile link props on an instance.\n *\n * @param {Vue} vm\n * @param {Element} el\n * @param {Object} props\n * @param {Object} [scope]\n * @return {Function}\n */\n\nfunction compileAndLinkProps(vm, el, props, scope) {\n  var propsLinkFn = compileProps(el, props, vm);\n  var propDirs = linkAndCapture(function () {\n    propsLinkFn(vm, scope);\n  }, vm);\n  return makeUnlinkFn(vm, propDirs);\n}\n\n/**\n * Compile the root element of an instance.\n *\n * 1. attrs on context container (context scope)\n * 2. attrs on the component template root node, if\n *    replace:true (child scope)\n *\n * If this is a fragment instance, we only need to compile 1.\n *\n * @param {Element} el\n * @param {Object} options\n * @param {Object} contextOptions\n * @return {Function}\n */\n\nfunction compileRoot(el, options, contextOptions) {\n  var containerAttrs = options._containerAttrs;\n  var replacerAttrs = options._replacerAttrs;\n  var contextLinkFn, replacerLinkFn;\n\n  // only need to compile other attributes for\n  // non-fragment instances\n  if (el.nodeType !== 11) {\n    // for components, container and replacer need to be\n    // compiled separately and linked in different scopes.\n    if (options._asComponent) {\n      // 2. container attributes\n      if (containerAttrs && contextOptions) {\n        contextLinkFn = compileDirectives(containerAttrs, contextOptions);\n      }\n      if (replacerAttrs) {\n        // 3. replacer attributes\n        replacerLinkFn = compileDirectives(replacerAttrs, options);\n      }\n    } else {\n      // non-component, just compile as a normal element.\n      replacerLinkFn = compileDirectives(el.attributes, options);\n    }\n  } else if (process.env.NODE_ENV !== 'production' && containerAttrs) {\n    // warn container directives for fragment instances\n    var names = containerAttrs.filter(function (attr) {\n      // allow vue-loader/vueify scoped css attributes\n      return attr.name.indexOf('_v-') < 0 &&\n      // allow event listeners\n      !onRE.test(attr.name) &&\n      // allow slots\n      attr.name !== 'slot';\n    }).map(function (attr) {\n      return '\"' + attr.name + '\"';\n    });\n    if (names.length) {\n      var plural = names.length > 1;\n      warn('Attribute' + (plural ? 's ' : ' ') + names.join(', ') + (plural ? ' are' : ' is') + ' ignored on component ' + '<' + options.el.tagName.toLowerCase() + '> because ' + 'the component is a fragment instance: ' + 'http://vuejs.org/guide/components.html#Fragment_Instance');\n    }\n  }\n\n  options._containerAttrs = options._replacerAttrs = null;\n  return function rootLinkFn(vm, el, scope) {\n    // link context scope dirs\n    var context = vm._context;\n    var contextDirs;\n    if (context && contextLinkFn) {\n      contextDirs = linkAndCapture(function () {\n        contextLinkFn(context, el, null, scope);\n      }, context);\n    }\n\n    // link self\n    var selfDirs = linkAndCapture(function () {\n      if (replacerLinkFn) replacerLinkFn(vm, el);\n    }, vm);\n\n    // return the unlink function that tearsdown context\n    // container directives.\n    return makeUnlinkFn(vm, selfDirs, context, contextDirs);\n  };\n}\n\n/**\n * Compile a node and return a nodeLinkFn based on the\n * node type.\n *\n * @param {Node} node\n * @param {Object} options\n * @return {Function|null}\n */\n\nfunction compileNode(node, options) {\n  var type = node.nodeType;\n  if (type === 1 && node.tagName !== 'SCRIPT') {\n    return compileElement(node, options);\n  } else if (type === 3 && node.data.trim()) {\n    return compileTextNode(node, options);\n  } else {\n    return null;\n  }\n}\n\n/**\n * Compile an element and return a nodeLinkFn.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Function|null}\n */\n\nfunction compileElement(el, options) {\n  // preprocess textareas.\n  // textarea treats its text content as the initial value.\n  // just bind it as an attr directive for value.\n  if (el.tagName === 'TEXTAREA') {\n    var tokens = parseText(el.value);\n    if (tokens) {\n      el.setAttribute(':value', tokensToExp(tokens));\n      el.value = '';\n    }\n  }\n  var linkFn;\n  var hasAttrs = el.hasAttributes();\n  var attrs = hasAttrs && toArray(el.attributes);\n  // check terminal directives (for & if)\n  if (hasAttrs) {\n    linkFn = checkTerminalDirectives(el, attrs, options);\n  }\n  // check element directives\n  if (!linkFn) {\n    linkFn = checkElementDirectives(el, options);\n  }\n  // check component\n  if (!linkFn) {\n    linkFn = checkComponent(el, options);\n  }\n  // normal directives\n  if (!linkFn && hasAttrs) {\n    linkFn = compileDirectives(attrs, options);\n  }\n  return linkFn;\n}\n\n/**\n * Compile a textNode and return a nodeLinkFn.\n *\n * @param {TextNode} node\n * @param {Object} options\n * @return {Function|null} textNodeLinkFn\n */\n\nfunction compileTextNode(node, options) {\n  // skip marked text nodes\n  if (node._skip) {\n    return removeText;\n  }\n\n  var tokens = parseText(node.wholeText);\n  if (!tokens) {\n    return null;\n  }\n\n  // mark adjacent text nodes as skipped,\n  // because we are using node.wholeText to compile\n  // all adjacent text nodes together. This fixes\n  // issues in IE where sometimes it splits up a single\n  // text node into multiple ones.\n  var next = node.nextSibling;\n  while (next && next.nodeType === 3) {\n    next._skip = true;\n    next = next.nextSibling;\n  }\n\n  var frag = document.createDocumentFragment();\n  var el, token;\n  for (var i = 0, l = tokens.length; i < l; i++) {\n    token = tokens[i];\n    el = token.tag ? processTextToken(token, options) : document.createTextNode(token.value);\n    frag.appendChild(el);\n  }\n  return makeTextNodeLinkFn(tokens, frag, options);\n}\n\n/**\n * Linker for an skipped text node.\n *\n * @param {Vue} vm\n * @param {Text} node\n */\n\nfunction removeText(vm, node) {\n  remove(node);\n}\n\n/**\n * Process a single text token.\n *\n * @param {Object} token\n * @param {Object} options\n * @return {Node}\n */\n\nfunction processTextToken(token, options) {\n  var el;\n  if (token.oneTime) {\n    el = document.createTextNode(token.value);\n  } else {\n    if (token.html) {\n      el = document.createComment('v-html');\n      setTokenType('html');\n    } else {\n      // IE will clean up empty textNodes during\n      // frag.cloneNode(true), so we have to give it\n      // something here...\n      el = document.createTextNode(' ');\n      setTokenType('text');\n    }\n  }\n  function setTokenType(type) {\n    if (token.descriptor) return;\n    var parsed = parseDirective(token.value);\n    token.descriptor = {\n      name: type,\n      def: directives[type],\n      expression: parsed.expression,\n      filters: parsed.filters\n    };\n  }\n  return el;\n}\n\n/**\n * Build a function that processes a textNode.\n *\n * @param {Array<Object>} tokens\n * @param {DocumentFragment} frag\n */\n\nfunction makeTextNodeLinkFn(tokens, frag) {\n  return function textNodeLinkFn(vm, el, host, scope) {\n    var fragClone = frag.cloneNode(true);\n    var childNodes = toArray(fragClone.childNodes);\n    var token, value, node;\n    for (var i = 0, l = tokens.length; i < l; i++) {\n      token = tokens[i];\n      value = token.value;\n      if (token.tag) {\n        node = childNodes[i];\n        if (token.oneTime) {\n          value = (scope || vm).$eval(value);\n          if (token.html) {\n            replace(node, parseTemplate(value, true));\n          } else {\n            node.data = value;\n          }\n        } else {\n          vm._bindDir(token.descriptor, node, host, scope);\n        }\n      }\n    }\n    replace(el, fragClone);\n  };\n}\n\n/**\n * Compile a node list and return a childLinkFn.\n *\n * @param {NodeList} nodeList\n * @param {Object} options\n * @return {Function|undefined}\n */\n\nfunction compileNodeList(nodeList, options) {\n  var linkFns = [];\n  var nodeLinkFn, childLinkFn, node;\n  for (var i = 0, l = nodeList.length; i < l; i++) {\n    node = nodeList[i];\n    nodeLinkFn = compileNode(node, options);\n    childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && node.tagName !== 'SCRIPT' && node.hasChildNodes() ? compileNodeList(node.childNodes, options) : null;\n    linkFns.push(nodeLinkFn, childLinkFn);\n  }\n  return linkFns.length ? makeChildLinkFn(linkFns) : null;\n}\n\n/**\n * Make a child link function for a node's childNodes.\n *\n * @param {Array<Function>} linkFns\n * @return {Function} childLinkFn\n */\n\nfunction makeChildLinkFn(linkFns) {\n  return function childLinkFn(vm, nodes, host, scope, frag) {\n    var node, nodeLinkFn, childrenLinkFn;\n    for (var i = 0, n = 0, l = linkFns.length; i < l; n++) {\n      node = nodes[n];\n      nodeLinkFn = linkFns[i++];\n      childrenLinkFn = linkFns[i++];\n      // cache childNodes before linking parent, fix #657\n      var childNodes = toArray(node.childNodes);\n      if (nodeLinkFn) {\n        nodeLinkFn(vm, node, host, scope, frag);\n      }\n      if (childrenLinkFn) {\n        childrenLinkFn(vm, childNodes, host, scope, frag);\n      }\n    }\n  };\n}\n\n/**\n * Check for element directives (custom elements that should\n * be resovled as terminal directives).\n *\n * @param {Element} el\n * @param {Object} options\n */\n\nfunction checkElementDirectives(el, options) {\n  var tag = el.tagName.toLowerCase();\n  if (commonTagRE.test(tag)) {\n    return;\n  }\n  var def = resolveAsset(options, 'elementDirectives', tag);\n  if (def) {\n    return makeTerminalNodeLinkFn(el, tag, '', options, def);\n  }\n}\n\n/**\n * Check if an element is a component. If yes, return\n * a component link function.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Function|undefined}\n */\n\nfunction checkComponent(el, options) {\n  var component = checkComponentAttr(el, options);\n  if (component) {\n    var ref = findRef(el);\n    var descriptor = {\n      name: 'component',\n      ref: ref,\n      expression: component.id,\n      def: internalDirectives.component,\n      modifiers: {\n        literal: !component.dynamic\n      }\n    };\n    var componentLinkFn = function componentLinkFn(vm, el, host, scope, frag) {\n      if (ref) {\n        defineReactive((scope || vm).$refs, ref, null);\n      }\n      vm._bindDir(descriptor, el, host, scope, frag);\n    };\n    componentLinkFn.terminal = true;\n    return componentLinkFn;\n  }\n}\n\n/**\n * Check an element for terminal directives in fixed order.\n * If it finds one, return a terminal link function.\n *\n * @param {Element} el\n * @param {Array} attrs\n * @param {Object} options\n * @return {Function} terminalLinkFn\n */\n\nfunction checkTerminalDirectives(el, attrs, options) {\n  // skip v-pre\n  if (getAttr(el, 'v-pre') !== null) {\n    return skip;\n  }\n  // skip v-else block, but only if following v-if\n  if (el.hasAttribute('v-else')) {\n    var prev = el.previousElementSibling;\n    if (prev && prev.hasAttribute('v-if')) {\n      return skip;\n    }\n  }\n\n  var attr, name, value, modifiers, matched, dirName, rawName, arg, def, termDef;\n  for (var i = 0, j = attrs.length; i < j; i++) {\n    attr = attrs[i];\n    modifiers = parseModifiers(attr.name);\n    name = attr.name.replace(modifierRE, '');\n    if (matched = name.match(dirAttrRE)) {\n      def = resolveAsset(options, 'directives', matched[1]);\n      if (def && def.terminal) {\n        if (!termDef || (def.priority || DEFAULT_TERMINAL_PRIORITY) > termDef.priority) {\n          termDef = def;\n          rawName = attr.name;\n          value = attr.value;\n          dirName = matched[1];\n          arg = matched[2];\n        }\n      }\n    }\n  }\n\n  if (termDef) {\n    return makeTerminalNodeLinkFn(el, dirName, value, options, termDef, rawName, arg, modifiers);\n  }\n}\n\nfunction skip() {}\nskip.terminal = true;\n\n/**\n * Build a node link function for a terminal directive.\n * A terminal link function terminates the current\n * compilation recursion and handles compilation of the\n * subtree in the directive.\n *\n * @param {Element} el\n * @param {String} dirName\n * @param {String} value\n * @param {Object} options\n * @param {Object} def\n * @param {String} [rawName]\n * @param {String} [arg]\n * @param {Object} [modifiers]\n * @return {Function} terminalLinkFn\n */\n\nfunction makeTerminalNodeLinkFn(el, dirName, value, options, def, rawName, arg, modifiers) {\n  var parsed = parseDirective(value);\n  var descriptor = {\n    name: dirName,\n    arg: arg,\n    expression: parsed.expression,\n    filters: parsed.filters,\n    raw: value,\n    attr: rawName,\n    modifiers: modifiers,\n    def: def\n  };\n  // check ref for v-for and router-view\n  if (dirName === 'for' || dirName === 'router-view') {\n    descriptor.ref = findRef(el);\n  }\n  var fn = function terminalNodeLinkFn(vm, el, host, scope, frag) {\n    if (descriptor.ref) {\n      defineReactive((scope || vm).$refs, descriptor.ref, null);\n    }\n    vm._bindDir(descriptor, el, host, scope, frag);\n  };\n  fn.terminal = true;\n  return fn;\n}\n\n/**\n * Compile the directives on an element and return a linker.\n *\n * @param {Array|NamedNodeMap} attrs\n * @param {Object} options\n * @return {Function}\n */\n\nfunction compileDirectives(attrs, options) {\n  var i = attrs.length;\n  var dirs = [];\n  var attr, name, value, rawName, rawValue, dirName, arg, modifiers, dirDef, tokens, matched;\n  while (i--) {\n    attr = attrs[i];\n    name = rawName = attr.name;\n    value = rawValue = attr.value;\n    tokens = parseText(value);\n    // reset arg\n    arg = null;\n    // check modifiers\n    modifiers = parseModifiers(name);\n    name = name.replace(modifierRE, '');\n\n    // attribute interpolations\n    if (tokens) {\n      value = tokensToExp(tokens);\n      arg = name;\n      pushDir('bind', directives.bind, tokens);\n      // warn against mixing mustaches with v-bind\n      if (process.env.NODE_ENV !== 'production') {\n        if (name === 'class' && Array.prototype.some.call(attrs, function (attr) {\n          return attr.name === ':class' || attr.name === 'v-bind:class';\n        })) {\n          warn('class=\"' + rawValue + '\": Do not mix mustache interpolation ' + 'and v-bind for \"class\" on the same element. Use one or the other.', options);\n        }\n      }\n    } else\n\n      // special attribute: transition\n      if (transitionRE.test(name)) {\n        modifiers.literal = !bindRE.test(name);\n        pushDir('transition', internalDirectives.transition);\n      } else\n\n        // event handlers\n        if (onRE.test(name)) {\n          arg = name.replace(onRE, '');\n          pushDir('on', directives.on);\n        } else\n\n          // attribute bindings\n          if (bindRE.test(name)) {\n            dirName = name.replace(bindRE, '');\n            if (dirName === 'style' || dirName === 'class') {\n              pushDir(dirName, internalDirectives[dirName]);\n            } else {\n              arg = dirName;\n              pushDir('bind', directives.bind);\n            }\n          } else\n\n            // normal directives\n            if (matched = name.match(dirAttrRE)) {\n              dirName = matched[1];\n              arg = matched[2];\n\n              // skip v-else (when used with v-show)\n              if (dirName === 'else') {\n                continue;\n              }\n\n              dirDef = resolveAsset(options, 'directives', dirName, true);\n              if (dirDef) {\n                pushDir(dirName, dirDef);\n              }\n            }\n  }\n\n  /**\n   * Push a directive.\n   *\n   * @param {String} dirName\n   * @param {Object|Function} def\n   * @param {Array} [interpTokens]\n   */\n\n  function pushDir(dirName, def, interpTokens) {\n    var hasOneTimeToken = interpTokens && hasOneTime(interpTokens);\n    var parsed = !hasOneTimeToken && parseDirective(value);\n    dirs.push({\n      name: dirName,\n      attr: rawName,\n      raw: rawValue,\n      def: def,\n      arg: arg,\n      modifiers: modifiers,\n      // conversion from interpolation strings with one-time token\n      // to expression is differed until directive bind time so that we\n      // have access to the actual vm context for one-time bindings.\n      expression: parsed && parsed.expression,\n      filters: parsed && parsed.filters,\n      interp: interpTokens,\n      hasOneTime: hasOneTimeToken\n    });\n  }\n\n  if (dirs.length) {\n    return makeNodeLinkFn(dirs);\n  }\n}\n\n/**\n * Parse modifiers from directive attribute name.\n *\n * @param {String} name\n * @return {Object}\n */\n\nfunction parseModifiers(name) {\n  var res = Object.create(null);\n  var match = name.match(modifierRE);\n  if (match) {\n    var i = match.length;\n    while (i--) {\n      res[match[i].slice(1)] = true;\n    }\n  }\n  return res;\n}\n\n/**\n * Build a link function for all directives on a single node.\n *\n * @param {Array} directives\n * @return {Function} directivesLinkFn\n */\n\nfunction makeNodeLinkFn(directives) {\n  return function nodeLinkFn(vm, el, host, scope, frag) {\n    // reverse apply because it's sorted low to high\n    var i = directives.length;\n    while (i--) {\n      vm._bindDir(directives[i], el, host, scope, frag);\n    }\n  };\n}\n\n/**\n * Check if an interpolation string contains one-time tokens.\n *\n * @param {Array} tokens\n * @return {Boolean}\n */\n\nfunction hasOneTime(tokens) {\n  var i = tokens.length;\n  while (i--) {\n    if (tokens[i].oneTime) return true;\n  }\n}\n\nvar specialCharRE = /[^\\w\\-:\\.]/;\n\n/**\n * Process an element or a DocumentFragment based on a\n * instance option object. This allows us to transclude\n * a template node/fragment before the instance is created,\n * so the processed fragment can then be cloned and reused\n * in v-for.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Element|DocumentFragment}\n */\n\nfunction transclude(el, options) {\n  // extract container attributes to pass them down\n  // to compiler, because they need to be compiled in\n  // parent scope. we are mutating the options object here\n  // assuming the same object will be used for compile\n  // right after this.\n  if (options) {\n    options._containerAttrs = extractAttrs(el);\n  }\n  // for template tags, what we want is its content as\n  // a documentFragment (for fragment instances)\n  if (isTemplate(el)) {\n    el = parseTemplate(el);\n  }\n  if (options) {\n    if (options._asComponent && !options.template) {\n      options.template = '<slot></slot>';\n    }\n    if (options.template) {\n      options._content = extractContent(el);\n      el = transcludeTemplate(el, options);\n    }\n  }\n  if (isFragment(el)) {\n    // anchors for fragment instance\n    // passing in `persist: true` to avoid them being\n    // discarded by IE during template cloning\n    prepend(createAnchor('v-start', true), el);\n    el.appendChild(createAnchor('v-end', true));\n  }\n  return el;\n}\n\n/**\n * Process the template option.\n * If the replace option is true this will swap the $el.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Element|DocumentFragment}\n */\n\nfunction transcludeTemplate(el, options) {\n  var template = options.template;\n  var frag = parseTemplate(template, true);\n  if (frag) {\n    var replacer = frag.firstChild;\n    var tag = replacer.tagName && replacer.tagName.toLowerCase();\n    if (options.replace) {\n      /* istanbul ignore if */\n      if (el === document.body) {\n        process.env.NODE_ENV !== 'production' && warn('You are mounting an instance with a template to ' + '<body>. This will replace <body> entirely. You ' + 'should probably use `replace: false` here.');\n      }\n      // there are many cases where the instance must\n      // become a fragment instance: basically anything that\n      // can create more than 1 root nodes.\n      if (\n      // multi-children template\n      frag.childNodes.length > 1 ||\n      // non-element template\n      replacer.nodeType !== 1 ||\n      // single nested component\n      tag === 'component' || resolveAsset(options, 'components', tag) || hasBindAttr(replacer, 'is') ||\n      // element directive\n      resolveAsset(options, 'elementDirectives', tag) ||\n      // for block\n      replacer.hasAttribute('v-for') ||\n      // if block\n      replacer.hasAttribute('v-if')) {\n        return frag;\n      } else {\n        options._replacerAttrs = extractAttrs(replacer);\n        mergeAttrs(el, replacer);\n        return replacer;\n      }\n    } else {\n      el.appendChild(frag);\n      return el;\n    }\n  } else {\n    process.env.NODE_ENV !== 'production' && warn('Invalid template option: ' + template);\n  }\n}\n\n/**\n * Helper to extract a component container's attributes\n * into a plain object array.\n *\n * @param {Element} el\n * @return {Array}\n */\n\nfunction extractAttrs(el) {\n  if (el.nodeType === 1 && el.hasAttributes()) {\n    return toArray(el.attributes);\n  }\n}\n\n/**\n * Merge the attributes of two elements, and make sure\n * the class names are merged properly.\n *\n * @param {Element} from\n * @param {Element} to\n */\n\nfunction mergeAttrs(from, to) {\n  var attrs = from.attributes;\n  var i = attrs.length;\n  var name, value;\n  while (i--) {\n    name = attrs[i].name;\n    value = attrs[i].value;\n    if (!to.hasAttribute(name) && !specialCharRE.test(name)) {\n      to.setAttribute(name, value);\n    } else if (name === 'class' && !parseText(value)) {\n      value.trim().split(/\\s+/).forEach(function (cls) {\n        addClass(to, cls);\n      });\n    }\n  }\n}\n\n/**\n * Scan and determine slot content distribution.\n * We do this during transclusion instead at compile time so that\n * the distribution is decoupled from the compilation order of\n * the slots.\n *\n * @param {Element|DocumentFragment} template\n * @param {Element} content\n * @param {Vue} vm\n */\n\nfunction resolveSlots(vm, content) {\n  if (!content) {\n    return;\n  }\n  var contents = vm._slotContents = Object.create(null);\n  var el, name;\n  for (var i = 0, l = content.children.length; i < l; i++) {\n    el = content.children[i];\n    /* eslint-disable no-cond-assign */\n    if (name = el.getAttribute('slot')) {\n      (contents[name] || (contents[name] = [])).push(el);\n    }\n    /* eslint-enable no-cond-assign */\n    if (process.env.NODE_ENV !== 'production' && getBindAttr(el, 'slot')) {\n      warn('The \"slot\" attribute must be static.', vm.$parent);\n    }\n  }\n  for (name in contents) {\n    contents[name] = extractFragment(contents[name], content);\n  }\n  if (content.hasChildNodes()) {\n    contents['default'] = extractFragment(content.childNodes, content);\n  }\n}\n\n/**\n * Extract qualified content nodes from a node list.\n *\n * @param {NodeList} nodes\n * @return {DocumentFragment}\n */\n\nfunction extractFragment(nodes, parent) {\n  var frag = document.createDocumentFragment();\n  nodes = toArray(nodes);\n  for (var i = 0, l = nodes.length; i < l; i++) {\n    var node = nodes[i];\n    if (isTemplate(node) && !node.hasAttribute('v-if') && !node.hasAttribute('v-for')) {\n      parent.removeChild(node);\n      node = parseTemplate(node);\n    }\n    frag.appendChild(node);\n  }\n  return frag;\n}\n\n\n\nvar compiler = Object.freeze({\n\tcompile: compile,\n\tcompileAndLinkProps: compileAndLinkProps,\n\tcompileRoot: compileRoot,\n\ttransclude: transclude,\n\tresolveSlots: resolveSlots\n});\n\nfunction stateMixin (Vue) {\n  /**\n   * Accessor for `$data` property, since setting $data\n   * requires observing the new object and updating\n   * proxied properties.\n   */\n\n  Object.defineProperty(Vue.prototype, '$data', {\n    get: function get() {\n      return this._data;\n    },\n    set: function set(newData) {\n      if (newData !== this._data) {\n        this._setData(newData);\n      }\n    }\n  });\n\n  /**\n   * Setup the scope of an instance, which contains:\n   * - observed data\n   * - computed properties\n   * - user methods\n   * - meta properties\n   */\n\n  Vue.prototype._initState = function () {\n    this._initProps();\n    this._initMeta();\n    this._initMethods();\n    this._initData();\n    this._initComputed();\n  };\n\n  /**\n   * Initialize props.\n   */\n\n  Vue.prototype._initProps = function () {\n    var options = this.$options;\n    var el = options.el;\n    var props = options.props;\n    if (props && !el) {\n      process.env.NODE_ENV !== 'production' && warn('Props will not be compiled if no `el` option is ' + 'provided at instantiation.', this);\n    }\n    // make sure to convert string selectors into element now\n    el = options.el = query(el);\n    this._propsUnlinkFn = el && el.nodeType === 1 && props\n    // props must be linked in proper scope if inside v-for\n    ? compileAndLinkProps(this, el, props, this._scope) : null;\n  };\n\n  /**\n   * Initialize the data.\n   */\n\n  Vue.prototype._initData = function () {\n    var dataFn = this.$options.data;\n    var data = this._data = dataFn ? dataFn() : {};\n    if (!isPlainObject(data)) {\n      data = {};\n      process.env.NODE_ENV !== 'production' && warn('data functions should return an object.', this);\n    }\n    var props = this._props;\n    var runtimeData = this._runtimeData ? typeof this._runtimeData === 'function' ? this._runtimeData() : this._runtimeData : null;\n    // proxy data on instance\n    var keys = Object.keys(data);\n    var i, key;\n    i = keys.length;\n    while (i--) {\n      key = keys[i];\n      // there are two scenarios where we can proxy a data key:\n      // 1. it's not already defined as a prop\n      // 2. it's provided via a instantiation option AND there are no\n      //    template prop present\n      if (!props || !hasOwn(props, key) || runtimeData && hasOwn(runtimeData, key) && props[key].raw === null) {\n        this._proxy(key);\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn('Data field \"' + key + '\" is already defined ' + 'as a prop. Use prop default value instead.', this);\n      }\n    }\n    // observe data\n    observe(data, this);\n  };\n\n  /**\n   * Swap the instance's $data. Called in $data's setter.\n   *\n   * @param {Object} newData\n   */\n\n  Vue.prototype._setData = function (newData) {\n    newData = newData || {};\n    var oldData = this._data;\n    this._data = newData;\n    var keys, key, i;\n    // unproxy keys not present in new data\n    keys = Object.keys(oldData);\n    i = keys.length;\n    while (i--) {\n      key = keys[i];\n      if (!(key in newData)) {\n        this._unproxy(key);\n      }\n    }\n    // proxy keys not already proxied,\n    // and trigger change for changed values\n    keys = Object.keys(newData);\n    i = keys.length;\n    while (i--) {\n      key = keys[i];\n      if (!hasOwn(this, key)) {\n        // new property\n        this._proxy(key);\n      }\n    }\n    oldData.__ob__.removeVm(this);\n    observe(newData, this);\n    this._digest();\n  };\n\n  /**\n   * Proxy a property, so that\n   * vm.prop === vm._data.prop\n   *\n   * @param {String} key\n   */\n\n  Vue.prototype._proxy = function (key) {\n    if (!isReserved(key)) {\n      // need to store ref to self here\n      // because these getter/setters might\n      // be called by child scopes via\n      // prototype inheritance.\n      var self = this;\n      Object.defineProperty(self, key, {\n        configurable: true,\n        enumerable: true,\n        get: function proxyGetter() {\n          return self._data[key];\n        },\n        set: function proxySetter(val) {\n          self._data[key] = val;\n        }\n      });\n    }\n  };\n\n  /**\n   * Unproxy a property.\n   *\n   * @param {String} key\n   */\n\n  Vue.prototype._unproxy = function (key) {\n    if (!isReserved(key)) {\n      delete this[key];\n    }\n  };\n\n  /**\n   * Force update on every watcher in scope.\n   */\n\n  Vue.prototype._digest = function () {\n    for (var i = 0, l = this._watchers.length; i < l; i++) {\n      this._watchers[i].update(true); // shallow updates\n    }\n  };\n\n  /**\n   * Setup computed properties. They are essentially\n   * special getter/setters\n   */\n\n  function noop() {}\n  Vue.prototype._initComputed = function () {\n    var computed = this.$options.computed;\n    if (computed) {\n      for (var key in computed) {\n        var userDef = computed[key];\n        var def = {\n          enumerable: true,\n          configurable: true\n        };\n        if (typeof userDef === 'function') {\n          def.get = makeComputedGetter(userDef, this);\n          def.set = noop;\n        } else {\n          def.get = userDef.get ? userDef.cache !== false ? makeComputedGetter(userDef.get, this) : bind(userDef.get, this) : noop;\n          def.set = userDef.set ? bind(userDef.set, this) : noop;\n        }\n        Object.defineProperty(this, key, def);\n      }\n    }\n  };\n\n  function makeComputedGetter(getter, owner) {\n    var watcher = new Watcher(owner, getter, null, {\n      lazy: true\n    });\n    return function computedGetter() {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value;\n    };\n  }\n\n  /**\n   * Setup instance methods. Methods must be bound to the\n   * instance since they might be passed down as a prop to\n   * child components.\n   */\n\n  Vue.prototype._initMethods = function () {\n    var methods = this.$options.methods;\n    if (methods) {\n      for (var key in methods) {\n        this[key] = bind(methods[key], this);\n      }\n    }\n  };\n\n  /**\n   * Initialize meta information like $index, $key & $value.\n   */\n\n  Vue.prototype._initMeta = function () {\n    var metas = this.$options._meta;\n    if (metas) {\n      for (var key in metas) {\n        defineReactive(this, key, metas[key]);\n      }\n    }\n  };\n}\n\nvar eventRE = /^v-on:|^@/;\n\nfunction eventsMixin (Vue) {\n  /**\n   * Setup the instance's option events & watchers.\n   * If the value is a string, we pull it from the\n   * instance's methods by name.\n   */\n\n  Vue.prototype._initEvents = function () {\n    var options = this.$options;\n    if (options._asComponent) {\n      registerComponentEvents(this, options.el);\n    }\n    registerCallbacks(this, '$on', options.events);\n    registerCallbacks(this, '$watch', options.watch);\n  };\n\n  /**\n   * Register v-on events on a child component\n   *\n   * @param {Vue} vm\n   * @param {Element} el\n   */\n\n  function registerComponentEvents(vm, el) {\n    var attrs = el.attributes;\n    var name, handler;\n    for (var i = 0, l = attrs.length; i < l; i++) {\n      name = attrs[i].name;\n      if (eventRE.test(name)) {\n        name = name.replace(eventRE, '');\n        handler = (vm._scope || vm._context).$eval(attrs[i].value, true);\n        if (typeof handler === 'function') {\n          handler._fromParent = true;\n          vm.$on(name.replace(eventRE), handler);\n        } else if (process.env.NODE_ENV !== 'production') {\n          warn('v-on:' + name + '=\"' + attrs[i].value + '\" ' + 'expects a function value, got ' + handler, vm);\n        }\n      }\n    }\n  }\n\n  /**\n   * Register callbacks for option events and watchers.\n   *\n   * @param {Vue} vm\n   * @param {String} action\n   * @param {Object} hash\n   */\n\n  function registerCallbacks(vm, action, hash) {\n    if (!hash) return;\n    var handlers, key, i, j;\n    for (key in hash) {\n      handlers = hash[key];\n      if (isArray(handlers)) {\n        for (i = 0, j = handlers.length; i < j; i++) {\n          register(vm, action, key, handlers[i]);\n        }\n      } else {\n        register(vm, action, key, handlers);\n      }\n    }\n  }\n\n  /**\n   * Helper to register an event/watch callback.\n   *\n   * @param {Vue} vm\n   * @param {String} action\n   * @param {String} key\n   * @param {Function|String|Object} handler\n   * @param {Object} [options]\n   */\n\n  function register(vm, action, key, handler, options) {\n    var type = typeof handler;\n    if (type === 'function') {\n      vm[action](key, handler, options);\n    } else if (type === 'string') {\n      var methods = vm.$options.methods;\n      var method = methods && methods[handler];\n      if (method) {\n        vm[action](key, method, options);\n      } else {\n        process.env.NODE_ENV !== 'production' && warn('Unknown method: \"' + handler + '\" when ' + 'registering callback for ' + action + ': \"' + key + '\".', vm);\n      }\n    } else if (handler && type === 'object') {\n      register(vm, action, key, handler.handler, handler);\n    }\n  }\n\n  /**\n   * Setup recursive attached/detached calls\n   */\n\n  Vue.prototype._initDOMHooks = function () {\n    this.$on('hook:attached', onAttached);\n    this.$on('hook:detached', onDetached);\n  };\n\n  /**\n   * Callback to recursively call attached hook on children\n   */\n\n  function onAttached() {\n    if (!this._isAttached) {\n      this._isAttached = true;\n      this.$children.forEach(callAttach);\n    }\n  }\n\n  /**\n   * Iterator to call attached hook\n   *\n   * @param {Vue} child\n   */\n\n  function callAttach(child) {\n    if (!child._isAttached && inDoc(child.$el)) {\n      child._callHook('attached');\n    }\n  }\n\n  /**\n   * Callback to recursively call detached hook on children\n   */\n\n  function onDetached() {\n    if (this._isAttached) {\n      this._isAttached = false;\n      this.$children.forEach(callDetach);\n    }\n  }\n\n  /**\n   * Iterator to call detached hook\n   *\n   * @param {Vue} child\n   */\n\n  function callDetach(child) {\n    if (child._isAttached && !inDoc(child.$el)) {\n      child._callHook('detached');\n    }\n  }\n\n  /**\n   * Trigger all handlers for a hook\n   *\n   * @param {String} hook\n   */\n\n  Vue.prototype._callHook = function (hook) {\n    this.$emit('pre-hook:' + hook);\n    var handlers = this.$options[hook];\n    if (handlers) {\n      for (var i = 0, j = handlers.length; i < j; i++) {\n        handlers[i].call(this);\n      }\n    }\n    this.$emit('hook:' + hook);\n  };\n}\n\nfunction noop() {}\n\n/**\n * A directive links a DOM element with a piece of data,\n * which is the result of evaluating an expression.\n * It registers a watcher with the expression and calls\n * the DOM update function when a change is triggered.\n *\n * @param {Object} descriptor\n *                 - {String} name\n *                 - {Object} def\n *                 - {String} expression\n *                 - {Array<Object>} [filters]\n *                 - {Object} [modifiers]\n *                 - {Boolean} literal\n *                 - {String} attr\n *                 - {String} arg\n *                 - {String} raw\n *                 - {String} [ref]\n *                 - {Array<Object>} [interp]\n *                 - {Boolean} [hasOneTime]\n * @param {Vue} vm\n * @param {Node} el\n * @param {Vue} [host] - transclusion host component\n * @param {Object} [scope] - v-for scope\n * @param {Fragment} [frag] - owner fragment\n * @constructor\n */\nfunction Directive(descriptor, vm, el, host, scope, frag) {\n  this.vm = vm;\n  this.el = el;\n  // copy descriptor properties\n  this.descriptor = descriptor;\n  this.name = descriptor.name;\n  this.expression = descriptor.expression;\n  this.arg = descriptor.arg;\n  this.modifiers = descriptor.modifiers;\n  this.filters = descriptor.filters;\n  this.literal = this.modifiers && this.modifiers.literal;\n  // private\n  this._locked = false;\n  this._bound = false;\n  this._listeners = null;\n  // link context\n  this._host = host;\n  this._scope = scope;\n  this._frag = frag;\n  // store directives on node in dev mode\n  if (process.env.NODE_ENV !== 'production' && this.el) {\n    this.el._vue_directives = this.el._vue_directives || [];\n    this.el._vue_directives.push(this);\n  }\n}\n\n/**\n * Initialize the directive, mixin definition properties,\n * setup the watcher, call definition bind() and update()\n * if present.\n */\n\nDirective.prototype._bind = function () {\n  var name = this.name;\n  var descriptor = this.descriptor;\n\n  // remove attribute\n  if ((name !== 'cloak' || this.vm._isCompiled) && this.el && this.el.removeAttribute) {\n    var attr = descriptor.attr || 'v-' + name;\n    this.el.removeAttribute(attr);\n  }\n\n  // copy def properties\n  var def = descriptor.def;\n  if (typeof def === 'function') {\n    this.update = def;\n  } else {\n    extend(this, def);\n  }\n\n  // setup directive params\n  this._setupParams();\n\n  // initial bind\n  if (this.bind) {\n    this.bind();\n  }\n  this._bound = true;\n\n  if (this.literal) {\n    this.update && this.update(descriptor.raw);\n  } else if ((this.expression || this.modifiers) && (this.update || this.twoWay) && !this._checkStatement()) {\n    // wrapped updater for context\n    var dir = this;\n    if (this.update) {\n      this._update = function (val, oldVal) {\n        if (!dir._locked) {\n          dir.update(val, oldVal);\n        }\n      };\n    } else {\n      this._update = noop;\n    }\n    var preProcess = this._preProcess ? bind(this._preProcess, this) : null;\n    var postProcess = this._postProcess ? bind(this._postProcess, this) : null;\n    var watcher = this._watcher = new Watcher(this.vm, this.expression, this._update, // callback\n    {\n      filters: this.filters,\n      twoWay: this.twoWay,\n      deep: this.deep,\n      preProcess: preProcess,\n      postProcess: postProcess,\n      scope: this._scope\n    });\n    // v-model with inital inline value need to sync back to\n    // model instead of update to DOM on init. They would\n    // set the afterBind hook to indicate that.\n    if (this.afterBind) {\n      this.afterBind();\n    } else if (this.update) {\n      this.update(watcher.value);\n    }\n  }\n};\n\n/**\n * Setup all param attributes, e.g. track-by,\n * transition-mode, etc...\n */\n\nDirective.prototype._setupParams = function () {\n  if (!this.params) {\n    return;\n  }\n  var params = this.params;\n  // swap the params array with a fresh object.\n  this.params = Object.create(null);\n  var i = params.length;\n  var key, val, mappedKey;\n  while (i--) {\n    key = hyphenate(params[i]);\n    mappedKey = camelize(key);\n    val = getBindAttr(this.el, key);\n    if (val != null) {\n      // dynamic\n      this._setupParamWatcher(mappedKey, val);\n    } else {\n      // static\n      val = getAttr(this.el, key);\n      if (val != null) {\n        this.params[mappedKey] = val === '' ? true : val;\n      }\n    }\n  }\n};\n\n/**\n * Setup a watcher for a dynamic param.\n *\n * @param {String} key\n * @param {String} expression\n */\n\nDirective.prototype._setupParamWatcher = function (key, expression) {\n  var self = this;\n  var called = false;\n  var unwatch = (this._scope || this.vm).$watch(expression, function (val, oldVal) {\n    self.params[key] = val;\n    // since we are in immediate mode,\n    // only call the param change callbacks if this is not the first update.\n    if (called) {\n      var cb = self.paramWatchers && self.paramWatchers[key];\n      if (cb) {\n        cb.call(self, val, oldVal);\n      }\n    } else {\n      called = true;\n    }\n  }, {\n    immediate: true,\n    user: false\n  });(this._paramUnwatchFns || (this._paramUnwatchFns = [])).push(unwatch);\n};\n\n/**\n * Check if the directive is a function caller\n * and if the expression is a callable one. If both true,\n * we wrap up the expression and use it as the event\n * handler.\n *\n * e.g. on-click=\"a++\"\n *\n * @return {Boolean}\n */\n\nDirective.prototype._checkStatement = function () {\n  var expression = this.expression;\n  if (expression && this.acceptStatement && !isSimplePath(expression)) {\n    var fn = parseExpression(expression).get;\n    var scope = this._scope || this.vm;\n    var handler = function handler(e) {\n      scope.$event = e;\n      fn.call(scope, scope);\n      scope.$event = null;\n    };\n    if (this.filters) {\n      handler = scope._applyFilters(handler, null, this.filters);\n    }\n    this.update(handler);\n    return true;\n  }\n};\n\n/**\n * Set the corresponding value with the setter.\n * This should only be used in two-way directives\n * e.g. v-model.\n *\n * @param {*} value\n * @public\n */\n\nDirective.prototype.set = function (value) {\n  /* istanbul ignore else */\n  if (this.twoWay) {\n    this._withLock(function () {\n      this._watcher.set(value);\n    });\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn('Directive.set() can only be used inside twoWay' + 'directives.');\n  }\n};\n\n/**\n * Execute a function while preventing that function from\n * triggering updates on this directive instance.\n *\n * @param {Function} fn\n */\n\nDirective.prototype._withLock = function (fn) {\n  var self = this;\n  self._locked = true;\n  fn.call(self);\n  nextTick(function () {\n    self._locked = false;\n  });\n};\n\n/**\n * Convenience method that attaches a DOM event listener\n * to the directive element and autometically tears it down\n * during unbind.\n *\n * @param {String} event\n * @param {Function} handler\n * @param {Boolean} [useCapture]\n */\n\nDirective.prototype.on = function (event, handler, useCapture) {\n  on(this.el, event, handler, useCapture);(this._listeners || (this._listeners = [])).push([event, handler]);\n};\n\n/**\n * Teardown the watcher and call unbind.\n */\n\nDirective.prototype._teardown = function () {\n  if (this._bound) {\n    this._bound = false;\n    if (this.unbind) {\n      this.unbind();\n    }\n    if (this._watcher) {\n      this._watcher.teardown();\n    }\n    var listeners = this._listeners;\n    var i;\n    if (listeners) {\n      i = listeners.length;\n      while (i--) {\n        off(this.el, listeners[i][0], listeners[i][1]);\n      }\n    }\n    var unwatchFns = this._paramUnwatchFns;\n    if (unwatchFns) {\n      i = unwatchFns.length;\n      while (i--) {\n        unwatchFns[i]();\n      }\n    }\n    if (process.env.NODE_ENV !== 'production' && this.el) {\n      this.el._vue_directives.$remove(this);\n    }\n    this.vm = this.el = this._watcher = this._listeners = null;\n  }\n};\n\nfunction lifecycleMixin (Vue) {\n  /**\n   * Update v-ref for component.\n   *\n   * @param {Boolean} remove\n   */\n\n  Vue.prototype._updateRef = function (remove) {\n    var ref = this.$options._ref;\n    if (ref) {\n      var refs = (this._scope || this._context).$refs;\n      if (remove) {\n        if (refs[ref] === this) {\n          refs[ref] = null;\n        }\n      } else {\n        refs[ref] = this;\n      }\n    }\n  };\n\n  /**\n   * Transclude, compile and link element.\n   *\n   * If a pre-compiled linker is available, that means the\n   * passed in element will be pre-transcluded and compiled\n   * as well - all we need to do is to call the linker.\n   *\n   * Otherwise we need to call transclude/compile/link here.\n   *\n   * @param {Element} el\n   */\n\n  Vue.prototype._compile = function (el) {\n    var options = this.$options;\n\n    // transclude and init element\n    // transclude can potentially replace original\n    // so we need to keep reference; this step also injects\n    // the template and caches the original attributes\n    // on the container node and replacer node.\n    var original = el;\n    el = transclude(el, options);\n    this._initElement(el);\n\n    // handle v-pre on root node (#2026)\n    if (el.nodeType === 1 && getAttr(el, 'v-pre') !== null) {\n      return;\n    }\n\n    // root is always compiled per-instance, because\n    // container attrs and props can be different every time.\n    var contextOptions = this._context && this._context.$options;\n    var rootLinker = compileRoot(el, options, contextOptions);\n\n    // resolve slot distribution\n    resolveSlots(this, options._content);\n\n    // compile and link the rest\n    var contentLinkFn;\n    var ctor = this.constructor;\n    // component compilation can be cached\n    // as long as it's not using inline-template\n    if (options._linkerCachable) {\n      contentLinkFn = ctor.linker;\n      if (!contentLinkFn) {\n        contentLinkFn = ctor.linker = compile(el, options);\n      }\n    }\n\n    // link phase\n    // make sure to link root with prop scope!\n    var rootUnlinkFn = rootLinker(this, el, this._scope);\n    var contentUnlinkFn = contentLinkFn ? contentLinkFn(this, el) : compile(el, options)(this, el);\n\n    // register composite unlink function\n    // to be called during instance destruction\n    this._unlinkFn = function () {\n      rootUnlinkFn();\n      // passing destroying: true to avoid searching and\n      // splicing the directives\n      contentUnlinkFn(true);\n    };\n\n    // finally replace original\n    if (options.replace) {\n      replace(original, el);\n    }\n\n    this._isCompiled = true;\n    this._callHook('compiled');\n  };\n\n  /**\n   * Initialize instance element. Called in the public\n   * $mount() method.\n   *\n   * @param {Element} el\n   */\n\n  Vue.prototype._initElement = function (el) {\n    if (isFragment(el)) {\n      this._isFragment = true;\n      this.$el = this._fragmentStart = el.firstChild;\n      this._fragmentEnd = el.lastChild;\n      // set persisted text anchors to empty\n      if (this._fragmentStart.nodeType === 3) {\n        this._fragmentStart.data = this._fragmentEnd.data = '';\n      }\n      this._fragment = el;\n    } else {\n      this.$el = el;\n    }\n    this.$el.__vue__ = this;\n    this._callHook('beforeCompile');\n  };\n\n  /**\n   * Create and bind a directive to an element.\n   *\n   * @param {Object} descriptor - parsed directive descriptor\n   * @param {Node} node   - target node\n   * @param {Vue} [host] - transclusion host component\n   * @param {Object} [scope] - v-for scope\n   * @param {Fragment} [frag] - owner fragment\n   */\n\n  Vue.prototype._bindDir = function (descriptor, node, host, scope, frag) {\n    this._directives.push(new Directive(descriptor, this, node, host, scope, frag));\n  };\n\n  /**\n   * Teardown an instance, unobserves the data, unbind all the\n   * directives, turn off all the event listeners, etc.\n   *\n   * @param {Boolean} remove - whether to remove the DOM node.\n   * @param {Boolean} deferCleanup - if true, defer cleanup to\n   *                                 be called later\n   */\n\n  Vue.prototype._destroy = function (remove, deferCleanup) {\n    if (this._isBeingDestroyed) {\n      if (!deferCleanup) {\n        this._cleanup();\n      }\n      return;\n    }\n\n    var destroyReady;\n    var pendingRemoval;\n\n    var self = this;\n    // Cleanup should be called either synchronously or asynchronoysly as\n    // callback of this.$remove(), or if remove and deferCleanup are false.\n    // In any case it should be called after all other removing, unbinding and\n    // turning of is done\n    var cleanupIfPossible = function cleanupIfPossible() {\n      if (destroyReady && !pendingRemoval && !deferCleanup) {\n        self._cleanup();\n      }\n    };\n\n    // remove DOM element\n    if (remove && this.$el) {\n      pendingRemoval = true;\n      this.$remove(function () {\n        pendingRemoval = false;\n        cleanupIfPossible();\n      });\n    }\n\n    this._callHook('beforeDestroy');\n    this._isBeingDestroyed = true;\n    var i;\n    // remove self from parent. only necessary\n    // if parent is not being destroyed as well.\n    var parent = this.$parent;\n    if (parent && !parent._isBeingDestroyed) {\n      parent.$children.$remove(this);\n      // unregister ref (remove: true)\n      this._updateRef(true);\n    }\n    // destroy all children.\n    i = this.$children.length;\n    while (i--) {\n      this.$children[i].$destroy();\n    }\n    // teardown props\n    if (this._propsUnlinkFn) {\n      this._propsUnlinkFn();\n    }\n    // teardown all directives. this also tearsdown all\n    // directive-owned watchers.\n    if (this._unlinkFn) {\n      this._unlinkFn();\n    }\n    i = this._watchers.length;\n    while (i--) {\n      this._watchers[i].teardown();\n    }\n    // remove reference to self on $el\n    if (this.$el) {\n      this.$el.__vue__ = null;\n    }\n\n    destroyReady = true;\n    cleanupIfPossible();\n  };\n\n  /**\n   * Clean up to ensure garbage collection.\n   * This is called after the leave transition if there\n   * is any.\n   */\n\n  Vue.prototype._cleanup = function () {\n    if (this._isDestroyed) {\n      return;\n    }\n    // remove self from owner fragment\n    // do it in cleanup so that we can call $destroy with\n    // defer right when a fragment is about to be removed.\n    if (this._frag) {\n      this._frag.children.$remove(this);\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (this._data.__ob__) {\n      this._data.__ob__.removeVm(this);\n    }\n    // Clean up references to private properties and other\n    // instances. preserve reference to _data so that proxy\n    // accessors still work. The only potential side effect\n    // here is that mutating the instance after it's destroyed\n    // may affect the state of other components that are still\n    // observing the same object, but that seems to be a\n    // reasonable responsibility for the user rather than\n    // always throwing an error on them.\n    this.$el = this.$parent = this.$root = this.$children = this._watchers = this._context = this._scope = this._directives = null;\n    // call the last hook...\n    this._isDestroyed = true;\n    this._callHook('destroyed');\n    // turn off all instance listeners.\n    this.$off();\n  };\n}\n\nfunction miscMixin (Vue) {\n  /**\n   * Apply a list of filter (descriptors) to a value.\n   * Using plain for loops here because this will be called in\n   * the getter of any watcher with filters so it is very\n   * performance sensitive.\n   *\n   * @param {*} value\n   * @param {*} [oldValue]\n   * @param {Array} filters\n   * @param {Boolean} write\n   * @return {*}\n   */\n\n  Vue.prototype._applyFilters = function (value, oldValue, filters, write) {\n    var filter, fn, args, arg, offset, i, l, j, k;\n    for (i = 0, l = filters.length; i < l; i++) {\n      filter = filters[write ? l - i - 1 : i];\n      fn = resolveAsset(this.$options, 'filters', filter.name, true);\n      if (!fn) continue;\n      fn = write ? fn.write : fn.read || fn;\n      if (typeof fn !== 'function') continue;\n      args = write ? [value, oldValue] : [value];\n      offset = write ? 2 : 1;\n      if (filter.args) {\n        for (j = 0, k = filter.args.length; j < k; j++) {\n          arg = filter.args[j];\n          args[j + offset] = arg.dynamic ? this.$get(arg.value) : arg.value;\n        }\n      }\n      value = fn.apply(this, args);\n    }\n    return value;\n  };\n\n  /**\n   * Resolve a component, depending on whether the component\n   * is defined normally or using an async factory function.\n   * Resolves synchronously if already resolved, otherwise\n   * resolves asynchronously and caches the resolved\n   * constructor on the factory.\n   *\n   * @param {String|Function} value\n   * @param {Function} cb\n   */\n\n  Vue.prototype._resolveComponent = function (value, cb) {\n    var factory;\n    if (typeof value === 'function') {\n      factory = value;\n    } else {\n      factory = resolveAsset(this.$options, 'components', value, true);\n    }\n    if (!factory) {\n      return;\n    }\n    // async component factory\n    if (!factory.options) {\n      if (factory.resolved) {\n        // cached\n        cb(factory.resolved);\n      } else if (factory.requested) {\n        // pool callbacks\n        factory.pendingCallbacks.push(cb);\n      } else {\n        factory.requested = true;\n        var cbs = factory.pendingCallbacks = [cb];\n        factory.call(this, function resolve(res) {\n          if (isPlainObject(res)) {\n            res = Vue.extend(res);\n          }\n          // cache resolved\n          factory.resolved = res;\n          // invoke callbacks\n          for (var i = 0, l = cbs.length; i < l; i++) {\n            cbs[i](res);\n          }\n        }, function reject(reason) {\n          process.env.NODE_ENV !== 'production' && warn('Failed to resolve async component' + (typeof value === 'string' ? ': ' + value : '') + '. ' + (reason ? '\\nReason: ' + reason : ''));\n        });\n      }\n    } else {\n      // normal component\n      cb(factory);\n    }\n  };\n}\n\nvar filterRE$1 = /[^|]\\|[^|]/;\n\nfunction dataAPI (Vue) {\n  /**\n   * Get the value from an expression on this vm.\n   *\n   * @param {String} exp\n   * @param {Boolean} [asStatement]\n   * @return {*}\n   */\n\n  Vue.prototype.$get = function (exp, asStatement) {\n    var res = parseExpression(exp);\n    if (res) {\n      if (asStatement && !isSimplePath(exp)) {\n        var self = this;\n        return function statementHandler() {\n          self.$arguments = toArray(arguments);\n          var result = res.get.call(self, self);\n          self.$arguments = null;\n          return result;\n        };\n      } else {\n        try {\n          return res.get.call(this, this);\n        } catch (e) {}\n      }\n    }\n  };\n\n  /**\n   * Set the value from an expression on this vm.\n   * The expression must be a valid left-hand\n   * expression in an assignment.\n   *\n   * @param {String} exp\n   * @param {*} val\n   */\n\n  Vue.prototype.$set = function (exp, val) {\n    var res = parseExpression(exp, true);\n    if (res && res.set) {\n      res.set.call(this, this, val);\n    }\n  };\n\n  /**\n   * Delete a property on the VM\n   *\n   * @param {String} key\n   */\n\n  Vue.prototype.$delete = function (key) {\n    del(this._data, key);\n  };\n\n  /**\n   * Watch an expression, trigger callback when its\n   * value changes.\n   *\n   * @param {String|Function} expOrFn\n   * @param {Function} cb\n   * @param {Object} [options]\n   *                 - {Boolean} deep\n   *                 - {Boolean} immediate\n   * @return {Function} - unwatchFn\n   */\n\n  Vue.prototype.$watch = function (expOrFn, cb, options) {\n    var vm = this;\n    var parsed;\n    if (typeof expOrFn === 'string') {\n      parsed = parseDirective(expOrFn);\n      expOrFn = parsed.expression;\n    }\n    var watcher = new Watcher(vm, expOrFn, cb, {\n      deep: options && options.deep,\n      sync: options && options.sync,\n      filters: parsed && parsed.filters,\n      user: !options || options.user !== false\n    });\n    if (options && options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn() {\n      watcher.teardown();\n    };\n  };\n\n  /**\n   * Evaluate a text directive, including filters.\n   *\n   * @param {String} text\n   * @param {Boolean} [asStatement]\n   * @return {String}\n   */\n\n  Vue.prototype.$eval = function (text, asStatement) {\n    // check for filters.\n    if (filterRE$1.test(text)) {\n      var dir = parseDirective(text);\n      // the filter regex check might give false positive\n      // for pipes inside strings, so it's possible that\n      // we don't get any filters here\n      var val = this.$get(dir.expression, asStatement);\n      return dir.filters ? this._applyFilters(val, null, dir.filters) : val;\n    } else {\n      // no filter\n      return this.$get(text, asStatement);\n    }\n  };\n\n  /**\n   * Interpolate a piece of template text.\n   *\n   * @param {String} text\n   * @return {String}\n   */\n\n  Vue.prototype.$interpolate = function (text) {\n    var tokens = parseText(text);\n    var vm = this;\n    if (tokens) {\n      if (tokens.length === 1) {\n        return vm.$eval(tokens[0].value) + '';\n      } else {\n        return tokens.map(function (token) {\n          return token.tag ? vm.$eval(token.value) : token.value;\n        }).join('');\n      }\n    } else {\n      return text;\n    }\n  };\n\n  /**\n   * Log instance data as a plain JS object\n   * so that it is easier to inspect in console.\n   * This method assumes console is available.\n   *\n   * @param {String} [path]\n   */\n\n  Vue.prototype.$log = function (path) {\n    var data = path ? getPath(this._data, path) : this._data;\n    if (data) {\n      data = clean(data);\n    }\n    // include computed fields\n    if (!path) {\n      var key;\n      for (key in this.$options.computed) {\n        data[key] = clean(this[key]);\n      }\n      if (this._props) {\n        for (key in this._props) {\n          data[key] = clean(this[key]);\n        }\n      }\n    }\n    console.log(data);\n  };\n\n  /**\n   * \"clean\" a getter/setter converted object into a plain\n   * object copy.\n   *\n   * @param {Object} - obj\n   * @return {Object}\n   */\n\n  function clean(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n}\n\nfunction domAPI (Vue) {\n  /**\n   * Convenience on-instance nextTick. The callback is\n   * auto-bound to the instance, and this avoids component\n   * modules having to rely on the global Vue.\n   *\n   * @param {Function} fn\n   */\n\n  Vue.prototype.$nextTick = function (fn) {\n    nextTick(fn, this);\n  };\n\n  /**\n   * Append instance to target\n   *\n   * @param {Node} target\n   * @param {Function} [cb]\n   * @param {Boolean} [withTransition] - defaults to true\n   */\n\n  Vue.prototype.$appendTo = function (target, cb, withTransition) {\n    return insert(this, target, cb, withTransition, append, appendWithTransition);\n  };\n\n  /**\n   * Prepend instance to target\n   *\n   * @param {Node} target\n   * @param {Function} [cb]\n   * @param {Boolean} [withTransition] - defaults to true\n   */\n\n  Vue.prototype.$prependTo = function (target, cb, withTransition) {\n    target = query(target);\n    if (target.hasChildNodes()) {\n      this.$before(target.firstChild, cb, withTransition);\n    } else {\n      this.$appendTo(target, cb, withTransition);\n    }\n    return this;\n  };\n\n  /**\n   * Insert instance before target\n   *\n   * @param {Node} target\n   * @param {Function} [cb]\n   * @param {Boolean} [withTransition] - defaults to true\n   */\n\n  Vue.prototype.$before = function (target, cb, withTransition) {\n    return insert(this, target, cb, withTransition, beforeWithCb, beforeWithTransition);\n  };\n\n  /**\n   * Insert instance after target\n   *\n   * @param {Node} target\n   * @param {Function} [cb]\n   * @param {Boolean} [withTransition] - defaults to true\n   */\n\n  Vue.prototype.$after = function (target, cb, withTransition) {\n    target = query(target);\n    if (target.nextSibling) {\n      this.$before(target.nextSibling, cb, withTransition);\n    } else {\n      this.$appendTo(target.parentNode, cb, withTransition);\n    }\n    return this;\n  };\n\n  /**\n   * Remove instance from DOM\n   *\n   * @param {Function} [cb]\n   * @param {Boolean} [withTransition] - defaults to true\n   */\n\n  Vue.prototype.$remove = function (cb, withTransition) {\n    if (!this.$el.parentNode) {\n      return cb && cb();\n    }\n    var inDocument = this._isAttached && inDoc(this.$el);\n    // if we are not in document, no need to check\n    // for transitions\n    if (!inDocument) withTransition = false;\n    var self = this;\n    var realCb = function realCb() {\n      if (inDocument) self._callHook('detached');\n      if (cb) cb();\n    };\n    if (this._isFragment) {\n      removeNodeRange(this._fragmentStart, this._fragmentEnd, this, this._fragment, realCb);\n    } else {\n      var op = withTransition === false ? removeWithCb : removeWithTransition;\n      op(this.$el, this, realCb);\n    }\n    return this;\n  };\n\n  /**\n   * Shared DOM insertion function.\n   *\n   * @param {Vue} vm\n   * @param {Element} target\n   * @param {Function} [cb]\n   * @param {Boolean} [withTransition]\n   * @param {Function} op1 - op for non-transition insert\n   * @param {Function} op2 - op for transition insert\n   * @return vm\n   */\n\n  function insert(vm, target, cb, withTransition, op1, op2) {\n    target = query(target);\n    var targetIsDetached = !inDoc(target);\n    var op = withTransition === false || targetIsDetached ? op1 : op2;\n    var shouldCallHook = !targetIsDetached && !vm._isAttached && !inDoc(vm.$el);\n    if (vm._isFragment) {\n      mapNodeRange(vm._fragmentStart, vm._fragmentEnd, function (node) {\n        op(node, target, vm);\n      });\n      cb && cb();\n    } else {\n      op(vm.$el, target, vm, cb);\n    }\n    if (shouldCallHook) {\n      vm._callHook('attached');\n    }\n    return vm;\n  }\n\n  /**\n   * Check for selectors\n   *\n   * @param {String|Element} el\n   */\n\n  function query(el) {\n    return typeof el === 'string' ? document.querySelector(el) : el;\n  }\n\n  /**\n   * Append operation that takes a callback.\n   *\n   * @param {Node} el\n   * @param {Node} target\n   * @param {Vue} vm - unused\n   * @param {Function} [cb]\n   */\n\n  function append(el, target, vm, cb) {\n    target.appendChild(el);\n    if (cb) cb();\n  }\n\n  /**\n   * InsertBefore operation that takes a callback.\n   *\n   * @param {Node} el\n   * @param {Node} target\n   * @param {Vue} vm - unused\n   * @param {Function} [cb]\n   */\n\n  function beforeWithCb(el, target, vm, cb) {\n    before(el, target);\n    if (cb) cb();\n  }\n\n  /**\n   * Remove operation that takes a callback.\n   *\n   * @param {Node} el\n   * @param {Vue} vm - unused\n   * @param {Function} [cb]\n   */\n\n  function removeWithCb(el, vm, cb) {\n    remove(el);\n    if (cb) cb();\n  }\n}\n\nfunction eventsAPI (Vue) {\n  /**\n   * Listen on the given `event` with `fn`.\n   *\n   * @param {String} event\n   * @param {Function} fn\n   */\n\n  Vue.prototype.$on = function (event, fn) {\n    (this._events[event] || (this._events[event] = [])).push(fn);\n    modifyListenerCount(this, event, 1);\n    return this;\n  };\n\n  /**\n   * Adds an `event` listener that will be invoked a single\n   * time then automatically removed.\n   *\n   * @param {String} event\n   * @param {Function} fn\n   */\n\n  Vue.prototype.$once = function (event, fn) {\n    var self = this;\n    function on() {\n      self.$off(event, on);\n      fn.apply(this, arguments);\n    }\n    on.fn = fn;\n    this.$on(event, on);\n    return this;\n  };\n\n  /**\n   * Remove the given callback for `event` or all\n   * registered callbacks.\n   *\n   * @param {String} event\n   * @param {Function} fn\n   */\n\n  Vue.prototype.$off = function (event, fn) {\n    var cbs;\n    // all\n    if (!arguments.length) {\n      if (this.$parent) {\n        for (event in this._events) {\n          cbs = this._events[event];\n          if (cbs) {\n            modifyListenerCount(this, event, -cbs.length);\n          }\n        }\n      }\n      this._events = {};\n      return this;\n    }\n    // specific event\n    cbs = this._events[event];\n    if (!cbs) {\n      return this;\n    }\n    if (arguments.length === 1) {\n      modifyListenerCount(this, event, -cbs.length);\n      this._events[event] = null;\n      return this;\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        modifyListenerCount(this, event, -1);\n        cbs.splice(i, 1);\n        break;\n      }\n    }\n    return this;\n  };\n\n  /**\n   * Trigger an event on self.\n   *\n   * @param {String|Object} event\n   * @return {Boolean} shouldPropagate\n   */\n\n  Vue.prototype.$emit = function (event) {\n    var isSource = typeof event === 'string';\n    event = isSource ? event : event.name;\n    var cbs = this._events[event];\n    var shouldPropagate = isSource || !cbs;\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      // this is a somewhat hacky solution to the question raised\n      // in #2102: for an inline component listener like <comp @test=\"doThis\">,\n      // the propagation handling is somewhat broken. Therefore we\n      // need to treat these inline callbacks differently.\n      var hasParentCbs = isSource && cbs.some(function (cb) {\n        return cb._fromParent;\n      });\n      if (hasParentCbs) {\n        shouldPropagate = false;\n      }\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        var cb = cbs[i];\n        var res = cb.apply(this, args);\n        if (res === true && (!hasParentCbs || cb._fromParent)) {\n          shouldPropagate = true;\n        }\n      }\n    }\n    return shouldPropagate;\n  };\n\n  /**\n   * Recursively broadcast an event to all children instances.\n   *\n   * @param {String|Object} event\n   * @param {...*} additional arguments\n   */\n\n  Vue.prototype.$broadcast = function (event) {\n    var isSource = typeof event === 'string';\n    event = isSource ? event : event.name;\n    // if no child has registered for this event,\n    // then there's no need to broadcast.\n    if (!this._eventsCount[event]) return;\n    var children = this.$children;\n    var args = toArray(arguments);\n    if (isSource) {\n      // use object event to indicate non-source emit\n      // on children\n      args[0] = { name: event, source: this };\n    }\n    for (var i = 0, l = children.length; i < l; i++) {\n      var child = children[i];\n      var shouldPropagate = child.$emit.apply(child, args);\n      if (shouldPropagate) {\n        child.$broadcast.apply(child, args);\n      }\n    }\n    return this;\n  };\n\n  /**\n   * Recursively propagate an event up the parent chain.\n   *\n   * @param {String} event\n   * @param {...*} additional arguments\n   */\n\n  Vue.prototype.$dispatch = function (event) {\n    var shouldPropagate = this.$emit.apply(this, arguments);\n    if (!shouldPropagate) return;\n    var parent = this.$parent;\n    var args = toArray(arguments);\n    // use object event to indicate non-source emit\n    // on parents\n    args[0] = { name: event, source: this };\n    while (parent) {\n      shouldPropagate = parent.$emit.apply(parent, args);\n      parent = shouldPropagate ? parent.$parent : null;\n    }\n    return this;\n  };\n\n  /**\n   * Modify the listener counts on all parents.\n   * This bookkeeping allows $broadcast to return early when\n   * no child has listened to a certain event.\n   *\n   * @param {Vue} vm\n   * @param {String} event\n   * @param {Number} count\n   */\n\n  var hookRE = /^hook:/;\n  function modifyListenerCount(vm, event, count) {\n    var parent = vm.$parent;\n    // hooks do not get broadcasted so no need\n    // to do bookkeeping for them\n    if (!parent || !count || hookRE.test(event)) return;\n    while (parent) {\n      parent._eventsCount[event] = (parent._eventsCount[event] || 0) + count;\n      parent = parent.$parent;\n    }\n  }\n}\n\nfunction lifecycleAPI (Vue) {\n  /**\n   * Set instance target element and kick off the compilation\n   * process. The passed in `el` can be a selector string, an\n   * existing Element, or a DocumentFragment (for block\n   * instances).\n   *\n   * @param {Element|DocumentFragment|string} el\n   * @public\n   */\n\n  Vue.prototype.$mount = function (el) {\n    if (this._isCompiled) {\n      process.env.NODE_ENV !== 'production' && warn('$mount() should be called only once.', this);\n      return;\n    }\n    el = query(el);\n    if (!el) {\n      el = document.createElement('div');\n    }\n    this._compile(el);\n    this._initDOMHooks();\n    if (inDoc(this.$el)) {\n      this._callHook('attached');\n      ready.call(this);\n    } else {\n      this.$once('hook:attached', ready);\n    }\n    return this;\n  };\n\n  /**\n   * Mark an instance as ready.\n   */\n\n  function ready() {\n    this._isAttached = true;\n    this._isReady = true;\n    this._callHook('ready');\n  }\n\n  /**\n   * Teardown the instance, simply delegate to the internal\n   * _destroy.\n   *\n   * @param {Boolean} remove\n   * @param {Boolean} deferCleanup\n   */\n\n  Vue.prototype.$destroy = function (remove, deferCleanup) {\n    this._destroy(remove, deferCleanup);\n  };\n\n  /**\n   * Partially compile a piece of DOM and return a\n   * decompile function.\n   *\n   * @param {Element|DocumentFragment} el\n   * @param {Vue} [host]\n   * @param {Object} [scope]\n   * @param {Fragment} [frag]\n   * @return {Function}\n   */\n\n  Vue.prototype.$compile = function (el, host, scope, frag) {\n    return compile(el, this.$options, true)(this, el, host, scope, frag);\n  };\n}\n\n/**\n * The exposed Vue constructor.\n *\n * API conventions:\n * - public API methods/properties are prefixed with `$`\n * - internal methods/properties are prefixed with `_`\n * - non-prefixed properties are assumed to be proxied user\n *   data.\n *\n * @constructor\n * @param {Object} [options]\n * @public\n */\n\nfunction Vue(options) {\n  this._init(options);\n}\n\n// install internals\ninitMixin(Vue);\nstateMixin(Vue);\neventsMixin(Vue);\nlifecycleMixin(Vue);\nmiscMixin(Vue);\n\n// install instance APIs\ndataAPI(Vue);\ndomAPI(Vue);\neventsAPI(Vue);\nlifecycleAPI(Vue);\n\nvar slot = {\n\n  priority: SLOT,\n  params: ['name'],\n\n  bind: function bind() {\n    // this was resolved during component transclusion\n    var name = this.params.name || 'default';\n    var content = this.vm._slotContents && this.vm._slotContents[name];\n    if (!content || !content.hasChildNodes()) {\n      this.fallback();\n    } else {\n      this.compile(content.cloneNode(true), this.vm._context, this.vm);\n    }\n  },\n\n  compile: function compile(content, context, host) {\n    if (content && context) {\n      if (this.el.hasChildNodes() && content.childNodes.length === 1 && content.childNodes[0].nodeType === 1 && content.childNodes[0].hasAttribute('v-if')) {\n        // if the inserted slot has v-if\n        // inject fallback content as the v-else\n        var elseBlock = document.createElement('template');\n        elseBlock.setAttribute('v-else', '');\n        elseBlock.innerHTML = this.el.innerHTML;\n        // the else block should be compiled in child scope\n        elseBlock._context = this.vm;\n        content.appendChild(elseBlock);\n      }\n      var scope = host ? host._scope : this._scope;\n      this.unlink = context.$compile(content, host, scope, this._frag);\n    }\n    if (content) {\n      replace(this.el, content);\n    } else {\n      remove(this.el);\n    }\n  },\n\n  fallback: function fallback() {\n    this.compile(extractContent(this.el, true), this.vm);\n  },\n\n  unbind: function unbind() {\n    if (this.unlink) {\n      this.unlink();\n    }\n  }\n};\n\nvar partial = {\n\n  priority: PARTIAL,\n\n  params: ['name'],\n\n  // watch changes to name for dynamic partials\n  paramWatchers: {\n    name: function name(value) {\n      vIf.remove.call(this);\n      if (value) {\n        this.insert(value);\n      }\n    }\n  },\n\n  bind: function bind() {\n    this.anchor = createAnchor('v-partial');\n    replace(this.el, this.anchor);\n    this.insert(this.params.name);\n  },\n\n  insert: function insert(id) {\n    var partial = resolveAsset(this.vm.$options, 'partials', id, true);\n    if (partial) {\n      this.factory = new FragmentFactory(this.vm, partial);\n      vIf.insert.call(this);\n    }\n  },\n\n  unbind: function unbind() {\n    if (this.frag) {\n      this.frag.destroy();\n    }\n  }\n};\n\nvar elementDirectives = {\n  slot: slot,\n  partial: partial\n};\n\nvar convertArray = vFor._postProcess;\n\n/**\n * Limit filter for arrays\n *\n * @param {Number} n\n * @param {Number} offset (Decimal expected)\n */\n\nfunction limitBy(arr, n, offset) {\n  offset = offset ? parseInt(offset, 10) : 0;\n  n = toNumber(n);\n  return typeof n === 'number' ? arr.slice(offset, offset + n) : arr;\n}\n\n/**\n * Filter filter for arrays\n *\n * @param {String} search\n * @param {String} [delimiter]\n * @param {String} ...dataKeys\n */\n\nfunction filterBy(arr, search, delimiter) {\n  arr = convertArray(arr);\n  if (search == null) {\n    return arr;\n  }\n  if (typeof search === 'function') {\n    return arr.filter(search);\n  }\n  // cast to lowercase string\n  search = ('' + search).toLowerCase();\n  // allow optional `in` delimiter\n  // because why not\n  var n = delimiter === 'in' ? 3 : 2;\n  // extract and flatten keys\n  var keys = Array.prototype.concat.apply([], toArray(arguments, n));\n  var res = [];\n  var item, key, val, j;\n  for (var i = 0, l = arr.length; i < l; i++) {\n    item = arr[i];\n    val = item && item.$value || item;\n    j = keys.length;\n    if (j) {\n      while (j--) {\n        key = keys[j];\n        if (key === '$key' && contains(item.$key, search) || contains(getPath(val, key), search)) {\n          res.push(item);\n          break;\n        }\n      }\n    } else if (contains(item, search)) {\n      res.push(item);\n    }\n  }\n  return res;\n}\n\n/**\n * Filter filter for arrays\n *\n * @param {String|Array<String>|Function} ...sortKeys\n * @param {Number} [order]\n */\n\nfunction orderBy(arr) {\n  var comparator = null;\n  var sortKeys = undefined;\n  arr = convertArray(arr);\n\n  // determine order (last argument)\n  var args = toArray(arguments, 1);\n  var order = args[args.length - 1];\n  if (typeof order === 'number') {\n    order = order < 0 ? -1 : 1;\n    args = args.length > 1 ? args.slice(0, -1) : args;\n  } else {\n    order = 1;\n  }\n\n  // determine sortKeys & comparator\n  var firstArg = args[0];\n  if (!firstArg) {\n    return arr;\n  } else if (typeof firstArg === 'function') {\n    // custom comparator\n    comparator = function (a, b) {\n      return firstArg(a, b) * order;\n    };\n  } else {\n    // string keys. flatten first\n    sortKeys = Array.prototype.concat.apply([], args);\n    comparator = function (a, b, i) {\n      i = i || 0;\n      return i >= sortKeys.length - 1 ? baseCompare(a, b, i) : baseCompare(a, b, i) || comparator(a, b, i + 1);\n    };\n  }\n\n  function baseCompare(a, b, sortKeyIndex) {\n    var sortKey = sortKeys[sortKeyIndex];\n    if (sortKey) {\n      if (sortKey !== '$key') {\n        if (isObject(a) && '$value' in a) a = a.$value;\n        if (isObject(b) && '$value' in b) b = b.$value;\n      }\n      a = isObject(a) ? getPath(a, sortKey) : a;\n      b = isObject(b) ? getPath(b, sortKey) : b;\n    }\n    return a === b ? 0 : a > b ? order : -order;\n  }\n\n  // sort on a copy to avoid mutating original array\n  return arr.slice().sort(comparator);\n}\n\n/**\n * String contain helper\n *\n * @param {*} val\n * @param {String} search\n */\n\nfunction contains(val, search) {\n  var i;\n  if (isPlainObject(val)) {\n    var keys = Object.keys(val);\n    i = keys.length;\n    while (i--) {\n      if (contains(val[keys[i]], search)) {\n        return true;\n      }\n    }\n  } else if (isArray(val)) {\n    i = val.length;\n    while (i--) {\n      if (contains(val[i], search)) {\n        return true;\n      }\n    }\n  } else if (val != null) {\n    return val.toString().toLowerCase().indexOf(search) > -1;\n  }\n}\n\nvar digitsRE = /(\\d{3})(?=\\d)/g;\n\n// asset collections must be a plain object.\nvar filters = {\n\n  orderBy: orderBy,\n  filterBy: filterBy,\n  limitBy: limitBy,\n\n  /**\n   * Stringify value.\n   *\n   * @param {Number} indent\n   */\n\n  json: {\n    read: function read(value, indent) {\n      return typeof value === 'string' ? value : JSON.stringify(value, null, Number(indent) || 2);\n    },\n    write: function write(value) {\n      try {\n        return JSON.parse(value);\n      } catch (e) {\n        return value;\n      }\n    }\n  },\n\n  /**\n   * 'abc' => 'Abc'\n   */\n\n  capitalize: function capitalize(value) {\n    if (!value && value !== 0) return '';\n    value = value.toString();\n    return value.charAt(0).toUpperCase() + value.slice(1);\n  },\n\n  /**\n   * 'abc' => 'ABC'\n   */\n\n  uppercase: function uppercase(value) {\n    return value || value === 0 ? value.toString().toUpperCase() : '';\n  },\n\n  /**\n   * 'AbC' => 'abc'\n   */\n\n  lowercase: function lowercase(value) {\n    return value || value === 0 ? value.toString().toLowerCase() : '';\n  },\n\n  /**\n   * 12345 => $12,345.00\n   *\n   * @param {String} sign\n   */\n\n  currency: function currency(value, _currency) {\n    value = parseFloat(value);\n    if (!isFinite(value) || !value && value !== 0) return '';\n    _currency = _currency != null ? _currency : '$';\n    var stringified = Math.abs(value).toFixed(2);\n    var _int = stringified.slice(0, -3);\n    var i = _int.length % 3;\n    var head = i > 0 ? _int.slice(0, i) + (_int.length > 3 ? ',' : '') : '';\n    var _float = stringified.slice(-3);\n    var sign = value < 0 ? '-' : '';\n    return sign + _currency + head + _int.slice(i).replace(digitsRE, '$1,') + _float;\n  },\n\n  /**\n   * 'item' => 'items'\n   *\n   * @params\n   *  an array of strings corresponding to\n   *  the single, double, triple ... forms of the word to\n   *  be pluralized. When the number to be pluralized\n   *  exceeds the length of the args, it will use the last\n   *  entry in the array.\n   *\n   *  e.g. ['single', 'double', 'triple', 'multiple']\n   */\n\n  pluralize: function pluralize(value) {\n    var args = toArray(arguments, 1);\n    return args.length > 1 ? args[value % 10 - 1] || args[args.length - 1] : args[0] + (value === 1 ? '' : 's');\n  },\n\n  /**\n   * Debounce a handler function.\n   *\n   * @param {Function} handler\n   * @param {Number} delay = 300\n   * @return {Function}\n   */\n\n  debounce: function debounce(handler, delay) {\n    if (!handler) return;\n    if (!delay) {\n      delay = 300;\n    }\n    return _debounce(handler, delay);\n  }\n};\n\nfunction installGlobalAPI (Vue) {\n  /**\n   * Vue and every constructor that extends Vue has an\n   * associated options object, which can be accessed during\n   * compilation steps as `this.constructor.options`.\n   *\n   * These can be seen as the default options of every\n   * Vue instance.\n   */\n\n  Vue.options = {\n    directives: directives,\n    elementDirectives: elementDirectives,\n    filters: filters,\n    transitions: {},\n    components: {},\n    partials: {},\n    replace: true\n  };\n\n  /**\n   * Expose useful internals\n   */\n\n  Vue.util = util;\n  Vue.config = config;\n  Vue.set = set;\n  Vue['delete'] = del;\n  Vue.nextTick = nextTick;\n\n  /**\n   * The following are exposed for advanced usage / plugins\n   */\n\n  Vue.compiler = compiler;\n  Vue.FragmentFactory = FragmentFactory;\n  Vue.internalDirectives = internalDirectives;\n  Vue.parsers = {\n    path: path,\n    text: text,\n    template: template,\n    directive: directive,\n    expression: expression\n  };\n\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   *\n   * @param {Object} extendOptions\n   */\n\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var isFirstExtend = Super.cid === 0;\n    if (isFirstExtend && extendOptions._Ctor) {\n      return extendOptions._Ctor;\n    }\n    var name = extendOptions.name || Super.options.name;\n    if (process.env.NODE_ENV !== 'production') {\n      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n        warn('Invalid component name: \"' + name + '\". Component names ' + 'can only contain alphanumeric characaters and the hyphen.');\n        name = null;\n      }\n    }\n    var Sub = createClass(name || 'VueComponent');\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(Super.options, extendOptions);\n    Sub['super'] = Super;\n    // allow further extension\n    Sub.extend = Super.extend;\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    config._assetTypes.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n    // cache constructor\n    if (isFirstExtend) {\n      extendOptions._Ctor = Sub;\n    }\n    return Sub;\n  };\n\n  /**\n   * A function that returns a sub-class constructor with the\n   * given name. This gives us much nicer output when\n   * logging instances in the console.\n   *\n   * @param {String} name\n   * @return {Function}\n   */\n\n  function createClass(name) {\n    /* eslint-disable no-new-func */\n    return new Function('return function ' + classify(name) + ' (options) { this._init(options) }')();\n    /* eslint-enable no-new-func */\n  }\n\n  /**\n   * Plugin system\n   *\n   * @param {Object} plugin\n   */\n\n  Vue.use = function (plugin) {\n    /* istanbul ignore if */\n    if (plugin.installed) {\n      return;\n    }\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else {\n      plugin.apply(null, args);\n    }\n    plugin.installed = true;\n    return this;\n  };\n\n  /**\n   * Apply a global mixin by merging it into the default\n   * options.\n   */\n\n  Vue.mixin = function (mixin) {\n    Vue.options = mergeOptions(Vue.options, mixin);\n  };\n\n  /**\n   * Create asset registration methods with the following\n   * signature:\n   *\n   * @param {String} id\n   * @param {*} definition\n   */\n\n  config._assetTypes.forEach(function (type) {\n    Vue[type] = function (id, definition) {\n      if (!definition) {\n        return this.options[type + 's'][id];\n      } else {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production') {\n          if (type === 'component' && (commonTagRE.test(id) || reservedTagRE.test(id))) {\n            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);\n          }\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = id;\n          definition = Vue.extend(definition);\n        }\n        this.options[type + 's'][id] = definition;\n        return definition;\n      }\n    };\n  });\n\n  // expose internal transition API\n  extend(Vue.transition, transition);\n}\n\ninstallGlobalAPI(Vue);\n\nVue.version = '1.0.21';\n\n// devtools global hook\n/* istanbul ignore next */\nsetTimeout(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue);\n    } else if (process.env.NODE_ENV !== 'production' && inBrowser && /Chrome\\/\\d+/.test(window.navigator.userAgent)) {\n      console.log('Download the Vue Devtools for a better development experience:\\n' + 'https://github.com/vuejs/vue-devtools');\n    }\n  }\n}, 0);\n\nmodule.exports = Vue;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vue/dist/vue.common.js\n ** module id = 16\n ** module chunks = 0\n **/","var nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/timers-browserify/main.js\n ** module id = 17\n ** module chunks = 0\n **/","import Vue from 'vue';\r\nimport Q from 'q';\r\nimport {DeferredReadyMixin} from '../deferredReady'\r\nimport {DeferredReady} from '../deferredReady'\r\n\r\nVue.use(DeferredReady);\r\n\r\nexport default Vue.extend({\r\n    mixins: [DeferredReadyMixin],\r\n    created() {\r\n        this.$map = null;\r\n    },\r\n    deferredReady() {\r\n        this.$dispatch('register-component', this);\r\n    },\r\n    events: {\r\n        'map-ready'(map) {\r\n            this.$map = map;\r\n        },\r\n    },\r\n})\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/mapComponent.js\n **/","import Q from 'q'\r\n\r\n/**\r\n * 1. Create a DeferredReady plugin.\r\n * \r\n * a. Updates options.configMergeStrategies to handle our new hook correctly (using Promise.all!)\r\n *     \r\n * 2. VueGoogleMaps uses a DeferredReady mixin.\r\n * \r\n *     a. Each component checks for ancestors that are also DeferredReady (via dispatch/emit)\r\n *     b. If no, then run DeferredReady after ready.\r\n *     c. If yes, then run DeferredReady after parent's deferredReady.\r\n *     \r\n *     \r\n * Say we have the following inheritance:\r\n * \r\n * --> == 'child of'\r\n * \r\n * A --> B --> C\r\n * \r\n * ready is called in the following order:\r\n * \r\n * A.ready, B.ready, C.ready\r\n * \r\n * C.ready -- no further ancestors supporting mixin, so in ready() we run+\r\n * \r\n *     // I believe this executes synchronously.\r\n *     Vue.$dispatch('register-deferredReadyChild', this);\r\n * \r\n *     if (!this.hasDeferredReadyAncestors) {\r\n *         (do we need nextTick?)\r\n *         Vue.nextTick(() => {\r\n *             Promise.all(this.$options.deferredReady.map(x => x()))\r\n *             .then(() => this.deferredReadyDeferred.resolve());\r\n *         })\r\n *     }\r\n *     \r\n *     Event handler:\r\n *     \r\n *     'register-deferredReadyChild' (obj) {\r\n *         if (this == obj)\r\n *             return true;\r\n *             \r\n *         this.hasDeferredReadyAncestors = true;\r\n *         \r\n *         this.deferredReadyDeferred.promise.then(() => {\r\n *             Promise.all(obj.$options.deferredReady.map(x => x()))\r\n *             .then(() => obj.deferredReadyDeferred.resolve())\r\n *         });\r\n *     }\r\n * \r\n * B.ready -- parent C supports deferredReady. \r\n *     \r\n   **/ \r\n\r\nexport var DeferredReady = {\r\n  install(Vue, options) {\r\n    // Use the same merge strategy as regular hooks\r\n    Vue.config.optionMergeStrategies.deferredReady = Vue.config.optionMergeStrategies.created;\r\n  },\r\n};\r\n\r\nfunction runHooks(vm) {\r\n  var hooks = vm.$options.deferredReady || [];\r\n  if (typeof hooks === 'function') {\r\n    hooks = [hooks]\r\n  }\r\n  Promise.all(hooks.map(x => {\r\n    var rv;\r\n    try {\r\n      rv = x.apply(vm)\r\n    } catch (err) {\r\n      console.error(err.stack);\r\n    }\r\n    return rv;\r\n  })) // execute all handlers, expecting them to return promises\r\n  // wait for the promises to complete, before allowing child to execute\r\n  .then(() => {\r\n      vm.$deferredReadyDeferred.resolve()\r\n  });\r\n}\r\n\r\nexport var DeferredReadyMixin = {\r\n  created() {\r\n    this.$hasDeferredReadyAncestors = false;\r\n    this.$deferredReadyDeferred = Q.defer();\r\n  },\r\n\r\n  ready() {\r\n    this.$dispatch('register-deferredReadyChild', this);\r\n\r\n    if (!this.$hasDeferredReadyAncestors) {\r\n      // call deferredReady() hook only after ready() has completed\r\n      this.$nextTick(() => runHooks(this));\r\n    }\r\n    /* else hooks will be called when parents are done */\r\n  },\r\n\r\n  events: {\r\n    'register-deferredReadyChild' (child) {\r\n      if (this == child)\r\n        return true;\r\n\r\n      // delay child's execution of its hooks\r\n      child.$hasDeferredReadyAncestors = true;\r\n\r\n      // after we are done running deferredReady()\r\n      // children should run their deferredReady()\r\n      this.$deferredReadyDeferred.promise\r\n      .then(() => runHooks(child));\r\n    },\r\n  },\r\n};\n\n\n/** WEBPACK FOOTER **\n ** ./src/deferredReady.js\n **/","// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = require('./$.cof')\n  , TAG = require('./$.wks')('toStringTag')\n  // ES3 wrong here\n  , ARG = cof(function(){ return arguments; }()) == 'Arguments';\n\nmodule.exports = function(it){\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = (O = Object(it))[TAG]) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.classof.js\n ** module id = 20\n ** module chunks = 0\n **/","// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function(it){\n  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.defined.js\n ** module id = 21\n ** module chunks = 0\n **/","var global    = require('./$.global')\n  , core      = require('./$.core')\n  , ctx       = require('./$.ctx')\n  , PROTOTYPE = 'prototype';\n\nvar $export = function(type, name, source){\n  var IS_FORCED = type & $export.F\n    , IS_GLOBAL = type & $export.G\n    , IS_STATIC = type & $export.S\n    , IS_PROTO  = type & $export.P\n    , IS_BIND   = type & $export.B\n    , IS_WRAP   = type & $export.W\n    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n    , key, own, out;\n  if(IS_GLOBAL)source = name;\n  for(key in source){\n    // contains in native\n    own = !IS_FORCED && target && key in target;\n    if(own && key in exports)continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? ctx(out, global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function(C){\n      var F = function(param){\n        return this instanceof C ? new C(param) : C(param);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    if(IS_PROTO)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;\n  }\n};\n// type bitmap\n$export.F = 1;  // forced\n$export.G = 2;  // global\n$export.S = 4;  // static\n$export.P = 8;  // proto\n$export.B = 16; // bind\n$export.W = 32; // wrap\nmodule.exports = $export;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.export.js\n ** module id = 22\n ** module chunks = 0\n **/","var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function(it, key){\n  return hasOwnProperty.call(it, key);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.has.js\n ** module id = 23\n ** module chunks = 0\n **/","'use strict';\nvar LIBRARY        = require('./$.library')\n  , $export        = require('./$.export')\n  , redefine       = require('./$.redefine')\n  , hide           = require('./$.hide')\n  , has            = require('./$.has')\n  , Iterators      = require('./$.iterators')\n  , $iterCreate    = require('./$.iter-create')\n  , setToStringTag = require('./$.set-to-string-tag')\n  , getProto       = require('./$').getProto\n  , ITERATOR       = require('./$.wks')('iterator')\n  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n  , FF_ITERATOR    = '@@iterator'\n  , KEYS           = 'keys'\n  , VALUES         = 'values';\n\nvar returnThis = function(){ return this; };\n\nmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function(kind){\n    if(!BUGGY && kind in proto)return proto[kind];\n    switch(kind){\n      case KEYS: return function keys(){ return new Constructor(this, kind); };\n      case VALUES: return function values(){ return new Constructor(this, kind); };\n    } return function entries(){ return new Constructor(this, kind); };\n  };\n  var TAG        = NAME + ' Iterator'\n    , DEF_VALUES = DEFAULT == VALUES\n    , VALUES_BUG = false\n    , proto      = Base.prototype\n    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n    , $default   = $native || getMethod(DEFAULT)\n    , methods, key;\n  // Fix native\n  if($native){\n    var IteratorPrototype = getProto($default.call(new Base));\n    // Set @@toStringTag to native iterators\n    setToStringTag(IteratorPrototype, TAG, true);\n    // FF fix\n    if(!LIBRARY && has(proto, FF_ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n    // fix Array#{values, @@iterator}.name in V8 / FF\n    if(DEF_VALUES && $native.name !== VALUES){\n      VALUES_BUG = true;\n      $default = function values(){ return $native.call(this); };\n    }\n  }\n  // Define iterator\n  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG]  = returnThis;\n  if(DEFAULT){\n    methods = {\n      values:  DEF_VALUES  ? $default : getMethod(VALUES),\n      keys:    IS_SET      ? $default : getMethod(KEYS),\n      entries: !DEF_VALUES ? $default : getMethod('entries')\n    };\n    if(FORCED)for(key in methods){\n      if(!(key in proto))redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.iter-define.js\n ** module id = 24\n ** module chunks = 0\n **/","module.exports = true;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.library.js\n ** module id = 25\n ** module chunks = 0\n **/","module.exports = function(bitmap, value){\n  return {\n    enumerable  : !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable    : !(bitmap & 4),\n    value       : value\n  };\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.property-desc.js\n ** module id = 26\n ** module chunks = 0\n **/","module.exports = require('./$.hide');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.redefine.js\n ** module id = 27\n ** module chunks = 0\n **/","// 7.1.4 ToInteger\nvar ceil  = Math.ceil\n  , floor = Math.floor;\nmodule.exports = function(it){\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.to-integer.js\n ** module id = 28\n ** module chunks = 0\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader/lib/css-base.js\n ** module id = 29\n ** module chunks = 0\n **/","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nvar stylesInDom = {},\n\tmemoize = function(fn) {\n\t\tvar memo;\n\t\treturn function () {\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\treturn memo;\n\t\t};\n\t},\n\tisOldIE = memoize(function() {\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\n\t}),\n\tgetHeadElement = memoize(function () {\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t}),\n\tsingletonElement = null,\n\tsingletonCounter = 0,\n\tstyleElementsInsertedAtTop = [];\n\nmodule.exports = function(list, options) {\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the bottom of <head>.\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list);\n\taddStylesToDom(styles, options);\n\n\treturn function update(newList) {\n\t\tvar mayRemove = [];\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction addStylesToDom(styles, options) {\n\tfor(var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles(list) {\n\tvar styles = [];\n\tvar newStyles = {};\n\tfor(var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\tif(!newStyles[id])\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse\n\t\t\tnewStyles[id].parts.push(part);\n\t}\n\treturn styles;\n}\n\nfunction insertStyleElement(options, styleElement) {\n\tvar head = getHeadElement();\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\tif (options.insertAt === \"top\") {\n\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\thead.insertBefore(styleElement, head.firstChild);\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\thead.appendChild(styleElement);\n\t\t}\n\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t} else if (options.insertAt === \"bottom\") {\n\t\thead.appendChild(styleElement);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement(styleElement) {\n\tstyleElement.parentNode.removeChild(styleElement);\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\tif(idx >= 0) {\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement(options) {\n\tvar styleElement = document.createElement(\"style\");\n\tstyleElement.type = \"text/css\";\n\tinsertStyleElement(options, styleElement);\n\treturn styleElement;\n}\n\nfunction addStyle(obj, options) {\n\tvar styleElement, update, remove;\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t} else {\n\t\tstyleElement = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle(newObj) {\n\t\tif(newObj) {\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\treturn;\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = styleElement.childNodes;\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\tif (childNodes.length) {\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyleElement.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag(styleElement, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\tvar sourceMap = obj.sourceMap;\n\n\tif (media) {\n\t\tstyleElement.setAttribute(\"media\", media);\n\t}\n\n\tif (sourceMap) {\n\t\t// https://developer.chrome.com/devtools/docs/javascript-debugging\n\t\t// this makes source maps inside style tags work properly in Chrome\n\t\tcss += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */';\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = css;\n\t} else {\n\t\twhile(styleElement.firstChild) {\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t}\n\t\tstyleElement.appendChild(document.createTextNode(css));\n\t}\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vue-style-loader/addStyles.js\n ** module id = 30\n ** module chunks = 0\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/process/browser.js\n ** module id = 31\n ** module chunks = 0\n **/","import MapComponent from './mapComponent';\r\nimport Leaflet from 'leaflet';\r\n\r\nexport default MapComponent.extend({\r\n    props:['position'],\r\n    deferredReady(){\r\n        console.log(this.position);\r\n        Leaflet.Icon.Default.imagePath = \"http://cdn.leafletjs.com/leaflet/v0.7.7/images\";\r\n        Leaflet.marker(this.position).addTo(this.$map);\r\n    }\r\n});\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/Marker.js\n **/","import MapComponent from './mapComponent';\r\nimport Leaflet from 'leaflet';\r\n\r\nexport default MapComponent.extend({\r\n    props:['url','attribution'],\r\n    deferredReady(){\r\n        Leaflet.tileLayer(this.url,{attribution:this.attribution}).addTo(this.$map);\r\n    }\r\n});\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/TileLayer.js\n **/","<template>\n  <div id=\"app\">\n    <h1>{{ title }}</h1>\n    <map :zoom=\"zoom\" :center=\"center\" :min-zoom=\"minZoom\" :max-zoom=\"maxZoom\">\n      <tilelayer :url=\"url\" :attribution=\"attribution\"></tilelayer>\n      <marker :position=\"center\" ></marker>\n    </map>\n  </div>\n</template>\n\n<script>\nimport map from \"./components/Map.vue\"\nimport tilelayer from \"./components/TileLayer\"\nimport marker from \"./components/Marker\"\n\nexport default {\n  data () {\n    return {\n      title: 'Vue Leaflet Demo',\n      zoom:13,\n      center:[51.505, -0.09],\n      minZoom:8,\n      maxZoom:15,\n      url:\"http://{s}.tile.osm.org/{z}/{x}/{y}.png\",\n      attribution:\"mymap\"\n    }\n  },\n  components: {map ,tilelayer,marker}\n}\n</script>\n\n<style>\nbody {\n  font-family: Helvetica, sans-serif;\n}\n</style>\n\n\n\n/** WEBPACK FOOTER **\n ** App.vue?8daf33fa\n **/","<template>\r\n\t<div id=\"map\">\r\n\t<slot></slot>\r\n\t</div>\r\n</template>\r\n\r\n<script>\r\nimport Q from 'q';\r\nimport Vue from 'vue'\r\nimport {DeferredReadyMixin} from '../deferredReady.js'\r\nimport {DeferredReady} from '../deferredReady.js'\r\nimport Leaflet from 'leaflet';\r\n\r\nVue.use(DeferredReady);\r\n\r\nconst registerChild = function (child, type) {\r\n  if (!this.mapObject)\r\n    throw new Error(\"Map not initialized\");\r\n  child.$emit('map-ready', this.mapObject);\r\n  // Simpler: child.$map = mapObject but not so\r\n  // modular\r\n}\r\n\r\nconst eventListeners = {\r\n  'register-component': registerChild,\r\n}\r\n\r\nexport default{\r\n\tmixins:[DeferredReadyMixin],\r\n\tprops:['center','zoom','minZoom','maxZoom'],\r\n\tcreated(){\r\n\t\tthis.mapCreatedDefered = new Q.defer();\r\n\t\tthis.mapCreated = this.mapCreatedDefered.promise;\t\r\n\t},\r\n\tready(){\r\n\t\tthis.mapObject = Leaflet.map(\"map\",{\r\n\t\t\tcenter:this.center,\r\n\t\t\tzoom:this.zoom,\r\n\t\t\tminZoom:this.minZoom,\r\n\t\t\tmaxZoom:this.maxZoom\r\n\t\t})\r\n\t},\r\n\tevents:eventListeners\r\n}\r\n</script>\r\n<style type=\"text/css\">\r\n\t#map{height: 800px;width: 800px;}\r\n</style>\n\n\n/** WEBPACK FOOTER **\n ** Map.vue?a8c2550a\n **/","module.exports = { \"default\": require(\"core-js/library/fn/promise\"), __esModule: true };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/core-js/promise.js\n ** module id = 36\n ** module chunks = 0\n **/","require('../modules/es6.object.to-string');\nrequire('../modules/es6.string.iterator');\nrequire('../modules/web.dom.iterable');\nrequire('../modules/es6.promise');\nmodule.exports = require('../modules/$.core').Promise;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/fn/promise.js\n ** module id = 37\n ** module chunks = 0\n **/","module.exports = function(){ /* empty */ };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.add-to-unscopables.js\n ** module id = 38\n ** module chunks = 0\n **/","var isObject = require('./$.is-object')\n  , document = require('./$.global').document\n  // in old IE typeof document.createElement is 'object'\n  , is = isObject(document) && isObject(document.createElement);\nmodule.exports = function(it){\n  return is ? document.createElement(it) : {};\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.dom-create.js\n ** module id = 39\n ** module chunks = 0\n **/","module.exports = function(exec){\n  try {\n    return !!exec();\n  } catch(e){\n    return true;\n  }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.fails.js\n ** module id = 40\n ** module chunks = 0\n **/","var ctx         = require('./$.ctx')\n  , call        = require('./$.iter-call')\n  , isArrayIter = require('./$.is-array-iter')\n  , anObject    = require('./$.an-object')\n  , toLength    = require('./$.to-length')\n  , getIterFn   = require('./core.get-iterator-method');\nmodule.exports = function(iterable, entries, fn, that){\n  var iterFn = getIterFn(iterable)\n    , f      = ctx(fn, that, entries ? 2 : 1)\n    , index  = 0\n    , length, step, iterator;\n  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');\n  // fast case for arrays with default iterator\n  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){\n    entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\n  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){\n    call(iterator, f, step.value, entries);\n  }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.for-of.js\n ** module id = 41\n ** module chunks = 0\n **/","module.exports = require('./$.global').document && document.documentElement;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.html.js\n ** module id = 42\n ** module chunks = 0\n **/","// fast apply, http://jsperf.lnkit.com/fast-apply/5\nmodule.exports = function(fn, args, that){\n  var un = that === undefined;\n  switch(args.length){\n    case 0: return un ? fn()\n                      : fn.call(that);\n    case 1: return un ? fn(args[0])\n                      : fn.call(that, args[0]);\n    case 2: return un ? fn(args[0], args[1])\n                      : fn.call(that, args[0], args[1]);\n    case 3: return un ? fn(args[0], args[1], args[2])\n                      : fn.call(that, args[0], args[1], args[2]);\n    case 4: return un ? fn(args[0], args[1], args[2], args[3])\n                      : fn.call(that, args[0], args[1], args[2], args[3]);\n  } return              fn.apply(that, args);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.invoke.js\n ** module id = 43\n ** module chunks = 0\n **/","// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = require('./$.cof');\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.iobject.js\n ** module id = 44\n ** module chunks = 0\n **/","// check on default Array iterator\nvar Iterators  = require('./$.iterators')\n  , ITERATOR   = require('./$.wks')('iterator')\n  , ArrayProto = Array.prototype;\n\nmodule.exports = function(it){\n  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.is-array-iter.js\n ** module id = 45\n ** module chunks = 0\n **/","// call something on iterator step with safe closing on error\nvar anObject = require('./$.an-object');\nmodule.exports = function(iterator, fn, value, entries){\n  try {\n    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch(e){\n    var ret = iterator['return'];\n    if(ret !== undefined)anObject(ret.call(iterator));\n    throw e;\n  }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.iter-call.js\n ** module id = 46\n ** module chunks = 0\n **/","'use strict';\nvar $              = require('./$')\n  , descriptor     = require('./$.property-desc')\n  , setToStringTag = require('./$.set-to-string-tag')\n  , IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\nrequire('./$.hide')(IteratorPrototype, require('./$.wks')('iterator'), function(){ return this; });\n\nmodule.exports = function(Constructor, NAME, next){\n  Constructor.prototype = $.create(IteratorPrototype, {next: descriptor(1, next)});\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.iter-create.js\n ** module id = 47\n ** module chunks = 0\n **/","var ITERATOR     = require('./$.wks')('iterator')\n  , SAFE_CLOSING = false;\n\ntry {\n  var riter = [7][ITERATOR]();\n  riter['return'] = function(){ SAFE_CLOSING = true; };\n  Array.from(riter, function(){ throw 2; });\n} catch(e){ /* empty */ }\n\nmodule.exports = function(exec, skipClosing){\n  if(!skipClosing && !SAFE_CLOSING)return false;\n  var safe = false;\n  try {\n    var arr  = [7]\n      , iter = arr[ITERATOR]();\n    iter.next = function(){ safe = true; };\n    arr[ITERATOR] = function(){ return iter; };\n    exec(arr);\n  } catch(e){ /* empty */ }\n  return safe;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.iter-detect.js\n ** module id = 48\n ** module chunks = 0\n **/","module.exports = function(done, value){\n  return {value: value, done: !!done};\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.iter-step.js\n ** module id = 49\n ** module chunks = 0\n **/","var global    = require('./$.global')\n  , macrotask = require('./$.task').set\n  , Observer  = global.MutationObserver || global.WebKitMutationObserver\n  , process   = global.process\n  , Promise   = global.Promise\n  , isNode    = require('./$.cof')(process) == 'process'\n  , head, last, notify;\n\nvar flush = function(){\n  var parent, domain, fn;\n  if(isNode && (parent = process.domain)){\n    process.domain = null;\n    parent.exit();\n  }\n  while(head){\n    domain = head.domain;\n    fn     = head.fn;\n    if(domain)domain.enter();\n    fn(); // <- currently we use it only for Promise - try / catch not required\n    if(domain)domain.exit();\n    head = head.next;\n  } last = undefined;\n  if(parent)parent.enter();\n};\n\n// Node.js\nif(isNode){\n  notify = function(){\n    process.nextTick(flush);\n  };\n// browsers with MutationObserver\n} else if(Observer){\n  var toggle = 1\n    , node   = document.createTextNode('');\n  new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new\n  notify = function(){\n    node.data = toggle = -toggle;\n  };\n// environments with maybe non-completely correct, but existent Promise\n} else if(Promise && Promise.resolve){\n  notify = function(){\n    Promise.resolve().then(flush);\n  };\n// for other environments - macrotask based on:\n// - setImmediate\n// - MessageChannel\n// - window.postMessag\n// - onreadystatechange\n// - setTimeout\n} else {\n  notify = function(){\n    // strange IE + webpack dev server bug - use .call(global)\n    macrotask.call(global, flush);\n  };\n}\n\nmodule.exports = function asap(fn){\n  var task = {fn: fn, next: undefined, domain: isNode && process.domain};\n  if(last)last.next = task;\n  if(!head){\n    head = task;\n    notify();\n  } last = task;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.microtask.js\n ** module id = 50\n ** module chunks = 0\n **/","var redefine = require('./$.redefine');\nmodule.exports = function(target, src){\n  for(var key in src)redefine(target, key, src[key]);\n  return target;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.redefine-all.js\n ** module id = 51\n ** module chunks = 0\n **/","// 7.2.9 SameValue(x, y)\nmodule.exports = Object.is || function is(x, y){\n  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.same-value.js\n ** module id = 52\n ** module chunks = 0\n **/","// Works with __proto__ only. Old v8 can't work with null proto objects.\n/* eslint-disable no-proto */\nvar getDesc  = require('./$').getDesc\n  , isObject = require('./$.is-object')\n  , anObject = require('./$.an-object');\nvar check = function(O, proto){\n  anObject(O);\n  if(!isObject(proto) && proto !== null)throw TypeError(proto + \": can't set as prototype!\");\n};\nmodule.exports = {\n  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line\n    function(test, buggy, set){\n      try {\n        set = require('./$.ctx')(Function.call, getDesc(Object.prototype, '__proto__').set, 2);\n        set(test, []);\n        buggy = !(test instanceof Array);\n      } catch(e){ buggy = true; }\n      return function setPrototypeOf(O, proto){\n        check(O, proto);\n        if(buggy)O.__proto__ = proto;\n        else set(O, proto);\n        return O;\n      };\n    }({}, false) : undefined),\n  check: check\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.set-proto.js\n ** module id = 53\n ** module chunks = 0\n **/","'use strict';\nvar core        = require('./$.core')\n  , $           = require('./$')\n  , DESCRIPTORS = require('./$.descriptors')\n  , SPECIES     = require('./$.wks')('species');\n\nmodule.exports = function(KEY){\n  var C = core[KEY];\n  if(DESCRIPTORS && C && !C[SPECIES])$.setDesc(C, SPECIES, {\n    configurable: true,\n    get: function(){ return this; }\n  });\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.set-species.js\n ** module id = 54\n ** module chunks = 0\n **/","var global = require('./$.global')\n  , SHARED = '__core-js_shared__'\n  , store  = global[SHARED] || (global[SHARED] = {});\nmodule.exports = function(key){\n  return store[key] || (store[key] = {});\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.shared.js\n ** module id = 55\n ** module chunks = 0\n **/","// 7.3.20 SpeciesConstructor(O, defaultConstructor)\nvar anObject  = require('./$.an-object')\n  , aFunction = require('./$.a-function')\n  , SPECIES   = require('./$.wks')('species');\nmodule.exports = function(O, D){\n  var C = anObject(O).constructor, S;\n  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.species-constructor.js\n ** module id = 56\n ** module chunks = 0\n **/","module.exports = function(it, Constructor, name){\n  if(!(it instanceof Constructor))throw TypeError(name + \": use the 'new' operator!\");\n  return it;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.strict-new.js\n ** module id = 57\n ** module chunks = 0\n **/","var toInteger = require('./$.to-integer')\n  , defined   = require('./$.defined');\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function(TO_STRING){\n  return function(that, pos){\n    var s = String(defined(that))\n      , i = toInteger(pos)\n      , l = s.length\n      , a, b;\n    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.string-at.js\n ** module id = 58\n ** module chunks = 0\n **/","var ctx                = require('./$.ctx')\n  , invoke             = require('./$.invoke')\n  , html               = require('./$.html')\n  , cel                = require('./$.dom-create')\n  , global             = require('./$.global')\n  , process            = global.process\n  , setTask            = global.setImmediate\n  , clearTask          = global.clearImmediate\n  , MessageChannel     = global.MessageChannel\n  , counter            = 0\n  , queue              = {}\n  , ONREADYSTATECHANGE = 'onreadystatechange'\n  , defer, channel, port;\nvar run = function(){\n  var id = +this;\n  if(queue.hasOwnProperty(id)){\n    var fn = queue[id];\n    delete queue[id];\n    fn();\n  }\n};\nvar listner = function(event){\n  run.call(event.data);\n};\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif(!setTask || !clearTask){\n  setTask = function setImmediate(fn){\n    var args = [], i = 1;\n    while(arguments.length > i)args.push(arguments[i++]);\n    queue[++counter] = function(){\n      invoke(typeof fn == 'function' ? fn : Function(fn), args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clearTask = function clearImmediate(id){\n    delete queue[id];\n  };\n  // Node.js 0.8-\n  if(require('./$.cof')(process) == 'process'){\n    defer = function(id){\n      process.nextTick(ctx(run, id, 1));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  } else if(MessageChannel){\n    channel = new MessageChannel;\n    port    = channel.port2;\n    channel.port1.onmessage = listner;\n    defer = ctx(port.postMessage, port, 1);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){\n    defer = function(id){\n      global.postMessage(id + '', '*');\n    };\n    global.addEventListener('message', listner, false);\n  // IE8-\n  } else if(ONREADYSTATECHANGE in cel('script')){\n    defer = function(id){\n      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){\n        html.removeChild(this);\n        run.call(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function(id){\n      setTimeout(ctx(run, id, 1), 0);\n    };\n  }\n}\nmodule.exports = {\n  set:   setTask,\n  clear: clearTask\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.task.js\n ** module id = 59\n ** module chunks = 0\n **/","// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = require('./$.iobject')\n  , defined = require('./$.defined');\nmodule.exports = function(it){\n  return IObject(defined(it));\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.to-iobject.js\n ** module id = 60\n ** module chunks = 0\n **/","// 7.1.15 ToLength\nvar toInteger = require('./$.to-integer')\n  , min       = Math.min;\nmodule.exports = function(it){\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.to-length.js\n ** module id = 61\n ** module chunks = 0\n **/","var id = 0\n  , px = Math.random();\nmodule.exports = function(key){\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.uid.js\n ** module id = 62\n ** module chunks = 0\n **/","var classof   = require('./$.classof')\n  , ITERATOR  = require('./$.wks')('iterator')\n  , Iterators = require('./$.iterators');\nmodule.exports = require('./$.core').getIteratorMethod = function(it){\n  if(it != undefined)return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/core.get-iterator-method.js\n ** module id = 63\n ** module chunks = 0\n **/","'use strict';\nvar addToUnscopables = require('./$.add-to-unscopables')\n  , step             = require('./$.iter-step')\n  , Iterators        = require('./$.iterators')\n  , toIObject        = require('./$.to-iobject');\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = require('./$.iter-define')(Array, 'Array', function(iterated, kind){\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , kind  = this._k\n    , index = this._i++;\n  if(!O || index >= O.length){\n    this._t = undefined;\n    return step(1);\n  }\n  if(kind == 'keys'  )return step(0, index);\n  if(kind == 'values')return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/es6.array.iterator.js\n ** module id = 64\n ** module chunks = 0\n **/","'use strict';\nvar $          = require('./$')\n  , LIBRARY    = require('./$.library')\n  , global     = require('./$.global')\n  , ctx        = require('./$.ctx')\n  , classof    = require('./$.classof')\n  , $export    = require('./$.export')\n  , isObject   = require('./$.is-object')\n  , anObject   = require('./$.an-object')\n  , aFunction  = require('./$.a-function')\n  , strictNew  = require('./$.strict-new')\n  , forOf      = require('./$.for-of')\n  , setProto   = require('./$.set-proto').set\n  , same       = require('./$.same-value')\n  , SPECIES    = require('./$.wks')('species')\n  , speciesConstructor = require('./$.species-constructor')\n  , asap       = require('./$.microtask')\n  , PROMISE    = 'Promise'\n  , process    = global.process\n  , isNode     = classof(process) == 'process'\n  , P          = global[PROMISE]\n  , Wrapper;\n\nvar testResolve = function(sub){\n  var test = new P(function(){});\n  if(sub)test.constructor = Object;\n  return P.resolve(test) === test;\n};\n\nvar USE_NATIVE = function(){\n  var works = false;\n  function P2(x){\n    var self = new P(x);\n    setProto(self, P2.prototype);\n    return self;\n  }\n  try {\n    works = P && P.resolve && testResolve();\n    setProto(P2, P);\n    P2.prototype = $.create(P.prototype, {constructor: {value: P2}});\n    // actual Firefox has broken subclass support, test that\n    if(!(P2.resolve(5).then(function(){}) instanceof P2)){\n      works = false;\n    }\n    // actual V8 bug, https://code.google.com/p/v8/issues/detail?id=4162\n    if(works && require('./$.descriptors')){\n      var thenableThenGotten = false;\n      P.resolve($.setDesc({}, 'then', {\n        get: function(){ thenableThenGotten = true; }\n      }));\n      works = thenableThenGotten;\n    }\n  } catch(e){ works = false; }\n  return works;\n}();\n\n// helpers\nvar sameConstructor = function(a, b){\n  // library wrapper special case\n  if(LIBRARY && a === P && b === Wrapper)return true;\n  return same(a, b);\n};\nvar getConstructor = function(C){\n  var S = anObject(C)[SPECIES];\n  return S != undefined ? S : C;\n};\nvar isThenable = function(it){\n  var then;\n  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;\n};\nvar PromiseCapability = function(C){\n  var resolve, reject;\n  this.promise = new C(function($$resolve, $$reject){\n    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');\n    resolve = $$resolve;\n    reject  = $$reject;\n  });\n  this.resolve = aFunction(resolve),\n  this.reject  = aFunction(reject)\n};\nvar perform = function(exec){\n  try {\n    exec();\n  } catch(e){\n    return {error: e};\n  }\n};\nvar notify = function(record, isReject){\n  if(record.n)return;\n  record.n = true;\n  var chain = record.c;\n  asap(function(){\n    var value = record.v\n      , ok    = record.s == 1\n      , i     = 0;\n    var run = function(reaction){\n      var handler = ok ? reaction.ok : reaction.fail\n        , resolve = reaction.resolve\n        , reject  = reaction.reject\n        , result, then;\n      try {\n        if(handler){\n          if(!ok)record.h = true;\n          result = handler === true ? value : handler(value);\n          if(result === reaction.promise){\n            reject(TypeError('Promise-chain cycle'));\n          } else if(then = isThenable(result)){\n            then.call(result, resolve, reject);\n          } else resolve(result);\n        } else reject(value);\n      } catch(e){\n        reject(e);\n      }\n    };\n    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach\n    chain.length = 0;\n    record.n = false;\n    if(isReject)setTimeout(function(){\n      var promise = record.p\n        , handler, console;\n      if(isUnhandled(promise)){\n        if(isNode){\n          process.emit('unhandledRejection', value, promise);\n        } else if(handler = global.onunhandledrejection){\n          handler({promise: promise, reason: value});\n        } else if((console = global.console) && console.error){\n          console.error('Unhandled promise rejection', value);\n        }\n      } record.a = undefined;\n    }, 1);\n  });\n};\nvar isUnhandled = function(promise){\n  var record = promise._d\n    , chain  = record.a || record.c\n    , i      = 0\n    , reaction;\n  if(record.h)return false;\n  while(chain.length > i){\n    reaction = chain[i++];\n    if(reaction.fail || !isUnhandled(reaction.promise))return false;\n  } return true;\n};\nvar $reject = function(value){\n  var record = this;\n  if(record.d)return;\n  record.d = true;\n  record = record.r || record; // unwrap\n  record.v = value;\n  record.s = 2;\n  record.a = record.c.slice();\n  notify(record, true);\n};\nvar $resolve = function(value){\n  var record = this\n    , then;\n  if(record.d)return;\n  record.d = true;\n  record = record.r || record; // unwrap\n  try {\n    if(record.p === value)throw TypeError(\"Promise can't be resolved itself\");\n    if(then = isThenable(value)){\n      asap(function(){\n        var wrapper = {r: record, d: false}; // wrap\n        try {\n          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));\n        } catch(e){\n          $reject.call(wrapper, e);\n        }\n      });\n    } else {\n      record.v = value;\n      record.s = 1;\n      notify(record, false);\n    }\n  } catch(e){\n    $reject.call({r: record, d: false}, e); // wrap\n  }\n};\n\n// constructor polyfill\nif(!USE_NATIVE){\n  // 25.4.3.1 Promise(executor)\n  P = function Promise(executor){\n    aFunction(executor);\n    var record = this._d = {\n      p: strictNew(this, P, PROMISE),         // <- promise\n      c: [],                                  // <- awaiting reactions\n      a: undefined,                           // <- checked in isUnhandled reactions\n      s: 0,                                   // <- state\n      d: false,                               // <- done\n      v: undefined,                           // <- value\n      h: false,                               // <- handled rejection\n      n: false                                // <- notify\n    };\n    try {\n      executor(ctx($resolve, record, 1), ctx($reject, record, 1));\n    } catch(err){\n      $reject.call(record, err);\n    }\n  };\n  require('./$.redefine-all')(P.prototype, {\n    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\n    then: function then(onFulfilled, onRejected){\n      var reaction = new PromiseCapability(speciesConstructor(this, P))\n        , promise  = reaction.promise\n        , record   = this._d;\n      reaction.ok   = typeof onFulfilled == 'function' ? onFulfilled : true;\n      reaction.fail = typeof onRejected == 'function' && onRejected;\n      record.c.push(reaction);\n      if(record.a)record.a.push(reaction);\n      if(record.s)notify(record, false);\n      return promise;\n    },\n    // 25.4.5.1 Promise.prototype.catch(onRejected)\n    'catch': function(onRejected){\n      return this.then(undefined, onRejected);\n    }\n  });\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: P});\nrequire('./$.set-to-string-tag')(P, PROMISE);\nrequire('./$.set-species')(PROMISE);\nWrapper = require('./$.core')[PROMISE];\n\n// statics\n$export($export.S + $export.F * !USE_NATIVE, PROMISE, {\n  // 25.4.4.5 Promise.reject(r)\n  reject: function reject(r){\n    var capability = new PromiseCapability(this)\n      , $$reject   = capability.reject;\n    $$reject(r);\n    return capability.promise;\n  }\n});\n$export($export.S + $export.F * (!USE_NATIVE || testResolve(true)), PROMISE, {\n  // 25.4.4.6 Promise.resolve(x)\n  resolve: function resolve(x){\n    // instanceof instead of internal slot check because we should fix it without replacement native Promise core\n    if(x instanceof P && sameConstructor(x.constructor, this))return x;\n    var capability = new PromiseCapability(this)\n      , $$resolve  = capability.resolve;\n    $$resolve(x);\n    return capability.promise;\n  }\n});\n$export($export.S + $export.F * !(USE_NATIVE && require('./$.iter-detect')(function(iter){\n  P.all(iter)['catch'](function(){});\n})), PROMISE, {\n  // 25.4.4.1 Promise.all(iterable)\n  all: function all(iterable){\n    var C          = getConstructor(this)\n      , capability = new PromiseCapability(C)\n      , resolve    = capability.resolve\n      , reject     = capability.reject\n      , values     = [];\n    var abrupt = perform(function(){\n      forOf(iterable, false, values.push, values);\n      var remaining = values.length\n        , results   = Array(remaining);\n      if(remaining)$.each.call(values, function(promise, index){\n        var alreadyCalled = false;\n        C.resolve(promise).then(function(value){\n          if(alreadyCalled)return;\n          alreadyCalled = true;\n          results[index] = value;\n          --remaining || resolve(results);\n        }, reject);\n      });\n      else resolve(results);\n    });\n    if(abrupt)reject(abrupt.error);\n    return capability.promise;\n  },\n  // 25.4.4.4 Promise.race(iterable)\n  race: function race(iterable){\n    var C          = getConstructor(this)\n      , capability = new PromiseCapability(C)\n      , reject     = capability.reject;\n    var abrupt = perform(function(){\n      forOf(iterable, false, function(promise){\n        C.resolve(promise).then(capability.resolve, reject);\n      });\n    });\n    if(abrupt)reject(abrupt.error);\n    return capability.promise;\n  }\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/es6.promise.js\n ** module id = 66\n ** module chunks = 0\n **/","'use strict';\nvar $at  = require('./$.string-at')(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\nrequire('./$.iter-define')(String, 'String', function(iterated){\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , index = this._i\n    , point;\n  if(index >= O.length)return {value: undefined, done: true};\n  point = $at(O, index);\n  this._i += point.length;\n  return {value: point, done: false};\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/es6.string.iterator.js\n ** module id = 67\n ** module chunks = 0\n **/","require('./es6.array.iterator');\nvar Iterators = require('./$.iterators');\nIterators.NodeList = Iterators.HTMLCollection = Iterators.Array;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/web.dom.iterable.js\n ** module id = 68\n ** module chunks = 0\n **/","exports = module.exports = require(\"./../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"body{font-family:Helvetica,sans-serif}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader!./~/vue-loader/lib/style-rewriter.js!./~/vue-loader/lib/selector.js?type=style&index=0!./src/App.vue\n ** module id = 69\n ** module chunks = 0\n **/","exports = module.exports = require(\"./../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"#map{height:800px;width:800px}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader!./~/vue-loader/lib/style-rewriter.js!./~/vue-loader/lib/selector.js?type=style&index=0!./src/components/Map.vue\n ** module id = 70\n ** module chunks = 0\n **/","module.exports = \"<div id=app> <h1>{{ title }}</h1> <map :zoom=zoom :center=center :min-zoom=minZoom :max-zoom=maxZoom> <tilelayer :url=url :attribution=attribution></tilelayer> <marker :position=center></marker> </map> </div>\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vue-html-loader!./~/vue-loader/lib/selector.js?type=template&index=0!./src/App.vue\n ** module id = 71\n ** module chunks = 0\n **/","module.exports = \"<div id=map> <slot></slot> </div>\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vue-html-loader!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/Map.vue\n ** module id = 72\n ** module chunks = 0\n **/","var __vue_script__, __vue_template__\nrequire(\"!!vue-style-loader!css-loader!./../node_modules/vue-loader/lib/style-rewriter.js!./../node_modules/vue-loader/lib/selector.js?type=style&index=0!./App.vue\")\n__vue_script__ = require(\"!!babel-loader?presets[]=es2015&plugins[]=transform-runtime&comments=false!./../node_modules/vue-loader/lib/selector.js?type=script&index=0!./App.vue\")\n__vue_template__ = require(\"!!vue-html-loader!./../node_modules/vue-loader/lib/selector.js?type=template&index=0!./App.vue\")\nmodule.exports = __vue_script__ || {}\nif (module.exports.__esModule) module.exports = module.exports.default\nif (__vue_template__) {\n(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/App.vue\n ** module id = 73\n ** module chunks = 0\n **/","var __vue_script__, __vue_template__\nrequire(\"!!vue-style-loader!css-loader!./../../node_modules/vue-loader/lib/style-rewriter.js!./../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./Map.vue\")\n__vue_script__ = require(\"!!babel-loader?presets[]=es2015&plugins[]=transform-runtime&comments=false!./../../node_modules/vue-loader/lib/selector.js?type=script&index=0!./Map.vue\")\n__vue_template__ = require(\"!!vue-html-loader!./../../node_modules/vue-loader/lib/selector.js?type=template&index=0!./Map.vue\")\nmodule.exports = __vue_script__ || {}\nif (module.exports.__esModule) module.exports = module.exports.default\nif (__vue_template__) {\n(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/components/Map.vue\n ** module id = 74\n ** module chunks = 0\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../node_modules/css-loader/index.js!./../node_modules/vue-loader/lib/style-rewriter.js!./../node_modules/vue-loader/lib/selector.js?type=style&index=0!./App.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../node_modules/vue-style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../node_modules/css-loader/index.js!./../node_modules/vue-loader/lib/style-rewriter.js!./../node_modules/vue-loader/lib/selector.js?type=style&index=0!./App.vue\", function() {\n\t\t\tvar newContent = require(\"!!./../node_modules/css-loader/index.js!./../node_modules/vue-loader/lib/style-rewriter.js!./../node_modules/vue-loader/lib/selector.js?type=style&index=0!./App.vue\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vue-style-loader!./~/css-loader!./~/vue-loader/lib/style-rewriter.js!./~/vue-loader/lib/selector.js?type=style&index=0!./src/App.vue\n ** module id = 75\n ** module chunks = 0\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/vue-loader/lib/style-rewriter.js!./../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./Map.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/vue-style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/vue-loader/lib/style-rewriter.js!./../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./Map.vue\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/vue-loader/lib/style-rewriter.js!./../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./Map.vue\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vue-style-loader!./~/css-loader!./~/vue-loader/lib/style-rewriter.js!./~/vue-loader/lib/selector.js?type=style&index=0!./src/components/Map.vue\n ** module id = 76\n ** module chunks = 0\n **/"],"sourceRoot":""}